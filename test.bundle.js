/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

	__webpack_require__(6);
	if(typeof window !== 'undefined' && window.initMochaPhantomJS) { window.initMochaPhantomJS(); }
	mocha.setup({"ui":"bdd"});
	__webpack_require__(15)
	__webpack_require__(16);
	if(false) {
		module.hot.accept();
		module.hot.dispose(function() {
			mocha.suite.suites.length = 0;
			var stats = document.getElementById('mocha-stats');
			var report = document.getElementById('mocha-report');
			stats && stats.parentNode.removeChild(stats);
			report && report.parentNode.removeChild(report);
		});
	}

/***/ }),
/* 1 */,
/* 2 */,
/* 3 */,
/* 4 */,
/* 5 */,
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

	if (! document.getElementById("mocha")) { document.write("<div id=\"mocha\"></div>"); }
	
	__webpack_require__(7);
	__webpack_require__(12);


/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

	// style-loader: Adds some css to the DOM by adding a <style> tag
	
	// load the styles
	var content = __webpack_require__(8);
	if(typeof content === 'string') content = [[module.id, content, '']];
	// Prepare cssTransformation
	var transform;
	
	var options = {"hmr":true}
	options.transform = transform
	// add the styles to the DOM
	var update = __webpack_require__(10)(content, options);
	if(content.locals) module.exports = content.locals;
	// Hot Module Replacement
	if(false) {
		// When the styles change, update the <style> tags
		if(!content.locals) {
			module.hot.accept("!!../mocha-loader/node_modules/css-loader/index.js!./mocha.css", function() {
				var newContent = require("!!../mocha-loader/node_modules/css-loader/index.js!./mocha.css");
				if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
				update(newContent);
			});
		}
		// When the module is disposed, remove the <style> tags
		module.hot.dispose(function() { update(); });
	}

/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(9)(false);
	// imports
	
	
	// module
	exports.push([module.id, "@charset \"utf-8\";\n\nbody {\n  margin:0;\n}\n\n#mocha {\n  font: 20px/1.5 \"Helvetica Neue\", Helvetica, Arial, sans-serif;\n  margin: 60px 50px;\n}\n\n#mocha ul,\n#mocha li {\n  margin: 0;\n  padding: 0;\n}\n\n#mocha ul {\n  list-style: none;\n}\n\n#mocha h1,\n#mocha h2 {\n  margin: 0;\n}\n\n#mocha h1 {\n  margin-top: 15px;\n  font-size: 1em;\n  font-weight: 200;\n}\n\n#mocha h1 a {\n  text-decoration: none;\n  color: inherit;\n}\n\n#mocha h1 a:hover {\n  text-decoration: underline;\n}\n\n#mocha .suite .suite h1 {\n  margin-top: 0;\n  font-size: .8em;\n}\n\n#mocha .hidden {\n  display: none;\n}\n\n#mocha h2 {\n  font-size: 12px;\n  font-weight: normal;\n  cursor: pointer;\n}\n\n#mocha .suite {\n  margin-left: 15px;\n}\n\n#mocha .test {\n  margin-left: 15px;\n  overflow: hidden;\n}\n\n#mocha .test.pending:hover h2::after {\n  content: '(pending)';\n  font-family: arial, sans-serif;\n}\n\n#mocha .test.pass.medium .duration {\n  background: #c09853;\n}\n\n#mocha .test.pass.slow .duration {\n  background: #b94a48;\n}\n\n#mocha .test.pass::before {\n  content: '\\2713';\n  font-size: 12px;\n  display: block;\n  float: left;\n  margin-right: 5px;\n  color: #00d6b2;\n}\n\n#mocha .test.pass .duration {\n  font-size: 9px;\n  margin-left: 5px;\n  padding: 2px 5px;\n  color: #fff;\n  -webkit-box-shadow: inset 0 1px 1px rgba(0,0,0,.2);\n  -moz-box-shadow: inset 0 1px 1px rgba(0,0,0,.2);\n  box-shadow: inset 0 1px 1px rgba(0,0,0,.2);\n  -webkit-border-radius: 5px;\n  -moz-border-radius: 5px;\n  -ms-border-radius: 5px;\n  -o-border-radius: 5px;\n  border-radius: 5px;\n}\n\n#mocha .test.pass.fast .duration {\n  display: none;\n}\n\n#mocha .test.pending {\n  color: #0b97c4;\n}\n\n#mocha .test.pending::before {\n  content: '\\25E6';\n  color: #0b97c4;\n}\n\n#mocha .test.fail {\n  color: #c00;\n}\n\n#mocha .test.fail pre {\n  color: black;\n}\n\n#mocha .test.fail::before {\n  content: '\\2716';\n  font-size: 12px;\n  display: block;\n  float: left;\n  margin-right: 5px;\n  color: #c00;\n}\n\n#mocha .test pre.error {\n  color: #c00;\n  max-height: 300px;\n  overflow: auto;\n}\n\n#mocha .test .html-error {\n  overflow: auto;\n  color: black;\n  line-height: 1.5;\n  display: block;\n  float: left;\n  clear: left;\n  font: 12px/1.5 monaco, monospace;\n  margin: 5px;\n  padding: 15px;\n  border: 1px solid #eee;\n  max-width: 85%; /*(1)*/\n  max-width: -webkit-calc(100% - 42px);\n  max-width: -moz-calc(100% - 42px);\n  max-width: calc(100% - 42px); /*(2)*/\n  max-height: 300px;\n  word-wrap: break-word;\n  border-bottom-color: #ddd;\n  -webkit-box-shadow: 0 1px 3px #eee;\n  -moz-box-shadow: 0 1px 3px #eee;\n  box-shadow: 0 1px 3px #eee;\n  -webkit-border-radius: 3px;\n  -moz-border-radius: 3px;\n  border-radius: 3px;\n}\n\n#mocha .test .html-error pre.error {\n  border: none;\n  -webkit-border-radius: 0;\n  -moz-border-radius: 0;\n  border-radius: 0;\n  -webkit-box-shadow: 0;\n  -moz-box-shadow: 0;\n  box-shadow: 0;\n  padding: 0;\n  margin: 0;\n  margin-top: 18px;\n  max-height: none;\n}\n\n/**\n * (1): approximate for browsers not supporting calc\n * (2): 42 = 2*15 + 2*10 + 2*1 (padding + margin + border)\n *      ^^ seriously\n */\n#mocha .test pre {\n  display: block;\n  float: left;\n  clear: left;\n  font: 12px/1.5 monaco, monospace;\n  margin: 5px;\n  padding: 15px;\n  border: 1px solid #eee;\n  max-width: 85%; /*(1)*/\n  max-width: -webkit-calc(100% - 42px);\n  max-width: -moz-calc(100% - 42px);\n  max-width: calc(100% - 42px); /*(2)*/\n  word-wrap: break-word;\n  border-bottom-color: #ddd;\n  -webkit-box-shadow: 0 1px 3px #eee;\n  -moz-box-shadow: 0 1px 3px #eee;\n  box-shadow: 0 1px 3px #eee;\n  -webkit-border-radius: 3px;\n  -moz-border-radius: 3px;\n  border-radius: 3px;\n}\n\n#mocha .test h2 {\n  position: relative;\n}\n\n#mocha .test a.replay {\n  position: absolute;\n  top: 3px;\n  right: 0;\n  text-decoration: none;\n  vertical-align: middle;\n  display: block;\n  width: 15px;\n  height: 15px;\n  line-height: 15px;\n  text-align: center;\n  background: #eee;\n  font-size: 15px;\n  -webkit-border-radius: 15px;\n  -moz-border-radius: 15px;\n  border-radius: 15px;\n  -webkit-transition:opacity 200ms;\n  -moz-transition:opacity 200ms;\n  -o-transition:opacity 200ms;\n  transition: opacity 200ms;\n  opacity: 0.3;\n  color: #888;\n}\n\n#mocha .test:hover a.replay {\n  opacity: 1;\n}\n\n#mocha-report.pass .test.fail {\n  display: none;\n}\n\n#mocha-report.fail .test.pass {\n  display: none;\n}\n\n#mocha-report.pending .test.pass,\n#mocha-report.pending .test.fail {\n  display: none;\n}\n#mocha-report.pending .test.pass.pending {\n  display: block;\n}\n\n#mocha-error {\n  color: #c00;\n  font-size: 1.5em;\n  font-weight: 100;\n  letter-spacing: 1px;\n}\n\n#mocha-stats {\n  position: fixed;\n  top: 15px;\n  right: 10px;\n  font-size: 12px;\n  margin: 0;\n  color: #888;\n  z-index: 1;\n}\n\n#mocha-stats .progress {\n  float: right;\n  padding-top: 0;\n\n  /**\n   * Set safe initial values, so mochas .progress does not inherit these\n   * properties from Bootstrap .progress (which causes .progress height to\n   * equal line height set in Bootstrap).\n   */\n  height: auto;\n  -webkit-box-shadow: none;\n  -moz-box-shadow: none;\n  box-shadow: none;\n  background-color: initial;\n}\n\n#mocha-stats em {\n  color: black;\n}\n\n#mocha-stats a {\n  text-decoration: none;\n  color: inherit;\n}\n\n#mocha-stats a:hover {\n  border-bottom: 1px solid #eee;\n}\n\n#mocha-stats li {\n  display: inline-block;\n  margin: 0 5px;\n  list-style: none;\n  padding-top: 11px;\n}\n\n#mocha-stats canvas {\n  width: 40px;\n  height: 40px;\n}\n\n#mocha code .comment { color: #ddd; }\n#mocha code .init { color: #2f6fad; }\n#mocha code .string { color: #5890ad; }\n#mocha code .keyword { color: #8a6343; }\n#mocha code .number { color: #2f6fad; }\n\n@media screen and (max-device-width: 480px) {\n  #mocha {\n    margin: 60px 0px;\n  }\n\n  #mocha #stats {\n    position: absolute;\n  }\n}\n", ""]);
	
	// exports


/***/ }),
/* 9 */
/***/ (function(module, exports) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	// css base code, injected by the css-loader
	module.exports = function(useSourceMap) {
		var list = [];
	
		// return the list of modules as css string
		list.toString = function toString() {
			return this.map(function (item) {
				var content = cssWithMappingToString(item, useSourceMap);
				if(item[2]) {
					return "@media " + item[2] + "{" + content + "}";
				} else {
					return content;
				}
			}).join("");
		};
	
		// import a list of modules into the list
		list.i = function(modules, mediaQuery) {
			if(typeof modules === "string")
				modules = [[null, modules, ""]];
			var alreadyImportedModules = {};
			for(var i = 0; i < this.length; i++) {
				var id = this[i][0];
				if(typeof id === "number")
					alreadyImportedModules[id] = true;
			}
			for(i = 0; i < modules.length; i++) {
				var item = modules[i];
				// skip already imported module
				// this implementation is not 100% perfect for weird media query combinations
				//  when a module is imported multiple times with different media queries.
				//  I hope this will never occur (Hey this way we have smaller bundles)
				if(typeof item[0] !== "number" || !alreadyImportedModules[item[0]]) {
					if(mediaQuery && !item[2]) {
						item[2] = mediaQuery;
					} else if(mediaQuery) {
						item[2] = "(" + item[2] + ") and (" + mediaQuery + ")";
					}
					list.push(item);
				}
			}
		};
		return list;
	};
	
	function cssWithMappingToString(item, useSourceMap) {
		var content = item[1] || '';
		var cssMapping = item[3];
		if (!cssMapping) {
			return content;
		}
	
		if (useSourceMap && typeof btoa === 'function') {
			var sourceMapping = toComment(cssMapping);
			var sourceURLs = cssMapping.sources.map(function (source) {
				return '/*# sourceURL=' + cssMapping.sourceRoot + source + ' */'
			});
	
			return [content].concat(sourceURLs).concat([sourceMapping]).join('\n');
		}
	
		return [content].join('\n');
	}
	
	// Adapted from convert-source-map (MIT)
	function toComment(sourceMap) {
		// eslint-disable-next-line no-undef
		var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));
		var data = 'sourceMappingURL=data:application/json;charset=utf-8;base64,' + base64;
	
		return '/*# ' + data + ' */';
	}


/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	
	var stylesInDom = {};
	
	var	memoize = function (fn) {
		var memo;
	
		return function () {
			if (typeof memo === "undefined") memo = fn.apply(this, arguments);
			return memo;
		};
	};
	
	var isOldIE = memoize(function () {
		// Test for IE <= 9 as proposed by Browserhacks
		// @see http://browserhacks.com/#hack-e71d8692f65334173fee715c222cb805
		// Tests for existence of standard globals is to allow style-loader
		// to operate correctly into non-standard environments
		// @see https://github.com/webpack-contrib/style-loader/issues/177
		return window && document && document.all && !window.atob;
	});
	
	var getElement = (function (fn) {
		var memo = {};
	
		return function(selector) {
			if (typeof memo[selector] === "undefined") {
				var styleTarget = fn.call(this, selector);
				// Special case to return head of iframe instead of iframe itself
				if (styleTarget instanceof window.HTMLIFrameElement) {
					try {
						// This will throw an exception if access to iframe is blocked
						// due to cross-origin restrictions
						styleTarget = styleTarget.contentDocument.head;
					} catch(e) {
						styleTarget = null;
					}
				}
				memo[selector] = styleTarget;
			}
			return memo[selector]
		};
	})(function (target) {
		return document.querySelector(target)
	});
	
	var singleton = null;
	var	singletonCounter = 0;
	var	stylesInsertedAtTop = [];
	
	var	fixUrls = __webpack_require__(11);
	
	module.exports = function(list, options) {
		if (false) {
			if (typeof document !== "object") throw new Error("The style-loader cannot be used in a non-browser environment");
		}
	
		options = options || {};
	
		options.attrs = typeof options.attrs === "object" ? options.attrs : {};
	
		// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>
		// tags it will allow on a page
		if (!options.singleton && typeof options.singleton !== "boolean") options.singleton = isOldIE();
	
		// By default, add <style> tags to the <head> element
		if (!options.insertInto) options.insertInto = "head";
	
		// By default, add <style> tags to the bottom of the target
		if (!options.insertAt) options.insertAt = "bottom";
	
		var styles = listToStyles(list, options);
	
		addStylesToDom(styles, options);
	
		return function update (newList) {
			var mayRemove = [];
	
			for (var i = 0; i < styles.length; i++) {
				var item = styles[i];
				var domStyle = stylesInDom[item.id];
	
				domStyle.refs--;
				mayRemove.push(domStyle);
			}
	
			if(newList) {
				var newStyles = listToStyles(newList, options);
				addStylesToDom(newStyles, options);
			}
	
			for (var i = 0; i < mayRemove.length; i++) {
				var domStyle = mayRemove[i];
	
				if(domStyle.refs === 0) {
					for (var j = 0; j < domStyle.parts.length; j++) domStyle.parts[j]();
	
					delete stylesInDom[domStyle.id];
				}
			}
		};
	};
	
	function addStylesToDom (styles, options) {
		for (var i = 0; i < styles.length; i++) {
			var item = styles[i];
			var domStyle = stylesInDom[item.id];
	
			if(domStyle) {
				domStyle.refs++;
	
				for(var j = 0; j < domStyle.parts.length; j++) {
					domStyle.parts[j](item.parts[j]);
				}
	
				for(; j < item.parts.length; j++) {
					domStyle.parts.push(addStyle(item.parts[j], options));
				}
			} else {
				var parts = [];
	
				for(var j = 0; j < item.parts.length; j++) {
					parts.push(addStyle(item.parts[j], options));
				}
	
				stylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};
			}
		}
	}
	
	function listToStyles (list, options) {
		var styles = [];
		var newStyles = {};
	
		for (var i = 0; i < list.length; i++) {
			var item = list[i];
			var id = options.base ? item[0] + options.base : item[0];
			var css = item[1];
			var media = item[2];
			var sourceMap = item[3];
			var part = {css: css, media: media, sourceMap: sourceMap};
	
			if(!newStyles[id]) styles.push(newStyles[id] = {id: id, parts: [part]});
			else newStyles[id].parts.push(part);
		}
	
		return styles;
	}
	
	function insertStyleElement (options, style) {
		var target = getElement(options.insertInto)
	
		if (!target) {
			throw new Error("Couldn't find a style target. This probably means that the value for the 'insertInto' parameter is invalid.");
		}
	
		var lastStyleElementInsertedAtTop = stylesInsertedAtTop[stylesInsertedAtTop.length - 1];
	
		if (options.insertAt === "top") {
			if (!lastStyleElementInsertedAtTop) {
				target.insertBefore(style, target.firstChild);
			} else if (lastStyleElementInsertedAtTop.nextSibling) {
				target.insertBefore(style, lastStyleElementInsertedAtTop.nextSibling);
			} else {
				target.appendChild(style);
			}
			stylesInsertedAtTop.push(style);
		} else if (options.insertAt === "bottom") {
			target.appendChild(style);
		} else if (typeof options.insertAt === "object" && options.insertAt.before) {
			var nextSibling = getElement(options.insertInto + " " + options.insertAt.before);
			target.insertBefore(style, nextSibling);
		} else {
			throw new Error("[Style Loader]\n\n Invalid value for parameter 'insertAt' ('options.insertAt') found.\n Must be 'top', 'bottom', or Object.\n (https://github.com/webpack-contrib/style-loader#insertat)\n");
		}
	}
	
	function removeStyleElement (style) {
		if (style.parentNode === null) return false;
		style.parentNode.removeChild(style);
	
		var idx = stylesInsertedAtTop.indexOf(style);
		if(idx >= 0) {
			stylesInsertedAtTop.splice(idx, 1);
		}
	}
	
	function createStyleElement (options) {
		var style = document.createElement("style");
	
		options.attrs.type = "text/css";
	
		addAttrs(style, options.attrs);
		insertStyleElement(options, style);
	
		return style;
	}
	
	function createLinkElement (options) {
		var link = document.createElement("link");
	
		options.attrs.type = "text/css";
		options.attrs.rel = "stylesheet";
	
		addAttrs(link, options.attrs);
		insertStyleElement(options, link);
	
		return link;
	}
	
	function addAttrs (el, attrs) {
		Object.keys(attrs).forEach(function (key) {
			el.setAttribute(key, attrs[key]);
		});
	}
	
	function addStyle (obj, options) {
		var style, update, remove, result;
	
		// If a transform function was defined, run it on the css
		if (options.transform && obj.css) {
		    result = options.transform(obj.css);
	
		    if (result) {
		    	// If transform returns a value, use that instead of the original css.
		    	// This allows running runtime transformations on the css.
		    	obj.css = result;
		    } else {
		    	// If the transform function returns a falsy value, don't add this css.
		    	// This allows conditional loading of css
		    	return function() {
		    		// noop
		    	};
		    }
		}
	
		if (options.singleton) {
			var styleIndex = singletonCounter++;
	
			style = singleton || (singleton = createStyleElement(options));
	
			update = applyToSingletonTag.bind(null, style, styleIndex, false);
			remove = applyToSingletonTag.bind(null, style, styleIndex, true);
	
		} else if (
			obj.sourceMap &&
			typeof URL === "function" &&
			typeof URL.createObjectURL === "function" &&
			typeof URL.revokeObjectURL === "function" &&
			typeof Blob === "function" &&
			typeof btoa === "function"
		) {
			style = createLinkElement(options);
			update = updateLink.bind(null, style, options);
			remove = function () {
				removeStyleElement(style);
	
				if(style.href) URL.revokeObjectURL(style.href);
			};
		} else {
			style = createStyleElement(options);
			update = applyToTag.bind(null, style);
			remove = function () {
				removeStyleElement(style);
			};
		}
	
		update(obj);
	
		return function updateStyle (newObj) {
			if (newObj) {
				if (
					newObj.css === obj.css &&
					newObj.media === obj.media &&
					newObj.sourceMap === obj.sourceMap
				) {
					return;
				}
	
				update(obj = newObj);
			} else {
				remove();
			}
		};
	}
	
	var replaceText = (function () {
		var textStore = [];
	
		return function (index, replacement) {
			textStore[index] = replacement;
	
			return textStore.filter(Boolean).join('\n');
		};
	})();
	
	function applyToSingletonTag (style, index, remove, obj) {
		var css = remove ? "" : obj.css;
	
		if (style.styleSheet) {
			style.styleSheet.cssText = replaceText(index, css);
		} else {
			var cssNode = document.createTextNode(css);
			var childNodes = style.childNodes;
	
			if (childNodes[index]) style.removeChild(childNodes[index]);
	
			if (childNodes.length) {
				style.insertBefore(cssNode, childNodes[index]);
			} else {
				style.appendChild(cssNode);
			}
		}
	}
	
	function applyToTag (style, obj) {
		var css = obj.css;
		var media = obj.media;
	
		if(media) {
			style.setAttribute("media", media)
		}
	
		if(style.styleSheet) {
			style.styleSheet.cssText = css;
		} else {
			while(style.firstChild) {
				style.removeChild(style.firstChild);
			}
	
			style.appendChild(document.createTextNode(css));
		}
	}
	
	function updateLink (link, options, obj) {
		var css = obj.css;
		var sourceMap = obj.sourceMap;
	
		/*
			If convertToAbsoluteUrls isn't defined, but sourcemaps are enabled
			and there is no publicPath defined then lets turn convertToAbsoluteUrls
			on by default.  Otherwise default to the convertToAbsoluteUrls option
			directly
		*/
		var autoFixUrls = options.convertToAbsoluteUrls === undefined && sourceMap;
	
		if (options.convertToAbsoluteUrls || autoFixUrls) {
			css = fixUrls(css);
		}
	
		if (sourceMap) {
			// http://stackoverflow.com/a/26603875
			css += "\n/*# sourceMappingURL=data:application/json;base64," + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + " */";
		}
	
		var blob = new Blob([css], { type: "text/css" });
	
		var oldSrc = link.href;
	
		link.href = URL.createObjectURL(blob);
	
		if(oldSrc) URL.revokeObjectURL(oldSrc);
	}


/***/ }),
/* 11 */
/***/ (function(module, exports) {

	
	/**
	 * When source maps are enabled, `style-loader` uses a link element with a data-uri to
	 * embed the css on the page. This breaks all relative urls because now they are relative to a
	 * bundle instead of the current page.
	 *
	 * One solution is to only use full urls, but that may be impossible.
	 *
	 * Instead, this function "fixes" the relative urls to be absolute according to the current page location.
	 *
	 * A rudimentary test suite is located at `test/fixUrls.js` and can be run via the `npm test` command.
	 *
	 */
	
	module.exports = function (css) {
	  // get current location
	  var location = typeof window !== "undefined" && window.location;
	
	  if (!location) {
	    throw new Error("fixUrls requires window.location");
	  }
	
		// blank or null?
		if (!css || typeof css !== "string") {
		  return css;
	  }
	
	  var baseUrl = location.protocol + "//" + location.host;
	  var currentDir = baseUrl + location.pathname.replace(/\/[^\/]*$/, "/");
	
		// convert each url(...)
		/*
		This regular expression is just a way to recursively match brackets within
		a string.
	
		 /url\s*\(  = Match on the word "url" with any whitespace after it and then a parens
		   (  = Start a capturing group
		     (?:  = Start a non-capturing group
		         [^)(]  = Match anything that isn't a parentheses
		         |  = OR
		         \(  = Match a start parentheses
		             (?:  = Start another non-capturing groups
		                 [^)(]+  = Match anything that isn't a parentheses
		                 |  = OR
		                 \(  = Match a start parentheses
		                     [^)(]*  = Match anything that isn't a parentheses
		                 \)  = Match a end parentheses
		             )  = End Group
	              *\) = Match anything and then a close parens
	          )  = Close non-capturing group
	          *  = Match anything
	       )  = Close capturing group
		 \)  = Match a close parens
	
		 /gi  = Get all matches, not the first.  Be case insensitive.
		 */
		var fixedCss = css.replace(/url\s*\(((?:[^)(]|\((?:[^)(]+|\([^)(]*\))*\))*)\)/gi, function(fullMatch, origUrl) {
			// strip quotes (if they exist)
			var unquotedOrigUrl = origUrl
				.trim()
				.replace(/^"(.*)"$/, function(o, $1){ return $1; })
				.replace(/^'(.*)'$/, function(o, $1){ return $1; });
	
			// already a full url? no change
			if (/^(#|data:|http:\/\/|https:\/\/|file:\/\/\/)/i.test(unquotedOrigUrl)) {
			  return fullMatch;
			}
	
			// convert the url to a full url
			var newUrl;
	
			if (unquotedOrigUrl.indexOf("//") === 0) {
			  	//TODO: should we add protocol?
				newUrl = unquotedOrigUrl;
			} else if (unquotedOrigUrl.indexOf("/") === 0) {
				// path should be relative to the base url
				newUrl = baseUrl + unquotedOrigUrl; // already starts with '/'
			} else {
				// path should be relative to current directory
				newUrl = currentDir + unquotedOrigUrl.replace(/^\.\//, ""); // Strip leading './'
			}
	
			// send back the fixed url(...)
			return "url(" + JSON.stringify(newUrl) + ")";
		});
	
		// send back the fixed css
		return fixedCss;
	};


/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

	__webpack_require__(13)(__webpack_require__(14))

/***/ }),
/* 13 */
/***/ (function(module, exports) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	module.exports = function(src) {
		function log(error) {
			(typeof console !== "undefined")
			&& (console.error || console.log)("[Script Loader]", error);
		}
	
		// Check for IE =< 8
		function isIE() {
			return typeof attachEvent !== "undefined" && typeof addEventListener === "undefined";
		}
	
		try {
			if (typeof execScript !== "undefined" && isIE()) {
				execScript(src);
			} else if (typeof eval !== "undefined") {
				eval.call(null, src);
			} else {
				log("EvalError: No eval function available");
			}
		} catch (error) {
			log(error);
		}
	}


/***/ }),
/* 14 */
/***/ (function(module, exports) {

	module.exports = "(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){\n(function (process,global){\n'use strict';\n\n/* eslint no-unused-vars: off */\n/* eslint-env commonjs */\n\n/**\n * Shim process.stdout.\n */\n\nprocess.stdout = require('browser-stdout')();\n\nvar Mocha = require('./lib/mocha');\n\n/**\n * Create a Mocha instance.\n *\n * @return {undefined}\n */\n\nvar mocha = new Mocha({ reporter: 'html' });\n\n/**\n * Save timer references to avoid Sinon interfering (see GH-237).\n */\n\nvar Date = global.Date;\nvar setTimeout = global.setTimeout;\nvar setInterval = global.setInterval;\nvar clearTimeout = global.clearTimeout;\nvar clearInterval = global.clearInterval;\n\nvar uncaughtExceptionHandlers = [];\n\nvar originalOnerrorHandler = global.onerror;\n\n/**\n * Remove uncaughtException listener.\n * Revert to original onerror handler if previously defined.\n */\n\nprocess.removeListener = function (e, fn) {\n  if (e === 'uncaughtException') {\n    if (originalOnerrorHandler) {\n      global.onerror = originalOnerrorHandler;\n    } else {\n      global.onerror = function () {};\n    }\n    var i = Mocha.utils.indexOf(uncaughtExceptionHandlers, fn);\n    if (i !== -1) {\n      uncaughtExceptionHandlers.splice(i, 1);\n    }\n  }\n};\n\n/**\n * Implements uncaughtException listener.\n */\n\nprocess.on = function (e, fn) {\n  if (e === 'uncaughtException') {\n    global.onerror = function (err, url, line) {\n      fn(new Error(err + ' (' + url + ':' + line + ')'));\n      return !mocha.allowUncaught;\n    };\n    uncaughtExceptionHandlers.push(fn);\n  }\n};\n\n// The BDD UI is registered by default, but no UI will be functional in the\n// browser without an explicit call to the overridden `mocha.ui` (see below).\n// Ensure that this default UI does not expose its methods to the global scope.\nmocha.suite.removeAllListeners('pre-require');\n\nvar immediateQueue = [];\nvar immediateTimeout;\n\nfunction timeslice () {\n  var immediateStart = new Date().getTime();\n  while (immediateQueue.length && (new Date().getTime() - immediateStart) < 100) {\n    immediateQueue.shift()();\n  }\n  if (immediateQueue.length) {\n    immediateTimeout = setTimeout(timeslice, 0);\n  } else {\n    immediateTimeout = null;\n  }\n}\n\n/**\n * High-performance override of Runner.immediately.\n */\n\nMocha.Runner.immediately = function (callback) {\n  immediateQueue.push(callback);\n  if (!immediateTimeout) {\n    immediateTimeout = setTimeout(timeslice, 0);\n  }\n};\n\n/**\n * Function to allow assertion libraries to throw errors directly into mocha.\n * This is useful when running tests in a browser because window.onerror will\n * only receive the 'message' attribute of the Error.\n */\nmocha.throwError = function (err) {\n  Mocha.utils.forEach(uncaughtExceptionHandlers, function (fn) {\n    fn(err);\n  });\n  throw err;\n};\n\n/**\n * Override ui to ensure that the ui functions are initialized.\n * Normally this would happen in Mocha.prototype.loadFiles.\n */\n\nmocha.ui = function (ui) {\n  Mocha.prototype.ui.call(this, ui);\n  this.suite.emit('pre-require', global, null, this);\n  return this;\n};\n\n/**\n * Setup mocha with the given setting options.\n */\n\nmocha.setup = function (opts) {\n  if (typeof opts === 'string') {\n    opts = { ui: opts };\n  }\n  for (var opt in opts) {\n    if (opts.hasOwnProperty(opt)) {\n      this[opt](opts[opt]);\n    }\n  }\n  return this;\n};\n\n/**\n * Run mocha, returning the Runner.\n */\n\nmocha.run = function (fn) {\n  var options = mocha.options;\n  mocha.globals('location');\n\n  var query = Mocha.utils.parseQuery(global.location.search || '');\n  if (query.grep) {\n    mocha.grep(query.grep);\n  }\n  if (query.fgrep) {\n    mocha.fgrep(query.fgrep);\n  }\n  if (query.invert) {\n    mocha.invert();\n  }\n\n  return Mocha.prototype.run.call(mocha, function (err) {\n    // The DOM Document is not available in Web Workers.\n    var document = global.document;\n    if (document && document.getElementById('mocha') && options.noHighlighting !== true) {\n      Mocha.utils.highlightTags('code');\n    }\n    if (fn) {\n      fn(err);\n    }\n  });\n};\n\n/**\n * Expose the process shim.\n * https://github.com/mochajs/mocha/pull/916\n */\n\nMocha.process = process;\n\n/**\n * Expose mocha.\n */\n\nglobal.Mocha = Mocha;\nglobal.mocha = mocha;\n\n// this allows test/acceptance/required-tokens.js to pass; thus,\n// you can now do `const describe = require('mocha').describe` in a\n// browser context (assuming browserification).  should fix #880\nmodule.exports = global;\n\n}).call(this,require('_process'),typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n},{\"./lib/mocha\":14,\"_process\":82,\"browser-stdout\":41}],2:[function(require,module,exports){\n'use strict';\n\nfunction noop () {}\n\nmodule.exports = function () {\n  return noop;\n};\n\n},{}],3:[function(require,module,exports){\n'use strict';\n\n/**\n * Module exports.\n */\n\nexports.EventEmitter = EventEmitter;\n\n/**\n * Object#toString reference.\n */\nvar objToString = Object.prototype.toString;\n\n/**\n * Check if a value is an array.\n *\n * @api private\n * @param {*} val The value to test.\n * @return {boolean} true if the value is an array, otherwise false.\n */\nfunction isArray (val) {\n  return objToString.call(val) === '[object Array]';\n}\n\n/**\n * Event emitter constructor.\n *\n * @api public\n */\nfunction EventEmitter () {}\n\n/**\n * Add a listener.\n *\n * @api public\n * @param {string} name Event name.\n * @param {Function} fn Event handler.\n * @return {EventEmitter} Emitter instance.\n */\nEventEmitter.prototype.on = function (name, fn) {\n  if (!this.$events) {\n    this.$events = {};\n  }\n\n  if (!this.$events[name]) {\n    this.$events[name] = fn;\n  } else if (isArray(this.$events[name])) {\n    this.$events[name].push(fn);\n  } else {\n    this.$events[name] = [this.$events[name], fn];\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.addListener = EventEmitter.prototype.on;\n\n/**\n * Adds a volatile listener.\n *\n * @api public\n * @param {string} name Event name.\n * @param {Function} fn Event handler.\n * @return {EventEmitter} Emitter instance.\n */\nEventEmitter.prototype.once = function (name, fn) {\n  var self = this;\n\n  function on () {\n    self.removeListener(name, on);\n    fn.apply(this, arguments);\n  }\n\n  on.listener = fn;\n  this.on(name, on);\n\n  return this;\n};\n\n/**\n * Remove a listener.\n *\n * @api public\n * @param {string} name Event name.\n * @param {Function} fn Event handler.\n * @return {EventEmitter} Emitter instance.\n */\nEventEmitter.prototype.removeListener = function (name, fn) {\n  if (this.$events && this.$events[name]) {\n    var list = this.$events[name];\n\n    if (isArray(list)) {\n      var pos = -1;\n\n      for (var i = 0, l = list.length; i < l; i++) {\n        if (list[i] === fn || (list[i].listener && list[i].listener === fn)) {\n          pos = i;\n          break;\n        }\n      }\n\n      if (pos < 0) {\n        return this;\n      }\n\n      list.splice(pos, 1);\n\n      if (!list.length) {\n        delete this.$events[name];\n      }\n    } else if (list === fn || (list.listener && list.listener === fn)) {\n      delete this.$events[name];\n    }\n  }\n\n  return this;\n};\n\n/**\n * Remove all listeners for an event.\n *\n * @api public\n * @param {string} name Event name.\n * @return {EventEmitter} Emitter instance.\n */\nEventEmitter.prototype.removeAllListeners = function (name) {\n  if (name === undefined) {\n    this.$events = {};\n    return this;\n  }\n\n  if (this.$events && this.$events[name]) {\n    this.$events[name] = null;\n  }\n\n  return this;\n};\n\n/**\n * Get all listeners for a given event.\n *\n * @api public\n * @param {string} name Event name.\n * @return {EventEmitter} Emitter instance.\n */\nEventEmitter.prototype.listeners = function (name) {\n  if (!this.$events) {\n    this.$events = {};\n  }\n\n  if (!this.$events[name]) {\n    this.$events[name] = [];\n  }\n\n  if (!isArray(this.$events[name])) {\n    this.$events[name] = [this.$events[name]];\n  }\n\n  return this.$events[name];\n};\n\n/**\n * Emit an event.\n *\n * @api public\n * @param {string} name Event name.\n * @return {boolean} true if at least one handler was invoked, else false.\n */\nEventEmitter.prototype.emit = function (name) {\n  if (!this.$events) {\n    return false;\n  }\n\n  var handler = this.$events[name];\n\n  if (!handler) {\n    return false;\n  }\n\n  var args = Array.prototype.slice.call(arguments, 1);\n\n  if (typeof handler === 'function') {\n    handler.apply(this, args);\n  } else if (isArray(handler)) {\n    var listeners = handler.slice();\n\n    for (var i = 0, l = listeners.length; i < l; i++) {\n      listeners[i].apply(this, args);\n    }\n  } else {\n    return false;\n  }\n\n  return true;\n};\n\n},{}],4:[function(require,module,exports){\n'use strict';\n\n/**\n * Expose `Progress`.\n */\n\nmodule.exports = Progress;\n\n/**\n * Initialize a new `Progress` indicator.\n */\nfunction Progress () {\n  this.percent = 0;\n  this.size(0);\n  this.fontSize(11);\n  this.font('helvetica, arial, sans-serif');\n}\n\n/**\n * Set progress size to `size`.\n *\n * @api public\n * @param {number} size\n * @return {Progress} Progress instance.\n */\nProgress.prototype.size = function (size) {\n  this._size = size;\n  return this;\n};\n\n/**\n * Set text to `text`.\n *\n * @api public\n * @param {string} text\n * @return {Progress} Progress instance.\n */\nProgress.prototype.text = function (text) {\n  this._text = text;\n  return this;\n};\n\n/**\n * Set font size to `size`.\n *\n * @api public\n * @param {number} size\n * @return {Progress} Progress instance.\n */\nProgress.prototype.fontSize = function (size) {\n  this._fontSize = size;\n  return this;\n};\n\n/**\n * Set font to `family`.\n *\n * @param {string} family\n * @return {Progress} Progress instance.\n */\nProgress.prototype.font = function (family) {\n  this._font = family;\n  return this;\n};\n\n/**\n * Update percentage to `n`.\n *\n * @param {number} n\n * @return {Progress} Progress instance.\n */\nProgress.prototype.update = function (n) {\n  this.percent = n;\n  return this;\n};\n\n/**\n * Draw on `ctx`.\n *\n * @param {CanvasRenderingContext2d} ctx\n * @return {Progress} Progress instance.\n */\nProgress.prototype.draw = function (ctx) {\n  try {\n    var percent = Math.min(this.percent, 100);\n    var size = this._size;\n    var half = size / 2;\n    var x = half;\n    var y = half;\n    var rad = half - 1;\n    var fontSize = this._fontSize;\n\n    ctx.font = fontSize + 'px ' + this._font;\n\n    var angle = Math.PI * 2 * (percent / 100);\n    ctx.clearRect(0, 0, size, size);\n\n    // outer circle\n    ctx.strokeStyle = '#9f9f9f';\n    ctx.beginPath();\n    ctx.arc(x, y, rad, 0, angle, false);\n    ctx.stroke();\n\n    // inner circle\n    ctx.strokeStyle = '#eee';\n    ctx.beginPath();\n    ctx.arc(x, y, rad - 1, 0, angle, true);\n    ctx.stroke();\n\n    // text\n    var text = this._text || (percent | 0) + '%';\n    var w = ctx.measureText(text).width;\n\n    ctx.fillText(text, x - w / 2 + 1, y + fontSize / 2 - 1);\n  } catch (err) {\n    // don't fail if we can't render progress\n  }\n  return this;\n};\n\n},{}],5:[function(require,module,exports){\n(function (global){\n'use strict';\n\nexports.isatty = function isatty () {\n  return true;\n};\n\nexports.getWindowSize = function getWindowSize () {\n  if ('innerHeight' in global) {\n    return [global.innerHeight, global.innerWidth];\n  }\n  // In a Web Worker, the DOM Window is not available.\n  return [640, 480];\n};\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n},{}],6:[function(require,module,exports){\n'use strict';\n\n/**\n * Module dependencies.\n */\n\nvar JSON = require('json3');\n\n/**\n * Expose `Context`.\n */\n\nmodule.exports = Context;\n\n/**\n * Initialize a new `Context`.\n *\n * @api private\n */\nfunction Context () {}\n\n/**\n * Set or get the context `Runnable` to `runnable`.\n *\n * @api private\n * @param {Runnable} runnable\n * @return {Context}\n */\nContext.prototype.runnable = function (runnable) {\n  if (!arguments.length) {\n    return this._runnable;\n  }\n  this.test = this._runnable = runnable;\n  return this;\n};\n\n/**\n * Set test timeout `ms`.\n *\n * @api private\n * @param {number} ms\n * @return {Context} self\n */\nContext.prototype.timeout = function (ms) {\n  if (!arguments.length) {\n    return this.runnable().timeout();\n  }\n  this.runnable().timeout(ms);\n  return this;\n};\n\n/**\n * Set test timeout `enabled`.\n *\n * @api private\n * @param {boolean} enabled\n * @return {Context} self\n */\nContext.prototype.enableTimeouts = function (enabled) {\n  this.runnable().enableTimeouts(enabled);\n  return this;\n};\n\n/**\n * Set test slowness threshold `ms`.\n *\n * @api private\n * @param {number} ms\n * @return {Context} self\n */\nContext.prototype.slow = function (ms) {\n  this.runnable().slow(ms);\n  return this;\n};\n\n/**\n * Mark a test as skipped.\n *\n * @api private\n * @return {Context} self\n */\nContext.prototype.skip = function () {\n  this.runnable().skip();\n  return this;\n};\n\n/**\n * Allow a number of retries on failed tests\n *\n * @api private\n * @param {number} n\n * @return {Context} self\n */\nContext.prototype.retries = function (n) {\n  if (!arguments.length) {\n    return this.runnable().retries();\n  }\n  this.runnable().retries(n);\n  return this;\n};\n\n/**\n * Inspect the context void of `._runnable`.\n *\n * @api private\n * @return {string}\n */\nContext.prototype.inspect = function () {\n  return JSON.stringify(this, function (key, val) {\n    return key === 'runnable' || key === 'test' ? undefined : val;\n  }, 2);\n};\n\n},{\"json3\":69}],7:[function(require,module,exports){\n'use strict';\n\n/**\n * Module dependencies.\n */\n\nvar Runnable = require('./runnable');\nvar inherits = require('./utils').inherits;\n\n/**\n * Expose `Hook`.\n */\n\nmodule.exports = Hook;\n\n/**\n * Initialize a new `Hook` with the given `title` and callback `fn`.\n *\n * @param {String} title\n * @param {Function} fn\n * @api private\n */\nfunction Hook (title, fn) {\n  Runnable.call(this, title, fn);\n  this.type = 'hook';\n}\n\n/**\n * Inherit from `Runnable.prototype`.\n */\ninherits(Hook, Runnable);\n\n/**\n * Get or set the test `err`.\n *\n * @param {Error} err\n * @return {Error}\n * @api public\n */\nHook.prototype.error = function (err) {\n  if (!arguments.length) {\n    err = this._error;\n    this._error = null;\n    return err;\n  }\n\n  this._error = err;\n};\n\n},{\"./runnable\":33,\"./utils\":38}],8:[function(require,module,exports){\n'use strict';\n\n/**\n * Module dependencies.\n */\n\nvar Test = require('../test');\n\n/**\n * BDD-style interface:\n *\n *      describe('Array', function() {\n *        describe('#indexOf()', function() {\n *          it('should return -1 when not present', function() {\n *            // ...\n *          });\n *\n *          it('should return the index when present', function() {\n *            // ...\n *          });\n *        });\n *      });\n *\n * @param {Suite} suite Root suite.\n */\nmodule.exports = function (suite) {\n  var suites = [suite];\n\n  suite.on('pre-require', function (context, file, mocha) {\n    var common = require('./common')(suites, context, mocha);\n\n    context.before = common.before;\n    context.after = common.after;\n    context.beforeEach = common.beforeEach;\n    context.afterEach = common.afterEach;\n    context.run = mocha.options.delay && common.runWithSuite(suite);\n    /**\n     * Describe a \"suite\" with the given `title`\n     * and callback `fn` containing nested suites\n     * and/or tests.\n     */\n\n    context.describe = context.context = function (title, fn) {\n      return common.suite.create({\n        title: title,\n        file: file,\n        fn: fn\n      });\n    };\n\n    /**\n     * Pending describe.\n     */\n\n    context.xdescribe = context.xcontext = context.describe.skip = function (title, fn) {\n      return common.suite.skip({\n        title: title,\n        file: file,\n        fn: fn\n      });\n    };\n\n    /**\n     * Exclusive suite.\n     */\n\n    context.describe.only = function (title, fn) {\n      return common.suite.only({\n        title: title,\n        file: file,\n        fn: fn\n      });\n    };\n\n    /**\n     * Describe a specification or test-case\n     * with the given `title` and callback `fn`\n     * acting as a thunk.\n     */\n\n    context.it = context.specify = function (title, fn) {\n      var suite = suites[0];\n      if (suite.isPending()) {\n        fn = null;\n      }\n      var test = new Test(title, fn);\n      test.file = file;\n      suite.addTest(test);\n      return test;\n    };\n\n    /**\n     * Exclusive test-case.\n     */\n\n    context.it.only = function (title, fn) {\n      return common.test.only(mocha, context.it(title, fn));\n    };\n\n    /**\n     * Pending test case.\n     */\n\n    context.xit = context.xspecify = context.it.skip = function (title) {\n      context.it(title);\n    };\n\n    /**\n     * Number of attempts to retry.\n     */\n    context.it.retries = function (n) {\n      context.retries(n);\n    };\n  });\n};\n\n},{\"../test\":36,\"./common\":9}],9:[function(require,module,exports){\n'use strict';\n\nvar Suite = require('../suite');\n\n/**\n * Functions common to more than one interface.\n *\n * @param {Suite[]} suites\n * @param {Context} context\n * @param {Mocha} mocha\n * @return {Object} An object containing common functions.\n */\nmodule.exports = function (suites, context, mocha) {\n  return {\n    /**\n     * This is only present if flag --delay is passed into Mocha. It triggers\n     * root suite execution.\n     *\n     * @param {Suite} suite The root suite.\n     * @return {Function} A function which runs the root suite\n     */\n    runWithSuite: function runWithSuite (suite) {\n      return function run () {\n        suite.run();\n      };\n    },\n\n    /**\n     * Execute before running tests.\n     *\n     * @param {string} name\n     * @param {Function} fn\n     */\n    before: function (name, fn) {\n      suites[0].beforeAll(name, fn);\n    },\n\n    /**\n     * Execute after running tests.\n     *\n     * @param {string} name\n     * @param {Function} fn\n     */\n    after: function (name, fn) {\n      suites[0].afterAll(name, fn);\n    },\n\n    /**\n     * Execute before each test case.\n     *\n     * @param {string} name\n     * @param {Function} fn\n     */\n    beforeEach: function (name, fn) {\n      suites[0].beforeEach(name, fn);\n    },\n\n    /**\n     * Execute after each test case.\n     *\n     * @param {string} name\n     * @param {Function} fn\n     */\n    afterEach: function (name, fn) {\n      suites[0].afterEach(name, fn);\n    },\n\n    suite: {\n      /**\n       * Create an exclusive Suite; convenience function\n       * See docstring for create() below.\n       *\n       * @param {Object} opts\n       * @returns {Suite}\n       */\n      only: function only (opts) {\n        mocha.options.hasOnly = true;\n        opts.isOnly = true;\n        return this.create(opts);\n      },\n\n      /**\n       * Create a Suite, but skip it; convenience function\n       * See docstring for create() below.\n       *\n       * @param {Object} opts\n       * @returns {Suite}\n       */\n      skip: function skip (opts) {\n        opts.pending = true;\n        return this.create(opts);\n      },\n\n      /**\n       * Creates a suite.\n       * @param {Object} opts Options\n       * @param {string} opts.title Title of Suite\n       * @param {Function} [opts.fn] Suite Function (not always applicable)\n       * @param {boolean} [opts.pending] Is Suite pending?\n       * @param {string} [opts.file] Filepath where this Suite resides\n       * @param {boolean} [opts.isOnly] Is Suite exclusive?\n       * @returns {Suite}\n       */\n      create: function create (opts) {\n        var suite = Suite.create(suites[0], opts.title);\n        suite.pending = Boolean(opts.pending);\n        suite.file = opts.file;\n        suites.unshift(suite);\n        if (opts.isOnly) {\n          suite.parent._onlySuites = suite.parent._onlySuites.concat(suite);\n          mocha.options.hasOnly = true;\n        }\n        if (typeof opts.fn === 'function') {\n          opts.fn.call(suite);\n          suites.shift();\n        } else if (typeof opts.fn === 'undefined' && !suite.pending) {\n          throw new Error('Suite \"' + suite.fullTitle() + '\" was defined but no callback was supplied. Supply a callback or explicitly skip the suite.');\n        }\n\n        return suite;\n      }\n    },\n\n    test: {\n\n      /**\n       * Exclusive test-case.\n       *\n       * @param {Object} mocha\n       * @param {Function} test\n       * @returns {*}\n       */\n      only: function (mocha, test) {\n        test.parent._onlyTests = test.parent._onlyTests.concat(test);\n        mocha.options.hasOnly = true;\n        return test;\n      },\n\n      /**\n       * Pending test case.\n       *\n       * @param {string} title\n       */\n      skip: function (title) {\n        context.test(title);\n      },\n\n      /**\n       * Number of retry attempts\n       *\n       * @param {number} n\n       */\n      retries: function (n) {\n        context.retries(n);\n      }\n    }\n  };\n};\n\n},{\"../suite\":35}],10:[function(require,module,exports){\n'use strict';\n\n/**\n * Module dependencies.\n */\n\nvar Suite = require('../suite');\nvar Test = require('../test');\n\n/**\n * Exports-style (as Node.js module) interface:\n *\n *     exports.Array = {\n *       '#indexOf()': {\n *         'should return -1 when the value is not present': function() {\n *\n *         },\n *\n *         'should return the correct index when the value is present': function() {\n *\n *         }\n *       }\n *     };\n *\n * @param {Suite} suite Root suite.\n */\nmodule.exports = function (suite) {\n  var suites = [suite];\n\n  suite.on('require', visit);\n\n  function visit (obj, file) {\n    var suite;\n    for (var key in obj) {\n      if (typeof obj[key] === 'function') {\n        var fn = obj[key];\n        switch (key) {\n          case 'before':\n            suites[0].beforeAll(fn);\n            break;\n          case 'after':\n            suites[0].afterAll(fn);\n            break;\n          case 'beforeEach':\n            suites[0].beforeEach(fn);\n            break;\n          case 'afterEach':\n            suites[0].afterEach(fn);\n            break;\n          default:\n            var test = new Test(key, fn);\n            test.file = file;\n            suites[0].addTest(test);\n        }\n      } else {\n        suite = Suite.create(suites[0], key);\n        suites.unshift(suite);\n        visit(obj[key], file);\n        suites.shift();\n      }\n    }\n  }\n};\n\n},{\"../suite\":35,\"../test\":36}],11:[function(require,module,exports){\n'use strict';\n\nexports.bdd = require('./bdd');\nexports.tdd = require('./tdd');\nexports.qunit = require('./qunit');\nexports.exports = require('./exports');\n\n},{\"./bdd\":8,\"./exports\":10,\"./qunit\":12,\"./tdd\":13}],12:[function(require,module,exports){\n'use strict';\n\n/**\n * Module dependencies.\n */\n\nvar Test = require('../test');\n\n/**\n * QUnit-style interface:\n *\n *     suite('Array');\n *\n *     test('#length', function() {\n *       var arr = [1,2,3];\n *       ok(arr.length == 3);\n *     });\n *\n *     test('#indexOf()', function() {\n *       var arr = [1,2,3];\n *       ok(arr.indexOf(1) == 0);\n *       ok(arr.indexOf(2) == 1);\n *       ok(arr.indexOf(3) == 2);\n *     });\n *\n *     suite('String');\n *\n *     test('#length', function() {\n *       ok('foo'.length == 3);\n *     });\n *\n * @param {Suite} suite Root suite.\n */\nmodule.exports = function (suite) {\n  var suites = [suite];\n\n  suite.on('pre-require', function (context, file, mocha) {\n    var common = require('./common')(suites, context, mocha);\n\n    context.before = common.before;\n    context.after = common.after;\n    context.beforeEach = common.beforeEach;\n    context.afterEach = common.afterEach;\n    context.run = mocha.options.delay && common.runWithSuite(suite);\n    /**\n     * Describe a \"suite\" with the given `title`.\n     */\n\n    context.suite = function (title) {\n      if (suites.length > 1) {\n        suites.shift();\n      }\n      return common.suite.create({\n        title: title,\n        file: file,\n        fn: false\n      });\n    };\n\n    /**\n     * Exclusive Suite.\n     */\n\n    context.suite.only = function (title) {\n      if (suites.length > 1) {\n        suites.shift();\n      }\n      return common.suite.only({\n        title: title,\n        file: file,\n        fn: false\n      });\n    };\n\n    /**\n     * Describe a specification or test-case\n     * with the given `title` and callback `fn`\n     * acting as a thunk.\n     */\n\n    context.test = function (title, fn) {\n      var test = new Test(title, fn);\n      test.file = file;\n      suites[0].addTest(test);\n      return test;\n    };\n\n    /**\n     * Exclusive test-case.\n     */\n\n    context.test.only = function (title, fn) {\n      return common.test.only(mocha, context.test(title, fn));\n    };\n\n    context.test.skip = common.test.skip;\n    context.test.retries = common.test.retries;\n  });\n};\n\n},{\"../test\":36,\"./common\":9}],13:[function(require,module,exports){\n'use strict';\n\n/**\n * Module dependencies.\n */\n\nvar Test = require('../test');\n\n/**\n * TDD-style interface:\n *\n *      suite('Array', function() {\n *        suite('#indexOf()', function() {\n *          suiteSetup(function() {\n *\n *          });\n *\n *          test('should return -1 when not present', function() {\n *\n *          });\n *\n *          test('should return the index when present', function() {\n *\n *          });\n *\n *          suiteTeardown(function() {\n *\n *          });\n *        });\n *      });\n *\n * @param {Suite} suite Root suite.\n */\nmodule.exports = function (suite) {\n  var suites = [suite];\n\n  suite.on('pre-require', function (context, file, mocha) {\n    var common = require('./common')(suites, context, mocha);\n\n    context.setup = common.beforeEach;\n    context.teardown = common.afterEach;\n    context.suiteSetup = common.before;\n    context.suiteTeardown = common.after;\n    context.run = mocha.options.delay && common.runWithSuite(suite);\n\n    /**\n     * Describe a \"suite\" with the given `title` and callback `fn` containing\n     * nested suites and/or tests.\n     */\n    context.suite = function (title, fn) {\n      return common.suite.create({\n        title: title,\n        file: file,\n        fn: fn\n      });\n    };\n\n    /**\n     * Pending suite.\n     */\n    context.suite.skip = function (title, fn) {\n      return common.suite.skip({\n        title: title,\n        file: file,\n        fn: fn\n      });\n    };\n\n    /**\n     * Exclusive test-case.\n     */\n    context.suite.only = function (title, fn) {\n      return common.suite.only({\n        title: title,\n        file: file,\n        fn: fn\n      });\n    };\n\n    /**\n     * Describe a specification or test-case with the given `title` and\n     * callback `fn` acting as a thunk.\n     */\n    context.test = function (title, fn) {\n      var suite = suites[0];\n      if (suite.isPending()) {\n        fn = null;\n      }\n      var test = new Test(title, fn);\n      test.file = file;\n      suite.addTest(test);\n      return test;\n    };\n\n    /**\n     * Exclusive test-case.\n     */\n\n    context.test.only = function (title, fn) {\n      return common.test.only(mocha, context.test(title, fn));\n    };\n\n    context.test.skip = common.test.skip;\n    context.test.retries = common.test.retries;\n  });\n};\n\n},{\"../test\":36,\"./common\":9}],14:[function(require,module,exports){\n(function (process,global,__dirname){\n'use strict';\n\n/*!\n * mocha\n * Copyright(c) 2011 TJ Holowaychuk <tj@vision-media.ca>\n * MIT Licensed\n */\n\n/**\n * Module dependencies.\n */\n\nvar escapeRe = require('escape-string-regexp');\nvar path = require('path');\nvar reporters = require('./reporters');\nvar utils = require('./utils');\n\n/**\n * Expose `Mocha`.\n */\n\nexports = module.exports = Mocha;\n\n/**\n * To require local UIs and reporters when running in node.\n */\n\nif (!process.browser) {\n  var cwd = process.cwd();\n  module.paths.push(cwd, path.join(cwd, 'node_modules'));\n}\n\n/**\n * Expose internals.\n */\n\nexports.utils = utils;\nexports.interfaces = require('./interfaces');\nexports.reporters = reporters;\nexports.Runnable = require('./runnable');\nexports.Context = require('./context');\nexports.Runner = require('./runner');\nexports.Suite = require('./suite');\nexports.Hook = require('./hook');\nexports.Test = require('./test');\n\n/**\n * Return image `name` path.\n *\n * @api private\n * @param {string} name\n * @return {string}\n */\nfunction image (name) {\n  return path.join(__dirname, '../images', name + '.png');\n}\n\n/**\n * Set up mocha with `options`.\n *\n * Options:\n *\n *   - `ui` name \"bdd\", \"tdd\", \"exports\" etc\n *   - `reporter` reporter instance, defaults to `mocha.reporters.spec`\n *   - `globals` array of accepted globals\n *   - `timeout` timeout in milliseconds\n *   - `retries` number of times to retry failed tests\n *   - `bail` bail on the first test failure\n *   - `slow` milliseconds to wait before considering a test slow\n *   - `ignoreLeaks` ignore global leaks\n *   - `fullTrace` display the full stack-trace on failing\n *   - `grep` string or regexp to filter tests with\n *\n * @param {Object} options\n * @api public\n */\nfunction Mocha (options) {\n  options = options || {};\n  this.files = [];\n  this.options = options;\n  if (options.grep) {\n    this.grep(new RegExp(options.grep));\n  }\n  if (options.fgrep) {\n    this.fgrep(options.fgrep);\n  }\n  this.suite = new exports.Suite('', new exports.Context());\n  this.ui(options.ui);\n  this.bail(options.bail);\n  this.reporter(options.reporter, options.reporterOptions);\n  if (typeof options.timeout !== 'undefined' && options.timeout !== null) {\n    this.timeout(options.timeout);\n  }\n  if (typeof options.retries !== 'undefined' && options.retries !== null) {\n    this.retries(options.retries);\n  }\n  this.useColors(options.useColors);\n  if (options.enableTimeouts !== null) {\n    this.enableTimeouts(options.enableTimeouts);\n  }\n  if (options.slow) {\n    this.slow(options.slow);\n  }\n}\n\n/**\n * Enable or disable bailing on the first failure.\n *\n * @api public\n * @param {boolean} [bail]\n */\nMocha.prototype.bail = function (bail) {\n  if (!arguments.length) {\n    bail = true;\n  }\n  this.suite.bail(bail);\n  return this;\n};\n\n/**\n * Add test `file`.\n *\n * @api public\n * @param {string} file\n */\nMocha.prototype.addFile = function (file) {\n  this.files.push(file);\n  return this;\n};\n\n/**\n * Set reporter to `reporter`, defaults to \"spec\".\n *\n * @param {String|Function} reporter name or constructor\n * @param {Object} reporterOptions optional options\n * @api public\n * @param {string|Function} reporter name or constructor\n * @param {Object} reporterOptions optional options\n */\nMocha.prototype.reporter = function (reporter, reporterOptions) {\n  if (typeof reporter === 'function') {\n    this._reporter = reporter;\n  } else {\n    reporter = reporter || 'spec';\n    var _reporter;\n    // Try to load a built-in reporter.\n    if (reporters[reporter]) {\n      _reporter = reporters[reporter];\n    }\n    // Try to load reporters from process.cwd() and node_modules\n    if (!_reporter) {\n      try {\n        _reporter = require(reporter);\n      } catch (err) {\n        if (err.message.indexOf('Cannot find module') !== -1) {\n          // Try to load reporters from a path (absolute or relative)\n          try {\n            _reporter = require(path.resolve(process.cwd(), reporter));\n          } catch (_err) {\n            err.message.indexOf('Cannot find module') !== -1 ? console.warn('\"' + reporter + '\" reporter not found')\n              : console.warn('\"' + reporter + '\" reporter blew up with error:\\n' + err.stack);\n          }\n        } else {\n          console.warn('\"' + reporter + '\" reporter blew up with error:\\n' + err.stack);\n        }\n      }\n    }\n    if (!_reporter && reporter === 'teamcity') {\n      console.warn('The Teamcity reporter was moved to a package named ' +\n        'mocha-teamcity-reporter ' +\n        '(https://npmjs.org/package/mocha-teamcity-reporter).');\n    }\n    if (!_reporter) {\n      throw new Error('invalid reporter \"' + reporter + '\"');\n    }\n    this._reporter = _reporter;\n  }\n  this.options.reporterOptions = reporterOptions;\n  return this;\n};\n\n/**\n * Set test UI `name`, defaults to \"bdd\".\n *\n * @api public\n * @param {string} bdd\n */\nMocha.prototype.ui = function (name) {\n  name = name || 'bdd';\n  this._ui = exports.interfaces[name];\n  if (!this._ui) {\n    try {\n      this._ui = require(name);\n    } catch (err) {\n      throw new Error('invalid interface \"' + name + '\"');\n    }\n  }\n  this._ui = this._ui(this.suite);\n\n  this.suite.on('pre-require', function (context) {\n    exports.afterEach = context.afterEach || context.teardown;\n    exports.after = context.after || context.suiteTeardown;\n    exports.beforeEach = context.beforeEach || context.setup;\n    exports.before = context.before || context.suiteSetup;\n    exports.describe = context.describe || context.suite;\n    exports.it = context.it || context.test;\n    exports.xit = context.xit || context.test.skip;\n    exports.setup = context.setup || context.beforeEach;\n    exports.suiteSetup = context.suiteSetup || context.before;\n    exports.suiteTeardown = context.suiteTeardown || context.after;\n    exports.suite = context.suite || context.describe;\n    exports.teardown = context.teardown || context.afterEach;\n    exports.test = context.test || context.it;\n    exports.run = context.run;\n  });\n\n  return this;\n};\n\n/**\n * Load registered files.\n *\n * @api private\n */\nMocha.prototype.loadFiles = function (fn) {\n  var self = this;\n  var suite = this.suite;\n  this.files.forEach(function (file) {\n    file = path.resolve(file);\n    suite.emit('pre-require', global, file, self);\n    suite.emit('require', require(file), file, self);\n    suite.emit('post-require', global, file, self);\n  });\n  fn && fn();\n};\n\n/**\n * Enable growl support.\n *\n * @api private\n */\nMocha.prototype._growl = function (runner, reporter) {\n  var notify = require('growl');\n\n  runner.on('end', function () {\n    var stats = reporter.stats;\n    if (stats.failures) {\n      var msg = stats.failures + ' of ' + runner.total + ' tests failed';\n      notify(msg, { name: 'mocha', title: 'Failed', image: image('error') });\n    } else {\n      notify(stats.passes + ' tests passed in ' + stats.duration + 'ms', {\n        name: 'mocha',\n        title: 'Passed',\n        image: image('ok')\n      });\n    }\n  });\n};\n\n/**\n * Escape string and add it to grep as a regexp.\n *\n * @api public\n * @param str\n * @returns {Mocha}\n */\nMocha.prototype.fgrep = function (str) {\n  return this.grep(new RegExp(escapeRe(str)));\n};\n\n/**\n * Add regexp to grep, if `re` is a string it is escaped.\n *\n * @param {RegExp|String} re\n * @return {Mocha}\n * @api public\n * @param {RegExp|string} re\n * @return {Mocha}\n */\nMocha.prototype.grep = function (re) {\n  if (utils.isString(re)) {\n    // extract args if it's regex-like, i.e: [string, pattern, flag]\n    var arg = re.match(/^\\/(.*)\\/(g|i|)$|.*/);\n    this.options.grep = new RegExp(arg[1] || arg[0], arg[2]);\n  } else {\n    this.options.grep = re;\n  }\n  return this;\n};\n/**\n * Invert `.grep()` matches.\n *\n * @return {Mocha}\n * @api public\n */\nMocha.prototype.invert = function () {\n  this.options.invert = true;\n  return this;\n};\n\n/**\n * Ignore global leaks.\n *\n * @param {Boolean} ignore\n * @return {Mocha}\n * @api public\n * @param {boolean} ignore\n * @return {Mocha}\n */\nMocha.prototype.ignoreLeaks = function (ignore) {\n  this.options.ignoreLeaks = Boolean(ignore);\n  return this;\n};\n\n/**\n * Enable global leak checking.\n *\n * @return {Mocha}\n * @api public\n */\nMocha.prototype.checkLeaks = function () {\n  this.options.ignoreLeaks = false;\n  return this;\n};\n\n/**\n * Display long stack-trace on failing\n *\n * @return {Mocha}\n * @api public\n */\nMocha.prototype.fullTrace = function () {\n  this.options.fullStackTrace = true;\n  return this;\n};\n\n/**\n * Enable growl support.\n *\n * @return {Mocha}\n * @api public\n */\nMocha.prototype.growl = function () {\n  this.options.growl = true;\n  return this;\n};\n\n/**\n * Ignore `globals` array or string.\n *\n * @param {Array|String} globals\n * @return {Mocha}\n * @api public\n * @param {Array|string} globals\n * @return {Mocha}\n */\nMocha.prototype.globals = function (globals) {\n  this.options.globals = (this.options.globals || []).concat(globals);\n  return this;\n};\n\n/**\n * Emit color output.\n *\n * @param {Boolean} colors\n * @return {Mocha}\n * @api public\n * @param {boolean} colors\n * @return {Mocha}\n */\nMocha.prototype.useColors = function (colors) {\n  if (colors !== undefined) {\n    this.options.useColors = colors;\n  }\n  return this;\n};\n\n/**\n * Use inline diffs rather than +/-.\n *\n * @param {Boolean} inlineDiffs\n * @return {Mocha}\n * @api public\n * @param {boolean} inlineDiffs\n * @return {Mocha}\n */\nMocha.prototype.useInlineDiffs = function (inlineDiffs) {\n  this.options.useInlineDiffs = inlineDiffs !== undefined && inlineDiffs;\n  return this;\n};\n\n/**\n * Set the timeout in milliseconds.\n *\n * @param {Number} timeout\n * @return {Mocha}\n * @api public\n * @param {number} timeout\n * @return {Mocha}\n */\nMocha.prototype.timeout = function (timeout) {\n  this.suite.timeout(timeout);\n  return this;\n};\n\n/**\n * Set the number of times to retry failed tests.\n *\n * @param {Number} retry times\n * @return {Mocha}\n * @api public\n */\nMocha.prototype.retries = function (n) {\n  this.suite.retries(n);\n  return this;\n};\n\n/**\n * Set slowness threshold in milliseconds.\n *\n * @param {Number} slow\n * @return {Mocha}\n * @api public\n * @param {number} slow\n * @return {Mocha}\n */\nMocha.prototype.slow = function (slow) {\n  this.suite.slow(slow);\n  return this;\n};\n\n/**\n * Enable timeouts.\n *\n * @param {Boolean} enabled\n * @return {Mocha}\n * @api public\n * @param {boolean} enabled\n * @return {Mocha}\n */\nMocha.prototype.enableTimeouts = function (enabled) {\n  this.suite.enableTimeouts(arguments.length && enabled !== undefined ? enabled : true);\n  return this;\n};\n\n/**\n * Makes all tests async (accepting a callback)\n *\n * @return {Mocha}\n * @api public\n */\nMocha.prototype.asyncOnly = function () {\n  this.options.asyncOnly = true;\n  return this;\n};\n\n/**\n * Disable syntax highlighting (in browser).\n *\n * @api public\n */\nMocha.prototype.noHighlighting = function () {\n  this.options.noHighlighting = true;\n  return this;\n};\n\n/**\n * Enable uncaught errors to propagate (in browser).\n *\n * @return {Mocha}\n * @api public\n */\nMocha.prototype.allowUncaught = function () {\n  this.options.allowUncaught = true;\n  return this;\n};\n\n/**\n * Delay root suite execution.\n * @returns {Mocha}\n */\nMocha.prototype.delay = function delay () {\n  this.options.delay = true;\n  return this;\n};\n\n/**\n * Tests marked only fail the suite\n * @returns {Mocha}\n */\nMocha.prototype.forbidOnly = function () {\n  this.options.forbidOnly = true;\n  return this;\n};\n\n/**\n * Pending tests and tests marked skip fail the suite\n * @returns {Mocha}\n */\nMocha.prototype.forbidPending = function () {\n  this.options.forbidPending = true;\n  return this;\n};\n\n/**\n * Run tests and invoke `fn()` when complete.\n *\n * @api public\n * @param {Function} fn\n * @return {Runner}\n */\nMocha.prototype.run = function (fn) {\n  if (this.files.length) {\n    this.loadFiles();\n  }\n  var suite = this.suite;\n  var options = this.options;\n  options.files = this.files;\n  var runner = new exports.Runner(suite, options.delay);\n  var reporter = new this._reporter(runner, options);\n  runner.ignoreLeaks = options.ignoreLeaks !== false;\n  runner.fullStackTrace = options.fullStackTrace;\n  runner.hasOnly = options.hasOnly;\n  runner.asyncOnly = options.asyncOnly;\n  runner.allowUncaught = options.allowUncaught;\n  runner.forbidOnly = options.forbidOnly;\n  runner.forbidPending = options.forbidPending;\n  if (options.grep) {\n    runner.grep(options.grep, options.invert);\n  }\n  if (options.globals) {\n    runner.globals(options.globals);\n  }\n  if (options.growl) {\n    this._growl(runner, reporter);\n  }\n  if (options.useColors !== undefined) {\n    exports.reporters.Base.useColors = options.useColors;\n  }\n  exports.reporters.Base.inlineDiffs = options.useInlineDiffs;\n\n  function done (failures) {\n    if (reporter.done) {\n      reporter.done(failures, fn);\n    } else {\n      fn && fn(failures);\n    }\n  }\n\n  return runner.run(done);\n};\n\n}).call(this,require('_process'),typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {},\"/lib\")\n},{\"./context\":6,\"./hook\":7,\"./interfaces\":11,\"./reporters\":21,\"./runnable\":33,\"./runner\":34,\"./suite\":35,\"./test\":36,\"./utils\":38,\"_process\":82,\"escape-string-regexp\":61,\"growl\":63,\"path\":42}],15:[function(require,module,exports){\n'use strict';\n\n/**\n * Helpers.\n */\n\nvar s = 1000;\nvar m = s * 60;\nvar h = m * 60;\nvar d = h * 24;\nvar y = d * 365.25;\n\n/**\n * Parse or format the given `val`.\n *\n * Options:\n *\n *  - `long` verbose formatting [false]\n *\n * @api public\n * @param {string|number} val\n * @param {Object} options\n * @return {string|number}\n */\nmodule.exports = function (val, options) {\n  options = options || {};\n  if (typeof val === 'string') {\n    return parse(val);\n  }\n  // https://github.com/mochajs/mocha/pull/1035\n  return options['long'] ? longFormat(val) : shortFormat(val);\n};\n\n/**\n * Parse the given `str` and return milliseconds.\n *\n * @api private\n * @param {string} str\n * @return {number}\n */\nfunction parse (str) {\n  var match = (/^((?:\\d+)?\\.?\\d+) *(ms|seconds?|s|minutes?|m|hours?|h|days?|d|years?|y)?$/i).exec(str);\n  if (!match) {\n    return;\n  }\n  var n = parseFloat(match[1]);\n  var type = (match[2] || 'ms').toLowerCase();\n  switch (type) {\n    case 'years':\n    case 'year':\n    case 'y':\n      return n * y;\n    case 'days':\n    case 'day':\n    case 'd':\n      return n * d;\n    case 'hours':\n    case 'hour':\n    case 'h':\n      return n * h;\n    case 'minutes':\n    case 'minute':\n    case 'm':\n      return n * m;\n    case 'seconds':\n    case 'second':\n    case 's':\n      return n * s;\n    case 'ms':\n      return n;\n    default:\n      // No default case\n  }\n}\n\n/**\n * Short format for `ms`.\n *\n * @api private\n * @param {number} ms\n * @return {string}\n */\nfunction shortFormat (ms) {\n  if (ms >= d) {\n    return Math.round(ms / d) + 'd';\n  }\n  if (ms >= h) {\n    return Math.round(ms / h) + 'h';\n  }\n  if (ms >= m) {\n    return Math.round(ms / m) + 'm';\n  }\n  if (ms >= s) {\n    return Math.round(ms / s) + 's';\n  }\n  return ms + 'ms';\n}\n\n/**\n * Long format for `ms`.\n *\n * @api private\n * @param {number} ms\n * @return {string}\n */\nfunction longFormat (ms) {\n  return plural(ms, d, 'day') ||\n    plural(ms, h, 'hour') ||\n    plural(ms, m, 'minute') ||\n    plural(ms, s, 'second') ||\n    ms + ' ms';\n}\n\n/**\n * Pluralization helper.\n *\n * @api private\n * @param {number} ms\n * @param {number} n\n * @param {string} name\n */\nfunction plural (ms, n, name) {\n  if (ms < n) {\n    return;\n  }\n  if (ms < n * 1.5) {\n    return Math.floor(ms / n) + ' ' + name;\n  }\n  return Math.ceil(ms / n) + ' ' + name + 's';\n}\n\n},{}],16:[function(require,module,exports){\n'use strict';\n\n/**\n * Expose `Pending`.\n */\n\nmodule.exports = Pending;\n\n/**\n * Initialize a new `Pending` error with the given message.\n *\n * @param {string} message\n */\nfunction Pending (message) {\n  this.message = message;\n}\n\n},{}],17:[function(require,module,exports){\n(function (process,global){\n'use strict';\n\n/**\n * Module dependencies.\n */\n\nvar tty = require('tty');\nvar diff = require('diff');\nvar ms = require('../ms');\nvar utils = require('../utils');\nvar supportsColor = process.browser ? null : require('supports-color');\n\n/**\n * Expose `Base`.\n */\n\nexports = module.exports = Base;\n\n/**\n * Save timer references to avoid Sinon interfering.\n * See: https://github.com/mochajs/mocha/issues/237\n */\n\n/* eslint-disable no-unused-vars, no-native-reassign */\nvar Date = global.Date;\nvar setTimeout = global.setTimeout;\nvar setInterval = global.setInterval;\nvar clearTimeout = global.clearTimeout;\nvar clearInterval = global.clearInterval;\n/* eslint-enable no-unused-vars, no-native-reassign */\n\n/**\n * Check if both stdio streams are associated with a tty.\n */\n\nvar isatty = tty.isatty(1) && tty.isatty(2);\n\n/**\n * Enable coloring by default, except in the browser interface.\n */\n\nexports.useColors = !process.browser && (supportsColor || (process.env.MOCHA_COLORS !== undefined));\n\n/**\n * Inline diffs instead of +/-\n */\n\nexports.inlineDiffs = false;\n\n/**\n * Default color map.\n */\n\nexports.colors = {\n  pass: 90,\n  fail: 31,\n  'bright pass': 92,\n  'bright fail': 91,\n  'bright yellow': 93,\n  pending: 36,\n  suite: 0,\n  'error title': 0,\n  'error message': 31,\n  'error stack': 90,\n  checkmark: 32,\n  fast: 90,\n  medium: 33,\n  slow: 31,\n  green: 32,\n  light: 90,\n  'diff gutter': 90,\n  'diff added': 32,\n  'diff removed': 31\n};\n\n/**\n * Default symbol map.\n */\n\nexports.symbols = {\n  ok: '✓',\n  err: '✖',\n  dot: '․',\n  comma: ',',\n  bang: '!'\n};\n\n// With node.js on Windows: use symbols available in terminal default fonts\nif (process.platform === 'win32') {\n  exports.symbols.ok = '\\u221A';\n  exports.symbols.err = '\\u00D7';\n  exports.symbols.dot = '.';\n}\n\n/**\n * Color `str` with the given `type`,\n * allowing colors to be disabled,\n * as well as user-defined color\n * schemes.\n *\n * @param {string} type\n * @param {string} str\n * @return {string}\n * @api private\n */\nvar color = exports.color = function (type, str) {\n  if (!exports.useColors) {\n    return String(str);\n  }\n  return '\\u001b[' + exports.colors[type] + 'm' + str + '\\u001b[0m';\n};\n\n/**\n * Expose term window size, with some defaults for when stderr is not a tty.\n */\n\nexports.window = {\n  width: 75\n};\n\nif (isatty) {\n  exports.window.width = process.stdout.getWindowSize\n      ? process.stdout.getWindowSize(1)[0]\n      : tty.getWindowSize()[1];\n}\n\n/**\n * Expose some basic cursor interactions that are common among reporters.\n */\n\nexports.cursor = {\n  hide: function () {\n    isatty && process.stdout.write('\\u001b[?25l');\n  },\n\n  show: function () {\n    isatty && process.stdout.write('\\u001b[?25h');\n  },\n\n  deleteLine: function () {\n    isatty && process.stdout.write('\\u001b[2K');\n  },\n\n  beginningOfLine: function () {\n    isatty && process.stdout.write('\\u001b[0G');\n  },\n\n  CR: function () {\n    if (isatty) {\n      exports.cursor.deleteLine();\n      exports.cursor.beginningOfLine();\n    } else {\n      process.stdout.write('\\r');\n    }\n  }\n};\n\n/**\n * Output the given `failures` as a list.\n *\n * @param {Array} failures\n * @api public\n */\n\nexports.list = function (failures) {\n  console.log();\n  failures.forEach(function (test, i) {\n    // format\n    var fmt = color('error title', '  %s) %s:\\n') +\n      color('error message', '     %s') +\n      color('error stack', '\\n%s\\n');\n\n    // msg\n    var msg;\n    var err = test.err;\n    var message;\n    if (err.message && typeof err.message.toString === 'function') {\n      message = err.message + '';\n    } else if (typeof err.inspect === 'function') {\n      message = err.inspect() + '';\n    } else {\n      message = '';\n    }\n    var stack = err.stack || message;\n    var index = message ? stack.indexOf(message) : -1;\n    var actual = err.actual;\n    var expected = err.expected;\n    var escape = true;\n\n    if (index === -1) {\n      msg = message;\n    } else {\n      index += message.length;\n      msg = stack.slice(0, index);\n      // remove msg from stack\n      stack = stack.slice(index + 1);\n    }\n\n    // uncaught\n    if (err.uncaught) {\n      msg = 'Uncaught ' + msg;\n    }\n    // explicitly show diff\n    if (err.showDiff !== false && sameType(actual, expected) && expected !== undefined) {\n      escape = false;\n      if (!(utils.isString(actual) && utils.isString(expected))) {\n        err.actual = actual = utils.stringify(actual);\n        err.expected = expected = utils.stringify(expected);\n      }\n\n      fmt = color('error title', '  %s) %s:\\n%s') + color('error stack', '\\n%s\\n');\n      var match = message.match(/^([^:]+): expected/);\n      msg = '\\n      ' + color('error message', match ? match[1] : msg);\n\n      if (exports.inlineDiffs) {\n        msg += inlineDiff(err, escape);\n      } else {\n        msg += unifiedDiff(err, escape);\n      }\n    }\n\n    // indent stack trace\n    stack = stack.replace(/^/gm, '  ');\n\n    console.log(fmt, (i + 1), test.fullTitle(), msg, stack);\n  });\n};\n\n/**\n * Initialize a new `Base` reporter.\n *\n * All other reporters generally\n * inherit from this reporter, providing\n * stats such as test duration, number\n * of tests passed / failed etc.\n *\n * @param {Runner} runner\n * @api public\n */\n\nfunction Base (runner) {\n  var stats = this.stats = { suites: 0, tests: 0, passes: 0, pending: 0, failures: 0 };\n  var failures = this.failures = [];\n\n  if (!runner) {\n    return;\n  }\n  this.runner = runner;\n\n  runner.stats = stats;\n\n  runner.on('start', function () {\n    stats.start = new Date();\n  });\n\n  runner.on('suite', function (suite) {\n    stats.suites = stats.suites || 0;\n    suite.root || stats.suites++;\n  });\n\n  runner.on('test end', function () {\n    stats.tests = stats.tests || 0;\n    stats.tests++;\n  });\n\n  runner.on('pass', function (test) {\n    stats.passes = stats.passes || 0;\n\n    if (test.duration > test.slow()) {\n      test.speed = 'slow';\n    } else if (test.duration > test.slow() / 2) {\n      test.speed = 'medium';\n    } else {\n      test.speed = 'fast';\n    }\n\n    stats.passes++;\n  });\n\n  runner.on('fail', function (test, err) {\n    stats.failures = stats.failures || 0;\n    stats.failures++;\n    test.err = err;\n    failures.push(test);\n  });\n\n  runner.on('end', function () {\n    stats.end = new Date();\n    stats.duration = new Date() - stats.start;\n  });\n\n  runner.on('pending', function () {\n    stats.pending++;\n  });\n}\n\n/**\n * Output common epilogue used by many of\n * the bundled reporters.\n *\n * @api public\n */\nBase.prototype.epilogue = function () {\n  var stats = this.stats;\n  var fmt;\n\n  console.log();\n\n  // passes\n  fmt = color('bright pass', ' ') +\n    color('green', ' %d passing') +\n    color('light', ' (%s)');\n\n  console.log(fmt,\n    stats.passes || 0,\n    ms(stats.duration));\n\n  // pending\n  if (stats.pending) {\n    fmt = color('pending', ' ') +\n      color('pending', ' %d pending');\n\n    console.log(fmt, stats.pending);\n  }\n\n  // failures\n  if (stats.failures) {\n    fmt = color('fail', '  %d failing');\n\n    console.log(fmt, stats.failures);\n\n    Base.list(this.failures);\n    console.log();\n  }\n\n  console.log();\n};\n\n/**\n * Pad the given `str` to `len`.\n *\n * @api private\n * @param {string} str\n * @param {string} len\n * @return {string}\n */\nfunction pad (str, len) {\n  str = String(str);\n  return Array(len - str.length + 1).join(' ') + str;\n}\n\n/**\n * Returns an inline diff between 2 strings with coloured ANSI output\n *\n * @api private\n * @param {Error} err with actual/expected\n * @param {boolean} escape\n * @return {string} Diff\n */\nfunction inlineDiff (err, escape) {\n  var msg = errorDiff(err, 'WordsWithSpace', escape);\n\n  // linenos\n  var lines = msg.split('\\n');\n  if (lines.length > 4) {\n    var width = String(lines.length).length;\n    msg = lines.map(function (str, i) {\n      return pad(++i, width) + ' |' + ' ' + str;\n    }).join('\\n');\n  }\n\n  // legend\n  msg = '\\n' +\n    color('diff removed', 'actual') +\n    ' ' +\n    color('diff added', 'expected') +\n    '\\n\\n' +\n    msg +\n    '\\n';\n\n  // indent\n  msg = msg.replace(/^/gm, '      ');\n  return msg;\n}\n\n/**\n * Returns a unified diff between two strings.\n *\n * @api private\n * @param {Error} err with actual/expected\n * @param {boolean} escape\n * @return {string} The diff.\n */\nfunction unifiedDiff (err, escape) {\n  var indent = '      ';\n  function cleanUp (line) {\n    if (escape) {\n      line = escapeInvisibles(line);\n    }\n    if (line[0] === '+') {\n      return indent + colorLines('diff added', line);\n    }\n    if (line[0] === '-') {\n      return indent + colorLines('diff removed', line);\n    }\n    if (line.match(/@@/)) {\n      return null;\n    }\n    if (line.match(/\\\\ No newline/)) {\n      return null;\n    }\n    return indent + line;\n  }\n  function notBlank (line) {\n    return typeof line !== 'undefined' && line !== null;\n  }\n  var msg = diff.createPatch('string', err.actual, err.expected);\n  var lines = msg.split('\\n').splice(4);\n  return '\\n      ' +\n    colorLines('diff added', '+ expected') + ' ' +\n    colorLines('diff removed', '- actual') +\n    '\\n\\n' +\n    lines.map(cleanUp).filter(notBlank).join('\\n');\n}\n\n/**\n * Return a character diff for `err`.\n *\n * @api private\n * @param {Error} err\n * @param {string} type\n * @param {boolean} escape\n * @return {string}\n */\nfunction errorDiff (err, type, escape) {\n  var actual = escape ? escapeInvisibles(err.actual) : err.actual;\n  var expected = escape ? escapeInvisibles(err.expected) : err.expected;\n  return diff['diff' + type](actual, expected).map(function (str) {\n    if (str.added) {\n      return colorLines('diff added', str.value);\n    }\n    if (str.removed) {\n      return colorLines('diff removed', str.value);\n    }\n    return str.value;\n  }).join('');\n}\n\n/**\n * Returns a string with all invisible characters in plain text\n *\n * @api private\n * @param {string} line\n * @return {string}\n */\nfunction escapeInvisibles (line) {\n  return line.replace(/\\t/g, '<tab>')\n    .replace(/\\r/g, '<CR>')\n    .replace(/\\n/g, '<LF>\\n');\n}\n\n/**\n * Color lines for `str`, using the color `name`.\n *\n * @api private\n * @param {string} name\n * @param {string} str\n * @return {string}\n */\nfunction colorLines (name, str) {\n  return str.split('\\n').map(function (str) {\n    return color(name, str);\n  }).join('\\n');\n}\n\n/**\n * Object#toString reference.\n */\nvar objToString = Object.prototype.toString;\n\n/**\n * Check that a / b have the same type.\n *\n * @api private\n * @param {Object} a\n * @param {Object} b\n * @return {boolean}\n */\nfunction sameType (a, b) {\n  return objToString.call(a) === objToString.call(b);\n}\n\n}).call(this,require('_process'),typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n},{\"../ms\":15,\"../utils\":38,\"_process\":82,\"diff\":55,\"supports-color\":42,\"tty\":5}],18:[function(require,module,exports){\n'use strict';\n\n/**\n * Module dependencies.\n */\n\nvar Base = require('./base');\nvar utils = require('../utils');\n\n/**\n * Expose `Doc`.\n */\n\nexports = module.exports = Doc;\n\n/**\n * Initialize a new `Doc` reporter.\n *\n * @param {Runner} runner\n * @api public\n */\nfunction Doc (runner) {\n  Base.call(this, runner);\n\n  var indents = 2;\n\n  function indent () {\n    return Array(indents).join('  ');\n  }\n\n  runner.on('suite', function (suite) {\n    if (suite.root) {\n      return;\n    }\n    ++indents;\n    console.log('%s<section class=\"suite\">', indent());\n    ++indents;\n    console.log('%s<h1>%s</h1>', indent(), utils.escape(suite.title));\n    console.log('%s<dl>', indent());\n  });\n\n  runner.on('suite end', function (suite) {\n    if (suite.root) {\n      return;\n    }\n    console.log('%s</dl>', indent());\n    --indents;\n    console.log('%s</section>', indent());\n    --indents;\n  });\n\n  runner.on('pass', function (test) {\n    console.log('%s  <dt>%s</dt>', indent(), utils.escape(test.title));\n    var code = utils.escape(utils.clean(test.body));\n    console.log('%s  <dd><pre><code>%s</code></pre></dd>', indent(), code);\n  });\n\n  runner.on('fail', function (test, err) {\n    console.log('%s  <dt class=\"error\">%s</dt>', indent(), utils.escape(test.title));\n    var code = utils.escape(utils.clean(test.body));\n    console.log('%s  <dd class=\"error\"><pre><code>%s</code></pre></dd>', indent(), code);\n    console.log('%s  <dd class=\"error\">%s</dd>', indent(), utils.escape(err));\n  });\n}\n\n},{\"../utils\":38,\"./base\":17}],19:[function(require,module,exports){\n(function (process){\n'use strict';\n\n/**\n * Module dependencies.\n */\n\nvar Base = require('./base');\nvar inherits = require('../utils').inherits;\nvar color = Base.color;\n\n/**\n * Expose `Dot`.\n */\n\nexports = module.exports = Dot;\n\n/**\n * Initialize a new `Dot` matrix test reporter.\n *\n * @api public\n * @param {Runner} runner\n */\nfunction Dot (runner) {\n  Base.call(this, runner);\n\n  var self = this;\n  var width = Base.window.width * 0.75 | 0;\n  var n = -1;\n\n  runner.on('start', function () {\n    process.stdout.write('\\n');\n  });\n\n  runner.on('pending', function () {\n    if (++n % width === 0) {\n      process.stdout.write('\\n  ');\n    }\n    process.stdout.write(color('pending', Base.symbols.comma));\n  });\n\n  runner.on('pass', function (test) {\n    if (++n % width === 0) {\n      process.stdout.write('\\n  ');\n    }\n    if (test.speed === 'slow') {\n      process.stdout.write(color('bright yellow', Base.symbols.dot));\n    } else {\n      process.stdout.write(color(test.speed, Base.symbols.dot));\n    }\n  });\n\n  runner.on('fail', function () {\n    if (++n % width === 0) {\n      process.stdout.write('\\n  ');\n    }\n    process.stdout.write(color('fail', Base.symbols.bang));\n  });\n\n  runner.on('end', function () {\n    console.log();\n    self.epilogue();\n  });\n}\n\n/**\n * Inherit from `Base.prototype`.\n */\ninherits(Dot, Base);\n\n}).call(this,require('_process'))\n},{\"../utils\":38,\"./base\":17,\"_process\":82}],20:[function(require,module,exports){\n(function (global){\n'use strict';\n\n/* eslint-env browser */\n\n/**\n * Module dependencies.\n */\n\nvar Base = require('./base');\nvar utils = require('../utils');\nvar Progress = require('../browser/progress');\nvar escapeRe = require('escape-string-regexp');\nvar escape = utils.escape;\n\n/**\n * Save timer references to avoid Sinon interfering (see GH-237).\n */\n\n/* eslint-disable no-unused-vars, no-native-reassign */\nvar Date = global.Date;\nvar setTimeout = global.setTimeout;\nvar setInterval = global.setInterval;\nvar clearTimeout = global.clearTimeout;\nvar clearInterval = global.clearInterval;\n/* eslint-enable no-unused-vars, no-native-reassign */\n\n/**\n * Expose `HTML`.\n */\n\nexports = module.exports = HTML;\n\n/**\n * Stats template.\n */\n\nvar statsTemplate = '<ul id=\"mocha-stats\">' +\n  '<li class=\"progress\"><canvas width=\"40\" height=\"40\"></canvas></li>' +\n  '<li class=\"passes\"><a href=\"javascript:void(0);\">passes:</a> <em>0</em></li>' +\n  '<li class=\"failures\"><a href=\"javascript:void(0);\">failures:</a> <em>0</em></li>' +\n  '<li class=\"duration\">duration: <em>0</em>s</li>' +\n  '</ul>';\n\nvar playIcon = '&#x2023;';\n\n/**\n * Initialize a new `HTML` reporter.\n *\n * @api public\n * @param {Runner} runner\n */\nfunction HTML (runner) {\n  Base.call(this, runner);\n\n  var self = this;\n  var stats = this.stats;\n  var stat = fragment(statsTemplate);\n  var items = stat.getElementsByTagName('li');\n  var passes = items[1].getElementsByTagName('em')[0];\n  var passesLink = items[1].getElementsByTagName('a')[0];\n  var failures = items[2].getElementsByTagName('em')[0];\n  var failuresLink = items[2].getElementsByTagName('a')[0];\n  var duration = items[3].getElementsByTagName('em')[0];\n  var canvas = stat.getElementsByTagName('canvas')[0];\n  var report = fragment('<ul id=\"mocha-report\"></ul>');\n  var stack = [report];\n  var progress;\n  var ctx;\n  var root = document.getElementById('mocha');\n\n  if (canvas.getContext) {\n    var ratio = window.devicePixelRatio || 1;\n    canvas.style.width = canvas.width;\n    canvas.style.height = canvas.height;\n    canvas.width *= ratio;\n    canvas.height *= ratio;\n    ctx = canvas.getContext('2d');\n    ctx.scale(ratio, ratio);\n    progress = new Progress();\n  }\n\n  if (!root) {\n    return error('#mocha div missing, add it to your document');\n  }\n\n  // pass toggle\n  on(passesLink, 'click', function (evt) {\n    evt.preventDefault();\n    unhide();\n    var name = (/pass/).test(report.className) ? '' : ' pass';\n    report.className = report.className.replace(/fail|pass/g, '') + name;\n    if (report.className.trim()) {\n      hideSuitesWithout('test pass');\n    }\n  });\n\n  // failure toggle\n  on(failuresLink, 'click', function (evt) {\n    evt.preventDefault();\n    unhide();\n    var name = (/fail/).test(report.className) ? '' : ' fail';\n    report.className = report.className.replace(/fail|pass/g, '') + name;\n    if (report.className.trim()) {\n      hideSuitesWithout('test fail');\n    }\n  });\n\n  root.appendChild(stat);\n  root.appendChild(report);\n\n  if (progress) {\n    progress.size(40);\n  }\n\n  runner.on('suite', function (suite) {\n    if (suite.root) {\n      return;\n    }\n\n    // suite\n    var url = self.suiteURL(suite);\n    var el = fragment('<li class=\"suite\"><h1><a href=\"%s\">%s</a></h1></li>', url, escape(suite.title));\n\n    // container\n    stack[0].appendChild(el);\n    stack.unshift(document.createElement('ul'));\n    el.appendChild(stack[0]);\n  });\n\n  runner.on('suite end', function (suite) {\n    if (suite.root) {\n      updateStats();\n      return;\n    }\n    stack.shift();\n  });\n\n  runner.on('pass', function (test) {\n    var url = self.testURL(test);\n    var markup = '<li class=\"test pass %e\"><h2>%e<span class=\"duration\">%ems</span> ' +\n      '<a href=\"%s\" class=\"replay\">' + playIcon + '</a></h2></li>';\n    var el = fragment(markup, test.speed, test.title, test.duration, url);\n    self.addCodeToggle(el, test.body);\n    appendToStack(el);\n    updateStats();\n  });\n\n  runner.on('fail', function (test) {\n    var el = fragment('<li class=\"test fail\"><h2>%e <a href=\"%e\" class=\"replay\">' + playIcon + '</a></h2></li>',\n      test.title, self.testURL(test));\n    var stackString; // Note: Includes leading newline\n    var message = test.err.toString();\n\n    // <=IE7 stringifies to [Object Error]. Since it can be overloaded, we\n    // check for the result of the stringifying.\n    if (message === '[object Error]') {\n      message = test.err.message;\n    }\n\n    if (test.err.stack) {\n      var indexOfMessage = test.err.stack.indexOf(test.err.message);\n      if (indexOfMessage === -1) {\n        stackString = test.err.stack;\n      } else {\n        stackString = test.err.stack.substr(test.err.message.length + indexOfMessage);\n      }\n    } else if (test.err.sourceURL && test.err.line !== undefined) {\n      // Safari doesn't give you a stack. Let's at least provide a source line.\n      stackString = '\\n(' + test.err.sourceURL + ':' + test.err.line + ')';\n    }\n\n    stackString = stackString || '';\n\n    if (test.err.htmlMessage && stackString) {\n      el.appendChild(fragment('<div class=\"html-error\">%s\\n<pre class=\"error\">%e</pre></div>',\n        test.err.htmlMessage, stackString));\n    } else if (test.err.htmlMessage) {\n      el.appendChild(fragment('<div class=\"html-error\">%s</div>', test.err.htmlMessage));\n    } else {\n      el.appendChild(fragment('<pre class=\"error\">%e%e</pre>', message, stackString));\n    }\n\n    self.addCodeToggle(el, test.body);\n    appendToStack(el);\n    updateStats();\n  });\n\n  runner.on('pending', function (test) {\n    var el = fragment('<li class=\"test pass pending\"><h2>%e</h2></li>', test.title);\n    appendToStack(el);\n    updateStats();\n  });\n\n  function appendToStack (el) {\n    // Don't call .appendChild if #mocha-report was already .shift()'ed off the stack.\n    if (stack[0]) {\n      stack[0].appendChild(el);\n    }\n  }\n\n  function updateStats () {\n    // TODO: add to stats\n    var percent = stats.tests / runner.total * 100 | 0;\n    if (progress) {\n      progress.update(percent).draw(ctx);\n    }\n\n    // update stats\n    var ms = new Date() - stats.start;\n    text(passes, stats.passes);\n    text(failures, stats.failures);\n    text(duration, (ms / 1000).toFixed(2));\n  }\n}\n\n/**\n * Makes a URL, preserving querystring (\"search\") parameters.\n *\n * @param {string} s\n * @return {string} A new URL.\n */\nfunction makeUrl (s) {\n  var search = window.location.search;\n\n  // Remove previous grep query parameter if present\n  if (search) {\n    search = search.replace(/[?&]grep=[^&\\s]*/g, '').replace(/^&/, '?');\n  }\n\n  return window.location.pathname + (search ? search + '&' : '?') + 'grep=' + encodeURIComponent(escapeRe(s));\n}\n\n/**\n * Provide suite URL.\n *\n * @param {Object} [suite]\n */\nHTML.prototype.suiteURL = function (suite) {\n  return makeUrl(suite.fullTitle());\n};\n\n/**\n * Provide test URL.\n *\n * @param {Object} [test]\n */\nHTML.prototype.testURL = function (test) {\n  return makeUrl(test.fullTitle());\n};\n\n/**\n * Adds code toggle functionality for the provided test's list element.\n *\n * @param {HTMLLIElement} el\n * @param {string} contents\n */\nHTML.prototype.addCodeToggle = function (el, contents) {\n  var h2 = el.getElementsByTagName('h2')[0];\n\n  on(h2, 'click', function () {\n    pre.style.display = pre.style.display === 'none' ? 'block' : 'none';\n  });\n\n  var pre = fragment('<pre><code>%e</code></pre>', utils.clean(contents));\n  el.appendChild(pre);\n  pre.style.display = 'none';\n};\n\n/**\n * Display error `msg`.\n *\n * @param {string} msg\n */\nfunction error (msg) {\n  document.body.appendChild(fragment('<div id=\"mocha-error\">%s</div>', msg));\n}\n\n/**\n * Return a DOM fragment from `html`.\n *\n * @param {string} html\n */\nfunction fragment (html) {\n  var args = arguments;\n  var div = document.createElement('div');\n  var i = 1;\n\n  div.innerHTML = html.replace(/%([se])/g, function (_, type) {\n    switch (type) {\n      case 's': return String(args[i++]);\n      case 'e': return escape(args[i++]);\n      // no default\n    }\n  });\n\n  return div.firstChild;\n}\n\n/**\n * Check for suites that do not have elements\n * with `classname`, and hide them.\n *\n * @param {text} classname\n */\nfunction hideSuitesWithout (classname) {\n  var suites = document.getElementsByClassName('suite');\n  for (var i = 0; i < suites.length; i++) {\n    var els = suites[i].getElementsByClassName(classname);\n    if (!els.length) {\n      suites[i].className += ' hidden';\n    }\n  }\n}\n\n/**\n * Unhide .hidden suites.\n */\nfunction unhide () {\n  var els = document.getElementsByClassName('suite hidden');\n  for (var i = 0; i < els.length; ++i) {\n    els[i].className = els[i].className.replace('suite hidden', 'suite');\n  }\n}\n\n/**\n * Set an element's text contents.\n *\n * @param {HTMLElement} el\n * @param {string} contents\n */\nfunction text (el, contents) {\n  if (el.textContent) {\n    el.textContent = contents;\n  } else {\n    el.innerText = contents;\n  }\n}\n\n/**\n * Listen on `event` with callback `fn`.\n */\nfunction on (el, event, fn) {\n  if (el.addEventListener) {\n    el.addEventListener(event, fn, false);\n  } else {\n    el.attachEvent('on' + event, fn);\n  }\n}\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n},{\"../browser/progress\":4,\"../utils\":38,\"./base\":17,\"escape-string-regexp\":61}],21:[function(require,module,exports){\n'use strict';\n\n// Alias exports to a their normalized format Mocha#reporter to prevent a need\n// for dynamic (try/catch) requires, which Browserify doesn't handle.\nexports.Base = exports.base = require('./base');\nexports.Dot = exports.dot = require('./dot');\nexports.Doc = exports.doc = require('./doc');\nexports.TAP = exports.tap = require('./tap');\nexports.JSON = exports.json = require('./json');\nexports.HTML = exports.html = require('./html');\nexports.List = exports.list = require('./list');\nexports.Min = exports.min = require('./min');\nexports.Spec = exports.spec = require('./spec');\nexports.Nyan = exports.nyan = require('./nyan');\nexports.XUnit = exports.xunit = require('./xunit');\nexports.Markdown = exports.markdown = require('./markdown');\nexports.Progress = exports.progress = require('./progress');\nexports.Landing = exports.landing = require('./landing');\nexports.JSONStream = exports['json-stream'] = require('./json-stream');\n\n},{\"./base\":17,\"./doc\":18,\"./dot\":19,\"./html\":20,\"./json\":23,\"./json-stream\":22,\"./landing\":24,\"./list\":25,\"./markdown\":26,\"./min\":27,\"./nyan\":28,\"./progress\":29,\"./spec\":30,\"./tap\":31,\"./xunit\":32}],22:[function(require,module,exports){\n(function (process){\n'use strict';\n\n/**\n * Module dependencies.\n */\n\nvar Base = require('./base');\nvar JSON = require('json3');\n\n/**\n * Expose `List`.\n */\n\nexports = module.exports = List;\n\n/**\n * Initialize a new `List` test reporter.\n *\n * @api public\n * @param {Runner} runner\n */\nfunction List (runner) {\n  Base.call(this, runner);\n\n  var self = this;\n  var total = runner.total;\n\n  runner.on('start', function () {\n    console.log(JSON.stringify(['start', { total: total }]));\n  });\n\n  runner.on('pass', function (test) {\n    console.log(JSON.stringify(['pass', clean(test)]));\n  });\n\n  runner.on('fail', function (test, err) {\n    test = clean(test);\n    test.err = err.message;\n    test.stack = err.stack || null;\n    console.log(JSON.stringify(['fail', test]));\n  });\n\n  runner.on('end', function () {\n    process.stdout.write(JSON.stringify(['end', self.stats]));\n  });\n}\n\n/**\n * Return a plain-object representation of `test`\n * free of cyclic properties etc.\n *\n * @api private\n * @param {Object} test\n * @return {Object}\n */\nfunction clean (test) {\n  return {\n    title: test.title,\n    fullTitle: test.fullTitle(),\n    duration: test.duration,\n    currentRetry: test.currentRetry()\n  };\n}\n\n}).call(this,require('_process'))\n},{\"./base\":17,\"_process\":82,\"json3\":69}],23:[function(require,module,exports){\n(function (process){\n'use strict';\n\n/**\n * Module dependencies.\n */\n\nvar Base = require('./base');\n\n/**\n * Expose `JSON`.\n */\n\nexports = module.exports = JSONReporter;\n\n/**\n * Initialize a new `JSON` reporter.\n *\n * @api public\n * @param {Runner} runner\n */\nfunction JSONReporter (runner) {\n  Base.call(this, runner);\n\n  var self = this;\n  var tests = [];\n  var pending = [];\n  var failures = [];\n  var passes = [];\n\n  runner.on('test end', function (test) {\n    tests.push(test);\n  });\n\n  runner.on('pass', function (test) {\n    passes.push(test);\n  });\n\n  runner.on('fail', function (test) {\n    failures.push(test);\n  });\n\n  runner.on('pending', function (test) {\n    pending.push(test);\n  });\n\n  runner.on('end', function () {\n    var obj = {\n      stats: self.stats,\n      tests: tests.map(clean),\n      pending: pending.map(clean),\n      failures: failures.map(clean),\n      passes: passes.map(clean)\n    };\n\n    runner.testResults = obj;\n\n    process.stdout.write(JSON.stringify(obj, null, 2));\n  });\n}\n\n/**\n * Return a plain-object representation of `test`\n * free of cyclic properties etc.\n *\n * @api private\n * @param {Object} test\n * @return {Object}\n */\nfunction clean (test) {\n  return {\n    title: test.title,\n    fullTitle: test.fullTitle(),\n    duration: test.duration,\n    currentRetry: test.currentRetry(),\n    err: errorJSON(test.err || {})\n  };\n}\n\n/**\n * Transform `error` into a JSON object.\n *\n * @api private\n * @param {Error} err\n * @return {Object}\n */\nfunction errorJSON (err) {\n  var res = {};\n  Object.getOwnPropertyNames(err).forEach(function (key) {\n    res[key] = err[key];\n  }, err);\n  return res;\n}\n\n}).call(this,require('_process'))\n},{\"./base\":17,\"_process\":82}],24:[function(require,module,exports){\n(function (process){\n'use strict';\n\n/**\n * Module dependencies.\n */\n\nvar Base = require('./base');\nvar inherits = require('../utils').inherits;\nvar cursor = Base.cursor;\nvar color = Base.color;\n\n/**\n * Expose `Landing`.\n */\n\nexports = module.exports = Landing;\n\n/**\n * Airplane color.\n */\n\nBase.colors.plane = 0;\n\n/**\n * Airplane crash color.\n */\n\nBase.colors['plane crash'] = 31;\n\n/**\n * Runway color.\n */\n\nBase.colors.runway = 90;\n\n/**\n * Initialize a new `Landing` reporter.\n *\n * @api public\n * @param {Runner} runner\n */\nfunction Landing (runner) {\n  Base.call(this, runner);\n\n  var self = this;\n  var width = Base.window.width * 0.75 | 0;\n  var total = runner.total;\n  var stream = process.stdout;\n  var plane = color('plane', '✈');\n  var crashed = -1;\n  var n = 0;\n\n  function runway () {\n    var buf = Array(width).join('-');\n    return '  ' + color('runway', buf);\n  }\n\n  runner.on('start', function () {\n    stream.write('\\n\\n\\n  ');\n    cursor.hide();\n  });\n\n  runner.on('test end', function (test) {\n    // check if the plane crashed\n    var col = crashed === -1 ? width * ++n / total | 0 : crashed;\n\n    // show the crash\n    if (test.state === 'failed') {\n      plane = color('plane crash', '✈');\n      crashed = col;\n    }\n\n    // render landing strip\n    stream.write('\\u001b[' + (width + 1) + 'D\\u001b[2A');\n    stream.write(runway());\n    stream.write('\\n  ');\n    stream.write(color('runway', Array(col).join('⋅')));\n    stream.write(plane);\n    stream.write(color('runway', Array(width - col).join('⋅') + '\\n'));\n    stream.write(runway());\n    stream.write('\\u001b[0m');\n  });\n\n  runner.on('end', function () {\n    cursor.show();\n    console.log();\n    self.epilogue();\n  });\n}\n\n/**\n * Inherit from `Base.prototype`.\n */\ninherits(Landing, Base);\n\n}).call(this,require('_process'))\n},{\"../utils\":38,\"./base\":17,\"_process\":82}],25:[function(require,module,exports){\n(function (process){\n'use strict';\n\n/**\n * Module dependencies.\n */\n\nvar Base = require('./base');\nvar inherits = require('../utils').inherits;\nvar color = Base.color;\nvar cursor = Base.cursor;\n\n/**\n * Expose `List`.\n */\n\nexports = module.exports = List;\n\n/**\n * Initialize a new `List` test reporter.\n *\n * @api public\n * @param {Runner} runner\n */\nfunction List (runner) {\n  Base.call(this, runner);\n\n  var self = this;\n  var n = 0;\n\n  runner.on('start', function () {\n    console.log();\n  });\n\n  runner.on('test', function (test) {\n    process.stdout.write(color('pass', '    ' + test.fullTitle() + ': '));\n  });\n\n  runner.on('pending', function (test) {\n    var fmt = color('checkmark', '  -') +\n      color('pending', ' %s');\n    console.log(fmt, test.fullTitle());\n  });\n\n  runner.on('pass', function (test) {\n    var fmt = color('checkmark', '  ' + Base.symbols.ok) +\n      color('pass', ' %s: ') +\n      color(test.speed, '%dms');\n    cursor.CR();\n    console.log(fmt, test.fullTitle(), test.duration);\n  });\n\n  runner.on('fail', function (test) {\n    cursor.CR();\n    console.log(color('fail', '  %d) %s'), ++n, test.fullTitle());\n  });\n\n  runner.on('end', self.epilogue.bind(self));\n}\n\n/**\n * Inherit from `Base.prototype`.\n */\ninherits(List, Base);\n\n}).call(this,require('_process'))\n},{\"../utils\":38,\"./base\":17,\"_process\":82}],26:[function(require,module,exports){\n(function (process){\n'use strict';\n\n/**\n * Module dependencies.\n */\n\nvar Base = require('./base');\nvar utils = require('../utils');\n\n/**\n * Constants\n */\n\nvar SUITE_PREFIX = '$';\n\n/**\n * Expose `Markdown`.\n */\n\nexports = module.exports = Markdown;\n\n/**\n * Initialize a new `Markdown` reporter.\n *\n * @api public\n * @param {Runner} runner\n */\nfunction Markdown (runner) {\n  Base.call(this, runner);\n\n  var level = 0;\n  var buf = '';\n\n  function title (str) {\n    return Array(level).join('#') + ' ' + str;\n  }\n\n  function mapTOC (suite, obj) {\n    var ret = obj;\n    var key = SUITE_PREFIX + suite.title;\n\n    obj = obj[key] = obj[key] || { suite: suite };\n    suite.suites.forEach(function (suite) {\n      mapTOC(suite, obj);\n    });\n\n    return ret;\n  }\n\n  function stringifyTOC (obj, level) {\n    ++level;\n    var buf = '';\n    var link;\n    for (var key in obj) {\n      if (key === 'suite') {\n        continue;\n      }\n      if (key !== SUITE_PREFIX) {\n        link = ' - [' + key.substring(1) + ']';\n        link += '(#' + utils.slug(obj[key].suite.fullTitle()) + ')\\n';\n        buf += Array(level).join('  ') + link;\n      }\n      buf += stringifyTOC(obj[key], level);\n    }\n    return buf;\n  }\n\n  function generateTOC (suite) {\n    var obj = mapTOC(suite, {});\n    return stringifyTOC(obj, 0);\n  }\n\n  generateTOC(runner.suite);\n\n  runner.on('suite', function (suite) {\n    ++level;\n    var slug = utils.slug(suite.fullTitle());\n    buf += '<a name=\"' + slug + '\"></a>' + '\\n';\n    buf += title(suite.title) + '\\n';\n  });\n\n  runner.on('suite end', function () {\n    --level;\n  });\n\n  runner.on('pass', function (test) {\n    var code = utils.clean(test.body);\n    buf += test.title + '.\\n';\n    buf += '\\n```js\\n';\n    buf += code + '\\n';\n    buf += '```\\n\\n';\n  });\n\n  runner.on('end', function () {\n    process.stdout.write('# TOC\\n');\n    process.stdout.write(generateTOC(runner.suite));\n    process.stdout.write(buf);\n  });\n}\n\n}).call(this,require('_process'))\n},{\"../utils\":38,\"./base\":17,\"_process\":82}],27:[function(require,module,exports){\n(function (process){\n'use strict';\n\n/**\n * Module dependencies.\n */\n\nvar Base = require('./base');\nvar inherits = require('../utils').inherits;\n\n/**\n * Expose `Min`.\n */\n\nexports = module.exports = Min;\n\n/**\n * Initialize a new `Min` minimal test reporter (best used with --watch).\n *\n * @api public\n * @param {Runner} runner\n */\nfunction Min (runner) {\n  Base.call(this, runner);\n\n  runner.on('start', function () {\n    // clear screen\n    process.stdout.write('\\u001b[2J');\n    // set cursor position\n    process.stdout.write('\\u001b[1;3H');\n  });\n\n  runner.on('end', this.epilogue.bind(this));\n}\n\n/**\n * Inherit from `Base.prototype`.\n */\ninherits(Min, Base);\n\n}).call(this,require('_process'))\n},{\"../utils\":38,\"./base\":17,\"_process\":82}],28:[function(require,module,exports){\n(function (process){\n'use strict';\n\n/**\n * Module dependencies.\n */\n\nvar Base = require('./base');\nvar inherits = require('../utils').inherits;\n\n/**\n * Expose `Dot`.\n */\n\nexports = module.exports = NyanCat;\n\n/**\n * Initialize a new `Dot` matrix test reporter.\n *\n * @param {Runner} runner\n * @api public\n */\n\nfunction NyanCat (runner) {\n  Base.call(this, runner);\n\n  var self = this;\n  var width = Base.window.width * 0.75 | 0;\n  var nyanCatWidth = this.nyanCatWidth = 11;\n\n  this.colorIndex = 0;\n  this.numberOfLines = 4;\n  this.rainbowColors = self.generateColors();\n  this.scoreboardWidth = 5;\n  this.tick = 0;\n  this.trajectories = [[], [], [], []];\n  this.trajectoryWidthMax = (width - nyanCatWidth);\n\n  runner.on('start', function () {\n    Base.cursor.hide();\n    self.draw();\n  });\n\n  runner.on('pending', function () {\n    self.draw();\n  });\n\n  runner.on('pass', function () {\n    self.draw();\n  });\n\n  runner.on('fail', function () {\n    self.draw();\n  });\n\n  runner.on('end', function () {\n    Base.cursor.show();\n    for (var i = 0; i < self.numberOfLines; i++) {\n      write('\\n');\n    }\n    self.epilogue();\n  });\n}\n\n/**\n * Inherit from `Base.prototype`.\n */\ninherits(NyanCat, Base);\n\n/**\n * Draw the nyan cat\n *\n * @api private\n */\n\nNyanCat.prototype.draw = function () {\n  this.appendRainbow();\n  this.drawScoreboard();\n  this.drawRainbow();\n  this.drawNyanCat();\n  this.tick = !this.tick;\n};\n\n/**\n * Draw the \"scoreboard\" showing the number\n * of passes, failures and pending tests.\n *\n * @api private\n */\n\nNyanCat.prototype.drawScoreboard = function () {\n  var stats = this.stats;\n\n  function draw (type, n) {\n    write(' ');\n    write(Base.color(type, n));\n    write('\\n');\n  }\n\n  draw('green', stats.passes);\n  draw('fail', stats.failures);\n  draw('pending', stats.pending);\n  write('\\n');\n\n  this.cursorUp(this.numberOfLines);\n};\n\n/**\n * Append the rainbow.\n *\n * @api private\n */\n\nNyanCat.prototype.appendRainbow = function () {\n  var segment = this.tick ? '_' : '-';\n  var rainbowified = this.rainbowify(segment);\n\n  for (var index = 0; index < this.numberOfLines; index++) {\n    var trajectory = this.trajectories[index];\n    if (trajectory.length >= this.trajectoryWidthMax) {\n      trajectory.shift();\n    }\n    trajectory.push(rainbowified);\n  }\n};\n\n/**\n * Draw the rainbow.\n *\n * @api private\n */\n\nNyanCat.prototype.drawRainbow = function () {\n  var self = this;\n\n  this.trajectories.forEach(function (line) {\n    write('\\u001b[' + self.scoreboardWidth + 'C');\n    write(line.join(''));\n    write('\\n');\n  });\n\n  this.cursorUp(this.numberOfLines);\n};\n\n/**\n * Draw the nyan cat\n *\n * @api private\n */\nNyanCat.prototype.drawNyanCat = function () {\n  var self = this;\n  var startWidth = this.scoreboardWidth + this.trajectories[0].length;\n  var dist = '\\u001b[' + startWidth + 'C';\n  var padding = '';\n\n  write(dist);\n  write('_,------,');\n  write('\\n');\n\n  write(dist);\n  padding = self.tick ? '  ' : '   ';\n  write('_|' + padding + '/\\\\_/\\\\ ');\n  write('\\n');\n\n  write(dist);\n  padding = self.tick ? '_' : '__';\n  var tail = self.tick ? '~' : '^';\n  write(tail + '|' + padding + this.face() + ' ');\n  write('\\n');\n\n  write(dist);\n  padding = self.tick ? ' ' : '  ';\n  write(padding + '\"\"  \"\" ');\n  write('\\n');\n\n  this.cursorUp(this.numberOfLines);\n};\n\n/**\n * Draw nyan cat face.\n *\n * @api private\n * @return {string}\n */\n\nNyanCat.prototype.face = function () {\n  var stats = this.stats;\n  if (stats.failures) {\n    return '( x .x)';\n  } else if (stats.pending) {\n    return '( o .o)';\n  } else if (stats.passes) {\n    return '( ^ .^)';\n  }\n  return '( - .-)';\n};\n\n/**\n * Move cursor up `n`.\n *\n * @api private\n * @param {number} n\n */\n\nNyanCat.prototype.cursorUp = function (n) {\n  write('\\u001b[' + n + 'A');\n};\n\n/**\n * Move cursor down `n`.\n *\n * @api private\n * @param {number} n\n */\n\nNyanCat.prototype.cursorDown = function (n) {\n  write('\\u001b[' + n + 'B');\n};\n\n/**\n * Generate rainbow colors.\n *\n * @api private\n * @return {Array}\n */\nNyanCat.prototype.generateColors = function () {\n  var colors = [];\n\n  for (var i = 0; i < (6 * 7); i++) {\n    var pi3 = Math.floor(Math.PI / 3);\n    var n = (i * (1.0 / 6));\n    var r = Math.floor(3 * Math.sin(n) + 3);\n    var g = Math.floor(3 * Math.sin(n + 2 * pi3) + 3);\n    var b = Math.floor(3 * Math.sin(n + 4 * pi3) + 3);\n    colors.push(36 * r + 6 * g + b + 16);\n  }\n\n  return colors;\n};\n\n/**\n * Apply rainbow to the given `str`.\n *\n * @api private\n * @param {string} str\n * @return {string}\n */\nNyanCat.prototype.rainbowify = function (str) {\n  if (!Base.useColors) {\n    return str;\n  }\n  var color = this.rainbowColors[this.colorIndex % this.rainbowColors.length];\n  this.colorIndex += 1;\n  return '\\u001b[38;5;' + color + 'm' + str + '\\u001b[0m';\n};\n\n/**\n * Stdout helper.\n *\n * @param {string} string A message to write to stdout.\n */\nfunction write (string) {\n  process.stdout.write(string);\n}\n\n}).call(this,require('_process'))\n},{\"../utils\":38,\"./base\":17,\"_process\":82}],29:[function(require,module,exports){\n(function (process){\n'use strict';\n\n/**\n * Module dependencies.\n */\n\nvar Base = require('./base');\nvar inherits = require('../utils').inherits;\nvar color = Base.color;\nvar cursor = Base.cursor;\n\n/**\n * Expose `Progress`.\n */\n\nexports = module.exports = Progress;\n\n/**\n * General progress bar color.\n */\n\nBase.colors.progress = 90;\n\n/**\n * Initialize a new `Progress` bar test reporter.\n *\n * @api public\n * @param {Runner} runner\n * @param {Object} options\n */\nfunction Progress (runner, options) {\n  Base.call(this, runner);\n\n  var self = this;\n  var width = Base.window.width * 0.50 | 0;\n  var total = runner.total;\n  var complete = 0;\n  var lastN = -1;\n\n  // default chars\n  options = options || {};\n  options.open = options.open || '[';\n  options.complete = options.complete || '▬';\n  options.incomplete = options.incomplete || Base.symbols.dot;\n  options.close = options.close || ']';\n  options.verbose = false;\n\n  // tests started\n  runner.on('start', function () {\n    console.log();\n    cursor.hide();\n  });\n\n  // tests complete\n  runner.on('test end', function () {\n    complete++;\n\n    var percent = complete / total;\n    var n = width * percent | 0;\n    var i = width - n;\n\n    if (n === lastN && !options.verbose) {\n      // Don't re-render the line if it hasn't changed\n      return;\n    }\n    lastN = n;\n\n    cursor.CR();\n    process.stdout.write('\\u001b[J');\n    process.stdout.write(color('progress', '  ' + options.open));\n    process.stdout.write(Array(n).join(options.complete));\n    process.stdout.write(Array(i).join(options.incomplete));\n    process.stdout.write(color('progress', options.close));\n    if (options.verbose) {\n      process.stdout.write(color('progress', ' ' + complete + ' of ' + total));\n    }\n  });\n\n  // tests are complete, output some stats\n  // and the failures if any\n  runner.on('end', function () {\n    cursor.show();\n    console.log();\n    self.epilogue();\n  });\n}\n\n/**\n * Inherit from `Base.prototype`.\n */\ninherits(Progress, Base);\n\n}).call(this,require('_process'))\n},{\"../utils\":38,\"./base\":17,\"_process\":82}],30:[function(require,module,exports){\n'use strict';\n\n/**\n * Module dependencies.\n */\n\nvar Base = require('./base');\nvar inherits = require('../utils').inherits;\nvar color = Base.color;\n\n/**\n * Expose `Spec`.\n */\n\nexports = module.exports = Spec;\n\n/**\n * Initialize a new `Spec` test reporter.\n *\n * @api public\n * @param {Runner} runner\n */\nfunction Spec (runner) {\n  Base.call(this, runner);\n\n  var self = this;\n  var indents = 0;\n  var n = 0;\n\n  function indent () {\n    return Array(indents).join('  ');\n  }\n\n  runner.on('start', function () {\n    console.log();\n  });\n\n  runner.on('suite', function (suite) {\n    ++indents;\n    console.log(color('suite', '%s%s'), indent(), suite.title);\n  });\n\n  runner.on('suite end', function () {\n    --indents;\n    if (indents === 1) {\n      console.log();\n    }\n  });\n\n  runner.on('pending', function (test) {\n    var fmt = indent() + color('pending', '  - %s');\n    console.log(fmt, test.title);\n  });\n\n  runner.on('pass', function (test) {\n    var fmt;\n    if (test.speed === 'fast') {\n      fmt = indent() +\n        color('checkmark', '  ' + Base.symbols.ok) +\n        color('pass', ' %s');\n      console.log(fmt, test.title);\n    } else {\n      fmt = indent() +\n        color('checkmark', '  ' + Base.symbols.ok) +\n        color('pass', ' %s') +\n        color(test.speed, ' (%dms)');\n      console.log(fmt, test.title, test.duration);\n    }\n  });\n\n  runner.on('fail', function (test) {\n    console.log(indent() + color('fail', '  %d) %s'), ++n, test.title);\n  });\n\n  runner.on('end', self.epilogue.bind(self));\n}\n\n/**\n * Inherit from `Base.prototype`.\n */\ninherits(Spec, Base);\n\n},{\"../utils\":38,\"./base\":17}],31:[function(require,module,exports){\n'use strict';\n\n/**\n * Module dependencies.\n */\n\nvar Base = require('./base');\n\n/**\n * Expose `TAP`.\n */\n\nexports = module.exports = TAP;\n\n/**\n * Initialize a new `TAP` reporter.\n *\n * @api public\n * @param {Runner} runner\n */\nfunction TAP (runner) {\n  Base.call(this, runner);\n\n  var n = 1;\n  var passes = 0;\n  var failures = 0;\n\n  runner.on('start', function () {\n    var total = runner.grepTotal(runner.suite);\n    console.log('%d..%d', 1, total);\n  });\n\n  runner.on('test end', function () {\n    ++n;\n  });\n\n  runner.on('pending', function (test) {\n    console.log('ok %d %s # SKIP -', n, title(test));\n  });\n\n  runner.on('pass', function (test) {\n    passes++;\n    console.log('ok %d %s', n, title(test));\n  });\n\n  runner.on('fail', function (test, err) {\n    failures++;\n    console.log('not ok %d %s', n, title(test));\n    if (err.stack) {\n      console.log(err.stack.replace(/^/gm, '  '));\n    }\n  });\n\n  runner.on('end', function () {\n    console.log('# tests ' + (passes + failures));\n    console.log('# pass ' + passes);\n    console.log('# fail ' + failures);\n  });\n}\n\n/**\n * Return a TAP-safe title of `test`\n *\n * @api private\n * @param {Object} test\n * @return {String}\n */\nfunction title (test) {\n  return test.fullTitle().replace(/#/g, '');\n}\n\n},{\"./base\":17}],32:[function(require,module,exports){\n(function (process,global){\n'use strict';\n\n/**\n * Module dependencies.\n */\n\nvar Base = require('./base');\nvar utils = require('../utils');\nvar inherits = utils.inherits;\nvar fs = require('fs');\nvar escape = utils.escape;\nvar mkdirp = require('mkdirp');\nvar path = require('path');\n\n/**\n * Save timer references to avoid Sinon interfering (see GH-237).\n */\n\n/* eslint-disable no-unused-vars, no-native-reassign */\nvar Date = global.Date;\nvar setTimeout = global.setTimeout;\nvar setInterval = global.setInterval;\nvar clearTimeout = global.clearTimeout;\nvar clearInterval = global.clearInterval;\n/* eslint-enable no-unused-vars, no-native-reassign */\n\n/**\n * Expose `XUnit`.\n */\n\nexports = module.exports = XUnit;\n\n/**\n * Initialize a new `XUnit` reporter.\n *\n * @api public\n * @param {Runner} runner\n */\nfunction XUnit (runner, options) {\n  Base.call(this, runner);\n\n  var stats = this.stats;\n  var tests = [];\n  var self = this;\n\n  if (options && options.reporterOptions && options.reporterOptions.output) {\n    if (!fs.createWriteStream) {\n      throw new Error('file output not supported in browser');\n    }\n    mkdirp.sync(path.dirname(options.reporterOptions.output));\n    self.fileStream = fs.createWriteStream(options.reporterOptions.output);\n  }\n\n  runner.on('pending', function (test) {\n    tests.push(test);\n  });\n\n  runner.on('pass', function (test) {\n    tests.push(test);\n  });\n\n  runner.on('fail', function (test) {\n    tests.push(test);\n  });\n\n  runner.on('end', function () {\n    self.write(tag('testsuite', {\n      name: 'Mocha Tests',\n      tests: stats.tests,\n      failures: stats.failures,\n      errors: stats.failures,\n      skipped: stats.tests - stats.failures - stats.passes,\n      timestamp: (new Date()).toUTCString(),\n      time: (stats.duration / 1000) || 0\n    }, false));\n\n    tests.forEach(function (t) {\n      self.test(t);\n    });\n\n    self.write('</testsuite>');\n  });\n}\n\n/**\n * Inherit from `Base.prototype`.\n */\ninherits(XUnit, Base);\n\n/**\n * Override done to close the stream (if it's a file).\n *\n * @param failures\n * @param {Function} fn\n */\nXUnit.prototype.done = function (failures, fn) {\n  if (this.fileStream) {\n    this.fileStream.end(function () {\n      fn(failures);\n    });\n  } else {\n    fn(failures);\n  }\n};\n\n/**\n * Write out the given line.\n *\n * @param {string} line\n */\nXUnit.prototype.write = function (line) {\n  if (this.fileStream) {\n    this.fileStream.write(line + '\\n');\n  } else if (typeof process === 'object' && process.stdout) {\n    process.stdout.write(line + '\\n');\n  } else {\n    console.log(line);\n  }\n};\n\n/**\n * Output tag for the given `test.`\n *\n * @param {Test} test\n */\nXUnit.prototype.test = function (test) {\n  var attrs = {\n    classname: test.parent.fullTitle(),\n    name: test.title,\n    time: (test.duration / 1000) || 0\n  };\n\n  if (test.state === 'failed') {\n    var err = test.err;\n    this.write(tag('testcase', attrs, false, tag('failure', {}, false, escape(err.message) + '\\n' + escape(err.stack))));\n  } else if (test.isPending()) {\n    this.write(tag('testcase', attrs, false, tag('skipped', {}, true)));\n  } else {\n    this.write(tag('testcase', attrs, true));\n  }\n};\n\n/**\n * HTML tag helper.\n *\n * @param name\n * @param attrs\n * @param close\n * @param content\n * @return {string}\n */\nfunction tag (name, attrs, close, content) {\n  var end = close ? '/>' : '>';\n  var pairs = [];\n  var tag;\n\n  for (var key in attrs) {\n    if (Object.prototype.hasOwnProperty.call(attrs, key)) {\n      pairs.push(key + '=\"' + escape(attrs[key]) + '\"');\n    }\n  }\n\n  tag = '<' + name + (pairs.length ? ' ' + pairs.join(' ') : '') + end;\n  if (content) {\n    tag += content + '</' + name + end;\n  }\n  return tag;\n}\n\n}).call(this,require('_process'),typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n},{\"../utils\":38,\"./base\":17,\"_process\":82,\"fs\":42,\"mkdirp\":79,\"path\":42}],33:[function(require,module,exports){\n(function (global){\n'use strict';\n\n/**\n * Module dependencies.\n */\n\nvar EventEmitter = require('events').EventEmitter;\nvar JSON = require('json3');\nvar Pending = require('./pending');\nvar debug = require('debug')('mocha:runnable');\nvar milliseconds = require('./ms');\nvar utils = require('./utils');\nvar create = require('lodash.create');\n\n/**\n * Save timer references to avoid Sinon interfering (see GH-237).\n */\n\n/* eslint-disable no-unused-vars, no-native-reassign */\nvar Date = global.Date;\nvar setTimeout = global.setTimeout;\nvar setInterval = global.setInterval;\nvar clearTimeout = global.clearTimeout;\nvar clearInterval = global.clearInterval;\n/* eslint-enable no-unused-vars, no-native-reassign */\n\n/**\n * Object#toString().\n */\n\nvar toString = Object.prototype.toString;\n\n/**\n * Expose `Runnable`.\n */\n\nmodule.exports = Runnable;\n\n/**\n * Initialize a new `Runnable` with the given `title` and callback `fn`.\n *\n * @param {String} title\n * @param {Function} fn\n * @api private\n * @param {string} title\n * @param {Function} fn\n */\nfunction Runnable (title, fn) {\n  this.title = title;\n  this.fn = fn;\n  this.body = (fn || '').toString();\n  this.async = fn && fn.length;\n  this.sync = !this.async;\n  this._timeout = 2000;\n  this._slow = 75;\n  this._enableTimeouts = true;\n  this.timedOut = false;\n  this._trace = new Error('done() called multiple times');\n  this._retries = -1;\n  this._currentRetry = 0;\n  this.pending = false;\n}\n\n/**\n * Inherit from `EventEmitter.prototype`.\n */\nRunnable.prototype = create(EventEmitter.prototype, {\n  constructor: Runnable\n});\n\n/**\n * Set & get timeout `ms`.\n *\n * @api private\n * @param {number|string} ms\n * @return {Runnable|number} ms or Runnable instance.\n */\nRunnable.prototype.timeout = function (ms) {\n  if (!arguments.length) {\n    return this._timeout;\n  }\n  // see #1652 for reasoning\n  if (ms === 0 || ms > Math.pow(2, 31)) {\n    this._enableTimeouts = false;\n  }\n  if (typeof ms === 'string') {\n    ms = milliseconds(ms);\n  }\n  debug('timeout %d', ms);\n  this._timeout = ms;\n  if (this.timer) {\n    this.resetTimeout();\n  }\n  return this;\n};\n\n/**\n * Set & get slow `ms`.\n *\n * @api private\n * @param {number|string} ms\n * @return {Runnable|number} ms or Runnable instance.\n */\nRunnable.prototype.slow = function (ms) {\n  if (typeof ms === 'undefined') {\n    return this._slow;\n  }\n  if (typeof ms === 'string') {\n    ms = milliseconds(ms);\n  }\n  debug('timeout %d', ms);\n  this._slow = ms;\n  return this;\n};\n\n/**\n * Set and get whether timeout is `enabled`.\n *\n * @api private\n * @param {boolean} enabled\n * @return {Runnable|boolean} enabled or Runnable instance.\n */\nRunnable.prototype.enableTimeouts = function (enabled) {\n  if (!arguments.length) {\n    return this._enableTimeouts;\n  }\n  debug('enableTimeouts %s', enabled);\n  this._enableTimeouts = enabled;\n  return this;\n};\n\n/**\n * Halt and mark as pending.\n *\n * @api public\n */\nRunnable.prototype.skip = function () {\n  throw new Pending('sync skip');\n};\n\n/**\n * Check if this runnable or its parent suite is marked as pending.\n *\n * @api private\n */\nRunnable.prototype.isPending = function () {\n  return this.pending || (this.parent && this.parent.isPending());\n};\n\n/**\n * Set number of retries.\n *\n * @api private\n */\nRunnable.prototype.retries = function (n) {\n  if (!arguments.length) {\n    return this._retries;\n  }\n  this._retries = n;\n};\n\n/**\n * Get current retry\n *\n * @api private\n */\nRunnable.prototype.currentRetry = function (n) {\n  if (!arguments.length) {\n    return this._currentRetry;\n  }\n  this._currentRetry = n;\n};\n\n/**\n * Return the full title generated by recursively concatenating the parent's\n * full title.\n *\n * @api public\n * @return {string}\n */\nRunnable.prototype.fullTitle = function () {\n  return this.parent.fullTitle() + ' ' + this.title;\n};\n\n/**\n * Clear the timeout.\n *\n * @api private\n */\nRunnable.prototype.clearTimeout = function () {\n  clearTimeout(this.timer);\n};\n\n/**\n * Inspect the runnable void of private properties.\n *\n * @api private\n * @return {string}\n */\nRunnable.prototype.inspect = function () {\n  return JSON.stringify(this, function (key, val) {\n    if (key[0] === '_') {\n      return;\n    }\n    if (key === 'parent') {\n      return '#<Suite>';\n    }\n    if (key === 'ctx') {\n      return '#<Context>';\n    }\n    return val;\n  }, 2);\n};\n\n/**\n * Reset the timeout.\n *\n * @api private\n */\nRunnable.prototype.resetTimeout = function () {\n  var self = this;\n  var ms = this.timeout() || 1e9;\n\n  if (!this._enableTimeouts) {\n    return;\n  }\n  this.clearTimeout();\n  this.timer = setTimeout(function () {\n    if (!self._enableTimeouts) {\n      return;\n    }\n    self.callback(new Error('Timeout of ' + ms +\n      'ms exceeded. For async tests and hooks, ensure \"done()\" is called; if returning a Promise, ensure it resolves.'));\n    self.timedOut = true;\n  }, ms);\n};\n\n/**\n * Whitelist a list of globals for this test run.\n *\n * @api private\n * @param {string[]} globals\n */\nRunnable.prototype.globals = function (globals) {\n  if (!arguments.length) {\n    return this._allowedGlobals;\n  }\n  this._allowedGlobals = globals;\n};\n\n/**\n * Run the test and invoke `fn(err)`.\n *\n * @param {Function} fn\n * @api private\n */\nRunnable.prototype.run = function (fn) {\n  var self = this;\n  var start = new Date();\n  var ctx = this.ctx;\n  var finished;\n  var emitted;\n\n  // Sometimes the ctx exists, but it is not runnable\n  if (ctx && ctx.runnable) {\n    ctx.runnable(this);\n  }\n\n  // called multiple times\n  function multiple (err) {\n    if (emitted) {\n      return;\n    }\n    emitted = true;\n    self.emit('error', err || new Error('done() called multiple times; stacktrace may be inaccurate'));\n  }\n\n  // finished\n  function done (err) {\n    var ms = self.timeout();\n    if (self.timedOut) {\n      return;\n    }\n    if (finished) {\n      return multiple(err || self._trace);\n    }\n\n    self.clearTimeout();\n    self.duration = new Date() - start;\n    finished = true;\n    if (!err && self.duration > ms && self._enableTimeouts) {\n      err = new Error('Timeout of ' + ms +\n      'ms exceeded. For async tests and hooks, ensure \"done()\" is called; if returning a Promise, ensure it resolves.');\n    }\n    fn(err);\n  }\n\n  // for .resetTimeout()\n  this.callback = done;\n\n  // explicit async with `done` argument\n  if (this.async) {\n    this.resetTimeout();\n\n    // allows skip() to be used in an explicit async context\n    this.skip = function asyncSkip () {\n      done(new Pending('async skip call'));\n      // halt execution.  the Runnable will be marked pending\n      // by the previous call, and the uncaught handler will ignore\n      // the failure.\n      throw new Pending('async skip; aborting execution');\n    };\n\n    if (this.allowUncaught) {\n      return callFnAsync(this.fn);\n    }\n    try {\n      callFnAsync(this.fn);\n    } catch (err) {\n      emitted = true;\n      done(utils.getError(err));\n    }\n    return;\n  }\n\n  if (this.allowUncaught) {\n    if (this.isPending()) {\n      done();\n    } else {\n      callFn(this.fn);\n    }\n    return;\n  }\n\n  // sync or promise-returning\n  try {\n    if (this.isPending()) {\n      done();\n    } else {\n      callFn(this.fn);\n    }\n  } catch (err) {\n    emitted = true;\n    done(utils.getError(err));\n  }\n\n  function callFn (fn) {\n    var result = fn.call(ctx);\n    if (result && typeof result.then === 'function') {\n      self.resetTimeout();\n      result\n        .then(function () {\n          done();\n          // Return null so libraries like bluebird do not warn about\n          // subsequently constructed Promises.\n          return null;\n        },\n        function (reason) {\n          done(reason || new Error('Promise rejected with no or falsy reason'));\n        });\n    } else {\n      if (self.asyncOnly) {\n        return done(new Error('--async-only option in use without declaring `done()` or returning a promise'));\n      }\n\n      done();\n    }\n  }\n\n  function callFnAsync (fn) {\n    var result = fn.call(ctx, function (err) {\n      if (err instanceof Error || toString.call(err) === '[object Error]') {\n        return done(err);\n      }\n      if (err) {\n        if (Object.prototype.toString.call(err) === '[object Object]') {\n          return done(new Error('done() invoked with non-Error: ' +\n            JSON.stringify(err)));\n        }\n        return done(new Error('done() invoked with non-Error: ' + err));\n      }\n      if (result && utils.isPromise(result)) {\n        return done(new Error('Resolution method is overspecified. Specify a callback *or* return a Promise; not both.'));\n      }\n\n      done();\n    });\n  }\n};\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n},{\"./ms\":15,\"./pending\":16,\"./utils\":38,\"debug\":2,\"events\":3,\"json3\":69,\"lodash.create\":75}],34:[function(require,module,exports){\n(function (process,global){\n'use strict';\n\n/**\n * Module dependencies.\n */\n\nvar EventEmitter = require('events').EventEmitter;\nvar Pending = require('./pending');\nvar utils = require('./utils');\nvar inherits = utils.inherits;\nvar debug = require('debug')('mocha:runner');\nvar Runnable = require('./runnable');\nvar filter = utils.filter;\nvar indexOf = utils.indexOf;\nvar some = utils.some;\nvar keys = utils.keys;\nvar stackFilter = utils.stackTraceFilter();\nvar stringify = utils.stringify;\nvar type = utils.type;\nvar undefinedError = utils.undefinedError;\nvar isArray = utils.isArray;\n\n/**\n * Non-enumerable globals.\n */\n\nvar globals = [\n  'setTimeout',\n  'clearTimeout',\n  'setInterval',\n  'clearInterval',\n  'XMLHttpRequest',\n  'Date',\n  'setImmediate',\n  'clearImmediate'\n];\n\n/**\n * Expose `Runner`.\n */\n\nmodule.exports = Runner;\n\n/**\n * Initialize a `Runner` for the given `suite`.\n *\n * Events:\n *\n *   - `start`  execution started\n *   - `end`  execution complete\n *   - `suite`  (suite) test suite execution started\n *   - `suite end`  (suite) all tests (and sub-suites) have finished\n *   - `test`  (test) test execution started\n *   - `test end`  (test) test completed\n *   - `hook`  (hook) hook execution started\n *   - `hook end`  (hook) hook complete\n *   - `pass`  (test) test passed\n *   - `fail`  (test, err) test failed\n *   - `pending`  (test) test pending\n *\n * @api public\n * @param {Suite} suite Root suite\n * @param {boolean} [delay] Whether or not to delay execution of root suite\n * until ready.\n */\nfunction Runner (suite, delay) {\n  var self = this;\n  this._globals = [];\n  this._abort = false;\n  this._delay = delay;\n  this.suite = suite;\n  this.started = false;\n  this.total = suite.total();\n  this.failures = 0;\n  this.on('test end', function (test) {\n    self.checkGlobals(test);\n  });\n  this.on('hook end', function (hook) {\n    self.checkGlobals(hook);\n  });\n  this._defaultGrep = /.*/;\n  this.grep(this._defaultGrep);\n  this.globals(this.globalProps().concat(extraGlobals()));\n}\n\n/**\n * Wrapper for setImmediate, process.nextTick, or browser polyfill.\n *\n * @param {Function} fn\n * @api private\n */\nRunner.immediately = global.setImmediate || process.nextTick;\n\n/**\n * Inherit from `EventEmitter.prototype`.\n */\ninherits(Runner, EventEmitter);\n\n/**\n * Run tests with full titles matching `re`. Updates runner.total\n * with number of tests matched.\n *\n * @param {RegExp} re\n * @param {Boolean} invert\n * @return {Runner} for chaining\n * @api public\n * @param {RegExp} re\n * @param {boolean} invert\n * @return {Runner} Runner instance.\n */\nRunner.prototype.grep = function (re, invert) {\n  debug('grep %s', re);\n  this._grep = re;\n  this._invert = invert;\n  this.total = this.grepTotal(this.suite);\n  return this;\n};\n\n/**\n * Returns the number of tests matching the grep search for the\n * given suite.\n *\n * @param {Suite} suite\n * @return {Number}\n * @api public\n * @param {Suite} suite\n * @return {number}\n */\nRunner.prototype.grepTotal = function (suite) {\n  var self = this;\n  var total = 0;\n\n  suite.eachTest(function (test) {\n    var match = self._grep.test(test.fullTitle());\n    if (self._invert) {\n      match = !match;\n    }\n    if (match) {\n      total++;\n    }\n  });\n\n  return total;\n};\n\n/**\n * Return a list of global properties.\n *\n * @return {Array}\n * @api private\n */\nRunner.prototype.globalProps = function () {\n  var props = keys(global);\n\n  // non-enumerables\n  for (var i = 0; i < globals.length; ++i) {\n    if (~indexOf(props, globals[i])) {\n      continue;\n    }\n    props.push(globals[i]);\n  }\n\n  return props;\n};\n\n/**\n * Allow the given `arr` of globals.\n *\n * @param {Array} arr\n * @return {Runner} for chaining\n * @api public\n * @param {Array} arr\n * @return {Runner} Runner instance.\n */\nRunner.prototype.globals = function (arr) {\n  if (!arguments.length) {\n    return this._globals;\n  }\n  debug('globals %j', arr);\n  this._globals = this._globals.concat(arr);\n  return this;\n};\n\n/**\n * Check for global variable leaks.\n *\n * @api private\n */\nRunner.prototype.checkGlobals = function (test) {\n  if (this.ignoreLeaks) {\n    return;\n  }\n  var ok = this._globals;\n\n  var globals = this.globalProps();\n  var leaks;\n\n  if (test) {\n    ok = ok.concat(test._allowedGlobals || []);\n  }\n\n  if (this.prevGlobalsLength === globals.length) {\n    return;\n  }\n  this.prevGlobalsLength = globals.length;\n\n  leaks = filterLeaks(ok, globals);\n  this._globals = this._globals.concat(leaks);\n\n  if (leaks.length > 1) {\n    this.fail(test, new Error('global leaks detected: ' + leaks.join(', ') + ''));\n  } else if (leaks.length) {\n    this.fail(test, new Error('global leak detected: ' + leaks[0]));\n  }\n};\n\n/**\n * Fail the given `test`.\n *\n * @api private\n * @param {Test} test\n * @param {Error} err\n */\nRunner.prototype.fail = function (test, err) {\n  if (test.isPending()) {\n    return;\n  }\n\n  ++this.failures;\n  test.state = 'failed';\n\n  if (!(err instanceof Error || err && typeof err.message === 'string')) {\n    err = new Error('the ' + type(err) + ' ' + stringify(err) + ' was thrown, throw an Error :)');\n  }\n\n  try {\n    err.stack = (this.fullStackTrace || !err.stack)\n      ? err.stack\n      : stackFilter(err.stack);\n  } catch (ignored) {\n    // some environments do not take kindly to monkeying with the stack\n  }\n\n  this.emit('fail', test, err);\n};\n\n/**\n * Fail the given `hook` with `err`.\n *\n * Hook failures work in the following pattern:\n * - If bail, then exit\n * - Failed `before` hook skips all tests in a suite and subsuites,\n *   but jumps to corresponding `after` hook\n * - Failed `before each` hook skips remaining tests in a\n *   suite and jumps to corresponding `after each` hook,\n *   which is run only once\n * - Failed `after` hook does not alter\n *   execution order\n * - Failed `after each` hook skips remaining tests in a\n *   suite and subsuites, but executes other `after each`\n *   hooks\n *\n * @api private\n * @param {Hook} hook\n * @param {Error} err\n */\nRunner.prototype.failHook = function (hook, err) {\n  if (hook.ctx && hook.ctx.currentTest) {\n    hook.originalTitle = hook.originalTitle || hook.title;\n    hook.title = hook.originalTitle + ' for \"' + hook.ctx.currentTest.title + '\"';\n  }\n\n  this.fail(hook, err);\n  if (this.suite.bail()) {\n    this.emit('end');\n  }\n};\n\n/**\n * Run hook `name` callbacks and then invoke `fn()`.\n *\n * @api private\n * @param {string} name\n * @param {Function} fn\n */\n\nRunner.prototype.hook = function (name, fn) {\n  var suite = this.suite;\n  var hooks = suite['_' + name];\n  var self = this;\n\n  function next (i) {\n    var hook = hooks[i];\n    if (!hook) {\n      return fn();\n    }\n    self.currentRunnable = hook;\n\n    hook.ctx.currentTest = self.test;\n\n    self.emit('hook', hook);\n\n    if (!hook.listeners('error').length) {\n      hook.on('error', function (err) {\n        self.failHook(hook, err);\n      });\n    }\n\n    hook.run(function (err) {\n      var testError = hook.error();\n      if (testError) {\n        self.fail(self.test, testError);\n      }\n      if (err) {\n        if (err instanceof Pending) {\n          if (name === 'beforeEach' || name === 'afterEach') {\n            self.test.pending = true;\n          } else {\n            utils.forEach(suite.tests, function (test) {\n              test.pending = true;\n            });\n            // a pending hook won't be executed twice.\n            hook.pending = true;\n          }\n        } else {\n          self.failHook(hook, err);\n\n          // stop executing hooks, notify callee of hook err\n          return fn(err);\n        }\n      }\n      self.emit('hook end', hook);\n      delete hook.ctx.currentTest;\n      next(++i);\n    });\n  }\n\n  Runner.immediately(function () {\n    next(0);\n  });\n};\n\n/**\n * Run hook `name` for the given array of `suites`\n * in order, and callback `fn(err, errSuite)`.\n *\n * @api private\n * @param {string} name\n * @param {Array} suites\n * @param {Function} fn\n */\nRunner.prototype.hooks = function (name, suites, fn) {\n  var self = this;\n  var orig = this.suite;\n\n  function next (suite) {\n    self.suite = suite;\n\n    if (!suite) {\n      self.suite = orig;\n      return fn();\n    }\n\n    self.hook(name, function (err) {\n      if (err) {\n        var errSuite = self.suite;\n        self.suite = orig;\n        return fn(err, errSuite);\n      }\n\n      next(suites.pop());\n    });\n  }\n\n  next(suites.pop());\n};\n\n/**\n * Run hooks from the top level down.\n *\n * @param {String} name\n * @param {Function} fn\n * @api private\n */\nRunner.prototype.hookUp = function (name, fn) {\n  var suites = [this.suite].concat(this.parents()).reverse();\n  this.hooks(name, suites, fn);\n};\n\n/**\n * Run hooks from the bottom up.\n *\n * @param {String} name\n * @param {Function} fn\n * @api private\n */\nRunner.prototype.hookDown = function (name, fn) {\n  var suites = [this.suite].concat(this.parents());\n  this.hooks(name, suites, fn);\n};\n\n/**\n * Return an array of parent Suites from\n * closest to furthest.\n *\n * @return {Array}\n * @api private\n */\nRunner.prototype.parents = function () {\n  var suite = this.suite;\n  var suites = [];\n  while (suite.parent) {\n    suite = suite.parent;\n    suites.push(suite);\n  }\n  return suites;\n};\n\n/**\n * Run the current test and callback `fn(err)`.\n *\n * @param {Function} fn\n * @api private\n */\nRunner.prototype.runTest = function (fn) {\n  var self = this;\n  var test = this.test;\n\n  if (!test) {\n    return;\n  }\n  if (this.asyncOnly) {\n    test.asyncOnly = true;\n  }\n  test.on('error', function (err) {\n    self.fail(test, err);\n  });\n  if (this.allowUncaught) {\n    test.allowUncaught = true;\n    return test.run(fn);\n  }\n  try {\n    test.run(fn);\n  } catch (err) {\n    fn(err);\n  }\n};\n\n/**\n * Run tests in the given `suite` and invoke the callback `fn()` when complete.\n *\n * @api private\n * @param {Suite} suite\n * @param {Function} fn\n */\nRunner.prototype.runTests = function (suite, fn) {\n  var self = this;\n  var tests = suite.tests.slice();\n  var test;\n\n  function hookErr (_, errSuite, after) {\n    // before/after Each hook for errSuite failed:\n    var orig = self.suite;\n\n    // for failed 'after each' hook start from errSuite parent,\n    // otherwise start from errSuite itself\n    self.suite = after ? errSuite.parent : errSuite;\n\n    if (self.suite) {\n      // call hookUp afterEach\n      self.hookUp('afterEach', function (err2, errSuite2) {\n        self.suite = orig;\n        // some hooks may fail even now\n        if (err2) {\n          return hookErr(err2, errSuite2, true);\n        }\n        // report error suite\n        fn(errSuite);\n      });\n    } else {\n      // there is no need calling other 'after each' hooks\n      self.suite = orig;\n      fn(errSuite);\n    }\n  }\n\n  function next (err, errSuite) {\n    // if we bail after first err\n    if (self.failures && suite._bail) {\n      return fn();\n    }\n\n    if (self._abort) {\n      return fn();\n    }\n\n    if (err) {\n      return hookErr(err, errSuite, true);\n    }\n\n    // next test\n    test = tests.shift();\n\n    // all done\n    if (!test) {\n      return fn();\n    }\n\n    // grep\n    var match = self._grep.test(test.fullTitle());\n    if (self._invert) {\n      match = !match;\n    }\n    if (!match) {\n      // Run immediately only if we have defined a grep. When we\n      // define a grep — It can cause maximum callstack error if\n      // the grep is doing a large recursive loop by neglecting\n      // all tests. The run immediately function also comes with\n      // a performance cost. So we don't want to run immediately\n      // if we run the whole test suite, because running the whole\n      // test suite don't do any immediate recursive loops. Thus,\n      // allowing a JS runtime to breathe.\n      if (self._grep !== self._defaultGrep) {\n        Runner.immediately(next);\n      } else {\n        next();\n      }\n      return;\n    }\n\n    if (test.isPending()) {\n      self.emit('pending', test);\n      self.emit('test end', test);\n      return next();\n    }\n\n    // execute test and hook(s)\n    self.emit('test', self.test = test);\n    self.hookDown('beforeEach', function (err, errSuite) {\n      if (test.isPending()) {\n        self.emit('pending', test);\n        self.emit('test end', test);\n        return next();\n      }\n      if (err) {\n        return hookErr(err, errSuite, false);\n      }\n      self.currentRunnable = self.test;\n      self.runTest(function (err) {\n        test = self.test;\n        if (err) {\n          var retry = test.currentRetry();\n          if (err instanceof Pending) {\n            test.pending = true;\n            self.emit('pending', test);\n          } else if (retry < test.retries()) {\n            var clonedTest = test.clone();\n            clonedTest.currentRetry(retry + 1);\n            tests.unshift(clonedTest);\n\n            // Early return + hook trigger so that it doesn't\n            // increment the count wrong\n            return self.hookUp('afterEach', next);\n          } else {\n            self.fail(test, err);\n          }\n          self.emit('test end', test);\n\n          if (err instanceof Pending) {\n            return next();\n          }\n\n          return self.hookUp('afterEach', next);\n        }\n\n        test.state = 'passed';\n        self.emit('pass', test);\n        self.emit('test end', test);\n        self.hookUp('afterEach', next);\n      });\n    });\n  }\n\n  this.next = next;\n  this.hookErr = hookErr;\n  next();\n};\n\n/**\n * Run the given `suite` and invoke the callback `fn()` when complete.\n *\n * @api private\n * @param {Suite} suite\n * @param {Function} fn\n */\nRunner.prototype.runSuite = function (suite, fn) {\n  var i = 0;\n  var self = this;\n  var total = this.grepTotal(suite);\n  var afterAllHookCalled = false;\n\n  debug('run suite %s', suite.fullTitle());\n\n  if (!total || (self.failures && suite._bail)) {\n    return fn();\n  }\n\n  this.emit('suite', this.suite = suite);\n\n  function next (errSuite) {\n    if (errSuite) {\n      // current suite failed on a hook from errSuite\n      if (errSuite === suite) {\n        // if errSuite is current suite\n        // continue to the next sibling suite\n        return done();\n      }\n      // errSuite is among the parents of current suite\n      // stop execution of errSuite and all sub-suites\n      return done(errSuite);\n    }\n\n    if (self._abort) {\n      return done();\n    }\n\n    var curr = suite.suites[i++];\n    if (!curr) {\n      return done();\n    }\n\n    // Avoid grep neglecting large number of tests causing a\n    // huge recursive loop and thus a maximum call stack error.\n    // See comment in `this.runTests()` for more information.\n    if (self._grep !== self._defaultGrep) {\n      Runner.immediately(function () {\n        self.runSuite(curr, next);\n      });\n    } else {\n      self.runSuite(curr, next);\n    }\n  }\n\n  function done (errSuite) {\n    self.suite = suite;\n    self.nextSuite = next;\n\n    if (afterAllHookCalled) {\n      fn(errSuite);\n    } else {\n      // mark that the afterAll block has been called once\n      // and so can be skipped if there is an error in it.\n      afterAllHookCalled = true;\n\n      // remove reference to test\n      delete self.test;\n\n      self.hook('afterAll', function () {\n        self.emit('suite end', suite);\n        fn(errSuite);\n      });\n    }\n  }\n\n  this.nextSuite = next;\n\n  this.hook('beforeAll', function (err) {\n    if (err) {\n      return done();\n    }\n    self.runTests(suite, next);\n  });\n};\n\n/**\n * Handle uncaught exceptions.\n *\n * @param {Error} err\n * @api private\n */\nRunner.prototype.uncaught = function (err) {\n  if (err) {\n    debug('uncaught exception %s', err === (function () {\n      return this;\n    }.call(err)) ? (err.message || err) : err);\n  } else {\n    debug('uncaught undefined exception');\n    err = undefinedError();\n  }\n  err.uncaught = true;\n\n  var runnable = this.currentRunnable;\n\n  if (!runnable) {\n    runnable = new Runnable('Uncaught error outside test suite');\n    runnable.parent = this.suite;\n\n    if (this.started) {\n      this.fail(runnable, err);\n    } else {\n      // Can't recover from this failure\n      this.emit('start');\n      this.fail(runnable, err);\n      this.emit('end');\n    }\n\n    return;\n  }\n\n  runnable.clearTimeout();\n\n  // Ignore errors if complete or pending\n  if (runnable.state || runnable.isPending()) {\n    return;\n  }\n  this.fail(runnable, err);\n\n  // recover from test\n  if (runnable.type === 'test') {\n    this.emit('test end', runnable);\n    this.hookUp('afterEach', this.next);\n    return;\n  }\n\n // recover from hooks\n  if (runnable.type === 'hook') {\n    var errSuite = this.suite;\n    // if hook failure is in afterEach block\n    if (runnable.fullTitle().indexOf('after each') > -1) {\n      return this.hookErr(err, errSuite, true);\n    }\n    // if hook failure is in beforeEach block\n    if (runnable.fullTitle().indexOf('before each') > -1) {\n      return this.hookErr(err, errSuite, false);\n    }\n    // if hook failure is in after or before blocks\n    return this.nextSuite(errSuite);\n  }\n\n  // bail\n  this.emit('end');\n};\n\n/**\n * Cleans up the references to all the deferred functions\n * (before/after/beforeEach/afterEach) and tests of a Suite.\n * These must be deleted otherwise a memory leak can happen,\n * as those functions may reference variables from closures,\n * thus those variables can never be garbage collected as long\n * as the deferred functions exist.\n *\n * @param {Suite} suite\n */\nfunction cleanSuiteReferences (suite) {\n  function cleanArrReferences (arr) {\n    for (var i = 0; i < arr.length; i++) {\n      delete arr[i].fn;\n    }\n  }\n\n  if (isArray(suite._beforeAll)) {\n    cleanArrReferences(suite._beforeAll);\n  }\n\n  if (isArray(suite._beforeEach)) {\n    cleanArrReferences(suite._beforeEach);\n  }\n\n  if (isArray(suite._afterAll)) {\n    cleanArrReferences(suite._afterAll);\n  }\n\n  if (isArray(suite._afterEach)) {\n    cleanArrReferences(suite._afterEach);\n  }\n\n  for (var i = 0; i < suite.tests.length; i++) {\n    delete suite.tests[i].fn;\n  }\n}\n\n/**\n * Run the root suite and invoke `fn(failures)`\n * on completion.\n *\n * @param {Function} fn\n * @return {Runner} for chaining\n * @api public\n * @param {Function} fn\n * @return {Runner} Runner instance.\n */\nRunner.prototype.run = function (fn) {\n  var self = this;\n  var rootSuite = this.suite;\n\n  // If there is an `only` filter\n  if (this.hasOnly) {\n    filterOnly(rootSuite);\n  }\n\n  fn = fn || function () {};\n\n  function uncaught (err) {\n    self.uncaught(err);\n  }\n\n  function start () {\n    self.started = true;\n    self.emit('start');\n    self.runSuite(rootSuite, function () {\n      debug('finished running');\n      self.emit('end');\n    });\n  }\n\n  debug('start');\n\n  // references cleanup to avoid memory leaks\n  this.on('suite end', cleanSuiteReferences);\n\n  // callback\n  this.on('end', function () {\n    if (self.forbidOnly && self.hasOnly) {\n      self.failures += self.stats.tests;\n    }\n    if (self.forbidPending) {\n      self.failures += self.stats.pending;\n    }\n    debug('end');\n    process.removeListener('uncaughtException', uncaught);\n    fn(self.failures);\n  });\n\n  // uncaught exception\n  process.on('uncaughtException', uncaught);\n\n  if (this._delay) {\n    // for reporters, I guess.\n    // might be nice to debounce some dots while we wait.\n    this.emit('waiting', rootSuite);\n    rootSuite.once('run', start);\n  } else {\n    start();\n  }\n\n  return this;\n};\n\n/**\n * Cleanly abort execution.\n *\n * @api public\n * @return {Runner} Runner instance.\n */\nRunner.prototype.abort = function () {\n  debug('aborting');\n  this._abort = true;\n\n  return this;\n};\n\n/**\n * Filter suites based on `isOnly` logic.\n *\n * @param {Array} suite\n * @returns {Boolean}\n * @api private\n */\nfunction filterOnly (suite) {\n  if (suite._onlyTests.length) {\n    // If the suite contains `only` tests, run those and ignore any nested suites.\n    suite.tests = suite._onlyTests;\n    suite.suites = [];\n  } else {\n    // Otherwise, do not run any of the tests in this suite.\n    suite.tests = [];\n    utils.forEach(suite._onlySuites, function (onlySuite) {\n      // If there are other `only` tests/suites nested in the current `only` suite, then filter that `only` suite.\n      // Otherwise, all of the tests on this `only` suite should be run, so don't filter it.\n      if (hasOnly(onlySuite)) {\n        filterOnly(onlySuite);\n      }\n    });\n    // Run the `only` suites, as well as any other suites that have `only` tests/suites as descendants.\n    suite.suites = filter(suite.suites, function (childSuite) {\n      return indexOf(suite._onlySuites, childSuite) !== -1 || filterOnly(childSuite);\n    });\n  }\n  // Keep the suite only if there is something to run\n  return suite.tests.length || suite.suites.length;\n}\n\n/**\n * Determines whether a suite has an `only` test or suite as a descendant.\n *\n * @param {Array} suite\n * @returns {Boolean}\n * @api private\n */\nfunction hasOnly (suite) {\n  return suite._onlyTests.length || suite._onlySuites.length || some(suite.suites, hasOnly);\n}\n\n/**\n * Filter leaks with the given globals flagged as `ok`.\n *\n * @api private\n * @param {Array} ok\n * @param {Array} globals\n * @return {Array}\n */\nfunction filterLeaks (ok, globals) {\n  return filter(globals, function (key) {\n    // Firefox and Chrome exposes iframes as index inside the window object\n    if (/^\\d+/.test(key)) {\n      return false;\n    }\n\n    // in firefox\n    // if runner runs in an iframe, this iframe's window.getInterface method\n    // not init at first it is assigned in some seconds\n    if (global.navigator && (/^getInterface/).test(key)) {\n      return false;\n    }\n\n    // an iframe could be approached by window[iframeIndex]\n    // in ie6,7,8 and opera, iframeIndex is enumerable, this could cause leak\n    if (global.navigator && (/^\\d+/).test(key)) {\n      return false;\n    }\n\n    // Opera and IE expose global variables for HTML element IDs (issue #243)\n    if (/^mocha-/.test(key)) {\n      return false;\n    }\n\n    var matched = filter(ok, function (ok) {\n      if (~ok.indexOf('*')) {\n        return key.indexOf(ok.split('*')[0]) === 0;\n      }\n      return key === ok;\n    });\n    return !matched.length && (!global.navigator || key !== 'onerror');\n  });\n}\n\n/**\n * Array of globals dependent on the environment.\n *\n * @return {Array}\n * @api private\n */\nfunction extraGlobals () {\n  if (typeof process === 'object' && typeof process.version === 'string') {\n    var parts = process.version.split('.');\n    var nodeVersion = utils.reduce(parts, function (a, v) {\n      return a << 8 | v;\n    });\n\n    // 'errno' was renamed to process._errno in v0.9.11.\n\n    if (nodeVersion < 0x00090B) {\n      return ['errno'];\n    }\n  }\n\n  return [];\n}\n\n}).call(this,require('_process'),typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n},{\"./pending\":16,\"./runnable\":33,\"./utils\":38,\"_process\":82,\"debug\":2,\"events\":3}],35:[function(require,module,exports){\n'use strict';\n\n/**\n * Module dependencies.\n */\n\nvar EventEmitter = require('events').EventEmitter;\nvar Hook = require('./hook');\nvar utils = require('./utils');\nvar inherits = utils.inherits;\nvar debug = require('debug')('mocha:suite');\nvar milliseconds = require('./ms');\n\n/**\n * Expose `Suite`.\n */\n\nexports = module.exports = Suite;\n\n/**\n * Create a new `Suite` with the given `title` and parent `Suite`. When a suite\n * with the same title is already present, that suite is returned to provide\n * nicer reporter and more flexible meta-testing.\n *\n * @api public\n * @param {Suite} parent\n * @param {string} title\n * @return {Suite}\n */\nexports.create = function (parent, title) {\n  var suite = new Suite(title, parent.ctx);\n  suite.parent = parent;\n  title = suite.fullTitle();\n  parent.addSuite(suite);\n  return suite;\n};\n\n/**\n * Initialize a new `Suite` with the given `title` and `ctx`.\n *\n * @api private\n * @param {string} title\n * @param {Context} parentContext\n */\nfunction Suite (title, parentContext) {\n  if (!utils.isString(title)) {\n    throw new Error('Suite `title` should be a \"string\" but \"' + typeof title + '\" was given instead.');\n  }\n  this.title = title;\n  function Context () {}\n  Context.prototype = parentContext;\n  this.ctx = new Context();\n  this.suites = [];\n  this.tests = [];\n  this.pending = false;\n  this._beforeEach = [];\n  this._beforeAll = [];\n  this._afterEach = [];\n  this._afterAll = [];\n  this.root = !title;\n  this._timeout = 2000;\n  this._enableTimeouts = true;\n  this._slow = 75;\n  this._bail = false;\n  this._retries = -1;\n  this._onlyTests = [];\n  this._onlySuites = [];\n  this.delayed = false;\n}\n\n/**\n * Inherit from `EventEmitter.prototype`.\n */\ninherits(Suite, EventEmitter);\n\n/**\n * Return a clone of this `Suite`.\n *\n * @api private\n * @return {Suite}\n */\nSuite.prototype.clone = function () {\n  var suite = new Suite(this.title);\n  debug('clone');\n  suite.ctx = this.ctx;\n  suite.timeout(this.timeout());\n  suite.retries(this.retries());\n  suite.enableTimeouts(this.enableTimeouts());\n  suite.slow(this.slow());\n  suite.bail(this.bail());\n  return suite;\n};\n\n/**\n * Set timeout `ms` or short-hand such as \"2s\".\n *\n * @api private\n * @param {number|string} ms\n * @return {Suite|number} for chaining\n */\nSuite.prototype.timeout = function (ms) {\n  if (!arguments.length) {\n    return this._timeout;\n  }\n  if (ms.toString() === '0') {\n    this._enableTimeouts = false;\n  }\n  if (typeof ms === 'string') {\n    ms = milliseconds(ms);\n  }\n  debug('timeout %d', ms);\n  this._timeout = parseInt(ms, 10);\n  return this;\n};\n\n/**\n * Set number of times to retry a failed test.\n *\n * @api private\n * @param {number|string} n\n * @return {Suite|number} for chaining\n */\nSuite.prototype.retries = function (n) {\n  if (!arguments.length) {\n    return this._retries;\n  }\n  debug('retries %d', n);\n  this._retries = parseInt(n, 10) || 0;\n  return this;\n};\n\n/**\n  * Set timeout to `enabled`.\n  *\n  * @api private\n  * @param {boolean} enabled\n  * @return {Suite|boolean} self or enabled\n  */\nSuite.prototype.enableTimeouts = function (enabled) {\n  if (!arguments.length) {\n    return this._enableTimeouts;\n  }\n  debug('enableTimeouts %s', enabled);\n  this._enableTimeouts = enabled;\n  return this;\n};\n\n/**\n * Set slow `ms` or short-hand such as \"2s\".\n *\n * @api private\n * @param {number|string} ms\n * @return {Suite|number} for chaining\n */\nSuite.prototype.slow = function (ms) {\n  if (!arguments.length) {\n    return this._slow;\n  }\n  if (typeof ms === 'string') {\n    ms = milliseconds(ms);\n  }\n  debug('slow %d', ms);\n  this._slow = ms;\n  return this;\n};\n\n/**\n * Sets whether to bail after first error.\n *\n * @api private\n * @param {boolean} bail\n * @return {Suite|number} for chaining\n */\nSuite.prototype.bail = function (bail) {\n  if (!arguments.length) {\n    return this._bail;\n  }\n  debug('bail %s', bail);\n  this._bail = bail;\n  return this;\n};\n\n/**\n * Check if this suite or its parent suite is marked as pending.\n *\n * @api private\n */\nSuite.prototype.isPending = function () {\n  return this.pending || (this.parent && this.parent.isPending());\n};\n\n/**\n * Run `fn(test[, done])` before running tests.\n *\n * @api private\n * @param {string} title\n * @param {Function} fn\n * @return {Suite} for chaining\n */\nSuite.prototype.beforeAll = function (title, fn) {\n  if (this.isPending()) {\n    return this;\n  }\n  if (typeof title === 'function') {\n    fn = title;\n    title = fn.name;\n  }\n  title = '\"before all\" hook' + (title ? ': ' + title : '');\n\n  var hook = new Hook(title, fn);\n  hook.parent = this;\n  hook.timeout(this.timeout());\n  hook.retries(this.retries());\n  hook.enableTimeouts(this.enableTimeouts());\n  hook.slow(this.slow());\n  hook.ctx = this.ctx;\n  this._beforeAll.push(hook);\n  this.emit('beforeAll', hook);\n  return this;\n};\n\n/**\n * Run `fn(test[, done])` after running tests.\n *\n * @api private\n * @param {string} title\n * @param {Function} fn\n * @return {Suite} for chaining\n */\nSuite.prototype.afterAll = function (title, fn) {\n  if (this.isPending()) {\n    return this;\n  }\n  if (typeof title === 'function') {\n    fn = title;\n    title = fn.name;\n  }\n  title = '\"after all\" hook' + (title ? ': ' + title : '');\n\n  var hook = new Hook(title, fn);\n  hook.parent = this;\n  hook.timeout(this.timeout());\n  hook.retries(this.retries());\n  hook.enableTimeouts(this.enableTimeouts());\n  hook.slow(this.slow());\n  hook.ctx = this.ctx;\n  this._afterAll.push(hook);\n  this.emit('afterAll', hook);\n  return this;\n};\n\n/**\n * Run `fn(test[, done])` before each test case.\n *\n * @api private\n * @param {string} title\n * @param {Function} fn\n * @return {Suite} for chaining\n */\nSuite.prototype.beforeEach = function (title, fn) {\n  if (this.isPending()) {\n    return this;\n  }\n  if (typeof title === 'function') {\n    fn = title;\n    title = fn.name;\n  }\n  title = '\"before each\" hook' + (title ? ': ' + title : '');\n\n  var hook = new Hook(title, fn);\n  hook.parent = this;\n  hook.timeout(this.timeout());\n  hook.retries(this.retries());\n  hook.enableTimeouts(this.enableTimeouts());\n  hook.slow(this.slow());\n  hook.ctx = this.ctx;\n  this._beforeEach.push(hook);\n  this.emit('beforeEach', hook);\n  return this;\n};\n\n/**\n * Run `fn(test[, done])` after each test case.\n *\n * @api private\n * @param {string} title\n * @param {Function} fn\n * @return {Suite} for chaining\n */\nSuite.prototype.afterEach = function (title, fn) {\n  if (this.isPending()) {\n    return this;\n  }\n  if (typeof title === 'function') {\n    fn = title;\n    title = fn.name;\n  }\n  title = '\"after each\" hook' + (title ? ': ' + title : '');\n\n  var hook = new Hook(title, fn);\n  hook.parent = this;\n  hook.timeout(this.timeout());\n  hook.retries(this.retries());\n  hook.enableTimeouts(this.enableTimeouts());\n  hook.slow(this.slow());\n  hook.ctx = this.ctx;\n  this._afterEach.push(hook);\n  this.emit('afterEach', hook);\n  return this;\n};\n\n/**\n * Add a test `suite`.\n *\n * @api private\n * @param {Suite} suite\n * @return {Suite} for chaining\n */\nSuite.prototype.addSuite = function (suite) {\n  suite.parent = this;\n  suite.timeout(this.timeout());\n  suite.retries(this.retries());\n  suite.enableTimeouts(this.enableTimeouts());\n  suite.slow(this.slow());\n  suite.bail(this.bail());\n  this.suites.push(suite);\n  this.emit('suite', suite);\n  return this;\n};\n\n/**\n * Add a `test` to this suite.\n *\n * @api private\n * @param {Test} test\n * @return {Suite} for chaining\n */\nSuite.prototype.addTest = function (test) {\n  test.parent = this;\n  test.timeout(this.timeout());\n  test.retries(this.retries());\n  test.enableTimeouts(this.enableTimeouts());\n  test.slow(this.slow());\n  test.ctx = this.ctx;\n  this.tests.push(test);\n  this.emit('test', test);\n  return this;\n};\n\n/**\n * Return the full title generated by recursively concatenating the parent's\n * full title.\n *\n * @api public\n * @return {string}\n */\nSuite.prototype.fullTitle = function () {\n  if (this.parent) {\n    var full = this.parent.fullTitle();\n    if (full) {\n      return full + ' ' + this.title;\n    }\n  }\n  return this.title;\n};\n\n/**\n * Return the total number of tests.\n *\n * @api public\n * @return {number}\n */\nSuite.prototype.total = function () {\n  return utils.reduce(this.suites, function (sum, suite) {\n    return sum + suite.total();\n  }, 0) + this.tests.length;\n};\n\n/**\n * Iterates through each suite recursively to find all tests. Applies a\n * function in the format `fn(test)`.\n *\n * @api private\n * @param {Function} fn\n * @return {Suite}\n */\nSuite.prototype.eachTest = function (fn) {\n  utils.forEach(this.tests, fn);\n  utils.forEach(this.suites, function (suite) {\n    suite.eachTest(fn);\n  });\n  return this;\n};\n\n/**\n * This will run the root suite if we happen to be running in delayed mode.\n */\nSuite.prototype.run = function run () {\n  if (this.root) {\n    this.emit('run');\n  }\n};\n\n},{\"./hook\":7,\"./ms\":15,\"./utils\":38,\"debug\":2,\"events\":3}],36:[function(require,module,exports){\n'use strict';\n\n/**\n * Module dependencies.\n */\n\nvar Runnable = require('./runnable');\nvar create = require('lodash.create');\nvar isString = require('./utils').isString;\n\n/**\n * Expose `Test`.\n */\n\nmodule.exports = Test;\n\n/**\n * Initialize a new `Test` with the given `title` and callback `fn`.\n *\n * @api private\n * @param {String} title\n * @param {Function} fn\n */\nfunction Test (title, fn) {\n  if (!isString(title)) {\n    throw new Error('Test `title` should be a \"string\" but \"' + typeof title + '\" was given instead.');\n  }\n  Runnable.call(this, title, fn);\n  this.pending = !fn;\n  this.type = 'test';\n}\n\n/**\n * Inherit from `Runnable.prototype`.\n */\nTest.prototype = create(Runnable.prototype, {\n  constructor: Test\n});\n\nTest.prototype.clone = function () {\n  var test = new Test(this.title, this.fn);\n  test.timeout(this.timeout());\n  test.slow(this.slow());\n  test.enableTimeouts(this.enableTimeouts());\n  test.retries(this.retries());\n  test.currentRetry(this.currentRetry());\n  test.globals(this.globals());\n  test.parent = this.parent;\n  test.file = this.file;\n  test.ctx = this.ctx;\n  return test;\n};\n\n},{\"./runnable\":33,\"./utils\":38,\"lodash.create\":75}],37:[function(require,module,exports){\n'use strict';\n\n/**\n * Pad a `number` with a ten's place zero.\n *\n * @param {number} number\n * @return {string}\n */\nfunction pad(number) {\n  var n = number.toString();\n  return n.length === 1 ? '0' + n : n;\n}\n\n/**\n * Turn a `date` into an ISO string.\n *\n * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/toISOString\n *\n * @param {Date} date\n * @return {string}\n */\nfunction toISOString(date) {\n  return date.getUTCFullYear()\n    + '-' + pad(date.getUTCMonth() + 1)\n    + '-' + pad(date.getUTCDate())\n    + 'T' + pad(date.getUTCHours())\n    + ':' + pad(date.getUTCMinutes())\n    + ':' + pad(date.getUTCSeconds())\n    + '.' + String((date.getUTCMilliseconds()/1000).toFixed(3)).slice(2, 5)\n    + 'Z';\n}\n\n/*\n * Exports.\n */\n\nmodule.exports = toISOString;\n\n},{}],38:[function(require,module,exports){\n(function (process,Buffer){\n'use strict';\n\n/* eslint-env browser */\n\n/**\n * Module dependencies.\n */\n\nvar JSON = require('json3');\nvar basename = require('path').basename;\nvar debug = require('debug')('mocha:watch');\nvar exists = require('fs').existsSync || require('path').existsSync;\nvar glob = require('glob');\nvar path = require('path');\nvar join = path.join;\nvar readdirSync = require('fs').readdirSync;\nvar statSync = require('fs').statSync;\nvar watchFile = require('fs').watchFile;\nvar lstatSync = require('fs').lstatSync;\nvar toISOString = require('./to-iso-string');\nvar he = require('he');\n\n/**\n * Ignored directories.\n */\n\nvar ignore = ['node_modules', '.git'];\n\nexports.inherits = require('util').inherits;\n\n/**\n * Escape special characters in the given string of html.\n *\n * @api private\n * @param  {string} html\n * @return {string}\n */\nexports.escape = function (html) {\n  return he.encode(String(html), { useNamedReferences: false });\n};\n\n/**\n * Array#forEach (<=IE8)\n *\n * @api private\n * @param {Array} arr\n * @param {Function} fn\n * @param {Object} scope\n */\nexports.forEach = function (arr, fn, scope) {\n  for (var i = 0, l = arr.length; i < l; i++) {\n    fn.call(scope, arr[i], i);\n  }\n};\n\n/**\n * Test if the given obj is type of string.\n *\n * @api private\n * @param {Object} obj\n * @return {boolean}\n */\nexports.isString = function (obj) {\n  return typeof obj === 'string';\n};\n\n/**\n * Array#map (<=IE8)\n *\n * @api private\n * @param {Array} arr\n * @param {Function} fn\n * @param {Object} scope\n * @return {Array}\n */\nexports.map = function (arr, fn, scope) {\n  var result = [];\n  for (var i = 0, l = arr.length; i < l; i++) {\n    result.push(fn.call(scope, arr[i], i, arr));\n  }\n  return result;\n};\n\n/**\n * Array#indexOf (<=IE8)\n *\n * @api private\n * @param {Array} arr\n * @param {Object} obj to find index of\n * @param {number} start\n * @return {number}\n */\nvar indexOf = exports.indexOf = function (arr, obj, start) {\n  for (var i = start || 0, l = arr.length; i < l; i++) {\n    if (arr[i] === obj) {\n      return i;\n    }\n  }\n  return -1;\n};\n\n/**\n * Array#reduce (<=IE8)\n *\n * @api private\n * @param {Array} arr\n * @param {Function} fn\n * @param {Object} val Initial value.\n * @return {*}\n */\nvar reduce = exports.reduce = function (arr, fn, val) {\n  var rval = val;\n\n  for (var i = 0, l = arr.length; i < l; i++) {\n    rval = fn(rval, arr[i], i, arr);\n  }\n\n  return rval;\n};\n\n/**\n * Array#filter (<=IE8)\n *\n * @api private\n * @param {Array} arr\n * @param {Function} fn\n * @return {Array}\n */\nexports.filter = function (arr, fn) {\n  var ret = [];\n\n  for (var i = 0, l = arr.length; i < l; i++) {\n    var val = arr[i];\n    if (fn(val, i, arr)) {\n      ret.push(val);\n    }\n  }\n\n  return ret;\n};\n\n/**\n * Array#some (<=IE8)\n *\n * @api private\n * @param {Array} arr\n * @param {Function} fn\n * @return {Array}\n */\nexports.some = function (arr, fn) {\n  for (var i = 0, l = arr.length; i < l; i++) {\n    if (fn(arr[i])) {\n      return true;\n    }\n  }\n  return false;\n};\n\n/**\n * Object.keys (<=IE8)\n *\n * @api private\n * @param {Object} obj\n * @return {Array} keys\n */\nexports.keys = typeof Object.keys === 'function' ? Object.keys : function (obj) {\n  var keys = [];\n  var has = Object.prototype.hasOwnProperty; // for `window` on <=IE8\n\n  for (var key in obj) {\n    if (has.call(obj, key)) {\n      keys.push(key);\n    }\n  }\n\n  return keys;\n};\n\n/**\n * Watch the given `files` for changes\n * and invoke `fn(file)` on modification.\n *\n * @api private\n * @param {Array} files\n * @param {Function} fn\n */\nexports.watch = function (files, fn) {\n  var options = { interval: 100 };\n  files.forEach(function (file) {\n    debug('file %s', file);\n    watchFile(file, options, function (curr, prev) {\n      if (prev.mtime < curr.mtime) {\n        fn(file);\n      }\n    });\n  });\n};\n\n/**\n * Array.isArray (<=IE8)\n *\n * @api private\n * @param {Object} obj\n * @return {Boolean}\n */\nvar isArray = typeof Array.isArray === 'function' ? Array.isArray : function (obj) {\n  return Object.prototype.toString.call(obj) === '[object Array]';\n};\n\nexports.isArray = isArray;\n\n/**\n * Buffer.prototype.toJSON polyfill.\n *\n * @type {Function}\n */\nif (typeof Buffer !== 'undefined' && Buffer.prototype) {\n  Buffer.prototype.toJSON = Buffer.prototype.toJSON || function () {\n    return Array.prototype.slice.call(this, 0);\n  };\n}\n\n/**\n * Ignored files.\n *\n * @api private\n * @param {string} path\n * @return {boolean}\n */\nfunction ignored (path) {\n  return !~ignore.indexOf(path);\n}\n\n/**\n * Lookup files in the given `dir`.\n *\n * @api private\n * @param {string} dir\n * @param {string[]} [ext=['.js']]\n * @param {Array} [ret=[]]\n * @return {Array}\n */\nexports.files = function (dir, ext, ret) {\n  ret = ret || [];\n  ext = ext || ['js'];\n\n  var re = new RegExp('\\\\.(' + ext.join('|') + ')$');\n\n  readdirSync(dir)\n    .filter(ignored)\n    .forEach(function (path) {\n      path = join(dir, path);\n      if (lstatSync(path).isDirectory()) {\n        exports.files(path, ext, ret);\n      } else if (path.match(re)) {\n        ret.push(path);\n      }\n    });\n\n  return ret;\n};\n\n/**\n * Compute a slug from the given `str`.\n *\n * @api private\n * @param {string} str\n * @return {string}\n */\nexports.slug = function (str) {\n  return str\n    .toLowerCase()\n    .replace(/ +/g, '-')\n    .replace(/[^-\\w]/g, '');\n};\n\n/**\n * Strip the function definition from `str`, and re-indent for pre whitespace.\n *\n * @param {string} str\n * @return {string}\n */\nexports.clean = function (str) {\n  str = str\n    .replace(/\\r\\n?|[\\n\\u2028\\u2029]/g, '\\n').replace(/^\\uFEFF/, '')\n    // (traditional)->  space/name     parameters    body     (lambda)-> parameters       body   multi-statement/single          keep body content\n    .replace(/^function(?:\\s*|\\s+[^(]*)\\([^)]*\\)\\s*\\{((?:.|\\n)*?)\\s*\\}$|^\\([^)]*\\)\\s*=>\\s*(?:\\{((?:.|\\n)*?)\\s*\\}|((?:.|\\n)*))$/, '$1$2$3');\n\n  var spaces = str.match(/^\\n?( *)/)[1].length;\n  var tabs = str.match(/^\\n?(\\t*)/)[1].length;\n  var re = new RegExp('^\\n?' + (tabs ? '\\t' : ' ') + '{' + (tabs || spaces) + '}', 'gm');\n\n  str = str.replace(re, '');\n\n  return exports.trim(str);\n};\n\n/**\n * Trim the given `str`.\n *\n * @api private\n * @param {string} str\n * @return {string}\n */\nexports.trim = function (str) {\n  return str.replace(/^\\s+|\\s+$/g, '');\n};\n\n/**\n * Parse the given `qs`.\n *\n * @api private\n * @param {string} qs\n * @return {Object}\n */\nexports.parseQuery = function (qs) {\n  return reduce(qs.replace('?', '').split('&'), function (obj, pair) {\n    var i = pair.indexOf('=');\n    var key = pair.slice(0, i);\n    var val = pair.slice(++i);\n\n    // Due to how the URLSearchParams API treats spaces\n    obj[key] = decodeURIComponent(val.replace(/\\+/g, '%20'));\n\n    return obj;\n  }, {});\n};\n\n/**\n * Highlight the given string of `js`.\n *\n * @api private\n * @param {string} js\n * @return {string}\n */\nfunction highlight (js) {\n  return js\n    .replace(/</g, '&lt;')\n    .replace(/>/g, '&gt;')\n    .replace(/\\/\\/(.*)/gm, '<span class=\"comment\">//$1</span>')\n    .replace(/('.*?')/gm, '<span class=\"string\">$1</span>')\n    .replace(/(\\d+\\.\\d+)/gm, '<span class=\"number\">$1</span>')\n    .replace(/(\\d+)/gm, '<span class=\"number\">$1</span>')\n    .replace(/\\bnew[ \\t]+(\\w+)/gm, '<span class=\"keyword\">new</span> <span class=\"init\">$1</span>')\n    .replace(/\\b(function|new|throw|return|var|if|else)\\b/gm, '<span class=\"keyword\">$1</span>');\n}\n\n/**\n * Highlight the contents of tag `name`.\n *\n * @api private\n * @param {string} name\n */\nexports.highlightTags = function (name) {\n  var code = document.getElementById('mocha').getElementsByTagName(name);\n  for (var i = 0, len = code.length; i < len; ++i) {\n    code[i].innerHTML = highlight(code[i].innerHTML);\n  }\n};\n\n/**\n * If a value could have properties, and has none, this function is called,\n * which returns a string representation of the empty value.\n *\n * Functions w/ no properties return `'[Function]'`\n * Arrays w/ length === 0 return `'[]'`\n * Objects w/ no properties return `'{}'`\n * All else: return result of `value.toString()`\n *\n * @api private\n * @param {*} value The value to inspect.\n * @param {string} typeHint The type of the value\n * @returns {string}\n */\nfunction emptyRepresentation (value, typeHint) {\n  switch (typeHint) {\n    case 'function':\n      return '[Function]';\n    case 'object':\n      return '{}';\n    case 'array':\n      return '[]';\n    default:\n      return value.toString();\n  }\n}\n\n/**\n * Takes some variable and asks `Object.prototype.toString()` what it thinks it\n * is.\n *\n * @api private\n * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/toString\n * @param {*} value The value to test.\n * @returns {string} Computed type\n * @example\n * type({}) // 'object'\n * type([]) // 'array'\n * type(1) // 'number'\n * type(false) // 'boolean'\n * type(Infinity) // 'number'\n * type(null) // 'null'\n * type(new Date()) // 'date'\n * type(/foo/) // 'regexp'\n * type('type') // 'string'\n * type(global) // 'global'\n * type(new String('foo') // 'object'\n */\nvar type = exports.type = function type (value) {\n  if (value === undefined) {\n    return 'undefined';\n  } else if (value === null) {\n    return 'null';\n  } else if (typeof Buffer !== 'undefined' && Buffer.isBuffer(value)) {\n    return 'buffer';\n  }\n  return Object.prototype.toString.call(value)\n    .replace(/^\\[.+\\s(.+?)]$/, '$1')\n    .toLowerCase();\n};\n\n/**\n * Stringify `value`. Different behavior depending on type of value:\n *\n * - If `value` is undefined or null, return `'[undefined]'` or `'[null]'`, respectively.\n * - If `value` is not an object, function or array, return result of `value.toString()` wrapped in double-quotes.\n * - If `value` is an *empty* object, function, or array, return result of function\n *   {@link emptyRepresentation}.\n * - If `value` has properties, call {@link exports.canonicalize} on it, then return result of\n *   JSON.stringify().\n *\n * @api private\n * @see exports.type\n * @param {*} value\n * @return {string}\n */\nexports.stringify = function (value) {\n  var typeHint = type(value);\n\n  if (!~indexOf(['object', 'array', 'function'], typeHint)) {\n    if (typeHint === 'buffer') {\n      var json = value.toJSON();\n      // Based on the toJSON result\n      return jsonStringify(json.data && json.type ? json.data : json, 2)\n        .replace(/,(\\n|$)/g, '$1');\n    }\n\n    // IE7/IE8 has a bizarre String constructor; needs to be coerced\n    // into an array and back to obj.\n    if (typeHint === 'string' && typeof value === 'object') {\n      value = reduce(value.split(''), function (acc, char, idx) {\n        acc[idx] = char;\n        return acc;\n      }, {});\n      typeHint = 'object';\n    } else {\n      return jsonStringify(value);\n    }\n  }\n\n  for (var prop in value) {\n    if (Object.prototype.hasOwnProperty.call(value, prop)) {\n      return jsonStringify(exports.canonicalize(value, null, typeHint), 2).replace(/,(\\n|$)/g, '$1');\n    }\n  }\n\n  return emptyRepresentation(value, typeHint);\n};\n\n/**\n * like JSON.stringify but more sense.\n *\n * @api private\n * @param {Object}  object\n * @param {number=} spaces\n * @param {number=} depth\n * @returns {*}\n */\nfunction jsonStringify (object, spaces, depth) {\n  if (typeof spaces === 'undefined') {\n    // primitive types\n    return _stringify(object);\n  }\n\n  depth = depth || 1;\n  var space = spaces * depth;\n  var str = isArray(object) ? '[' : '{';\n  var end = isArray(object) ? ']' : '}';\n  var length = typeof object.length === 'number' ? object.length : exports.keys(object).length;\n  // `.repeat()` polyfill\n  function repeat (s, n) {\n    return new Array(n).join(s);\n  }\n\n  function _stringify (val) {\n    switch (type(val)) {\n      case 'null':\n      case 'undefined':\n        val = '[' + val + ']';\n        break;\n      case 'array':\n      case 'object':\n        val = jsonStringify(val, spaces, depth + 1);\n        break;\n      case 'boolean':\n      case 'regexp':\n      case 'symbol':\n      case 'number':\n        val = val === 0 && (1 / val) === -Infinity // `-0`\n          ? '-0'\n          : val.toString();\n        break;\n      case 'date':\n        var sDate;\n        if (isNaN(val.getTime())) { // Invalid date\n          sDate = val.toString();\n        } else {\n          sDate = val.toISOString ? val.toISOString() : toISOString(val);\n        }\n        val = '[Date: ' + sDate + ']';\n        break;\n      case 'buffer':\n        var json = val.toJSON();\n        // Based on the toJSON result\n        json = json.data && json.type ? json.data : json;\n        val = '[Buffer: ' + jsonStringify(json, 2, depth + 1) + ']';\n        break;\n      default:\n        val = (val === '[Function]' || val === '[Circular]')\n          ? val\n          : JSON.stringify(val); // string\n    }\n    return val;\n  }\n\n  for (var i in object) {\n    if (!Object.prototype.hasOwnProperty.call(object, i)) {\n      continue; // not my business\n    }\n    --length;\n    str += '\\n ' + repeat(' ', space) +\n      (isArray(object) ? '' : '\"' + i + '\": ') + // key\n      _stringify(object[i]) +                    // value\n      (length ? ',' : '');                       // comma\n  }\n\n  return str +\n    // [], {}\n    (str.length !== 1 ? '\\n' + repeat(' ', --space) + end : end);\n}\n\n/**\n * Test if a value is a buffer.\n *\n * @api private\n * @param {*} value The value to test.\n * @return {boolean} True if `value` is a buffer, otherwise false\n */\nexports.isBuffer = function (value) {\n  return typeof Buffer !== 'undefined' && Buffer.isBuffer(value);\n};\n\n/**\n * Return a new Thing that has the keys in sorted order. Recursive.\n *\n * If the Thing...\n * - has already been seen, return string `'[Circular]'`\n * - is `undefined`, return string `'[undefined]'`\n * - is `null`, return value `null`\n * - is some other primitive, return the value\n * - is not a primitive or an `Array`, `Object`, or `Function`, return the value of the Thing's `toString()` method\n * - is a non-empty `Array`, `Object`, or `Function`, return the result of calling this function again.\n * - is an empty `Array`, `Object`, or `Function`, return the result of calling `emptyRepresentation()`\n *\n * @api private\n * @see {@link exports.stringify}\n * @param {*} value Thing to inspect.  May or may not have properties.\n * @param {Array} [stack=[]] Stack of seen values\n * @param {string} [typeHint] Type hint\n * @return {(Object|Array|Function|string|undefined)}\n */\nexports.canonicalize = function canonicalize (value, stack, typeHint) {\n  var canonicalizedObj;\n  /* eslint-disable no-unused-vars */\n  var prop;\n  /* eslint-enable no-unused-vars */\n  typeHint = typeHint || type(value);\n  function withStack (value, fn) {\n    stack.push(value);\n    fn();\n    stack.pop();\n  }\n\n  stack = stack || [];\n\n  if (indexOf(stack, value) !== -1) {\n    return '[Circular]';\n  }\n\n  switch (typeHint) {\n    case 'undefined':\n    case 'buffer':\n    case 'null':\n      canonicalizedObj = value;\n      break;\n    case 'array':\n      withStack(value, function () {\n        canonicalizedObj = exports.map(value, function (item) {\n          return exports.canonicalize(item, stack);\n        });\n      });\n      break;\n    case 'function':\n      /* eslint-disable guard-for-in */\n      for (prop in value) {\n        canonicalizedObj = {};\n        break;\n      }\n      /* eslint-enable guard-for-in */\n      if (!canonicalizedObj) {\n        canonicalizedObj = emptyRepresentation(value, typeHint);\n        break;\n      }\n    /* falls through */\n    case 'object':\n      canonicalizedObj = canonicalizedObj || {};\n      withStack(value, function () {\n        exports.forEach(exports.keys(value).sort(), function (key) {\n          canonicalizedObj[key] = exports.canonicalize(value[key], stack);\n        });\n      });\n      break;\n    case 'date':\n    case 'number':\n    case 'regexp':\n    case 'boolean':\n    case 'symbol':\n      canonicalizedObj = value;\n      break;\n    default:\n      canonicalizedObj = value + '';\n  }\n\n  return canonicalizedObj;\n};\n\n/**\n * Lookup file names at the given `path`.\n *\n * @api public\n * @param {string} path Base path to start searching from.\n * @param {string[]} extensions File extensions to look for.\n * @param {boolean} recursive Whether or not to recurse into subdirectories.\n * @return {string[]} An array of paths.\n */\nexports.lookupFiles = function lookupFiles (path, extensions, recursive) {\n  var files = [];\n  var re = new RegExp('\\\\.(' + extensions.join('|') + ')$');\n\n  if (!exists(path)) {\n    if (exists(path + '.js')) {\n      path += '.js';\n    } else {\n      files = glob.sync(path);\n      if (!files.length) {\n        throw new Error(\"cannot resolve path (or pattern) '\" + path + \"'\");\n      }\n      return files;\n    }\n  }\n\n  try {\n    var stat = statSync(path);\n    if (stat.isFile()) {\n      return path;\n    }\n  } catch (err) {\n    // ignore error\n    return;\n  }\n\n  readdirSync(path).forEach(function (file) {\n    file = join(path, file);\n    try {\n      var stat = statSync(file);\n      if (stat.isDirectory()) {\n        if (recursive) {\n          files = files.concat(lookupFiles(file, extensions, recursive));\n        }\n        return;\n      }\n    } catch (err) {\n      // ignore error\n      return;\n    }\n    if (!stat.isFile() || !re.test(file) || basename(file)[0] === '.') {\n      return;\n    }\n    files.push(file);\n  });\n\n  return files;\n};\n\n/**\n * Generate an undefined error with a message warning the user.\n *\n * @return {Error}\n */\n\nexports.undefinedError = function () {\n  return new Error('Caught undefined error, did you throw without specifying what?');\n};\n\n/**\n * Generate an undefined error if `err` is not defined.\n *\n * @param {Error} err\n * @return {Error}\n */\n\nexports.getError = function (err) {\n  return err || exports.undefinedError();\n};\n\n/**\n * @summary\n * This Filter based on `mocha-clean` module.(see: `github.com/rstacruz/mocha-clean`)\n * @description\n * When invoking this function you get a filter function that get the Error.stack as an input,\n * and return a prettify output.\n * (i.e: strip Mocha and internal node functions from stack trace).\n * @returns {Function}\n */\nexports.stackTraceFilter = function () {\n  // TODO: Replace with `process.browser`\n  var is = typeof document === 'undefined' ? { node: true } : { browser: true };\n  var slash = path.sep;\n  var cwd;\n  if (is.node) {\n    cwd = process.cwd() + slash;\n  } else {\n    cwd = (typeof location === 'undefined'\n      ? window.location\n      : location).href.replace(/\\/[^/]*$/, '/');\n    slash = '/';\n  }\n\n  function isMochaInternal (line) {\n    return (~line.indexOf('node_modules' + slash + 'mocha' + slash)) ||\n      (~line.indexOf('node_modules' + slash + 'mocha.js')) ||\n      (~line.indexOf('bower_components' + slash + 'mocha.js')) ||\n      (~line.indexOf(slash + 'mocha.js'));\n  }\n\n  function isNodeInternal (line) {\n    return (~line.indexOf('(timers.js:')) ||\n      (~line.indexOf('(events.js:')) ||\n      (~line.indexOf('(node.js:')) ||\n      (~line.indexOf('(module.js:')) ||\n      (~line.indexOf('GeneratorFunctionPrototype.next (native)')) ||\n      false;\n  }\n\n  return function (stack) {\n    stack = stack.split('\\n');\n\n    stack = reduce(stack, function (list, line) {\n      if (isMochaInternal(line)) {\n        return list;\n      }\n\n      if (is.node && isNodeInternal(line)) {\n        return list;\n      }\n\n      // Clean up cwd(absolute)\n      if (/\\(?.+:\\d+:\\d+\\)?$/.test(line)) {\n        line = line.replace(cwd, '');\n      }\n\n      list.push(line);\n      return list;\n    }, []);\n\n    return stack.join('\\n');\n  };\n};\n\n/**\n * Crude, but effective.\n * @api\n * @param {*} value\n * @returns {boolean} Whether or not `value` is a Promise\n */\nexports.isPromise = function isPromise (value) {\n  return typeof value === 'object' && typeof value.then === 'function';\n};\n\n/**\n * It's a noop.\n * @api\n */\nexports.noop = function () {};\n\n}).call(this,require('_process'),require(\"buffer\").Buffer)\n},{\"./to-iso-string\":37,\"_process\":82,\"buffer\":43,\"debug\":2,\"fs\":42,\"glob\":42,\"he\":64,\"json3\":69,\"path\":42,\"util\":102}],39:[function(require,module,exports){\n'use strict'\n\nexports.byteLength = byteLength\nexports.toByteArray = toByteArray\nexports.fromByteArray = fromByteArray\n\nvar lookup = []\nvar revLookup = []\nvar Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array\n\nvar code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\nfor (var i = 0, len = code.length; i < len; ++i) {\n  lookup[i] = code[i]\n  revLookup[code.charCodeAt(i)] = i\n}\n\nrevLookup['-'.charCodeAt(0)] = 62\nrevLookup['_'.charCodeAt(0)] = 63\n\nfunction placeHoldersCount (b64) {\n  var len = b64.length\n  if (len % 4 > 0) {\n    throw new Error('Invalid string. Length must be a multiple of 4')\n  }\n\n  // the number of equal signs (place holders)\n  // if there are two placeholders, than the two characters before it\n  // represent one byte\n  // if there is only one, then the three characters before it represent 2 bytes\n  // this is just a cheap hack to not do indexOf twice\n  return b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0\n}\n\nfunction byteLength (b64) {\n  // base64 is 4/3 + up to two characters of the original data\n  return (b64.length * 3 / 4) - placeHoldersCount(b64)\n}\n\nfunction toByteArray (b64) {\n  var i, l, tmp, placeHolders, arr\n  var len = b64.length\n  placeHolders = placeHoldersCount(b64)\n\n  arr = new Arr((len * 3 / 4) - placeHolders)\n\n  // if there are placeholders, only get up to the last complete 4 chars\n  l = placeHolders > 0 ? len - 4 : len\n\n  var L = 0\n\n  for (i = 0; i < l; i += 4) {\n    tmp = (revLookup[b64.charCodeAt(i)] << 18) | (revLookup[b64.charCodeAt(i + 1)] << 12) | (revLookup[b64.charCodeAt(i + 2)] << 6) | revLookup[b64.charCodeAt(i + 3)]\n    arr[L++] = (tmp >> 16) & 0xFF\n    arr[L++] = (tmp >> 8) & 0xFF\n    arr[L++] = tmp & 0xFF\n  }\n\n  if (placeHolders === 2) {\n    tmp = (revLookup[b64.charCodeAt(i)] << 2) | (revLookup[b64.charCodeAt(i + 1)] >> 4)\n    arr[L++] = tmp & 0xFF\n  } else if (placeHolders === 1) {\n    tmp = (revLookup[b64.charCodeAt(i)] << 10) | (revLookup[b64.charCodeAt(i + 1)] << 4) | (revLookup[b64.charCodeAt(i + 2)] >> 2)\n    arr[L++] = (tmp >> 8) & 0xFF\n    arr[L++] = tmp & 0xFF\n  }\n\n  return arr\n}\n\nfunction tripletToBase64 (num) {\n  return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F]\n}\n\nfunction encodeChunk (uint8, start, end) {\n  var tmp\n  var output = []\n  for (var i = start; i < end; i += 3) {\n    tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])\n    output.push(tripletToBase64(tmp))\n  }\n  return output.join('')\n}\n\nfunction fromByteArray (uint8) {\n  var tmp\n  var len = uint8.length\n  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes\n  var output = ''\n  var parts = []\n  var maxChunkLength = 16383 // must be multiple of 3\n\n  // go through the array every three bytes, we'll deal with trailing stuff later\n  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))\n  }\n\n  // pad the end with zeros, but make sure to not forget the extra bytes\n  if (extraBytes === 1) {\n    tmp = uint8[len - 1]\n    output += lookup[tmp >> 2]\n    output += lookup[(tmp << 4) & 0x3F]\n    output += '=='\n  } else if (extraBytes === 2) {\n    tmp = (uint8[len - 2] << 8) + (uint8[len - 1])\n    output += lookup[tmp >> 10]\n    output += lookup[(tmp >> 4) & 0x3F]\n    output += lookup[(tmp << 2) & 0x3F]\n    output += '='\n  }\n\n  parts.push(output)\n\n  return parts.join('')\n}\n\n},{}],40:[function(require,module,exports){\n\n},{}],41:[function(require,module,exports){\n(function (process){\nvar WritableStream = require('stream').Writable\nvar inherits = require('util').inherits\n\nmodule.exports = BrowserStdout\n\n\ninherits(BrowserStdout, WritableStream)\n\nfunction BrowserStdout(opts) {\n  if (!(this instanceof BrowserStdout)) return new BrowserStdout(opts)\n\n  opts = opts || {}\n  WritableStream.call(this, opts)\n  this.label = (opts.label !== undefined) ? opts.label : 'stdout'\n}\n\nBrowserStdout.prototype._write = function(chunks, encoding, cb) {\n  var output = chunks.toString ? chunks.toString() : chunks\n  if (this.label === false) {\n    console.log(output)\n  } else {\n    console.log(this.label+':', output)\n  }\n  process.nextTick(cb)\n}\n\n}).call(this,require('_process'))\n},{\"_process\":82,\"stream\":96,\"util\":102}],42:[function(require,module,exports){\narguments[4][40][0].apply(exports,arguments)\n},{\"dup\":40}],43:[function(require,module,exports){\n(function (global){\n/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>\n * @license  MIT\n */\n/* eslint-disable no-proto */\n\n'use strict'\n\nvar base64 = require('base64-js')\nvar ieee754 = require('ieee754')\nvar isArray = require('isarray')\n\nexports.Buffer = Buffer\nexports.SlowBuffer = SlowBuffer\nexports.INSPECT_MAX_BYTES = 50\n\n/**\n * If `Buffer.TYPED_ARRAY_SUPPORT`:\n *   === true    Use Uint8Array implementation (fastest)\n *   === false   Use Object implementation (most compatible, even IE6)\n *\n * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n * Opera 11.6+, iOS 4.2+.\n *\n * Due to various browser bugs, sometimes the Object implementation will be used even\n * when the browser supports typed arrays.\n *\n * Note:\n *\n *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,\n *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.\n *\n *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.\n *\n *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of\n *     incorrect length in some situations.\n\n * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they\n * get the Object implementation, which is slower but behaves correctly.\n */\nBuffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined\n  ? global.TYPED_ARRAY_SUPPORT\n  : typedArraySupport()\n\n/*\n * Export kMaxLength after typed array support is determined.\n */\nexports.kMaxLength = kMaxLength()\n\nfunction typedArraySupport () {\n  try {\n    var arr = new Uint8Array(1)\n    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}\n    return arr.foo() === 42 && // typed array instances can be augmented\n        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`\n        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`\n  } catch (e) {\n    return false\n  }\n}\n\nfunction kMaxLength () {\n  return Buffer.TYPED_ARRAY_SUPPORT\n    ? 0x7fffffff\n    : 0x3fffffff\n}\n\nfunction createBuffer (that, length) {\n  if (kMaxLength() < length) {\n    throw new RangeError('Invalid typed array length')\n  }\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    // Return an augmented `Uint8Array` instance, for best performance\n    that = new Uint8Array(length)\n    that.__proto__ = Buffer.prototype\n  } else {\n    // Fallback: Return an object instance of the Buffer class\n    if (that === null) {\n      that = new Buffer(length)\n    }\n    that.length = length\n  }\n\n  return that\n}\n\n/**\n * The Buffer constructor returns instances of `Uint8Array` that have their\n * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of\n * `Uint8Array`, so the returned instances will have all the node `Buffer` methods\n * and the `Uint8Array` methods. Square bracket notation works as expected -- it\n * returns a single octet.\n *\n * The `Uint8Array` prototype remains unmodified.\n */\n\nfunction Buffer (arg, encodingOrOffset, length) {\n  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {\n    return new Buffer(arg, encodingOrOffset, length)\n  }\n\n  // Common case.\n  if (typeof arg === 'number') {\n    if (typeof encodingOrOffset === 'string') {\n      throw new Error(\n        'If encoding is specified then the first argument must be a string'\n      )\n    }\n    return allocUnsafe(this, arg)\n  }\n  return from(this, arg, encodingOrOffset, length)\n}\n\nBuffer.poolSize = 8192 // not used by this implementation\n\n// TODO: Legacy, not needed anymore. Remove in next major version.\nBuffer._augment = function (arr) {\n  arr.__proto__ = Buffer.prototype\n  return arr\n}\n\nfunction from (that, value, encodingOrOffset, length) {\n  if (typeof value === 'number') {\n    throw new TypeError('\"value\" argument must not be a number')\n  }\n\n  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {\n    return fromArrayBuffer(that, value, encodingOrOffset, length)\n  }\n\n  if (typeof value === 'string') {\n    return fromString(that, value, encodingOrOffset)\n  }\n\n  return fromObject(that, value)\n}\n\n/**\n * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError\n * if value is a number.\n * Buffer.from(str[, encoding])\n * Buffer.from(array)\n * Buffer.from(buffer)\n * Buffer.from(arrayBuffer[, byteOffset[, length]])\n **/\nBuffer.from = function (value, encodingOrOffset, length) {\n  return from(null, value, encodingOrOffset, length)\n}\n\nif (Buffer.TYPED_ARRAY_SUPPORT) {\n  Buffer.prototype.__proto__ = Uint8Array.prototype\n  Buffer.__proto__ = Uint8Array\n  if (typeof Symbol !== 'undefined' && Symbol.species &&\n      Buffer[Symbol.species] === Buffer) {\n    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97\n    Object.defineProperty(Buffer, Symbol.species, {\n      value: null,\n      configurable: true\n    })\n  }\n}\n\nfunction assertSize (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('\"size\" argument must be a number')\n  } else if (size < 0) {\n    throw new RangeError('\"size\" argument must not be negative')\n  }\n}\n\nfunction alloc (that, size, fill, encoding) {\n  assertSize(size)\n  if (size <= 0) {\n    return createBuffer(that, size)\n  }\n  if (fill !== undefined) {\n    // Only pay attention to encoding if it's a string. This\n    // prevents accidentally sending in a number that would\n    // be interpretted as a start offset.\n    return typeof encoding === 'string'\n      ? createBuffer(that, size).fill(fill, encoding)\n      : createBuffer(that, size).fill(fill)\n  }\n  return createBuffer(that, size)\n}\n\n/**\n * Creates a new filled Buffer instance.\n * alloc(size[, fill[, encoding]])\n **/\nBuffer.alloc = function (size, fill, encoding) {\n  return alloc(null, size, fill, encoding)\n}\n\nfunction allocUnsafe (that, size) {\n  assertSize(size)\n  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) {\n    for (var i = 0; i < size; ++i) {\n      that[i] = 0\n    }\n  }\n  return that\n}\n\n/**\n * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.\n * */\nBuffer.allocUnsafe = function (size) {\n  return allocUnsafe(null, size)\n}\n/**\n * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.\n */\nBuffer.allocUnsafeSlow = function (size) {\n  return allocUnsafe(null, size)\n}\n\nfunction fromString (that, string, encoding) {\n  if (typeof encoding !== 'string' || encoding === '') {\n    encoding = 'utf8'\n  }\n\n  if (!Buffer.isEncoding(encoding)) {\n    throw new TypeError('\"encoding\" must be a valid string encoding')\n  }\n\n  var length = byteLength(string, encoding) | 0\n  that = createBuffer(that, length)\n\n  var actual = that.write(string, encoding)\n\n  if (actual !== length) {\n    // Writing a hex string, for example, that contains invalid characters will\n    // cause everything after the first invalid character to be ignored. (e.g.\n    // 'abxxcd' will be treated as 'ab')\n    that = that.slice(0, actual)\n  }\n\n  return that\n}\n\nfunction fromArrayLike (that, array) {\n  var length = array.length < 0 ? 0 : checked(array.length) | 0\n  that = createBuffer(that, length)\n  for (var i = 0; i < length; i += 1) {\n    that[i] = array[i] & 255\n  }\n  return that\n}\n\nfunction fromArrayBuffer (that, array, byteOffset, length) {\n  array.byteLength // this throws if `array` is not a valid ArrayBuffer\n\n  if (byteOffset < 0 || array.byteLength < byteOffset) {\n    throw new RangeError('\\'offset\\' is out of bounds')\n  }\n\n  if (array.byteLength < byteOffset + (length || 0)) {\n    throw new RangeError('\\'length\\' is out of bounds')\n  }\n\n  if (byteOffset === undefined && length === undefined) {\n    array = new Uint8Array(array)\n  } else if (length === undefined) {\n    array = new Uint8Array(array, byteOffset)\n  } else {\n    array = new Uint8Array(array, byteOffset, length)\n  }\n\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    // Return an augmented `Uint8Array` instance, for best performance\n    that = array\n    that.__proto__ = Buffer.prototype\n  } else {\n    // Fallback: Return an object instance of the Buffer class\n    that = fromArrayLike(that, array)\n  }\n  return that\n}\n\nfunction fromObject (that, obj) {\n  if (Buffer.isBuffer(obj)) {\n    var len = checked(obj.length) | 0\n    that = createBuffer(that, len)\n\n    if (that.length === 0) {\n      return that\n    }\n\n    obj.copy(that, 0, 0, len)\n    return that\n  }\n\n  if (obj) {\n    if ((typeof ArrayBuffer !== 'undefined' &&\n        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {\n      if (typeof obj.length !== 'number' || isnan(obj.length)) {\n        return createBuffer(that, 0)\n      }\n      return fromArrayLike(that, obj)\n    }\n\n    if (obj.type === 'Buffer' && isArray(obj.data)) {\n      return fromArrayLike(that, obj.data)\n    }\n  }\n\n  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')\n}\n\nfunction checked (length) {\n  // Note: cannot use `length < kMaxLength()` here because that fails when\n  // length is NaN (which is otherwise coerced to zero.)\n  if (length >= kMaxLength()) {\n    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +\n                         'size: 0x' + kMaxLength().toString(16) + ' bytes')\n  }\n  return length | 0\n}\n\nfunction SlowBuffer (length) {\n  if (+length != length) { // eslint-disable-line eqeqeq\n    length = 0\n  }\n  return Buffer.alloc(+length)\n}\n\nBuffer.isBuffer = function isBuffer (b) {\n  return !!(b != null && b._isBuffer)\n}\n\nBuffer.compare = function compare (a, b) {\n  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\n    throw new TypeError('Arguments must be Buffers')\n  }\n\n  if (a === b) return 0\n\n  var x = a.length\n  var y = b.length\n\n  for (var i = 0, len = Math.min(x, y); i < len; ++i) {\n    if (a[i] !== b[i]) {\n      x = a[i]\n      y = b[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\nBuffer.isEncoding = function isEncoding (encoding) {\n  switch (String(encoding).toLowerCase()) {\n    case 'hex':\n    case 'utf8':\n    case 'utf-8':\n    case 'ascii':\n    case 'latin1':\n    case 'binary':\n    case 'base64':\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      return true\n    default:\n      return false\n  }\n}\n\nBuffer.concat = function concat (list, length) {\n  if (!isArray(list)) {\n    throw new TypeError('\"list\" argument must be an Array of Buffers')\n  }\n\n  if (list.length === 0) {\n    return Buffer.alloc(0)\n  }\n\n  var i\n  if (length === undefined) {\n    length = 0\n    for (i = 0; i < list.length; ++i) {\n      length += list[i].length\n    }\n  }\n\n  var buffer = Buffer.allocUnsafe(length)\n  var pos = 0\n  for (i = 0; i < list.length; ++i) {\n    var buf = list[i]\n    if (!Buffer.isBuffer(buf)) {\n      throw new TypeError('\"list\" argument must be an Array of Buffers')\n    }\n    buf.copy(buffer, pos)\n    pos += buf.length\n  }\n  return buffer\n}\n\nfunction byteLength (string, encoding) {\n  if (Buffer.isBuffer(string)) {\n    return string.length\n  }\n  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&\n      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {\n    return string.byteLength\n  }\n  if (typeof string !== 'string') {\n    string = '' + string\n  }\n\n  var len = string.length\n  if (len === 0) return 0\n\n  // Use a for loop to avoid recursion\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return len\n      case 'utf8':\n      case 'utf-8':\n      case undefined:\n        return utf8ToBytes(string).length\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return len * 2\n      case 'hex':\n        return len >>> 1\n      case 'base64':\n        return base64ToBytes(string).length\n      default:\n        if (loweredCase) return utf8ToBytes(string).length // assume utf8\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\nBuffer.byteLength = byteLength\n\nfunction slowToString (encoding, start, end) {\n  var loweredCase = false\n\n  // No need to verify that \"this.length <= MAX_UINT32\" since it's a read-only\n  // property of a typed array.\n\n  // This behaves neither like String nor Uint8Array in that we set start/end\n  // to their upper/lower bounds if the value passed is out of range.\n  // undefined is handled specially as per ECMA-262 6th Edition,\n  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.\n  if (start === undefined || start < 0) {\n    start = 0\n  }\n  // Return early if start > this.length. Done here to prevent potential uint32\n  // coercion fail below.\n  if (start > this.length) {\n    return ''\n  }\n\n  if (end === undefined || end > this.length) {\n    end = this.length\n  }\n\n  if (end <= 0) {\n    return ''\n  }\n\n  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.\n  end >>>= 0\n  start >>>= 0\n\n  if (end <= start) {\n    return ''\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  while (true) {\n    switch (encoding) {\n      case 'hex':\n        return hexSlice(this, start, end)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Slice(this, start, end)\n\n      case 'ascii':\n        return asciiSlice(this, start, end)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Slice(this, start, end)\n\n      case 'base64':\n        return base64Slice(this, start, end)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return utf16leSlice(this, start, end)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = (encoding + '').toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\n// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect\n// Buffer instances.\nBuffer.prototype._isBuffer = true\n\nfunction swap (b, n, m) {\n  var i = b[n]\n  b[n] = b[m]\n  b[m] = i\n}\n\nBuffer.prototype.swap16 = function swap16 () {\n  var len = this.length\n  if (len % 2 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 16-bits')\n  }\n  for (var i = 0; i < len; i += 2) {\n    swap(this, i, i + 1)\n  }\n  return this\n}\n\nBuffer.prototype.swap32 = function swap32 () {\n  var len = this.length\n  if (len % 4 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 32-bits')\n  }\n  for (var i = 0; i < len; i += 4) {\n    swap(this, i, i + 3)\n    swap(this, i + 1, i + 2)\n  }\n  return this\n}\n\nBuffer.prototype.swap64 = function swap64 () {\n  var len = this.length\n  if (len % 8 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 64-bits')\n  }\n  for (var i = 0; i < len; i += 8) {\n    swap(this, i, i + 7)\n    swap(this, i + 1, i + 6)\n    swap(this, i + 2, i + 5)\n    swap(this, i + 3, i + 4)\n  }\n  return this\n}\n\nBuffer.prototype.toString = function toString () {\n  var length = this.length | 0\n  if (length === 0) return ''\n  if (arguments.length === 0) return utf8Slice(this, 0, length)\n  return slowToString.apply(this, arguments)\n}\n\nBuffer.prototype.equals = function equals (b) {\n  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\n  if (this === b) return true\n  return Buffer.compare(this, b) === 0\n}\n\nBuffer.prototype.inspect = function inspect () {\n  var str = ''\n  var max = exports.INSPECT_MAX_BYTES\n  if (this.length > 0) {\n    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')\n    if (this.length > max) str += ' ... '\n  }\n  return '<Buffer ' + str + '>'\n}\n\nBuffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {\n  if (!Buffer.isBuffer(target)) {\n    throw new TypeError('Argument must be a Buffer')\n  }\n\n  if (start === undefined) {\n    start = 0\n  }\n  if (end === undefined) {\n    end = target ? target.length : 0\n  }\n  if (thisStart === undefined) {\n    thisStart = 0\n  }\n  if (thisEnd === undefined) {\n    thisEnd = this.length\n  }\n\n  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\n    throw new RangeError('out of range index')\n  }\n\n  if (thisStart >= thisEnd && start >= end) {\n    return 0\n  }\n  if (thisStart >= thisEnd) {\n    return -1\n  }\n  if (start >= end) {\n    return 1\n  }\n\n  start >>>= 0\n  end >>>= 0\n  thisStart >>>= 0\n  thisEnd >>>= 0\n\n  if (this === target) return 0\n\n  var x = thisEnd - thisStart\n  var y = end - start\n  var len = Math.min(x, y)\n\n  var thisCopy = this.slice(thisStart, thisEnd)\n  var targetCopy = target.slice(start, end)\n\n  for (var i = 0; i < len; ++i) {\n    if (thisCopy[i] !== targetCopy[i]) {\n      x = thisCopy[i]\n      y = targetCopy[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\n// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,\n// OR the last index of `val` in `buffer` at offset <= `byteOffset`.\n//\n// Arguments:\n// - buffer - a Buffer to search\n// - val - a string, Buffer, or number\n// - byteOffset - an index into `buffer`; will be clamped to an int32\n// - encoding - an optional encoding, relevant is val is a string\n// - dir - true for indexOf, false for lastIndexOf\nfunction bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {\n  // Empty buffer means no match\n  if (buffer.length === 0) return -1\n\n  // Normalize byteOffset\n  if (typeof byteOffset === 'string') {\n    encoding = byteOffset\n    byteOffset = 0\n  } else if (byteOffset > 0x7fffffff) {\n    byteOffset = 0x7fffffff\n  } else if (byteOffset < -0x80000000) {\n    byteOffset = -0x80000000\n  }\n  byteOffset = +byteOffset  // Coerce to Number.\n  if (isNaN(byteOffset)) {\n    // byteOffset: it it's undefined, null, NaN, \"foo\", etc, search whole buffer\n    byteOffset = dir ? 0 : (buffer.length - 1)\n  }\n\n  // Normalize byteOffset: negative offsets start from the end of the buffer\n  if (byteOffset < 0) byteOffset = buffer.length + byteOffset\n  if (byteOffset >= buffer.length) {\n    if (dir) return -1\n    else byteOffset = buffer.length - 1\n  } else if (byteOffset < 0) {\n    if (dir) byteOffset = 0\n    else return -1\n  }\n\n  // Normalize val\n  if (typeof val === 'string') {\n    val = Buffer.from(val, encoding)\n  }\n\n  // Finally, search either indexOf (if dir is true) or lastIndexOf\n  if (Buffer.isBuffer(val)) {\n    // Special case: looking for empty string/buffer always fails\n    if (val.length === 0) {\n      return -1\n    }\n    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)\n  } else if (typeof val === 'number') {\n    val = val & 0xFF // Search for a byte value [0-255]\n    if (Buffer.TYPED_ARRAY_SUPPORT &&\n        typeof Uint8Array.prototype.indexOf === 'function') {\n      if (dir) {\n        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)\n      } else {\n        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)\n      }\n    }\n    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)\n  }\n\n  throw new TypeError('val must be string, number or Buffer')\n}\n\nfunction arrayIndexOf (arr, val, byteOffset, encoding, dir) {\n  var indexSize = 1\n  var arrLength = arr.length\n  var valLength = val.length\n\n  if (encoding !== undefined) {\n    encoding = String(encoding).toLowerCase()\n    if (encoding === 'ucs2' || encoding === 'ucs-2' ||\n        encoding === 'utf16le' || encoding === 'utf-16le') {\n      if (arr.length < 2 || val.length < 2) {\n        return -1\n      }\n      indexSize = 2\n      arrLength /= 2\n      valLength /= 2\n      byteOffset /= 2\n    }\n  }\n\n  function read (buf, i) {\n    if (indexSize === 1) {\n      return buf[i]\n    } else {\n      return buf.readUInt16BE(i * indexSize)\n    }\n  }\n\n  var i\n  if (dir) {\n    var foundIndex = -1\n    for (i = byteOffset; i < arrLength; i++) {\n      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n        if (foundIndex === -1) foundIndex = i\n        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize\n      } else {\n        if (foundIndex !== -1) i -= i - foundIndex\n        foundIndex = -1\n      }\n    }\n  } else {\n    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength\n    for (i = byteOffset; i >= 0; i--) {\n      var found = true\n      for (var j = 0; j < valLength; j++) {\n        if (read(arr, i + j) !== read(val, j)) {\n          found = false\n          break\n        }\n      }\n      if (found) return i\n    }\n  }\n\n  return -1\n}\n\nBuffer.prototype.includes = function includes (val, byteOffset, encoding) {\n  return this.indexOf(val, byteOffset, encoding) !== -1\n}\n\nBuffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)\n}\n\nBuffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)\n}\n\nfunction hexWrite (buf, string, offset, length) {\n  offset = Number(offset) || 0\n  var remaining = buf.length - offset\n  if (!length) {\n    length = remaining\n  } else {\n    length = Number(length)\n    if (length > remaining) {\n      length = remaining\n    }\n  }\n\n  // must be an even number of digits\n  var strLen = string.length\n  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')\n\n  if (length > strLen / 2) {\n    length = strLen / 2\n  }\n  for (var i = 0; i < length; ++i) {\n    var parsed = parseInt(string.substr(i * 2, 2), 16)\n    if (isNaN(parsed)) return i\n    buf[offset + i] = parsed\n  }\n  return i\n}\n\nfunction utf8Write (buf, string, offset, length) {\n  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nfunction asciiWrite (buf, string, offset, length) {\n  return blitBuffer(asciiToBytes(string), buf, offset, length)\n}\n\nfunction latin1Write (buf, string, offset, length) {\n  return asciiWrite(buf, string, offset, length)\n}\n\nfunction base64Write (buf, string, offset, length) {\n  return blitBuffer(base64ToBytes(string), buf, offset, length)\n}\n\nfunction ucs2Write (buf, string, offset, length) {\n  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nBuffer.prototype.write = function write (string, offset, length, encoding) {\n  // Buffer#write(string)\n  if (offset === undefined) {\n    encoding = 'utf8'\n    length = this.length\n    offset = 0\n  // Buffer#write(string, encoding)\n  } else if (length === undefined && typeof offset === 'string') {\n    encoding = offset\n    length = this.length\n    offset = 0\n  // Buffer#write(string, offset[, length][, encoding])\n  } else if (isFinite(offset)) {\n    offset = offset | 0\n    if (isFinite(length)) {\n      length = length | 0\n      if (encoding === undefined) encoding = 'utf8'\n    } else {\n      encoding = length\n      length = undefined\n    }\n  // legacy write(string, encoding, offset, length) - remove in v0.13\n  } else {\n    throw new Error(\n      'Buffer.write(string, encoding, offset[, length]) is no longer supported'\n    )\n  }\n\n  var remaining = this.length - offset\n  if (length === undefined || length > remaining) length = remaining\n\n  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {\n    throw new RangeError('Attempt to write outside buffer bounds')\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'hex':\n        return hexWrite(this, string, offset, length)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Write(this, string, offset, length)\n\n      case 'ascii':\n        return asciiWrite(this, string, offset, length)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Write(this, string, offset, length)\n\n      case 'base64':\n        // Warning: maxLength not taken into account in base64Write\n        return base64Write(this, string, offset, length)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return ucs2Write(this, string, offset, length)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\nBuffer.prototype.toJSON = function toJSON () {\n  return {\n    type: 'Buffer',\n    data: Array.prototype.slice.call(this._arr || this, 0)\n  }\n}\n\nfunction base64Slice (buf, start, end) {\n  if (start === 0 && end === buf.length) {\n    return base64.fromByteArray(buf)\n  } else {\n    return base64.fromByteArray(buf.slice(start, end))\n  }\n}\n\nfunction utf8Slice (buf, start, end) {\n  end = Math.min(buf.length, end)\n  var res = []\n\n  var i = start\n  while (i < end) {\n    var firstByte = buf[i]\n    var codePoint = null\n    var bytesPerSequence = (firstByte > 0xEF) ? 4\n      : (firstByte > 0xDF) ? 3\n      : (firstByte > 0xBF) ? 2\n      : 1\n\n    if (i + bytesPerSequence <= end) {\n      var secondByte, thirdByte, fourthByte, tempCodePoint\n\n      switch (bytesPerSequence) {\n        case 1:\n          if (firstByte < 0x80) {\n            codePoint = firstByte\n          }\n          break\n        case 2:\n          secondByte = buf[i + 1]\n          if ((secondByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)\n            if (tempCodePoint > 0x7F) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 3:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)\n            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 4:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          fourthByte = buf[i + 3]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)\n            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\n              codePoint = tempCodePoint\n            }\n          }\n      }\n    }\n\n    if (codePoint === null) {\n      // we did not generate a valid codePoint so insert a\n      // replacement char (U+FFFD) and advance only 1 byte\n      codePoint = 0xFFFD\n      bytesPerSequence = 1\n    } else if (codePoint > 0xFFFF) {\n      // encode to utf16 (surrogate pair dance)\n      codePoint -= 0x10000\n      res.push(codePoint >>> 10 & 0x3FF | 0xD800)\n      codePoint = 0xDC00 | codePoint & 0x3FF\n    }\n\n    res.push(codePoint)\n    i += bytesPerSequence\n  }\n\n  return decodeCodePointsArray(res)\n}\n\n// Based on http://stackoverflow.com/a/22747272/680742, the browser with\n// the lowest limit is Chrome, with 0x10000 args.\n// We go 1 magnitude less, for safety\nvar MAX_ARGUMENTS_LENGTH = 0x1000\n\nfunction decodeCodePointsArray (codePoints) {\n  var len = codePoints.length\n  if (len <= MAX_ARGUMENTS_LENGTH) {\n    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\n  }\n\n  // Decode in chunks to avoid \"call stack size exceeded\".\n  var res = ''\n  var i = 0\n  while (i < len) {\n    res += String.fromCharCode.apply(\n      String,\n      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\n    )\n  }\n  return res\n}\n\nfunction asciiSlice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i] & 0x7F)\n  }\n  return ret\n}\n\nfunction latin1Slice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i])\n  }\n  return ret\n}\n\nfunction hexSlice (buf, start, end) {\n  var len = buf.length\n\n  if (!start || start < 0) start = 0\n  if (!end || end < 0 || end > len) end = len\n\n  var out = ''\n  for (var i = start; i < end; ++i) {\n    out += toHex(buf[i])\n  }\n  return out\n}\n\nfunction utf16leSlice (buf, start, end) {\n  var bytes = buf.slice(start, end)\n  var res = ''\n  for (var i = 0; i < bytes.length; i += 2) {\n    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)\n  }\n  return res\n}\n\nBuffer.prototype.slice = function slice (start, end) {\n  var len = this.length\n  start = ~~start\n  end = end === undefined ? len : ~~end\n\n  if (start < 0) {\n    start += len\n    if (start < 0) start = 0\n  } else if (start > len) {\n    start = len\n  }\n\n  if (end < 0) {\n    end += len\n    if (end < 0) end = 0\n  } else if (end > len) {\n    end = len\n  }\n\n  if (end < start) end = start\n\n  var newBuf\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    newBuf = this.subarray(start, end)\n    newBuf.__proto__ = Buffer.prototype\n  } else {\n    var sliceLen = end - start\n    newBuf = new Buffer(sliceLen, undefined)\n    for (var i = 0; i < sliceLen; ++i) {\n      newBuf[i] = this[i + start]\n    }\n  }\n\n  return newBuf\n}\n\n/*\n * Need to make sure that buffer isn't trying to write out of bounds.\n */\nfunction checkOffset (offset, ext, length) {\n  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')\n  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')\n}\n\nBuffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    checkOffset(offset, byteLength, this.length)\n  }\n\n  var val = this[offset + --byteLength]\n  var mul = 1\n  while (byteLength > 0 && (mul *= 0x100)) {\n    val += this[offset + --byteLength] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  return this[offset]\n}\n\nBuffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return this[offset] | (this[offset + 1] << 8)\n}\n\nBuffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return (this[offset] << 8) | this[offset + 1]\n}\n\nBuffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return ((this[offset]) |\n      (this[offset + 1] << 8) |\n      (this[offset + 2] << 16)) +\n      (this[offset + 3] * 0x1000000)\n}\n\nBuffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] * 0x1000000) +\n    ((this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    this[offset + 3])\n}\n\nBuffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var i = byteLength\n  var mul = 1\n  var val = this[offset + --i]\n  while (i > 0 && (mul *= 0x100)) {\n    val += this[offset + --i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readInt8 = function readInt8 (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  if (!(this[offset] & 0x80)) return (this[offset])\n  return ((0xff - this[offset] + 1) * -1)\n}\n\nBuffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset] | (this[offset + 1] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset + 1] | (this[offset] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset]) |\n    (this[offset + 1] << 8) |\n    (this[offset + 2] << 16) |\n    (this[offset + 3] << 24)\n}\n\nBuffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] << 24) |\n    (this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    (this[offset + 3])\n}\n\nBuffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, true, 23, 4)\n}\n\nBuffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, false, 23, 4)\n}\n\nBuffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, true, 52, 8)\n}\n\nBuffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, false, 52, 8)\n}\n\nfunction checkInt (buf, value, offset, ext, max, min) {\n  if (!Buffer.isBuffer(buf)) throw new TypeError('\"buffer\" argument must be a Buffer instance')\n  if (value > max || value < min) throw new RangeError('\"value\" argument is out of bounds')\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n}\n\nBuffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var mul = 1\n  var i = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nfunction objectWriteUInt16 (buf, value, offset, littleEndian) {\n  if (value < 0) value = 0xffff + value + 1\n  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {\n    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>\n      (littleEndian ? i : 1 - i) * 8\n  }\n}\n\nBuffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n  } else {\n    objectWriteUInt16(this, value, offset, true)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 8)\n    this[offset + 1] = (value & 0xff)\n  } else {\n    objectWriteUInt16(this, value, offset, false)\n  }\n  return offset + 2\n}\n\nfunction objectWriteUInt32 (buf, value, offset, littleEndian) {\n  if (value < 0) value = 0xffffffff + value + 1\n  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {\n    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff\n  }\n}\n\nBuffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset + 3] = (value >>> 24)\n    this[offset + 2] = (value >>> 16)\n    this[offset + 1] = (value >>> 8)\n    this[offset] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, true)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 24)\n    this[offset + 1] = (value >>> 16)\n    this[offset + 2] = (value >>> 8)\n    this[offset + 3] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, false)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) {\n    var limit = Math.pow(2, 8 * byteLength - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = 0\n  var mul = 1\n  var sub = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) {\n    var limit = Math.pow(2, 8 * byteLength - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  var sub = 0\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n  if (value < 0) value = 0xff + value + 1\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n  } else {\n    objectWriteUInt16(this, value, offset, true)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 8)\n    this[offset + 1] = (value & 0xff)\n  } else {\n    objectWriteUInt16(this, value, offset, false)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n    this[offset + 2] = (value >>> 16)\n    this[offset + 3] = (value >>> 24)\n  } else {\n    objectWriteUInt32(this, value, offset, true)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (value < 0) value = 0xffffffff + value + 1\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 24)\n    this[offset + 1] = (value >>> 16)\n    this[offset + 2] = (value >>> 8)\n    this[offset + 3] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, false)\n  }\n  return offset + 4\n}\n\nfunction checkIEEE754 (buf, value, offset, ext, max, min) {\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n  if (offset < 0) throw new RangeError('Index out of range')\n}\n\nfunction writeFloat (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 23, 4)\n  return offset + 4\n}\n\nBuffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, false, noAssert)\n}\n\nfunction writeDouble (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 52, 8)\n  return offset + 8\n}\n\nBuffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, false, noAssert)\n}\n\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\nBuffer.prototype.copy = function copy (target, targetStart, start, end) {\n  if (!start) start = 0\n  if (!end && end !== 0) end = this.length\n  if (targetStart >= target.length) targetStart = target.length\n  if (!targetStart) targetStart = 0\n  if (end > 0 && end < start) end = start\n\n  // Copy 0 bytes; we're done\n  if (end === start) return 0\n  if (target.length === 0 || this.length === 0) return 0\n\n  // Fatal error conditions\n  if (targetStart < 0) {\n    throw new RangeError('targetStart out of bounds')\n  }\n  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')\n  if (end < 0) throw new RangeError('sourceEnd out of bounds')\n\n  // Are we oob?\n  if (end > this.length) end = this.length\n  if (target.length - targetStart < end - start) {\n    end = target.length - targetStart + start\n  }\n\n  var len = end - start\n  var i\n\n  if (this === target && start < targetStart && targetStart < end) {\n    // descending copy from end\n    for (i = len - 1; i >= 0; --i) {\n      target[i + targetStart] = this[i + start]\n    }\n  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {\n    // ascending copy from start\n    for (i = 0; i < len; ++i) {\n      target[i + targetStart] = this[i + start]\n    }\n  } else {\n    Uint8Array.prototype.set.call(\n      target,\n      this.subarray(start, start + len),\n      targetStart\n    )\n  }\n\n  return len\n}\n\n// Usage:\n//    buffer.fill(number[, offset[, end]])\n//    buffer.fill(buffer[, offset[, end]])\n//    buffer.fill(string[, offset[, end]][, encoding])\nBuffer.prototype.fill = function fill (val, start, end, encoding) {\n  // Handle string cases:\n  if (typeof val === 'string') {\n    if (typeof start === 'string') {\n      encoding = start\n      start = 0\n      end = this.length\n    } else if (typeof end === 'string') {\n      encoding = end\n      end = this.length\n    }\n    if (val.length === 1) {\n      var code = val.charCodeAt(0)\n      if (code < 256) {\n        val = code\n      }\n    }\n    if (encoding !== undefined && typeof encoding !== 'string') {\n      throw new TypeError('encoding must be a string')\n    }\n    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {\n      throw new TypeError('Unknown encoding: ' + encoding)\n    }\n  } else if (typeof val === 'number') {\n    val = val & 255\n  }\n\n  // Invalid ranges are not set to a default, so can range check early.\n  if (start < 0 || this.length < start || this.length < end) {\n    throw new RangeError('Out of range index')\n  }\n\n  if (end <= start) {\n    return this\n  }\n\n  start = start >>> 0\n  end = end === undefined ? this.length : end >>> 0\n\n  if (!val) val = 0\n\n  var i\n  if (typeof val === 'number') {\n    for (i = start; i < end; ++i) {\n      this[i] = val\n    }\n  } else {\n    var bytes = Buffer.isBuffer(val)\n      ? val\n      : utf8ToBytes(new Buffer(val, encoding).toString())\n    var len = bytes.length\n    for (i = 0; i < end - start; ++i) {\n      this[i + start] = bytes[i % len]\n    }\n  }\n\n  return this\n}\n\n// HELPER FUNCTIONS\n// ================\n\nvar INVALID_BASE64_RE = /[^+\\/0-9A-Za-z-_]/g\n\nfunction base64clean (str) {\n  // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n  str = stringtrim(str).replace(INVALID_BASE64_RE, '')\n  // Node converts strings with length < 2 to ''\n  if (str.length < 2) return ''\n  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n  while (str.length % 4 !== 0) {\n    str = str + '='\n  }\n  return str\n}\n\nfunction stringtrim (str) {\n  if (str.trim) return str.trim()\n  return str.replace(/^\\s+|\\s+$/g, '')\n}\n\nfunction toHex (n) {\n  if (n < 16) return '0' + n.toString(16)\n  return n.toString(16)\n}\n\nfunction utf8ToBytes (string, units) {\n  units = units || Infinity\n  var codePoint\n  var length = string.length\n  var leadSurrogate = null\n  var bytes = []\n\n  for (var i = 0; i < length; ++i) {\n    codePoint = string.charCodeAt(i)\n\n    // is surrogate component\n    if (codePoint > 0xD7FF && codePoint < 0xE000) {\n      // last char was a lead\n      if (!leadSurrogate) {\n        // no lead yet\n        if (codePoint > 0xDBFF) {\n          // unexpected trail\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        } else if (i + 1 === length) {\n          // unpaired lead\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        }\n\n        // valid lead\n        leadSurrogate = codePoint\n\n        continue\n      }\n\n      // 2 leads in a row\n      if (codePoint < 0xDC00) {\n        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n        leadSurrogate = codePoint\n        continue\n      }\n\n      // valid surrogate pair\n      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000\n    } else if (leadSurrogate) {\n      // valid bmp char, but last char was a lead\n      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n    }\n\n    leadSurrogate = null\n\n    // encode utf8\n    if (codePoint < 0x80) {\n      if ((units -= 1) < 0) break\n      bytes.push(codePoint)\n    } else if (codePoint < 0x800) {\n      if ((units -= 2) < 0) break\n      bytes.push(\n        codePoint >> 0x6 | 0xC0,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x10000) {\n      if ((units -= 3) < 0) break\n      bytes.push(\n        codePoint >> 0xC | 0xE0,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x110000) {\n      if ((units -= 4) < 0) break\n      bytes.push(\n        codePoint >> 0x12 | 0xF0,\n        codePoint >> 0xC & 0x3F | 0x80,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else {\n      throw new Error('Invalid code point')\n    }\n  }\n\n  return bytes\n}\n\nfunction asciiToBytes (str) {\n  var byteArray = []\n  for (var i = 0; i < str.length; ++i) {\n    // Node's code seems to be doing this and not & 0x7F..\n    byteArray.push(str.charCodeAt(i) & 0xFF)\n  }\n  return byteArray\n}\n\nfunction utf16leToBytes (str, units) {\n  var c, hi, lo\n  var byteArray = []\n  for (var i = 0; i < str.length; ++i) {\n    if ((units -= 2) < 0) break\n\n    c = str.charCodeAt(i)\n    hi = c >> 8\n    lo = c % 256\n    byteArray.push(lo)\n    byteArray.push(hi)\n  }\n\n  return byteArray\n}\n\nfunction base64ToBytes (str) {\n  return base64.toByteArray(base64clean(str))\n}\n\nfunction blitBuffer (src, dst, offset, length) {\n  for (var i = 0; i < length; ++i) {\n    if ((i + offset >= dst.length) || (i >= src.length)) break\n    dst[i + offset] = src[i]\n  }\n  return i\n}\n\nfunction isnan (val) {\n  return val !== val // eslint-disable-line no-self-compare\n}\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n},{\"base64-js\":39,\"ieee754\":65,\"isarray\":68}],44:[function(require,module,exports){\n(function (Buffer){\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// NOTE: These type checking functions intentionally don't use `instanceof`\n// because it is fragile and can be easily faked with `Object.create()`.\n\nfunction isArray(arg) {\n  if (Array.isArray) {\n    return Array.isArray(arg);\n  }\n  return objectToString(arg) === '[object Array]';\n}\nexports.isArray = isArray;\n\nfunction isBoolean(arg) {\n  return typeof arg === 'boolean';\n}\nexports.isBoolean = isBoolean;\n\nfunction isNull(arg) {\n  return arg === null;\n}\nexports.isNull = isNull;\n\nfunction isNullOrUndefined(arg) {\n  return arg == null;\n}\nexports.isNullOrUndefined = isNullOrUndefined;\n\nfunction isNumber(arg) {\n  return typeof arg === 'number';\n}\nexports.isNumber = isNumber;\n\nfunction isString(arg) {\n  return typeof arg === 'string';\n}\nexports.isString = isString;\n\nfunction isSymbol(arg) {\n  return typeof arg === 'symbol';\n}\nexports.isSymbol = isSymbol;\n\nfunction isUndefined(arg) {\n  return arg === void 0;\n}\nexports.isUndefined = isUndefined;\n\nfunction isRegExp(re) {\n  return objectToString(re) === '[object RegExp]';\n}\nexports.isRegExp = isRegExp;\n\nfunction isObject(arg) {\n  return typeof arg === 'object' && arg !== null;\n}\nexports.isObject = isObject;\n\nfunction isDate(d) {\n  return objectToString(d) === '[object Date]';\n}\nexports.isDate = isDate;\n\nfunction isError(e) {\n  return (objectToString(e) === '[object Error]' || e instanceof Error);\n}\nexports.isError = isError;\n\nfunction isFunction(arg) {\n  return typeof arg === 'function';\n}\nexports.isFunction = isFunction;\n\nfunction isPrimitive(arg) {\n  return arg === null ||\n         typeof arg === 'boolean' ||\n         typeof arg === 'number' ||\n         typeof arg === 'string' ||\n         typeof arg === 'symbol' ||  // ES6 symbol\n         typeof arg === 'undefined';\n}\nexports.isPrimitive = isPrimitive;\n\nexports.isBuffer = Buffer.isBuffer;\n\nfunction objectToString(o) {\n  return Object.prototype.toString.call(o);\n}\n\n}).call(this,{\"isBuffer\":require(\"../../is-buffer/index.js\")})\n},{\"../../is-buffer/index.js\":67}],45:[function(require,module,exports){\n/*istanbul ignore start*/\"use strict\";\n\nexports.__esModule = true;\nexports. /*istanbul ignore end*/convertChangesToDMP = convertChangesToDMP;\n// See: http://code.google.com/p/google-diff-match-patch/wiki/API\nfunction convertChangesToDMP(changes) {\n  var ret = [],\n      change = /*istanbul ignore start*/void 0 /*istanbul ignore end*/,\n      operation = /*istanbul ignore start*/void 0 /*istanbul ignore end*/;\n  for (var i = 0; i < changes.length; i++) {\n    change = changes[i];\n    if (change.added) {\n      operation = 1;\n    } else if (change.removed) {\n      operation = -1;\n    } else {\n      operation = 0;\n    }\n\n    ret.push([operation, change.value]);\n  }\n  return ret;\n}\n\n\n},{}],46:[function(require,module,exports){\n/*istanbul ignore start*/'use strict';\n\nexports.__esModule = true;\nexports. /*istanbul ignore end*/convertChangesToXML = convertChangesToXML;\nfunction convertChangesToXML(changes) {\n  var ret = [];\n  for (var i = 0; i < changes.length; i++) {\n    var change = changes[i];\n    if (change.added) {\n      ret.push('<ins>');\n    } else if (change.removed) {\n      ret.push('<del>');\n    }\n\n    ret.push(escapeHTML(change.value));\n\n    if (change.added) {\n      ret.push('</ins>');\n    } else if (change.removed) {\n      ret.push('</del>');\n    }\n  }\n  return ret.join('');\n}\n\nfunction escapeHTML(s) {\n  var n = s;\n  n = n.replace(/&/g, '&amp;');\n  n = n.replace(/</g, '&lt;');\n  n = n.replace(/>/g, '&gt;');\n  n = n.replace(/\"/g, '&quot;');\n\n  return n;\n}\n\n\n},{}],47:[function(require,module,exports){\n/*istanbul ignore start*/'use strict';\n\nexports.__esModule = true;\nexports.arrayDiff = undefined;\nexports. /*istanbul ignore end*/diffArrays = diffArrays;\n\nvar /*istanbul ignore start*/_base = require('./base') /*istanbul ignore end*/;\n\n/*istanbul ignore start*/\nvar _base2 = _interopRequireDefault(_base);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\n/*istanbul ignore end*/var arrayDiff = /*istanbul ignore start*/exports. /*istanbul ignore end*/arrayDiff = new /*istanbul ignore start*/_base2['default']() /*istanbul ignore end*/;\narrayDiff.tokenize = arrayDiff.join = function (value) {\n  return value.slice();\n};\n\nfunction diffArrays(oldArr, newArr, callback) {\n  return arrayDiff.diff(oldArr, newArr, callback);\n}\n\n\n},{\"./base\":48}],48:[function(require,module,exports){\n/*istanbul ignore start*/'use strict';\n\nexports.__esModule = true;\nexports['default'] = /*istanbul ignore end*/Diff;\nfunction Diff() {}\n\nDiff.prototype = { /*istanbul ignore start*/\n  /*istanbul ignore end*/diff: function diff(oldString, newString) {\n    /*istanbul ignore start*/var /*istanbul ignore end*/options = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];\n\n    var callback = options.callback;\n    if (typeof options === 'function') {\n      callback = options;\n      options = {};\n    }\n    this.options = options;\n\n    var self = this;\n\n    function done(value) {\n      if (callback) {\n        setTimeout(function () {\n          callback(undefined, value);\n        }, 0);\n        return true;\n      } else {\n        return value;\n      }\n    }\n\n    // Allow subclasses to massage the input prior to running\n    oldString = this.castInput(oldString);\n    newString = this.castInput(newString);\n\n    oldString = this.removeEmpty(this.tokenize(oldString));\n    newString = this.removeEmpty(this.tokenize(newString));\n\n    var newLen = newString.length,\n        oldLen = oldString.length;\n    var editLength = 1;\n    var maxEditLength = newLen + oldLen;\n    var bestPath = [{ newPos: -1, components: [] }];\n\n    // Seed editLength = 0, i.e. the content starts with the same values\n    var oldPos = this.extractCommon(bestPath[0], newString, oldString, 0);\n    if (bestPath[0].newPos + 1 >= newLen && oldPos + 1 >= oldLen) {\n      // Identity per the equality and tokenizer\n      return done([{ value: this.join(newString), count: newString.length }]);\n    }\n\n    // Main worker method. checks all permutations of a given edit length for acceptance.\n    function execEditLength() {\n      for (var diagonalPath = -1 * editLength; diagonalPath <= editLength; diagonalPath += 2) {\n        var basePath = /*istanbul ignore start*/void 0 /*istanbul ignore end*/;\n        var addPath = bestPath[diagonalPath - 1],\n            removePath = bestPath[diagonalPath + 1],\n            _oldPos = (removePath ? removePath.newPos : 0) - diagonalPath;\n        if (addPath) {\n          // No one else is going to attempt to use this value, clear it\n          bestPath[diagonalPath - 1] = undefined;\n        }\n\n        var canAdd = addPath && addPath.newPos + 1 < newLen,\n            canRemove = removePath && 0 <= _oldPos && _oldPos < oldLen;\n        if (!canAdd && !canRemove) {\n          // If this path is a terminal then prune\n          bestPath[diagonalPath] = undefined;\n          continue;\n        }\n\n        // Select the diagonal that we want to branch from. We select the prior\n        // path whose position in the new string is the farthest from the origin\n        // and does not pass the bounds of the diff graph\n        if (!canAdd || canRemove && addPath.newPos < removePath.newPos) {\n          basePath = clonePath(removePath);\n          self.pushComponent(basePath.components, undefined, true);\n        } else {\n          basePath = addPath; // No need to clone, we've pulled it from the list\n          basePath.newPos++;\n          self.pushComponent(basePath.components, true, undefined);\n        }\n\n        _oldPos = self.extractCommon(basePath, newString, oldString, diagonalPath);\n\n        // If we have hit the end of both strings, then we are done\n        if (basePath.newPos + 1 >= newLen && _oldPos + 1 >= oldLen) {\n          return done(buildValues(self, basePath.components, newString, oldString, self.useLongestToken));\n        } else {\n          // Otherwise track this path as a potential candidate and continue.\n          bestPath[diagonalPath] = basePath;\n        }\n      }\n\n      editLength++;\n    }\n\n    // Performs the length of edit iteration. Is a bit fugly as this has to support the\n    // sync and async mode which is never fun. Loops over execEditLength until a value\n    // is produced.\n    if (callback) {\n      (function exec() {\n        setTimeout(function () {\n          // This should not happen, but we want to be safe.\n          /* istanbul ignore next */\n          if (editLength > maxEditLength) {\n            return callback();\n          }\n\n          if (!execEditLength()) {\n            exec();\n          }\n        }, 0);\n      })();\n    } else {\n      while (editLength <= maxEditLength) {\n        var ret = execEditLength();\n        if (ret) {\n          return ret;\n        }\n      }\n    }\n  },\n  /*istanbul ignore start*/ /*istanbul ignore end*/pushComponent: function pushComponent(components, added, removed) {\n    var last = components[components.length - 1];\n    if (last && last.added === added && last.removed === removed) {\n      // We need to clone here as the component clone operation is just\n      // as shallow array clone\n      components[components.length - 1] = { count: last.count + 1, added: added, removed: removed };\n    } else {\n      components.push({ count: 1, added: added, removed: removed });\n    }\n  },\n  /*istanbul ignore start*/ /*istanbul ignore end*/extractCommon: function extractCommon(basePath, newString, oldString, diagonalPath) {\n    var newLen = newString.length,\n        oldLen = oldString.length,\n        newPos = basePath.newPos,\n        oldPos = newPos - diagonalPath,\n        commonCount = 0;\n    while (newPos + 1 < newLen && oldPos + 1 < oldLen && this.equals(newString[newPos + 1], oldString[oldPos + 1])) {\n      newPos++;\n      oldPos++;\n      commonCount++;\n    }\n\n    if (commonCount) {\n      basePath.components.push({ count: commonCount });\n    }\n\n    basePath.newPos = newPos;\n    return oldPos;\n  },\n  /*istanbul ignore start*/ /*istanbul ignore end*/equals: function equals(left, right) {\n    return left === right;\n  },\n  /*istanbul ignore start*/ /*istanbul ignore end*/removeEmpty: function removeEmpty(array) {\n    var ret = [];\n    for (var i = 0; i < array.length; i++) {\n      if (array[i]) {\n        ret.push(array[i]);\n      }\n    }\n    return ret;\n  },\n  /*istanbul ignore start*/ /*istanbul ignore end*/castInput: function castInput(value) {\n    return value;\n  },\n  /*istanbul ignore start*/ /*istanbul ignore end*/tokenize: function tokenize(value) {\n    return value.split('');\n  },\n  /*istanbul ignore start*/ /*istanbul ignore end*/join: function join(chars) {\n    return chars.join('');\n  }\n};\n\nfunction buildValues(diff, components, newString, oldString, useLongestToken) {\n  var componentPos = 0,\n      componentLen = components.length,\n      newPos = 0,\n      oldPos = 0;\n\n  for (; componentPos < componentLen; componentPos++) {\n    var component = components[componentPos];\n    if (!component.removed) {\n      if (!component.added && useLongestToken) {\n        var value = newString.slice(newPos, newPos + component.count);\n        value = value.map(function (value, i) {\n          var oldValue = oldString[oldPos + i];\n          return oldValue.length > value.length ? oldValue : value;\n        });\n\n        component.value = diff.join(value);\n      } else {\n        component.value = diff.join(newString.slice(newPos, newPos + component.count));\n      }\n      newPos += component.count;\n\n      // Common case\n      if (!component.added) {\n        oldPos += component.count;\n      }\n    } else {\n      component.value = diff.join(oldString.slice(oldPos, oldPos + component.count));\n      oldPos += component.count;\n\n      // Reverse add and remove so removes are output first to match common convention\n      // The diffing algorithm is tied to add then remove output and this is the simplest\n      // route to get the desired output with minimal overhead.\n      if (componentPos && components[componentPos - 1].added) {\n        var tmp = components[componentPos - 1];\n        components[componentPos - 1] = components[componentPos];\n        components[componentPos] = tmp;\n      }\n    }\n  }\n\n  // Special case handle for when one terminal is ignored. For this case we merge the\n  // terminal into the prior string and drop the change.\n  var lastComponent = components[componentLen - 1];\n  if (componentLen > 1 && (lastComponent.added || lastComponent.removed) && diff.equals('', lastComponent.value)) {\n    components[componentLen - 2].value += lastComponent.value;\n    components.pop();\n  }\n\n  return components;\n}\n\nfunction clonePath(path) {\n  return { newPos: path.newPos, components: path.components.slice(0) };\n}\n\n\n},{}],49:[function(require,module,exports){\n/*istanbul ignore start*/'use strict';\n\nexports.__esModule = true;\nexports.characterDiff = undefined;\nexports. /*istanbul ignore end*/diffChars = diffChars;\n\nvar /*istanbul ignore start*/_base = require('./base') /*istanbul ignore end*/;\n\n/*istanbul ignore start*/\nvar _base2 = _interopRequireDefault(_base);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\n/*istanbul ignore end*/var characterDiff = /*istanbul ignore start*/exports. /*istanbul ignore end*/characterDiff = new /*istanbul ignore start*/_base2['default']() /*istanbul ignore end*/;\nfunction diffChars(oldStr, newStr, callback) {\n  return characterDiff.diff(oldStr, newStr, callback);\n}\n\n\n},{\"./base\":48}],50:[function(require,module,exports){\n/*istanbul ignore start*/'use strict';\n\nexports.__esModule = true;\nexports.cssDiff = undefined;\nexports. /*istanbul ignore end*/diffCss = diffCss;\n\nvar /*istanbul ignore start*/_base = require('./base') /*istanbul ignore end*/;\n\n/*istanbul ignore start*/\nvar _base2 = _interopRequireDefault(_base);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\n/*istanbul ignore end*/var cssDiff = /*istanbul ignore start*/exports. /*istanbul ignore end*/cssDiff = new /*istanbul ignore start*/_base2['default']() /*istanbul ignore end*/;\ncssDiff.tokenize = function (value) {\n  return value.split(/([{}:;,]|\\s+)/);\n};\n\nfunction diffCss(oldStr, newStr, callback) {\n  return cssDiff.diff(oldStr, newStr, callback);\n}\n\n\n},{\"./base\":48}],51:[function(require,module,exports){\n/*istanbul ignore start*/'use strict';\n\nexports.__esModule = true;\nexports.jsonDiff = undefined;\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol ? \"symbol\" : typeof obj; };\n\nexports. /*istanbul ignore end*/diffJson = diffJson;\n/*istanbul ignore start*/exports. /*istanbul ignore end*/canonicalize = canonicalize;\n\nvar /*istanbul ignore start*/_base = require('./base') /*istanbul ignore end*/;\n\n/*istanbul ignore start*/\nvar _base2 = _interopRequireDefault(_base);\n\n/*istanbul ignore end*/\nvar /*istanbul ignore start*/_line = require('./line') /*istanbul ignore end*/;\n\n/*istanbul ignore start*/\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\n/*istanbul ignore end*/\n\nvar objectPrototypeToString = Object.prototype.toString;\n\nvar jsonDiff = /*istanbul ignore start*/exports. /*istanbul ignore end*/jsonDiff = new /*istanbul ignore start*/_base2['default']() /*istanbul ignore end*/;\n// Discriminate between two lines of pretty-printed, serialized JSON where one of them has a\n// dangling comma and the other doesn't. Turns out including the dangling comma yields the nicest output:\njsonDiff.useLongestToken = true;\n\njsonDiff.tokenize = /*istanbul ignore start*/_line.lineDiff. /*istanbul ignore end*/tokenize;\njsonDiff.castInput = function (value) {\n  /*istanbul ignore start*/var /*istanbul ignore end*/undefinedReplacement = this.options.undefinedReplacement;\n\n\n  return typeof value === 'string' ? value : JSON.stringify(canonicalize(value), function (k, v) {\n    if (typeof v === 'undefined') {\n      return undefinedReplacement;\n    }\n\n    return v;\n  }, '  ');\n};\njsonDiff.equals = function (left, right) {\n  return (/*istanbul ignore start*/_base2['default']. /*istanbul ignore end*/prototype.equals(left.replace(/,([\\r\\n])/g, '$1'), right.replace(/,([\\r\\n])/g, '$1'))\n  );\n};\n\nfunction diffJson(oldObj, newObj, options) {\n  return jsonDiff.diff(oldObj, newObj, options);\n}\n\n// This function handles the presence of circular references by bailing out when encountering an\n// object that is already on the \"stack\" of items being processed.\nfunction canonicalize(obj, stack, replacementStack) {\n  stack = stack || [];\n  replacementStack = replacementStack || [];\n\n  var i = /*istanbul ignore start*/void 0 /*istanbul ignore end*/;\n\n  for (i = 0; i < stack.length; i += 1) {\n    if (stack[i] === obj) {\n      return replacementStack[i];\n    }\n  }\n\n  var canonicalizedObj = /*istanbul ignore start*/void 0 /*istanbul ignore end*/;\n\n  if ('[object Array]' === objectPrototypeToString.call(obj)) {\n    stack.push(obj);\n    canonicalizedObj = new Array(obj.length);\n    replacementStack.push(canonicalizedObj);\n    for (i = 0; i < obj.length; i += 1) {\n      canonicalizedObj[i] = canonicalize(obj[i], stack, replacementStack);\n    }\n    stack.pop();\n    replacementStack.pop();\n    return canonicalizedObj;\n  }\n\n  if (obj && obj.toJSON) {\n    obj = obj.toJSON();\n  }\n\n  if ( /*istanbul ignore start*/(typeof /*istanbul ignore end*/obj === 'undefined' ? 'undefined' : _typeof(obj)) === 'object' && obj !== null) {\n    stack.push(obj);\n    canonicalizedObj = {};\n    replacementStack.push(canonicalizedObj);\n    var sortedKeys = [],\n        key = /*istanbul ignore start*/void 0 /*istanbul ignore end*/;\n    for (key in obj) {\n      /* istanbul ignore else */\n      if (obj.hasOwnProperty(key)) {\n        sortedKeys.push(key);\n      }\n    }\n    sortedKeys.sort();\n    for (i = 0; i < sortedKeys.length; i += 1) {\n      key = sortedKeys[i];\n      canonicalizedObj[key] = canonicalize(obj[key], stack, replacementStack);\n    }\n    stack.pop();\n    replacementStack.pop();\n  } else {\n    canonicalizedObj = obj;\n  }\n  return canonicalizedObj;\n}\n\n\n},{\"./base\":48,\"./line\":52}],52:[function(require,module,exports){\n/*istanbul ignore start*/'use strict';\n\nexports.__esModule = true;\nexports.lineDiff = undefined;\nexports. /*istanbul ignore end*/diffLines = diffLines;\n/*istanbul ignore start*/exports. /*istanbul ignore end*/diffTrimmedLines = diffTrimmedLines;\n\nvar /*istanbul ignore start*/_base = require('./base') /*istanbul ignore end*/;\n\n/*istanbul ignore start*/\nvar _base2 = _interopRequireDefault(_base);\n\n/*istanbul ignore end*/\nvar /*istanbul ignore start*/_params = require('../util/params') /*istanbul ignore end*/;\n\n/*istanbul ignore start*/\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\n/*istanbul ignore end*/var lineDiff = /*istanbul ignore start*/exports. /*istanbul ignore end*/lineDiff = new /*istanbul ignore start*/_base2['default']() /*istanbul ignore end*/;\nlineDiff.tokenize = function (value) {\n  var retLines = [],\n      linesAndNewlines = value.split(/(\\n|\\r\\n)/);\n\n  // Ignore the final empty token that occurs if the string ends with a new line\n  if (!linesAndNewlines[linesAndNewlines.length - 1]) {\n    linesAndNewlines.pop();\n  }\n\n  // Merge the content and line separators into single tokens\n  for (var i = 0; i < linesAndNewlines.length; i++) {\n    var line = linesAndNewlines[i];\n\n    if (i % 2 && !this.options.newlineIsToken) {\n      retLines[retLines.length - 1] += line;\n    } else {\n      if (this.options.ignoreWhitespace) {\n        line = line.trim();\n      }\n      retLines.push(line);\n    }\n  }\n\n  return retLines;\n};\n\nfunction diffLines(oldStr, newStr, callback) {\n  return lineDiff.diff(oldStr, newStr, callback);\n}\nfunction diffTrimmedLines(oldStr, newStr, callback) {\n  var options = /*istanbul ignore start*/(0, _params.generateOptions) /*istanbul ignore end*/(callback, { ignoreWhitespace: true });\n  return lineDiff.diff(oldStr, newStr, options);\n}\n\n\n},{\"../util/params\":60,\"./base\":48}],53:[function(require,module,exports){\n/*istanbul ignore start*/'use strict';\n\nexports.__esModule = true;\nexports.sentenceDiff = undefined;\nexports. /*istanbul ignore end*/diffSentences = diffSentences;\n\nvar /*istanbul ignore start*/_base = require('./base') /*istanbul ignore end*/;\n\n/*istanbul ignore start*/\nvar _base2 = _interopRequireDefault(_base);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\n/*istanbul ignore end*/var sentenceDiff = /*istanbul ignore start*/exports. /*istanbul ignore end*/sentenceDiff = new /*istanbul ignore start*/_base2['default']() /*istanbul ignore end*/;\nsentenceDiff.tokenize = function (value) {\n  return value.split(/(\\S.+?[.!?])(?=\\s+|$)/);\n};\n\nfunction diffSentences(oldStr, newStr, callback) {\n  return sentenceDiff.diff(oldStr, newStr, callback);\n}\n\n\n},{\"./base\":48}],54:[function(require,module,exports){\n/*istanbul ignore start*/'use strict';\n\nexports.__esModule = true;\nexports.wordDiff = undefined;\nexports. /*istanbul ignore end*/diffWords = diffWords;\n/*istanbul ignore start*/exports. /*istanbul ignore end*/diffWordsWithSpace = diffWordsWithSpace;\n\nvar /*istanbul ignore start*/_base = require('./base') /*istanbul ignore end*/;\n\n/*istanbul ignore start*/\nvar _base2 = _interopRequireDefault(_base);\n\n/*istanbul ignore end*/\nvar /*istanbul ignore start*/_params = require('../util/params') /*istanbul ignore end*/;\n\n/*istanbul ignore start*/\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\n/*istanbul ignore end*/\n\n// Based on https://en.wikipedia.org/wiki/Latin_script_in_Unicode\n//\n// Ranges and exceptions:\n// Latin-1 Supplement, 0080–00FF\n//  - U+00D7  × Multiplication sign\n//  - U+00F7  ÷ Division sign\n// Latin Extended-A, 0100–017F\n// Latin Extended-B, 0180–024F\n// IPA Extensions, 0250–02AF\n// Spacing Modifier Letters, 02B0–02FF\n//  - U+02C7  ˇ &#711;  Caron\n//  - U+02D8  ˘ &#728;  Breve\n//  - U+02D9  ˙ &#729;  Dot Above\n//  - U+02DA  ˚ &#730;  Ring Above\n//  - U+02DB  ˛ &#731;  Ogonek\n//  - U+02DC  ˜ &#732;  Small Tilde\n//  - U+02DD  ˝ &#733;  Double Acute Accent\n// Latin Extended Additional, 1E00–1EFF\nvar extendedWordChars = /^[A-Za-z\\xC0-\\u02C6\\u02C8-\\u02D7\\u02DE-\\u02FF\\u1E00-\\u1EFF]+$/;\n\nvar reWhitespace = /\\S/;\n\nvar wordDiff = /*istanbul ignore start*/exports. /*istanbul ignore end*/wordDiff = new /*istanbul ignore start*/_base2['default']() /*istanbul ignore end*/;\nwordDiff.equals = function (left, right) {\n  return left === right || this.options.ignoreWhitespace && !reWhitespace.test(left) && !reWhitespace.test(right);\n};\nwordDiff.tokenize = function (value) {\n  var tokens = value.split(/(\\s+|\\b)/);\n\n  // Join the boundary splits that we do not consider to be boundaries. This is primarily the extended Latin character set.\n  for (var i = 0; i < tokens.length - 1; i++) {\n    // If we have an empty string in the next field and we have only word chars before and after, merge\n    if (!tokens[i + 1] && tokens[i + 2] && extendedWordChars.test(tokens[i]) && extendedWordChars.test(tokens[i + 2])) {\n      tokens[i] += tokens[i + 2];\n      tokens.splice(i + 1, 2);\n      i--;\n    }\n  }\n\n  return tokens;\n};\n\nfunction diffWords(oldStr, newStr, callback) {\n  var options = /*istanbul ignore start*/(0, _params.generateOptions) /*istanbul ignore end*/(callback, { ignoreWhitespace: true });\n  return wordDiff.diff(oldStr, newStr, options);\n}\nfunction diffWordsWithSpace(oldStr, newStr, callback) {\n  return wordDiff.diff(oldStr, newStr, callback);\n}\n\n\n},{\"../util/params\":60,\"./base\":48}],55:[function(require,module,exports){\n/*istanbul ignore start*/'use strict';\n\nexports.__esModule = true;\nexports.canonicalize = exports.convertChangesToXML = exports.convertChangesToDMP = exports.parsePatch = exports.applyPatches = exports.applyPatch = exports.createPatch = exports.createTwoFilesPatch = exports.structuredPatch = exports.diffArrays = exports.diffJson = exports.diffCss = exports.diffSentences = exports.diffTrimmedLines = exports.diffLines = exports.diffWordsWithSpace = exports.diffWords = exports.diffChars = exports.Diff = undefined;\n/*istanbul ignore end*/\nvar /*istanbul ignore start*/_base = require('./diff/base') /*istanbul ignore end*/;\n\n/*istanbul ignore start*/\nvar _base2 = _interopRequireDefault(_base);\n\n/*istanbul ignore end*/\nvar /*istanbul ignore start*/_character = require('./diff/character') /*istanbul ignore end*/;\n\nvar /*istanbul ignore start*/_word = require('./diff/word') /*istanbul ignore end*/;\n\nvar /*istanbul ignore start*/_line = require('./diff/line') /*istanbul ignore end*/;\n\nvar /*istanbul ignore start*/_sentence = require('./diff/sentence') /*istanbul ignore end*/;\n\nvar /*istanbul ignore start*/_css = require('./diff/css') /*istanbul ignore end*/;\n\nvar /*istanbul ignore start*/_json = require('./diff/json') /*istanbul ignore end*/;\n\nvar /*istanbul ignore start*/_array = require('./diff/array') /*istanbul ignore end*/;\n\nvar /*istanbul ignore start*/_apply = require('./patch/apply') /*istanbul ignore end*/;\n\nvar /*istanbul ignore start*/_parse = require('./patch/parse') /*istanbul ignore end*/;\n\nvar /*istanbul ignore start*/_create = require('./patch/create') /*istanbul ignore end*/;\n\nvar /*istanbul ignore start*/_dmp = require('./convert/dmp') /*istanbul ignore end*/;\n\nvar /*istanbul ignore start*/_xml = require('./convert/xml') /*istanbul ignore end*/;\n\n/*istanbul ignore start*/\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\nexports. /*istanbul ignore end*/Diff = _base2['default'];\n/*istanbul ignore start*/exports. /*istanbul ignore end*/diffChars = _character.diffChars;\n/*istanbul ignore start*/exports. /*istanbul ignore end*/diffWords = _word.diffWords;\n/*istanbul ignore start*/exports. /*istanbul ignore end*/diffWordsWithSpace = _word.diffWordsWithSpace;\n/*istanbul ignore start*/exports. /*istanbul ignore end*/diffLines = _line.diffLines;\n/*istanbul ignore start*/exports. /*istanbul ignore end*/diffTrimmedLines = _line.diffTrimmedLines;\n/*istanbul ignore start*/exports. /*istanbul ignore end*/diffSentences = _sentence.diffSentences;\n/*istanbul ignore start*/exports. /*istanbul ignore end*/diffCss = _css.diffCss;\n/*istanbul ignore start*/exports. /*istanbul ignore end*/diffJson = _json.diffJson;\n/*istanbul ignore start*/exports. /*istanbul ignore end*/diffArrays = _array.diffArrays;\n/*istanbul ignore start*/exports. /*istanbul ignore end*/structuredPatch = _create.structuredPatch;\n/*istanbul ignore start*/exports. /*istanbul ignore end*/createTwoFilesPatch = _create.createTwoFilesPatch;\n/*istanbul ignore start*/exports. /*istanbul ignore end*/createPatch = _create.createPatch;\n/*istanbul ignore start*/exports. /*istanbul ignore end*/applyPatch = _apply.applyPatch;\n/*istanbul ignore start*/exports. /*istanbul ignore end*/applyPatches = _apply.applyPatches;\n/*istanbul ignore start*/exports. /*istanbul ignore end*/parsePatch = _parse.parsePatch;\n/*istanbul ignore start*/exports. /*istanbul ignore end*/convertChangesToDMP = _dmp.convertChangesToDMP;\n/*istanbul ignore start*/exports. /*istanbul ignore end*/convertChangesToXML = _xml.convertChangesToXML;\n/*istanbul ignore start*/exports. /*istanbul ignore end*/canonicalize = _json.canonicalize; /* See LICENSE file for terms of use */\n\n/*\n * Text diff implementation.\n *\n * This library supports the following APIS:\n * JsDiff.diffChars: Character by character diff\n * JsDiff.diffWords: Word (as defined by \\b regex) diff which ignores whitespace\n * JsDiff.diffLines: Line based diff\n *\n * JsDiff.diffCss: Diff targeted at CSS content\n *\n * These methods are based on the implementation proposed in\n * \"An O(ND) Difference Algorithm and its Variations\" (Myers, 1986).\n * http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.4.6927\n */\n\n\n},{\"./convert/dmp\":45,\"./convert/xml\":46,\"./diff/array\":47,\"./diff/base\":48,\"./diff/character\":49,\"./diff/css\":50,\"./diff/json\":51,\"./diff/line\":52,\"./diff/sentence\":53,\"./diff/word\":54,\"./patch/apply\":56,\"./patch/create\":57,\"./patch/parse\":58}],56:[function(require,module,exports){\n/*istanbul ignore start*/'use strict';\n\nexports.__esModule = true;\nexports. /*istanbul ignore end*/applyPatch = applyPatch;\n/*istanbul ignore start*/exports. /*istanbul ignore end*/applyPatches = applyPatches;\n\nvar /*istanbul ignore start*/_parse = require('./parse') /*istanbul ignore end*/;\n\nvar /*istanbul ignore start*/_distanceIterator = require('../util/distance-iterator') /*istanbul ignore end*/;\n\n/*istanbul ignore start*/\nvar _distanceIterator2 = _interopRequireDefault(_distanceIterator);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\n/*istanbul ignore end*/function applyPatch(source, uniDiff) {\n  /*istanbul ignore start*/var /*istanbul ignore end*/options = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];\n\n  if (typeof uniDiff === 'string') {\n    uniDiff = /*istanbul ignore start*/(0, _parse.parsePatch) /*istanbul ignore end*/(uniDiff);\n  }\n\n  if (Array.isArray(uniDiff)) {\n    if (uniDiff.length > 1) {\n      throw new Error('applyPatch only works with a single input.');\n    }\n\n    uniDiff = uniDiff[0];\n  }\n\n  // Apply the diff to the input\n  var lines = source.split(/\\r\\n|[\\n\\v\\f\\r\\x85]/),\n      delimiters = source.match(/\\r\\n|[\\n\\v\\f\\r\\x85]/g) || [],\n      hunks = uniDiff.hunks,\n      compareLine = options.compareLine || function (lineNumber, line, operation, patchContent) /*istanbul ignore start*/{\n    return (/*istanbul ignore end*/line === patchContent\n    );\n  },\n      errorCount = 0,\n      fuzzFactor = options.fuzzFactor || 0,\n      minLine = 0,\n      offset = 0,\n      removeEOFNL = /*istanbul ignore start*/void 0 /*istanbul ignore end*/,\n      addEOFNL = /*istanbul ignore start*/void 0 /*istanbul ignore end*/;\n\n  /**\n   * Checks if the hunk exactly fits on the provided location\n   */\n  function hunkFits(hunk, toPos) {\n    for (var j = 0; j < hunk.lines.length; j++) {\n      var line = hunk.lines[j],\n          operation = line[0],\n          content = line.substr(1);\n\n      if (operation === ' ' || operation === '-') {\n        // Context sanity check\n        if (!compareLine(toPos + 1, lines[toPos], operation, content)) {\n          errorCount++;\n\n          if (errorCount > fuzzFactor) {\n            return false;\n          }\n        }\n        toPos++;\n      }\n    }\n\n    return true;\n  }\n\n  // Search best fit offsets for each hunk based on the previous ones\n  for (var i = 0; i < hunks.length; i++) {\n    var hunk = hunks[i],\n        maxLine = lines.length - hunk.oldLines,\n        localOffset = 0,\n        toPos = offset + hunk.oldStart - 1;\n\n    var iterator = /*istanbul ignore start*/(0, _distanceIterator2['default']) /*istanbul ignore end*/(toPos, minLine, maxLine);\n\n    for (; localOffset !== undefined; localOffset = iterator()) {\n      if (hunkFits(hunk, toPos + localOffset)) {\n        hunk.offset = offset += localOffset;\n        break;\n      }\n    }\n\n    if (localOffset === undefined) {\n      return false;\n    }\n\n    // Set lower text limit to end of the current hunk, so next ones don't try\n    // to fit over already patched text\n    minLine = hunk.offset + hunk.oldStart + hunk.oldLines;\n  }\n\n  // Apply patch hunks\n  for (var _i = 0; _i < hunks.length; _i++) {\n    var _hunk = hunks[_i],\n        _toPos = _hunk.offset + _hunk.newStart - 1;\n    if (_hunk.newLines == 0) {\n      _toPos++;\n    }\n\n    for (var j = 0; j < _hunk.lines.length; j++) {\n      var line = _hunk.lines[j],\n          operation = line[0],\n          content = line.substr(1),\n          delimiter = _hunk.linedelimiters[j];\n\n      if (operation === ' ') {\n        _toPos++;\n      } else if (operation === '-') {\n        lines.splice(_toPos, 1);\n        delimiters.splice(_toPos, 1);\n        /* istanbul ignore else */\n      } else if (operation === '+') {\n          lines.splice(_toPos, 0, content);\n          delimiters.splice(_toPos, 0, delimiter);\n          _toPos++;\n        } else if (operation === '\\\\') {\n          var previousOperation = _hunk.lines[j - 1] ? _hunk.lines[j - 1][0] : null;\n          if (previousOperation === '+') {\n            removeEOFNL = true;\n          } else if (previousOperation === '-') {\n            addEOFNL = true;\n          }\n        }\n    }\n  }\n\n  // Handle EOFNL insertion/removal\n  if (removeEOFNL) {\n    while (!lines[lines.length - 1]) {\n      lines.pop();\n      delimiters.pop();\n    }\n  } else if (addEOFNL) {\n    lines.push('');\n    delimiters.push('\\n');\n  }\n  for (var _k = 0; _k < lines.length - 1; _k++) {\n    lines[_k] = lines[_k] + delimiters[_k];\n  }\n  return lines.join('');\n}\n\n// Wrapper that supports multiple file patches via callbacks.\nfunction applyPatches(uniDiff, options) {\n  if (typeof uniDiff === 'string') {\n    uniDiff = /*istanbul ignore start*/(0, _parse.parsePatch) /*istanbul ignore end*/(uniDiff);\n  }\n\n  var currentIndex = 0;\n  function processIndex() {\n    var index = uniDiff[currentIndex++];\n    if (!index) {\n      return options.complete();\n    }\n\n    options.loadFile(index, function (err, data) {\n      if (err) {\n        return options.complete(err);\n      }\n\n      var updatedContent = applyPatch(data, index, options);\n      options.patched(index, updatedContent, function (err) {\n        if (err) {\n          return options.complete(err);\n        }\n\n        processIndex();\n      });\n    });\n  }\n  processIndex();\n}\n\n\n},{\"../util/distance-iterator\":59,\"./parse\":58}],57:[function(require,module,exports){\n/*istanbul ignore start*/'use strict';\n\nexports.__esModule = true;\nexports. /*istanbul ignore end*/structuredPatch = structuredPatch;\n/*istanbul ignore start*/exports. /*istanbul ignore end*/createTwoFilesPatch = createTwoFilesPatch;\n/*istanbul ignore start*/exports. /*istanbul ignore end*/createPatch = createPatch;\n\nvar /*istanbul ignore start*/_line = require('../diff/line') /*istanbul ignore end*/;\n\n/*istanbul ignore start*/\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\n/*istanbul ignore end*/function structuredPatch(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader, options) {\n  if (!options) {\n    options = {};\n  }\n  if (typeof options.context === 'undefined') {\n    options.context = 4;\n  }\n\n  var diff = /*istanbul ignore start*/(0, _line.diffLines) /*istanbul ignore end*/(oldStr, newStr, options);\n  diff.push({ value: '', lines: [] }); // Append an empty value to make cleanup easier\n\n  function contextLines(lines) {\n    return lines.map(function (entry) {\n      return ' ' + entry;\n    });\n  }\n\n  var hunks = [];\n  var oldRangeStart = 0,\n      newRangeStart = 0,\n      curRange = [],\n      oldLine = 1,\n      newLine = 1;\n  /*istanbul ignore start*/\n  var _loop = function _loop( /*istanbul ignore end*/i) {\n    var current = diff[i],\n        lines = current.lines || current.value.replace(/\\n$/, '').split('\\n');\n    current.lines = lines;\n\n    if (current.added || current.removed) {\n      /*istanbul ignore start*/\n      var _curRange;\n\n      /*istanbul ignore end*/\n      // If we have previous context, start with that\n      if (!oldRangeStart) {\n        var prev = diff[i - 1];\n        oldRangeStart = oldLine;\n        newRangeStart = newLine;\n\n        if (prev) {\n          curRange = options.context > 0 ? contextLines(prev.lines.slice(-options.context)) : [];\n          oldRangeStart -= curRange.length;\n          newRangeStart -= curRange.length;\n        }\n      }\n\n      // Output our changes\n      /*istanbul ignore start*/(_curRange = /*istanbul ignore end*/curRange).push. /*istanbul ignore start*/apply /*istanbul ignore end*/( /*istanbul ignore start*/_curRange /*istanbul ignore end*/, /*istanbul ignore start*/_toConsumableArray( /*istanbul ignore end*/lines.map(function (entry) {\n        return (current.added ? '+' : '-') + entry;\n      })));\n\n      // Track the updated file position\n      if (current.added) {\n        newLine += lines.length;\n      } else {\n        oldLine += lines.length;\n      }\n    } else {\n      // Identical context lines. Track line changes\n      if (oldRangeStart) {\n        // Close out any changes that have been output (or join overlapping)\n        if (lines.length <= options.context * 2 && i < diff.length - 2) {\n          /*istanbul ignore start*/\n          var _curRange2;\n\n          /*istanbul ignore end*/\n          // Overlapping\n          /*istanbul ignore start*/(_curRange2 = /*istanbul ignore end*/curRange).push. /*istanbul ignore start*/apply /*istanbul ignore end*/( /*istanbul ignore start*/_curRange2 /*istanbul ignore end*/, /*istanbul ignore start*/_toConsumableArray( /*istanbul ignore end*/contextLines(lines)));\n        } else {\n          /*istanbul ignore start*/\n          var _curRange3;\n\n          /*istanbul ignore end*/\n          // end the range and output\n          var contextSize = Math.min(lines.length, options.context);\n          /*istanbul ignore start*/(_curRange3 = /*istanbul ignore end*/curRange).push. /*istanbul ignore start*/apply /*istanbul ignore end*/( /*istanbul ignore start*/_curRange3 /*istanbul ignore end*/, /*istanbul ignore start*/_toConsumableArray( /*istanbul ignore end*/contextLines(lines.slice(0, contextSize))));\n\n          var hunk = {\n            oldStart: oldRangeStart,\n            oldLines: oldLine - oldRangeStart + contextSize,\n            newStart: newRangeStart,\n            newLines: newLine - newRangeStart + contextSize,\n            lines: curRange\n          };\n          if (i >= diff.length - 2 && lines.length <= options.context) {\n            // EOF is inside this hunk\n            var oldEOFNewline = /\\n$/.test(oldStr);\n            var newEOFNewline = /\\n$/.test(newStr);\n            if (lines.length == 0 && !oldEOFNewline) {\n              // special case: old has no eol and no trailing context; no-nl can end up before adds\n              curRange.splice(hunk.oldLines, 0, '\\\\ No newline at end of file');\n            } else if (!oldEOFNewline || !newEOFNewline) {\n              curRange.push('\\\\ No newline at end of file');\n            }\n          }\n          hunks.push(hunk);\n\n          oldRangeStart = 0;\n          newRangeStart = 0;\n          curRange = [];\n        }\n      }\n      oldLine += lines.length;\n      newLine += lines.length;\n    }\n  };\n\n  for (var i = 0; i < diff.length; i++) {\n    /*istanbul ignore start*/\n    _loop( /*istanbul ignore end*/i);\n  }\n\n  return {\n    oldFileName: oldFileName, newFileName: newFileName,\n    oldHeader: oldHeader, newHeader: newHeader,\n    hunks: hunks\n  };\n}\n\nfunction createTwoFilesPatch(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader, options) {\n  var diff = structuredPatch(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader, options);\n\n  var ret = [];\n  if (oldFileName == newFileName) {\n    ret.push('Index: ' + oldFileName);\n  }\n  ret.push('===================================================================');\n  ret.push('--- ' + diff.oldFileName + (typeof diff.oldHeader === 'undefined' ? '' : '\\t' + diff.oldHeader));\n  ret.push('+++ ' + diff.newFileName + (typeof diff.newHeader === 'undefined' ? '' : '\\t' + diff.newHeader));\n\n  for (var i = 0; i < diff.hunks.length; i++) {\n    var hunk = diff.hunks[i];\n    ret.push('@@ -' + hunk.oldStart + ',' + hunk.oldLines + ' +' + hunk.newStart + ',' + hunk.newLines + ' @@');\n    ret.push.apply(ret, hunk.lines);\n  }\n\n  return ret.join('\\n') + '\\n';\n}\n\nfunction createPatch(fileName, oldStr, newStr, oldHeader, newHeader, options) {\n  return createTwoFilesPatch(fileName, fileName, oldStr, newStr, oldHeader, newHeader, options);\n}\n\n\n},{\"../diff/line\":52}],58:[function(require,module,exports){\n/*istanbul ignore start*/'use strict';\n\nexports.__esModule = true;\nexports. /*istanbul ignore end*/parsePatch = parsePatch;\nfunction parsePatch(uniDiff) {\n  /*istanbul ignore start*/var /*istanbul ignore end*/options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];\n\n  var diffstr = uniDiff.split(/\\r\\n|[\\n\\v\\f\\r\\x85]/),\n      delimiters = uniDiff.match(/\\r\\n|[\\n\\v\\f\\r\\x85]/g) || [],\n      list = [],\n      i = 0;\n\n  function parseIndex() {\n    var index = {};\n    list.push(index);\n\n    // Parse diff metadata\n    while (i < diffstr.length) {\n      var line = diffstr[i];\n\n      // File header found, end parsing diff metadata\n      if (/^(\\-\\-\\-|\\+\\+\\+|@@)\\s/.test(line)) {\n        break;\n      }\n\n      // Diff index\n      var header = /^(?:Index:|diff(?: -r \\w+)+)\\s+(.+?)\\s*$/.exec(line);\n      if (header) {\n        index.index = header[1];\n      }\n\n      i++;\n    }\n\n    // Parse file headers if they are defined. Unified diff requires them, but\n    // there's no technical issues to have an isolated hunk without file header\n    parseFileHeader(index);\n    parseFileHeader(index);\n\n    // Parse hunks\n    index.hunks = [];\n\n    while (i < diffstr.length) {\n      var _line = diffstr[i];\n\n      if (/^(Index:|diff|\\-\\-\\-|\\+\\+\\+)\\s/.test(_line)) {\n        break;\n      } else if (/^@@/.test(_line)) {\n        index.hunks.push(parseHunk());\n      } else if (_line && options.strict) {\n        // Ignore unexpected content unless in strict mode\n        throw new Error('Unknown line ' + (i + 1) + ' ' + JSON.stringify(_line));\n      } else {\n        i++;\n      }\n    }\n  }\n\n  // Parses the --- and +++ headers, if none are found, no lines\n  // are consumed.\n  function parseFileHeader(index) {\n    var headerPattern = /^(---|\\+\\+\\+)\\s+([\\S ]*)(?:\\t(.*?)\\s*)?$/;\n    var fileHeader = headerPattern.exec(diffstr[i]);\n    if (fileHeader) {\n      var keyPrefix = fileHeader[1] === '---' ? 'old' : 'new';\n      index[keyPrefix + 'FileName'] = fileHeader[2];\n      index[keyPrefix + 'Header'] = fileHeader[3];\n\n      i++;\n    }\n  }\n\n  // Parses a hunk\n  // This assumes that we are at the start of a hunk.\n  function parseHunk() {\n    var chunkHeaderIndex = i,\n        chunkHeaderLine = diffstr[i++],\n        chunkHeader = chunkHeaderLine.split(/@@ -(\\d+)(?:,(\\d+))? \\+(\\d+)(?:,(\\d+))? @@/);\n\n    var hunk = {\n      oldStart: +chunkHeader[1],\n      oldLines: +chunkHeader[2] || 1,\n      newStart: +chunkHeader[3],\n      newLines: +chunkHeader[4] || 1,\n      lines: [],\n      linedelimiters: []\n    };\n\n    var addCount = 0,\n        removeCount = 0;\n    for (; i < diffstr.length; i++) {\n      // Lines starting with '---' could be mistaken for the \"remove line\" operation\n      // But they could be the header for the next file. Therefore prune such cases out.\n      if (diffstr[i].indexOf('--- ') === 0 && i + 2 < diffstr.length && diffstr[i + 1].indexOf('+++ ') === 0 && diffstr[i + 2].indexOf('@@') === 0) {\n        break;\n      }\n      var operation = diffstr[i][0];\n\n      if (operation === '+' || operation === '-' || operation === ' ' || operation === '\\\\') {\n        hunk.lines.push(diffstr[i]);\n        hunk.linedelimiters.push(delimiters[i] || '\\n');\n\n        if (operation === '+') {\n          addCount++;\n        } else if (operation === '-') {\n          removeCount++;\n        } else if (operation === ' ') {\n          addCount++;\n          removeCount++;\n        }\n      } else {\n        break;\n      }\n    }\n\n    // Handle the empty block count case\n    if (!addCount && hunk.newLines === 1) {\n      hunk.newLines = 0;\n    }\n    if (!removeCount && hunk.oldLines === 1) {\n      hunk.oldLines = 0;\n    }\n\n    // Perform optional sanity checking\n    if (options.strict) {\n      if (addCount !== hunk.newLines) {\n        throw new Error('Added line count did not match for hunk at line ' + (chunkHeaderIndex + 1));\n      }\n      if (removeCount !== hunk.oldLines) {\n        throw new Error('Removed line count did not match for hunk at line ' + (chunkHeaderIndex + 1));\n      }\n    }\n\n    return hunk;\n  }\n\n  while (i < diffstr.length) {\n    parseIndex();\n  }\n\n  return list;\n}\n\n\n},{}],59:[function(require,module,exports){\n/*istanbul ignore start*/\"use strict\";\n\nexports.__esModule = true;\n\nexports[\"default\"] = /*istanbul ignore end*/function (start, minLine, maxLine) {\n  var wantForward = true,\n      backwardExhausted = false,\n      forwardExhausted = false,\n      localOffset = 1;\n\n  return function iterator() {\n    if (wantForward && !forwardExhausted) {\n      if (backwardExhausted) {\n        localOffset++;\n      } else {\n        wantForward = false;\n      }\n\n      // Check if trying to fit beyond text length, and if not, check it fits\n      // after offset location (or desired location on first iteration)\n      if (start + localOffset <= maxLine) {\n        return localOffset;\n      }\n\n      forwardExhausted = true;\n    }\n\n    if (!backwardExhausted) {\n      if (!forwardExhausted) {\n        wantForward = true;\n      }\n\n      // Check if trying to fit before text beginning, and if not, check it fits\n      // before offset location\n      if (minLine <= start - localOffset) {\n        return -localOffset++;\n      }\n\n      backwardExhausted = true;\n      return iterator();\n    }\n\n    // We tried to fit hunk before text beginning and beyond text lenght, then\n    // hunk can't fit on the text. Return undefined\n  };\n};\n\n\n},{}],60:[function(require,module,exports){\n/*istanbul ignore start*/'use strict';\n\nexports.__esModule = true;\nexports. /*istanbul ignore end*/generateOptions = generateOptions;\nfunction generateOptions(options, defaults) {\n  if (typeof options === 'function') {\n    defaults.callback = options;\n  } else if (options) {\n    for (var name in options) {\n      /* istanbul ignore else */\n      if (options.hasOwnProperty(name)) {\n        defaults[name] = options[name];\n      }\n    }\n  }\n  return defaults;\n}\n\n\n},{}],61:[function(require,module,exports){\n'use strict';\n\nvar matchOperatorsRe = /[|\\\\{}()[\\]^$+*?.]/g;\n\nmodule.exports = function (str) {\n\tif (typeof str !== 'string') {\n\t\tthrow new TypeError('Expected a string');\n\t}\n\n\treturn str.replace(matchOperatorsRe, '\\\\$&');\n};\n\n},{}],62:[function(require,module,exports){\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nfunction EventEmitter() {\n  this._events = this._events || {};\n  this._maxListeners = this._maxListeners || undefined;\n}\nmodule.exports = EventEmitter;\n\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nEventEmitter.defaultMaxListeners = 10;\n\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function(n) {\n  if (!isNumber(n) || n < 0 || isNaN(n))\n    throw TypeError('n must be a positive number');\n  this._maxListeners = n;\n  return this;\n};\n\nEventEmitter.prototype.emit = function(type) {\n  var er, handler, len, args, i, listeners;\n\n  if (!this._events)\n    this._events = {};\n\n  // If there is no 'error' event listener then throw.\n  if (type === 'error') {\n    if (!this._events.error ||\n        (isObject(this._events.error) && !this._events.error.length)) {\n      er = arguments[1];\n      if (er instanceof Error) {\n        throw er; // Unhandled 'error' event\n      } else {\n        // At least give some kind of context to the user\n        var err = new Error('Uncaught, unspecified \"error\" event. (' + er + ')');\n        err.context = er;\n        throw err;\n      }\n    }\n  }\n\n  handler = this._events[type];\n\n  if (isUndefined(handler))\n    return false;\n\n  if (isFunction(handler)) {\n    switch (arguments.length) {\n      // fast cases\n      case 1:\n        handler.call(this);\n        break;\n      case 2:\n        handler.call(this, arguments[1]);\n        break;\n      case 3:\n        handler.call(this, arguments[1], arguments[2]);\n        break;\n      // slower\n      default:\n        args = Array.prototype.slice.call(arguments, 1);\n        handler.apply(this, args);\n    }\n  } else if (isObject(handler)) {\n    args = Array.prototype.slice.call(arguments, 1);\n    listeners = handler.slice();\n    len = listeners.length;\n    for (i = 0; i < len; i++)\n      listeners[i].apply(this, args);\n  }\n\n  return true;\n};\n\nEventEmitter.prototype.addListener = function(type, listener) {\n  var m;\n\n  if (!isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  if (!this._events)\n    this._events = {};\n\n  // To avoid recursion in the case that type === \"newListener\"! Before\n  // adding it to the listeners, first emit \"newListener\".\n  if (this._events.newListener)\n    this.emit('newListener', type,\n              isFunction(listener.listener) ?\n              listener.listener : listener);\n\n  if (!this._events[type])\n    // Optimize the case of one listener. Don't need the extra array object.\n    this._events[type] = listener;\n  else if (isObject(this._events[type]))\n    // If we've already got an array, just append.\n    this._events[type].push(listener);\n  else\n    // Adding the second element, need to change to array.\n    this._events[type] = [this._events[type], listener];\n\n  // Check for listener leak\n  if (isObject(this._events[type]) && !this._events[type].warned) {\n    if (!isUndefined(this._maxListeners)) {\n      m = this._maxListeners;\n    } else {\n      m = EventEmitter.defaultMaxListeners;\n    }\n\n    if (m && m > 0 && this._events[type].length > m) {\n      this._events[type].warned = true;\n      console.error('(node) warning: possible EventEmitter memory ' +\n                    'leak detected. %d listeners added. ' +\n                    'Use emitter.setMaxListeners() to increase limit.',\n                    this._events[type].length);\n      if (typeof console.trace === 'function') {\n        // not supported in IE 10\n        console.trace();\n      }\n    }\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.once = function(type, listener) {\n  if (!isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  var fired = false;\n\n  function g() {\n    this.removeListener(type, g);\n\n    if (!fired) {\n      fired = true;\n      listener.apply(this, arguments);\n    }\n  }\n\n  g.listener = listener;\n  this.on(type, g);\n\n  return this;\n};\n\n// emits a 'removeListener' event iff the listener was removed\nEventEmitter.prototype.removeListener = function(type, listener) {\n  var list, position, length, i;\n\n  if (!isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  if (!this._events || !this._events[type])\n    return this;\n\n  list = this._events[type];\n  length = list.length;\n  position = -1;\n\n  if (list === listener ||\n      (isFunction(list.listener) && list.listener === listener)) {\n    delete this._events[type];\n    if (this._events.removeListener)\n      this.emit('removeListener', type, listener);\n\n  } else if (isObject(list)) {\n    for (i = length; i-- > 0;) {\n      if (list[i] === listener ||\n          (list[i].listener && list[i].listener === listener)) {\n        position = i;\n        break;\n      }\n    }\n\n    if (position < 0)\n      return this;\n\n    if (list.length === 1) {\n      list.length = 0;\n      delete this._events[type];\n    } else {\n      list.splice(position, 1);\n    }\n\n    if (this._events.removeListener)\n      this.emit('removeListener', type, listener);\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.removeAllListeners = function(type) {\n  var key, listeners;\n\n  if (!this._events)\n    return this;\n\n  // not listening for removeListener, no need to emit\n  if (!this._events.removeListener) {\n    if (arguments.length === 0)\n      this._events = {};\n    else if (this._events[type])\n      delete this._events[type];\n    return this;\n  }\n\n  // emit removeListener for all listeners on all events\n  if (arguments.length === 0) {\n    for (key in this._events) {\n      if (key === 'removeListener') continue;\n      this.removeAllListeners(key);\n    }\n    this.removeAllListeners('removeListener');\n    this._events = {};\n    return this;\n  }\n\n  listeners = this._events[type];\n\n  if (isFunction(listeners)) {\n    this.removeListener(type, listeners);\n  } else if (listeners) {\n    // LIFO order\n    while (listeners.length)\n      this.removeListener(type, listeners[listeners.length - 1]);\n  }\n  delete this._events[type];\n\n  return this;\n};\n\nEventEmitter.prototype.listeners = function(type) {\n  var ret;\n  if (!this._events || !this._events[type])\n    ret = [];\n  else if (isFunction(this._events[type]))\n    ret = [this._events[type]];\n  else\n    ret = this._events[type].slice();\n  return ret;\n};\n\nEventEmitter.prototype.listenerCount = function(type) {\n  if (this._events) {\n    var evlistener = this._events[type];\n\n    if (isFunction(evlistener))\n      return 1;\n    else if (evlistener)\n      return evlistener.length;\n  }\n  return 0;\n};\n\nEventEmitter.listenerCount = function(emitter, type) {\n  return emitter.listenerCount(type);\n};\n\nfunction isFunction(arg) {\n  return typeof arg === 'function';\n}\n\nfunction isNumber(arg) {\n  return typeof arg === 'number';\n}\n\nfunction isObject(arg) {\n  return typeof arg === 'object' && arg !== null;\n}\n\nfunction isUndefined(arg) {\n  return arg === void 0;\n}\n\n},{}],63:[function(require,module,exports){\n(function (process){\n// Growl - Copyright TJ Holowaychuk <tj@vision-media.ca> (MIT Licensed)\n\n/**\n * Module dependencies.\n */\n\nvar exec = require('child_process').exec\n  , fs = require('fs')\n  , path = require('path')\n  , exists = fs.existsSync || path.existsSync\n  , os = require('os')\n  , quote = JSON.stringify\n  , cmd;\n\nfunction which(name) {\n  var paths = process.env.PATH.split(':');\n  var loc;\n\n  for (var i = 0, len = paths.length; i < len; ++i) {\n    loc = path.join(paths[i], name);\n    if (exists(loc)) return loc;\n  }\n}\n\nswitch(os.type()) {\n  case 'Darwin':\n    if (which('terminal-notifier')) {\n      cmd = {\n          type: \"Darwin-NotificationCenter\"\n        , pkg: \"terminal-notifier\"\n        , msg: '-message'\n        , title: '-title'\n        , subtitle: '-subtitle'\n        , icon: '-appIcon'\n        , sound:  '-sound'\n        , url: '-open'\n        , priority: {\n              cmd: '-execute'\n            , range: []\n          }\n      };\n    } else {\n      cmd = {\n          type: \"Darwin-Growl\"\n        , pkg: \"growlnotify\"\n        , msg: '-m'\n        , sticky: '--sticky'\n        , priority: {\n              cmd: '--priority'\n            , range: [\n                -2\n              , -1\n              , 0\n              , 1\n              , 2\n              , \"Very Low\"\n              , \"Moderate\"\n              , \"Normal\"\n              , \"High\"\n              , \"Emergency\"\n            ]\n          }\n      };\n    }\n    break;\n  case 'Linux':\n    if (which('growl')) {\n      cmd = {\n          type: \"Linux-Growl\"\n        , pkg: \"growl\"\n        , msg: '-m'\n        , title: '-title'\n        , subtitle: '-subtitle'\n        , host: {\n            cmd: '-H'\n          , hostname: '192.168.33.1'\n        }\n      };\n    } else {\n      cmd = {\n          type: \"Linux\"\n        , pkg: \"notify-send\"\n        , msg: ''\n        , sticky: '-t 0'\n        , icon: '-i'\n        , priority: {\n            cmd: '-u'\n          , range: [\n              \"low\"\n            , \"normal\"\n            , \"critical\"\n          ]\n        }\n      };\n    }\n    break;\n  case 'Windows_NT':\n    cmd = {\n        type: \"Windows\"\n      , pkg: \"growlnotify\"\n      , msg: ''\n      , sticky: '/s:true'\n      , title: '/t:'\n      , icon: '/i:'\n      , url: '/cu:'\n      , priority: {\n            cmd: '/p:'\n          , range: [\n              -2\n            , -1\n            , 0\n            , 1\n            , 2\n          ]\n        }\n    };\n    break;\n}\n\n/**\n * Expose `growl`.\n */\n\nexports = module.exports = growl;\n\n/**\n * Node-growl version.\n */\n\nexports.version = '1.4.1'\n\n/**\n * Send growl notification _msg_ with _options_.\n *\n * Options:\n *\n *  - title   Notification title\n *  - sticky  Make the notification stick (defaults to false)\n *  - priority  Specify an int or named key (default is 0)\n *  - name    Application name (defaults to growlnotify)\n *  - sound   Sound efect ( in OSx defined in preferences -> sound -> effects) * works only in OSX > 10.8x\n *  - image\n *    - path to an icon sets --iconpath\n *    - path to an image sets --image\n *    - capitalized word sets --appIcon\n *    - filename uses extname as --icon\n *    - otherwise treated as --icon\n *\n * Examples:\n *\n *   growl('New email')\n *   growl('5 new emails', { title: 'Thunderbird' })\n *   growl('5 new emails', { title: 'Thunderbird', sound: 'Purr' })\n *   growl('Email sent', function(){\n *     // ... notification sent\n *   })\n *\n * @param {string} msg\n * @param {object} options\n * @param {function} fn\n * @api public\n */\n\nfunction growl(msg, options, fn) {\n  var image\n    , args\n    , options = options || {}\n    , fn = fn || function(){};\n\n  if (options.exec) {\n    cmd = {\n        type: \"Custom\"\n      , pkg: options.exec\n      , range: []\n    };\n  }\n\n  // noop\n  if (!cmd) return fn(new Error('growl not supported on this platform'));\n  args = [cmd.pkg];\n\n  // image\n  if (image = options.image) {\n    switch(cmd.type) {\n      case 'Darwin-Growl':\n        var flag, ext = path.extname(image).substr(1)\n        flag = flag || ext == 'icns' && 'iconpath'\n        flag = flag || /^[A-Z]/.test(image) && 'appIcon'\n        flag = flag || /^png|gif|jpe?g$/.test(ext) && 'image'\n        flag = flag || ext && (image = ext) && 'icon'\n        flag = flag || 'icon'\n        args.push('--' + flag, quote(image))\n        break;\n      case 'Darwin-NotificationCenter':\n        args.push(cmd.icon, quote(image));\n        break;\n      case 'Linux':\n        args.push(cmd.icon, quote(image));\n        // libnotify defaults to sticky, set a hint for transient notifications\n        if (!options.sticky) args.push('--hint=int:transient:1');\n        break;\n      case 'Windows':\n        args.push(cmd.icon + quote(image));\n        break;\n    }\n  }\n\n  // sticky\n  if (options.sticky) args.push(cmd.sticky);\n\n  // priority\n  if (options.priority) {\n    var priority = options.priority + '';\n    var checkindexOf = cmd.priority.range.indexOf(priority);\n    if (~cmd.priority.range.indexOf(priority)) {\n      args.push(cmd.priority, options.priority);\n    }\n  }\n\n  //sound\n  if(options.sound && cmd.type === 'Darwin-NotificationCenter'){\n    args.push(cmd.sound, options.sound)\n  }\n\n  // name\n  if (options.name && cmd.type === \"Darwin-Growl\") {\n    args.push('--name', options.name);\n  }\n\n  switch(cmd.type) {\n    case 'Darwin-Growl':\n      args.push(cmd.msg);\n      args.push(quote(msg).replace(/\\\\n/g, '\\n'));\n      if (options.title) args.push(quote(options.title));\n      break;\n    case 'Darwin-NotificationCenter':\n      args.push(cmd.msg);\n      var stringifiedMsg = quote(msg);\n      var escapedMsg = stringifiedMsg.replace(/\\\\n/g, '\\n');\n      args.push(escapedMsg);\n      if (options.title) {\n        args.push(cmd.title);\n        args.push(quote(options.title));\n      }\n      if (options.subtitle) {\n        args.push(cmd.subtitle);\n        args.push(quote(options.subtitle));\n      }\n      if (options.url) {\n        args.push(cmd.url);\n        args.push(quote(options.url));\n      }\n      break;\n    case 'Linux-Growl':\n      args.push(cmd.msg);\n      args.push(quote(msg).replace(/\\\\n/g, '\\n'));\n      if (options.title) args.push(quote(options.title));\n      if (cmd.host) {\n        args.push(cmd.host.cmd, cmd.host.hostname)\n      }\n      break;\n    case 'Linux':\n      if (options.title) {\n        args.push(quote(options.title));\n        args.push(cmd.msg);\n        args.push(quote(msg).replace(/\\\\n/g, '\\n'));\n      } else {\n        args.push(quote(msg).replace(/\\\\n/g, '\\n'));\n      }\n      break;\n    case 'Windows':\n      args.push(quote(msg).replace(/\\\\n/g, '\\n'));\n      if (options.title) args.push(cmd.title + quote(options.title));\n      if (options.url) args.push(cmd.url + quote(options.url));\n      break;\n    case 'Custom':\n      args[0] = (function(origCommand) {\n        var message = options.title\n          ? options.title + ': ' + msg\n          : msg;\n        var command = origCommand.replace(/(^|[^%])%s/g, '$1' + quote(message));\n        if (command === origCommand) args.push(quote(message));\n        return command;\n      })(args[0]);\n      break;\n  }\n\n  // execute\n  exec(args.join(' '), fn);\n};\n\n}).call(this,require('_process'))\n},{\"_process\":82,\"child_process\":42,\"fs\":42,\"os\":80,\"path\":42}],64:[function(require,module,exports){\n(function (global){\n/*! https://mths.be/he v1.1.1 by @mathias | MIT license */\n;(function(root) {\n\n\t// Detect free variables `exports`.\n\tvar freeExports = typeof exports == 'object' && exports;\n\n\t// Detect free variable `module`.\n\tvar freeModule = typeof module == 'object' && module &&\n\t\tmodule.exports == freeExports && module;\n\n\t// Detect free variable `global`, from Node.js or Browserified code,\n\t// and use it as `root`.\n\tvar freeGlobal = typeof global == 'object' && global;\n\tif (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal) {\n\t\troot = freeGlobal;\n\t}\n\n\t/*--------------------------------------------------------------------------*/\n\n\t// All astral symbols.\n\tvar regexAstralSymbols = /[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/g;\n\t// All ASCII symbols (not just printable ASCII) except those listed in the\n\t// first column of the overrides table.\n\t// https://html.spec.whatwg.org/multipage/syntax.html#table-charref-overrides\n\tvar regexAsciiWhitelist = /[\\x01-\\x7F]/g;\n\t// All BMP symbols that are not ASCII newlines, printable ASCII symbols, or\n\t// code points listed in the first column of the overrides table on\n\t// https://html.spec.whatwg.org/multipage/syntax.html#table-charref-overrides.\n\tvar regexBmpWhitelist = /[\\x01-\\t\\x0B\\f\\x0E-\\x1F\\x7F\\x81\\x8D\\x8F\\x90\\x9D\\xA0-\\uFFFF]/g;\n\n\tvar regexEncodeNonAscii = /<\\u20D2|=\\u20E5|>\\u20D2|\\u205F\\u200A|\\u219D\\u0338|\\u2202\\u0338|\\u2220\\u20D2|\\u2229\\uFE00|\\u222A\\uFE00|\\u223C\\u20D2|\\u223D\\u0331|\\u223E\\u0333|\\u2242\\u0338|\\u224B\\u0338|\\u224D\\u20D2|\\u224E\\u0338|\\u224F\\u0338|\\u2250\\u0338|\\u2261\\u20E5|\\u2264\\u20D2|\\u2265\\u20D2|\\u2266\\u0338|\\u2267\\u0338|\\u2268\\uFE00|\\u2269\\uFE00|\\u226A\\u0338|\\u226A\\u20D2|\\u226B\\u0338|\\u226B\\u20D2|\\u227F\\u0338|\\u2282\\u20D2|\\u2283\\u20D2|\\u228A\\uFE00|\\u228B\\uFE00|\\u228F\\u0338|\\u2290\\u0338|\\u2293\\uFE00|\\u2294\\uFE00|\\u22B4\\u20D2|\\u22B5\\u20D2|\\u22D8\\u0338|\\u22D9\\u0338|\\u22DA\\uFE00|\\u22DB\\uFE00|\\u22F5\\u0338|\\u22F9\\u0338|\\u2933\\u0338|\\u29CF\\u0338|\\u29D0\\u0338|\\u2A6D\\u0338|\\u2A70\\u0338|\\u2A7D\\u0338|\\u2A7E\\u0338|\\u2AA1\\u0338|\\u2AA2\\u0338|\\u2AAC\\uFE00|\\u2AAD\\uFE00|\\u2AAF\\u0338|\\u2AB0\\u0338|\\u2AC5\\u0338|\\u2AC6\\u0338|\\u2ACB\\uFE00|\\u2ACC\\uFE00|\\u2AFD\\u20E5|[\\xA0-\\u0113\\u0116-\\u0122\\u0124-\\u012B\\u012E-\\u014D\\u0150-\\u017E\\u0192\\u01B5\\u01F5\\u0237\\u02C6\\u02C7\\u02D8-\\u02DD\\u0311\\u0391-\\u03A1\\u03A3-\\u03A9\\u03B1-\\u03C9\\u03D1\\u03D2\\u03D5\\u03D6\\u03DC\\u03DD\\u03F0\\u03F1\\u03F5\\u03F6\\u0401-\\u040C\\u040E-\\u044F\\u0451-\\u045C\\u045E\\u045F\\u2002-\\u2005\\u2007-\\u2010\\u2013-\\u2016\\u2018-\\u201A\\u201C-\\u201E\\u2020-\\u2022\\u2025\\u2026\\u2030-\\u2035\\u2039\\u203A\\u203E\\u2041\\u2043\\u2044\\u204F\\u2057\\u205F-\\u2063\\u20AC\\u20DB\\u20DC\\u2102\\u2105\\u210A-\\u2113\\u2115-\\u211E\\u2122\\u2124\\u2127-\\u2129\\u212C\\u212D\\u212F-\\u2131\\u2133-\\u2138\\u2145-\\u2148\\u2153-\\u215E\\u2190-\\u219B\\u219D-\\u21A7\\u21A9-\\u21AE\\u21B0-\\u21B3\\u21B5-\\u21B7\\u21BA-\\u21DB\\u21DD\\u21E4\\u21E5\\u21F5\\u21FD-\\u2205\\u2207-\\u2209\\u220B\\u220C\\u220F-\\u2214\\u2216-\\u2218\\u221A\\u221D-\\u2238\\u223A-\\u2257\\u2259\\u225A\\u225C\\u225F-\\u2262\\u2264-\\u228B\\u228D-\\u229B\\u229D-\\u22A5\\u22A7-\\u22B0\\u22B2-\\u22BB\\u22BD-\\u22DB\\u22DE-\\u22E3\\u22E6-\\u22F7\\u22F9-\\u22FE\\u2305\\u2306\\u2308-\\u2310\\u2312\\u2313\\u2315\\u2316\\u231C-\\u231F\\u2322\\u2323\\u232D\\u232E\\u2336\\u233D\\u233F\\u237C\\u23B0\\u23B1\\u23B4-\\u23B6\\u23DC-\\u23DF\\u23E2\\u23E7\\u2423\\u24C8\\u2500\\u2502\\u250C\\u2510\\u2514\\u2518\\u251C\\u2524\\u252C\\u2534\\u253C\\u2550-\\u256C\\u2580\\u2584\\u2588\\u2591-\\u2593\\u25A1\\u25AA\\u25AB\\u25AD\\u25AE\\u25B1\\u25B3-\\u25B5\\u25B8\\u25B9\\u25BD-\\u25BF\\u25C2\\u25C3\\u25CA\\u25CB\\u25EC\\u25EF\\u25F8-\\u25FC\\u2605\\u2606\\u260E\\u2640\\u2642\\u2660\\u2663\\u2665\\u2666\\u266A\\u266D-\\u266F\\u2713\\u2717\\u2720\\u2736\\u2758\\u2772\\u2773\\u27C8\\u27C9\\u27E6-\\u27ED\\u27F5-\\u27FA\\u27FC\\u27FF\\u2902-\\u2905\\u290C-\\u2913\\u2916\\u2919-\\u2920\\u2923-\\u292A\\u2933\\u2935-\\u2939\\u293C\\u293D\\u2945\\u2948-\\u294B\\u294E-\\u2976\\u2978\\u2979\\u297B-\\u297F\\u2985\\u2986\\u298B-\\u2996\\u299A\\u299C\\u299D\\u29A4-\\u29B7\\u29B9\\u29BB\\u29BC\\u29BE-\\u29C5\\u29C9\\u29CD-\\u29D0\\u29DC-\\u29DE\\u29E3-\\u29E5\\u29EB\\u29F4\\u29F6\\u2A00-\\u2A02\\u2A04\\u2A06\\u2A0C\\u2A0D\\u2A10-\\u2A17\\u2A22-\\u2A27\\u2A29\\u2A2A\\u2A2D-\\u2A31\\u2A33-\\u2A3C\\u2A3F\\u2A40\\u2A42-\\u2A4D\\u2A50\\u2A53-\\u2A58\\u2A5A-\\u2A5D\\u2A5F\\u2A66\\u2A6A\\u2A6D-\\u2A75\\u2A77-\\u2A9A\\u2A9D-\\u2AA2\\u2AA4-\\u2AB0\\u2AB3-\\u2AC8\\u2ACB\\u2ACC\\u2ACF-\\u2ADB\\u2AE4\\u2AE6-\\u2AE9\\u2AEB-\\u2AF3\\u2AFD\\uFB00-\\uFB04]|\\uD835[\\uDC9C\\uDC9E\\uDC9F\\uDCA2\\uDCA5\\uDCA6\\uDCA9-\\uDCAC\\uDCAE-\\uDCB9\\uDCBB\\uDCBD-\\uDCC3\\uDCC5-\\uDCCF\\uDD04\\uDD05\\uDD07-\\uDD0A\\uDD0D-\\uDD14\\uDD16-\\uDD1C\\uDD1E-\\uDD39\\uDD3B-\\uDD3E\\uDD40-\\uDD44\\uDD46\\uDD4A-\\uDD50\\uDD52-\\uDD6B]/g;\n\tvar encodeMap = {'\\xAD':'shy','\\u200C':'zwnj','\\u200D':'zwj','\\u200E':'lrm','\\u2063':'ic','\\u2062':'it','\\u2061':'af','\\u200F':'rlm','\\u200B':'ZeroWidthSpace','\\u2060':'NoBreak','\\u0311':'DownBreve','\\u20DB':'tdot','\\u20DC':'DotDot','\\t':'Tab','\\n':'NewLine','\\u2008':'puncsp','\\u205F':'MediumSpace','\\u2009':'thinsp','\\u200A':'hairsp','\\u2004':'emsp13','\\u2002':'ensp','\\u2005':'emsp14','\\u2003':'emsp','\\u2007':'numsp','\\xA0':'nbsp','\\u205F\\u200A':'ThickSpace','\\u203E':'oline','_':'lowbar','\\u2010':'dash','\\u2013':'ndash','\\u2014':'mdash','\\u2015':'horbar',',':'comma',';':'semi','\\u204F':'bsemi',':':'colon','\\u2A74':'Colone','!':'excl','\\xA1':'iexcl','?':'quest','\\xBF':'iquest','.':'period','\\u2025':'nldr','\\u2026':'mldr','\\xB7':'middot','\\'':'apos','\\u2018':'lsquo','\\u2019':'rsquo','\\u201A':'sbquo','\\u2039':'lsaquo','\\u203A':'rsaquo','\"':'quot','\\u201C':'ldquo','\\u201D':'rdquo','\\u201E':'bdquo','\\xAB':'laquo','\\xBB':'raquo','(':'lpar',')':'rpar','[':'lsqb',']':'rsqb','{':'lcub','}':'rcub','\\u2308':'lceil','\\u2309':'rceil','\\u230A':'lfloor','\\u230B':'rfloor','\\u2985':'lopar','\\u2986':'ropar','\\u298B':'lbrke','\\u298C':'rbrke','\\u298D':'lbrkslu','\\u298E':'rbrksld','\\u298F':'lbrksld','\\u2990':'rbrkslu','\\u2991':'langd','\\u2992':'rangd','\\u2993':'lparlt','\\u2994':'rpargt','\\u2995':'gtlPar','\\u2996':'ltrPar','\\u27E6':'lobrk','\\u27E7':'robrk','\\u27E8':'lang','\\u27E9':'rang','\\u27EA':'Lang','\\u27EB':'Rang','\\u27EC':'loang','\\u27ED':'roang','\\u2772':'lbbrk','\\u2773':'rbbrk','\\u2016':'Vert','\\xA7':'sect','\\xB6':'para','@':'commat','*':'ast','/':'sol','undefined':null,'&':'amp','#':'num','%':'percnt','\\u2030':'permil','\\u2031':'pertenk','\\u2020':'dagger','\\u2021':'Dagger','\\u2022':'bull','\\u2043':'hybull','\\u2032':'prime','\\u2033':'Prime','\\u2034':'tprime','\\u2057':'qprime','\\u2035':'bprime','\\u2041':'caret','`':'grave','\\xB4':'acute','\\u02DC':'tilde','^':'Hat','\\xAF':'macr','\\u02D8':'breve','\\u02D9':'dot','\\xA8':'die','\\u02DA':'ring','\\u02DD':'dblac','\\xB8':'cedil','\\u02DB':'ogon','\\u02C6':'circ','\\u02C7':'caron','\\xB0':'deg','\\xA9':'copy','\\xAE':'reg','\\u2117':'copysr','\\u2118':'wp','\\u211E':'rx','\\u2127':'mho','\\u2129':'iiota','\\u2190':'larr','\\u219A':'nlarr','\\u2192':'rarr','\\u219B':'nrarr','\\u2191':'uarr','\\u2193':'darr','\\u2194':'harr','\\u21AE':'nharr','\\u2195':'varr','\\u2196':'nwarr','\\u2197':'nearr','\\u2198':'searr','\\u2199':'swarr','\\u219D':'rarrw','\\u219D\\u0338':'nrarrw','\\u219E':'Larr','\\u219F':'Uarr','\\u21A0':'Rarr','\\u21A1':'Darr','\\u21A2':'larrtl','\\u21A3':'rarrtl','\\u21A4':'mapstoleft','\\u21A5':'mapstoup','\\u21A6':'map','\\u21A7':'mapstodown','\\u21A9':'larrhk','\\u21AA':'rarrhk','\\u21AB':'larrlp','\\u21AC':'rarrlp','\\u21AD':'harrw','\\u21B0':'lsh','\\u21B1':'rsh','\\u21B2':'ldsh','\\u21B3':'rdsh','\\u21B5':'crarr','\\u21B6':'cularr','\\u21B7':'curarr','\\u21BA':'olarr','\\u21BB':'orarr','\\u21BC':'lharu','\\u21BD':'lhard','\\u21BE':'uharr','\\u21BF':'uharl','\\u21C0':'rharu','\\u21C1':'rhard','\\u21C2':'dharr','\\u21C3':'dharl','\\u21C4':'rlarr','\\u21C5':'udarr','\\u21C6':'lrarr','\\u21C7':'llarr','\\u21C8':'uuarr','\\u21C9':'rrarr','\\u21CA':'ddarr','\\u21CB':'lrhar','\\u21CC':'rlhar','\\u21D0':'lArr','\\u21CD':'nlArr','\\u21D1':'uArr','\\u21D2':'rArr','\\u21CF':'nrArr','\\u21D3':'dArr','\\u21D4':'iff','\\u21CE':'nhArr','\\u21D5':'vArr','\\u21D6':'nwArr','\\u21D7':'neArr','\\u21D8':'seArr','\\u21D9':'swArr','\\u21DA':'lAarr','\\u21DB':'rAarr','\\u21DD':'zigrarr','\\u21E4':'larrb','\\u21E5':'rarrb','\\u21F5':'duarr','\\u21FD':'loarr','\\u21FE':'roarr','\\u21FF':'hoarr','\\u2200':'forall','\\u2201':'comp','\\u2202':'part','\\u2202\\u0338':'npart','\\u2203':'exist','\\u2204':'nexist','\\u2205':'empty','\\u2207':'Del','\\u2208':'in','\\u2209':'notin','\\u220B':'ni','\\u220C':'notni','\\u03F6':'bepsi','\\u220F':'prod','\\u2210':'coprod','\\u2211':'sum','+':'plus','\\xB1':'pm','\\xF7':'div','\\xD7':'times','<':'lt','\\u226E':'nlt','<\\u20D2':'nvlt','=':'equals','\\u2260':'ne','=\\u20E5':'bne','\\u2A75':'Equal','>':'gt','\\u226F':'ngt','>\\u20D2':'nvgt','\\xAC':'not','|':'vert','\\xA6':'brvbar','\\u2212':'minus','\\u2213':'mp','\\u2214':'plusdo','\\u2044':'frasl','\\u2216':'setmn','\\u2217':'lowast','\\u2218':'compfn','\\u221A':'Sqrt','\\u221D':'prop','\\u221E':'infin','\\u221F':'angrt','\\u2220':'ang','\\u2220\\u20D2':'nang','\\u2221':'angmsd','\\u2222':'angsph','\\u2223':'mid','\\u2224':'nmid','\\u2225':'par','\\u2226':'npar','\\u2227':'and','\\u2228':'or','\\u2229':'cap','\\u2229\\uFE00':'caps','\\u222A':'cup','\\u222A\\uFE00':'cups','\\u222B':'int','\\u222C':'Int','\\u222D':'tint','\\u2A0C':'qint','\\u222E':'oint','\\u222F':'Conint','\\u2230':'Cconint','\\u2231':'cwint','\\u2232':'cwconint','\\u2233':'awconint','\\u2234':'there4','\\u2235':'becaus','\\u2236':'ratio','\\u2237':'Colon','\\u2238':'minusd','\\u223A':'mDDot','\\u223B':'homtht','\\u223C':'sim','\\u2241':'nsim','\\u223C\\u20D2':'nvsim','\\u223D':'bsim','\\u223D\\u0331':'race','\\u223E':'ac','\\u223E\\u0333':'acE','\\u223F':'acd','\\u2240':'wr','\\u2242':'esim','\\u2242\\u0338':'nesim','\\u2243':'sime','\\u2244':'nsime','\\u2245':'cong','\\u2247':'ncong','\\u2246':'simne','\\u2248':'ap','\\u2249':'nap','\\u224A':'ape','\\u224B':'apid','\\u224B\\u0338':'napid','\\u224C':'bcong','\\u224D':'CupCap','\\u226D':'NotCupCap','\\u224D\\u20D2':'nvap','\\u224E':'bump','\\u224E\\u0338':'nbump','\\u224F':'bumpe','\\u224F\\u0338':'nbumpe','\\u2250':'doteq','\\u2250\\u0338':'nedot','\\u2251':'eDot','\\u2252':'efDot','\\u2253':'erDot','\\u2254':'colone','\\u2255':'ecolon','\\u2256':'ecir','\\u2257':'cire','\\u2259':'wedgeq','\\u225A':'veeeq','\\u225C':'trie','\\u225F':'equest','\\u2261':'equiv','\\u2262':'nequiv','\\u2261\\u20E5':'bnequiv','\\u2264':'le','\\u2270':'nle','\\u2264\\u20D2':'nvle','\\u2265':'ge','\\u2271':'nge','\\u2265\\u20D2':'nvge','\\u2266':'lE','\\u2266\\u0338':'nlE','\\u2267':'gE','\\u2267\\u0338':'ngE','\\u2268\\uFE00':'lvnE','\\u2268':'lnE','\\u2269':'gnE','\\u2269\\uFE00':'gvnE','\\u226A':'ll','\\u226A\\u0338':'nLtv','\\u226A\\u20D2':'nLt','\\u226B':'gg','\\u226B\\u0338':'nGtv','\\u226B\\u20D2':'nGt','\\u226C':'twixt','\\u2272':'lsim','\\u2274':'nlsim','\\u2273':'gsim','\\u2275':'ngsim','\\u2276':'lg','\\u2278':'ntlg','\\u2277':'gl','\\u2279':'ntgl','\\u227A':'pr','\\u2280':'npr','\\u227B':'sc','\\u2281':'nsc','\\u227C':'prcue','\\u22E0':'nprcue','\\u227D':'sccue','\\u22E1':'nsccue','\\u227E':'prsim','\\u227F':'scsim','\\u227F\\u0338':'NotSucceedsTilde','\\u2282':'sub','\\u2284':'nsub','\\u2282\\u20D2':'vnsub','\\u2283':'sup','\\u2285':'nsup','\\u2283\\u20D2':'vnsup','\\u2286':'sube','\\u2288':'nsube','\\u2287':'supe','\\u2289':'nsupe','\\u228A\\uFE00':'vsubne','\\u228A':'subne','\\u228B\\uFE00':'vsupne','\\u228B':'supne','\\u228D':'cupdot','\\u228E':'uplus','\\u228F':'sqsub','\\u228F\\u0338':'NotSquareSubset','\\u2290':'sqsup','\\u2290\\u0338':'NotSquareSuperset','\\u2291':'sqsube','\\u22E2':'nsqsube','\\u2292':'sqsupe','\\u22E3':'nsqsupe','\\u2293':'sqcap','\\u2293\\uFE00':'sqcaps','\\u2294':'sqcup','\\u2294\\uFE00':'sqcups','\\u2295':'oplus','\\u2296':'ominus','\\u2297':'otimes','\\u2298':'osol','\\u2299':'odot','\\u229A':'ocir','\\u229B':'oast','\\u229D':'odash','\\u229E':'plusb','\\u229F':'minusb','\\u22A0':'timesb','\\u22A1':'sdotb','\\u22A2':'vdash','\\u22AC':'nvdash','\\u22A3':'dashv','\\u22A4':'top','\\u22A5':'bot','\\u22A7':'models','\\u22A8':'vDash','\\u22AD':'nvDash','\\u22A9':'Vdash','\\u22AE':'nVdash','\\u22AA':'Vvdash','\\u22AB':'VDash','\\u22AF':'nVDash','\\u22B0':'prurel','\\u22B2':'vltri','\\u22EA':'nltri','\\u22B3':'vrtri','\\u22EB':'nrtri','\\u22B4':'ltrie','\\u22EC':'nltrie','\\u22B4\\u20D2':'nvltrie','\\u22B5':'rtrie','\\u22ED':'nrtrie','\\u22B5\\u20D2':'nvrtrie','\\u22B6':'origof','\\u22B7':'imof','\\u22B8':'mumap','\\u22B9':'hercon','\\u22BA':'intcal','\\u22BB':'veebar','\\u22BD':'barvee','\\u22BE':'angrtvb','\\u22BF':'lrtri','\\u22C0':'Wedge','\\u22C1':'Vee','\\u22C2':'xcap','\\u22C3':'xcup','\\u22C4':'diam','\\u22C5':'sdot','\\u22C6':'Star','\\u22C7':'divonx','\\u22C8':'bowtie','\\u22C9':'ltimes','\\u22CA':'rtimes','\\u22CB':'lthree','\\u22CC':'rthree','\\u22CD':'bsime','\\u22CE':'cuvee','\\u22CF':'cuwed','\\u22D0':'Sub','\\u22D1':'Sup','\\u22D2':'Cap','\\u22D3':'Cup','\\u22D4':'fork','\\u22D5':'epar','\\u22D6':'ltdot','\\u22D7':'gtdot','\\u22D8':'Ll','\\u22D8\\u0338':'nLl','\\u22D9':'Gg','\\u22D9\\u0338':'nGg','\\u22DA\\uFE00':'lesg','\\u22DA':'leg','\\u22DB':'gel','\\u22DB\\uFE00':'gesl','\\u22DE':'cuepr','\\u22DF':'cuesc','\\u22E6':'lnsim','\\u22E7':'gnsim','\\u22E8':'prnsim','\\u22E9':'scnsim','\\u22EE':'vellip','\\u22EF':'ctdot','\\u22F0':'utdot','\\u22F1':'dtdot','\\u22F2':'disin','\\u22F3':'isinsv','\\u22F4':'isins','\\u22F5':'isindot','\\u22F5\\u0338':'notindot','\\u22F6':'notinvc','\\u22F7':'notinvb','\\u22F9':'isinE','\\u22F9\\u0338':'notinE','\\u22FA':'nisd','\\u22FB':'xnis','\\u22FC':'nis','\\u22FD':'notnivc','\\u22FE':'notnivb','\\u2305':'barwed','\\u2306':'Barwed','\\u230C':'drcrop','\\u230D':'dlcrop','\\u230E':'urcrop','\\u230F':'ulcrop','\\u2310':'bnot','\\u2312':'profline','\\u2313':'profsurf','\\u2315':'telrec','\\u2316':'target','\\u231C':'ulcorn','\\u231D':'urcorn','\\u231E':'dlcorn','\\u231F':'drcorn','\\u2322':'frown','\\u2323':'smile','\\u232D':'cylcty','\\u232E':'profalar','\\u2336':'topbot','\\u233D':'ovbar','\\u233F':'solbar','\\u237C':'angzarr','\\u23B0':'lmoust','\\u23B1':'rmoust','\\u23B4':'tbrk','\\u23B5':'bbrk','\\u23B6':'bbrktbrk','\\u23DC':'OverParenthesis','\\u23DD':'UnderParenthesis','\\u23DE':'OverBrace','\\u23DF':'UnderBrace','\\u23E2':'trpezium','\\u23E7':'elinters','\\u2423':'blank','\\u2500':'boxh','\\u2502':'boxv','\\u250C':'boxdr','\\u2510':'boxdl','\\u2514':'boxur','\\u2518':'boxul','\\u251C':'boxvr','\\u2524':'boxvl','\\u252C':'boxhd','\\u2534':'boxhu','\\u253C':'boxvh','\\u2550':'boxH','\\u2551':'boxV','\\u2552':'boxdR','\\u2553':'boxDr','\\u2554':'boxDR','\\u2555':'boxdL','\\u2556':'boxDl','\\u2557':'boxDL','\\u2558':'boxuR','\\u2559':'boxUr','\\u255A':'boxUR','\\u255B':'boxuL','\\u255C':'boxUl','\\u255D':'boxUL','\\u255E':'boxvR','\\u255F':'boxVr','\\u2560':'boxVR','\\u2561':'boxvL','\\u2562':'boxVl','\\u2563':'boxVL','\\u2564':'boxHd','\\u2565':'boxhD','\\u2566':'boxHD','\\u2567':'boxHu','\\u2568':'boxhU','\\u2569':'boxHU','\\u256A':'boxvH','\\u256B':'boxVh','\\u256C':'boxVH','\\u2580':'uhblk','\\u2584':'lhblk','\\u2588':'block','\\u2591':'blk14','\\u2592':'blk12','\\u2593':'blk34','\\u25A1':'squ','\\u25AA':'squf','\\u25AB':'EmptyVerySmallSquare','\\u25AD':'rect','\\u25AE':'marker','\\u25B1':'fltns','\\u25B3':'xutri','\\u25B4':'utrif','\\u25B5':'utri','\\u25B8':'rtrif','\\u25B9':'rtri','\\u25BD':'xdtri','\\u25BE':'dtrif','\\u25BF':'dtri','\\u25C2':'ltrif','\\u25C3':'ltri','\\u25CA':'loz','\\u25CB':'cir','\\u25EC':'tridot','\\u25EF':'xcirc','\\u25F8':'ultri','\\u25F9':'urtri','\\u25FA':'lltri','\\u25FB':'EmptySmallSquare','\\u25FC':'FilledSmallSquare','\\u2605':'starf','\\u2606':'star','\\u260E':'phone','\\u2640':'female','\\u2642':'male','\\u2660':'spades','\\u2663':'clubs','\\u2665':'hearts','\\u2666':'diams','\\u266A':'sung','\\u2713':'check','\\u2717':'cross','\\u2720':'malt','\\u2736':'sext','\\u2758':'VerticalSeparator','\\u27C8':'bsolhsub','\\u27C9':'suphsol','\\u27F5':'xlarr','\\u27F6':'xrarr','\\u27F7':'xharr','\\u27F8':'xlArr','\\u27F9':'xrArr','\\u27FA':'xhArr','\\u27FC':'xmap','\\u27FF':'dzigrarr','\\u2902':'nvlArr','\\u2903':'nvrArr','\\u2904':'nvHarr','\\u2905':'Map','\\u290C':'lbarr','\\u290D':'rbarr','\\u290E':'lBarr','\\u290F':'rBarr','\\u2910':'RBarr','\\u2911':'DDotrahd','\\u2912':'UpArrowBar','\\u2913':'DownArrowBar','\\u2916':'Rarrtl','\\u2919':'latail','\\u291A':'ratail','\\u291B':'lAtail','\\u291C':'rAtail','\\u291D':'larrfs','\\u291E':'rarrfs','\\u291F':'larrbfs','\\u2920':'rarrbfs','\\u2923':'nwarhk','\\u2924':'nearhk','\\u2925':'searhk','\\u2926':'swarhk','\\u2927':'nwnear','\\u2928':'toea','\\u2929':'tosa','\\u292A':'swnwar','\\u2933':'rarrc','\\u2933\\u0338':'nrarrc','\\u2935':'cudarrr','\\u2936':'ldca','\\u2937':'rdca','\\u2938':'cudarrl','\\u2939':'larrpl','\\u293C':'curarrm','\\u293D':'cularrp','\\u2945':'rarrpl','\\u2948':'harrcir','\\u2949':'Uarrocir','\\u294A':'lurdshar','\\u294B':'ldrushar','\\u294E':'LeftRightVector','\\u294F':'RightUpDownVector','\\u2950':'DownLeftRightVector','\\u2951':'LeftUpDownVector','\\u2952':'LeftVectorBar','\\u2953':'RightVectorBar','\\u2954':'RightUpVectorBar','\\u2955':'RightDownVectorBar','\\u2956':'DownLeftVectorBar','\\u2957':'DownRightVectorBar','\\u2958':'LeftUpVectorBar','\\u2959':'LeftDownVectorBar','\\u295A':'LeftTeeVector','\\u295B':'RightTeeVector','\\u295C':'RightUpTeeVector','\\u295D':'RightDownTeeVector','\\u295E':'DownLeftTeeVector','\\u295F':'DownRightTeeVector','\\u2960':'LeftUpTeeVector','\\u2961':'LeftDownTeeVector','\\u2962':'lHar','\\u2963':'uHar','\\u2964':'rHar','\\u2965':'dHar','\\u2966':'luruhar','\\u2967':'ldrdhar','\\u2968':'ruluhar','\\u2969':'rdldhar','\\u296A':'lharul','\\u296B':'llhard','\\u296C':'rharul','\\u296D':'lrhard','\\u296E':'udhar','\\u296F':'duhar','\\u2970':'RoundImplies','\\u2971':'erarr','\\u2972':'simrarr','\\u2973':'larrsim','\\u2974':'rarrsim','\\u2975':'rarrap','\\u2976':'ltlarr','\\u2978':'gtrarr','\\u2979':'subrarr','\\u297B':'suplarr','\\u297C':'lfisht','\\u297D':'rfisht','\\u297E':'ufisht','\\u297F':'dfisht','\\u299A':'vzigzag','\\u299C':'vangrt','\\u299D':'angrtvbd','\\u29A4':'ange','\\u29A5':'range','\\u29A6':'dwangle','\\u29A7':'uwangle','\\u29A8':'angmsdaa','\\u29A9':'angmsdab','\\u29AA':'angmsdac','\\u29AB':'angmsdad','\\u29AC':'angmsdae','\\u29AD':'angmsdaf','\\u29AE':'angmsdag','\\u29AF':'angmsdah','\\u29B0':'bemptyv','\\u29B1':'demptyv','\\u29B2':'cemptyv','\\u29B3':'raemptyv','\\u29B4':'laemptyv','\\u29B5':'ohbar','\\u29B6':'omid','\\u29B7':'opar','\\u29B9':'operp','\\u29BB':'olcross','\\u29BC':'odsold','\\u29BE':'olcir','\\u29BF':'ofcir','\\u29C0':'olt','\\u29C1':'ogt','\\u29C2':'cirscir','\\u29C3':'cirE','\\u29C4':'solb','\\u29C5':'bsolb','\\u29C9':'boxbox','\\u29CD':'trisb','\\u29CE':'rtriltri','\\u29CF':'LeftTriangleBar','\\u29CF\\u0338':'NotLeftTriangleBar','\\u29D0':'RightTriangleBar','\\u29D0\\u0338':'NotRightTriangleBar','\\u29DC':'iinfin','\\u29DD':'infintie','\\u29DE':'nvinfin','\\u29E3':'eparsl','\\u29E4':'smeparsl','\\u29E5':'eqvparsl','\\u29EB':'lozf','\\u29F4':'RuleDelayed','\\u29F6':'dsol','\\u2A00':'xodot','\\u2A01':'xoplus','\\u2A02':'xotime','\\u2A04':'xuplus','\\u2A06':'xsqcup','\\u2A0D':'fpartint','\\u2A10':'cirfnint','\\u2A11':'awint','\\u2A12':'rppolint','\\u2A13':'scpolint','\\u2A14':'npolint','\\u2A15':'pointint','\\u2A16':'quatint','\\u2A17':'intlarhk','\\u2A22':'pluscir','\\u2A23':'plusacir','\\u2A24':'simplus','\\u2A25':'plusdu','\\u2A26':'plussim','\\u2A27':'plustwo','\\u2A29':'mcomma','\\u2A2A':'minusdu','\\u2A2D':'loplus','\\u2A2E':'roplus','\\u2A2F':'Cross','\\u2A30':'timesd','\\u2A31':'timesbar','\\u2A33':'smashp','\\u2A34':'lotimes','\\u2A35':'rotimes','\\u2A36':'otimesas','\\u2A37':'Otimes','\\u2A38':'odiv','\\u2A39':'triplus','\\u2A3A':'triminus','\\u2A3B':'tritime','\\u2A3C':'iprod','\\u2A3F':'amalg','\\u2A40':'capdot','\\u2A42':'ncup','\\u2A43':'ncap','\\u2A44':'capand','\\u2A45':'cupor','\\u2A46':'cupcap','\\u2A47':'capcup','\\u2A48':'cupbrcap','\\u2A49':'capbrcup','\\u2A4A':'cupcup','\\u2A4B':'capcap','\\u2A4C':'ccups','\\u2A4D':'ccaps','\\u2A50':'ccupssm','\\u2A53':'And','\\u2A54':'Or','\\u2A55':'andand','\\u2A56':'oror','\\u2A57':'orslope','\\u2A58':'andslope','\\u2A5A':'andv','\\u2A5B':'orv','\\u2A5C':'andd','\\u2A5D':'ord','\\u2A5F':'wedbar','\\u2A66':'sdote','\\u2A6A':'simdot','\\u2A6D':'congdot','\\u2A6D\\u0338':'ncongdot','\\u2A6E':'easter','\\u2A6F':'apacir','\\u2A70':'apE','\\u2A70\\u0338':'napE','\\u2A71':'eplus','\\u2A72':'pluse','\\u2A73':'Esim','\\u2A77':'eDDot','\\u2A78':'equivDD','\\u2A79':'ltcir','\\u2A7A':'gtcir','\\u2A7B':'ltquest','\\u2A7C':'gtquest','\\u2A7D':'les','\\u2A7D\\u0338':'nles','\\u2A7E':'ges','\\u2A7E\\u0338':'nges','\\u2A7F':'lesdot','\\u2A80':'gesdot','\\u2A81':'lesdoto','\\u2A82':'gesdoto','\\u2A83':'lesdotor','\\u2A84':'gesdotol','\\u2A85':'lap','\\u2A86':'gap','\\u2A87':'lne','\\u2A88':'gne','\\u2A89':'lnap','\\u2A8A':'gnap','\\u2A8B':'lEg','\\u2A8C':'gEl','\\u2A8D':'lsime','\\u2A8E':'gsime','\\u2A8F':'lsimg','\\u2A90':'gsiml','\\u2A91':'lgE','\\u2A92':'glE','\\u2A93':'lesges','\\u2A94':'gesles','\\u2A95':'els','\\u2A96':'egs','\\u2A97':'elsdot','\\u2A98':'egsdot','\\u2A99':'el','\\u2A9A':'eg','\\u2A9D':'siml','\\u2A9E':'simg','\\u2A9F':'simlE','\\u2AA0':'simgE','\\u2AA1':'LessLess','\\u2AA1\\u0338':'NotNestedLessLess','\\u2AA2':'GreaterGreater','\\u2AA2\\u0338':'NotNestedGreaterGreater','\\u2AA4':'glj','\\u2AA5':'gla','\\u2AA6':'ltcc','\\u2AA7':'gtcc','\\u2AA8':'lescc','\\u2AA9':'gescc','\\u2AAA':'smt','\\u2AAB':'lat','\\u2AAC':'smte','\\u2AAC\\uFE00':'smtes','\\u2AAD':'late','\\u2AAD\\uFE00':'lates','\\u2AAE':'bumpE','\\u2AAF':'pre','\\u2AAF\\u0338':'npre','\\u2AB0':'sce','\\u2AB0\\u0338':'nsce','\\u2AB3':'prE','\\u2AB4':'scE','\\u2AB5':'prnE','\\u2AB6':'scnE','\\u2AB7':'prap','\\u2AB8':'scap','\\u2AB9':'prnap','\\u2ABA':'scnap','\\u2ABB':'Pr','\\u2ABC':'Sc','\\u2ABD':'subdot','\\u2ABE':'supdot','\\u2ABF':'subplus','\\u2AC0':'supplus','\\u2AC1':'submult','\\u2AC2':'supmult','\\u2AC3':'subedot','\\u2AC4':'supedot','\\u2AC5':'subE','\\u2AC5\\u0338':'nsubE','\\u2AC6':'supE','\\u2AC6\\u0338':'nsupE','\\u2AC7':'subsim','\\u2AC8':'supsim','\\u2ACB\\uFE00':'vsubnE','\\u2ACB':'subnE','\\u2ACC\\uFE00':'vsupnE','\\u2ACC':'supnE','\\u2ACF':'csub','\\u2AD0':'csup','\\u2AD1':'csube','\\u2AD2':'csupe','\\u2AD3':'subsup','\\u2AD4':'supsub','\\u2AD5':'subsub','\\u2AD6':'supsup','\\u2AD7':'suphsub','\\u2AD8':'supdsub','\\u2AD9':'forkv','\\u2ADA':'topfork','\\u2ADB':'mlcp','\\u2AE4':'Dashv','\\u2AE6':'Vdashl','\\u2AE7':'Barv','\\u2AE8':'vBar','\\u2AE9':'vBarv','\\u2AEB':'Vbar','\\u2AEC':'Not','\\u2AED':'bNot','\\u2AEE':'rnmid','\\u2AEF':'cirmid','\\u2AF0':'midcir','\\u2AF1':'topcir','\\u2AF2':'nhpar','\\u2AF3':'parsim','\\u2AFD':'parsl','\\u2AFD\\u20E5':'nparsl','\\u266D':'flat','\\u266E':'natur','\\u266F':'sharp','\\xA4':'curren','\\xA2':'cent','$':'dollar','\\xA3':'pound','\\xA5':'yen','\\u20AC':'euro','\\xB9':'sup1','\\xBD':'half','\\u2153':'frac13','\\xBC':'frac14','\\u2155':'frac15','\\u2159':'frac16','\\u215B':'frac18','\\xB2':'sup2','\\u2154':'frac23','\\u2156':'frac25','\\xB3':'sup3','\\xBE':'frac34','\\u2157':'frac35','\\u215C':'frac38','\\u2158':'frac45','\\u215A':'frac56','\\u215D':'frac58','\\u215E':'frac78','\\uD835\\uDCB6':'ascr','\\uD835\\uDD52':'aopf','\\uD835\\uDD1E':'afr','\\uD835\\uDD38':'Aopf','\\uD835\\uDD04':'Afr','\\uD835\\uDC9C':'Ascr','\\xAA':'ordf','\\xE1':'aacute','\\xC1':'Aacute','\\xE0':'agrave','\\xC0':'Agrave','\\u0103':'abreve','\\u0102':'Abreve','\\xE2':'acirc','\\xC2':'Acirc','\\xE5':'aring','\\xC5':'angst','\\xE4':'auml','\\xC4':'Auml','\\xE3':'atilde','\\xC3':'Atilde','\\u0105':'aogon','\\u0104':'Aogon','\\u0101':'amacr','\\u0100':'Amacr','\\xE6':'aelig','\\xC6':'AElig','\\uD835\\uDCB7':'bscr','\\uD835\\uDD53':'bopf','\\uD835\\uDD1F':'bfr','\\uD835\\uDD39':'Bopf','\\u212C':'Bscr','\\uD835\\uDD05':'Bfr','\\uD835\\uDD20':'cfr','\\uD835\\uDCB8':'cscr','\\uD835\\uDD54':'copf','\\u212D':'Cfr','\\uD835\\uDC9E':'Cscr','\\u2102':'Copf','\\u0107':'cacute','\\u0106':'Cacute','\\u0109':'ccirc','\\u0108':'Ccirc','\\u010D':'ccaron','\\u010C':'Ccaron','\\u010B':'cdot','\\u010A':'Cdot','\\xE7':'ccedil','\\xC7':'Ccedil','\\u2105':'incare','\\uD835\\uDD21':'dfr','\\u2146':'dd','\\uD835\\uDD55':'dopf','\\uD835\\uDCB9':'dscr','\\uD835\\uDC9F':'Dscr','\\uD835\\uDD07':'Dfr','\\u2145':'DD','\\uD835\\uDD3B':'Dopf','\\u010F':'dcaron','\\u010E':'Dcaron','\\u0111':'dstrok','\\u0110':'Dstrok','\\xF0':'eth','\\xD0':'ETH','\\u2147':'ee','\\u212F':'escr','\\uD835\\uDD22':'efr','\\uD835\\uDD56':'eopf','\\u2130':'Escr','\\uD835\\uDD08':'Efr','\\uD835\\uDD3C':'Eopf','\\xE9':'eacute','\\xC9':'Eacute','\\xE8':'egrave','\\xC8':'Egrave','\\xEA':'ecirc','\\xCA':'Ecirc','\\u011B':'ecaron','\\u011A':'Ecaron','\\xEB':'euml','\\xCB':'Euml','\\u0117':'edot','\\u0116':'Edot','\\u0119':'eogon','\\u0118':'Eogon','\\u0113':'emacr','\\u0112':'Emacr','\\uD835\\uDD23':'ffr','\\uD835\\uDD57':'fopf','\\uD835\\uDCBB':'fscr','\\uD835\\uDD09':'Ffr','\\uD835\\uDD3D':'Fopf','\\u2131':'Fscr','\\uFB00':'fflig','\\uFB03':'ffilig','\\uFB04':'ffllig','\\uFB01':'filig','fj':'fjlig','\\uFB02':'fllig','\\u0192':'fnof','\\u210A':'gscr','\\uD835\\uDD58':'gopf','\\uD835\\uDD24':'gfr','\\uD835\\uDCA2':'Gscr','\\uD835\\uDD3E':'Gopf','\\uD835\\uDD0A':'Gfr','\\u01F5':'gacute','\\u011F':'gbreve','\\u011E':'Gbreve','\\u011D':'gcirc','\\u011C':'Gcirc','\\u0121':'gdot','\\u0120':'Gdot','\\u0122':'Gcedil','\\uD835\\uDD25':'hfr','\\u210E':'planckh','\\uD835\\uDCBD':'hscr','\\uD835\\uDD59':'hopf','\\u210B':'Hscr','\\u210C':'Hfr','\\u210D':'Hopf','\\u0125':'hcirc','\\u0124':'Hcirc','\\u210F':'hbar','\\u0127':'hstrok','\\u0126':'Hstrok','\\uD835\\uDD5A':'iopf','\\uD835\\uDD26':'ifr','\\uD835\\uDCBE':'iscr','\\u2148':'ii','\\uD835\\uDD40':'Iopf','\\u2110':'Iscr','\\u2111':'Im','\\xED':'iacute','\\xCD':'Iacute','\\xEC':'igrave','\\xCC':'Igrave','\\xEE':'icirc','\\xCE':'Icirc','\\xEF':'iuml','\\xCF':'Iuml','\\u0129':'itilde','\\u0128':'Itilde','\\u0130':'Idot','\\u012F':'iogon','\\u012E':'Iogon','\\u012B':'imacr','\\u012A':'Imacr','\\u0133':'ijlig','\\u0132':'IJlig','\\u0131':'imath','\\uD835\\uDCBF':'jscr','\\uD835\\uDD5B':'jopf','\\uD835\\uDD27':'jfr','\\uD835\\uDCA5':'Jscr','\\uD835\\uDD0D':'Jfr','\\uD835\\uDD41':'Jopf','\\u0135':'jcirc','\\u0134':'Jcirc','\\u0237':'jmath','\\uD835\\uDD5C':'kopf','\\uD835\\uDCC0':'kscr','\\uD835\\uDD28':'kfr','\\uD835\\uDCA6':'Kscr','\\uD835\\uDD42':'Kopf','\\uD835\\uDD0E':'Kfr','\\u0137':'kcedil','\\u0136':'Kcedil','\\uD835\\uDD29':'lfr','\\uD835\\uDCC1':'lscr','\\u2113':'ell','\\uD835\\uDD5D':'lopf','\\u2112':'Lscr','\\uD835\\uDD0F':'Lfr','\\uD835\\uDD43':'Lopf','\\u013A':'lacute','\\u0139':'Lacute','\\u013E':'lcaron','\\u013D':'Lcaron','\\u013C':'lcedil','\\u013B':'Lcedil','\\u0142':'lstrok','\\u0141':'Lstrok','\\u0140':'lmidot','\\u013F':'Lmidot','\\uD835\\uDD2A':'mfr','\\uD835\\uDD5E':'mopf','\\uD835\\uDCC2':'mscr','\\uD835\\uDD10':'Mfr','\\uD835\\uDD44':'Mopf','\\u2133':'Mscr','\\uD835\\uDD2B':'nfr','\\uD835\\uDD5F':'nopf','\\uD835\\uDCC3':'nscr','\\u2115':'Nopf','\\uD835\\uDCA9':'Nscr','\\uD835\\uDD11':'Nfr','\\u0144':'nacute','\\u0143':'Nacute','\\u0148':'ncaron','\\u0147':'Ncaron','\\xF1':'ntilde','\\xD1':'Ntilde','\\u0146':'ncedil','\\u0145':'Ncedil','\\u2116':'numero','\\u014B':'eng','\\u014A':'ENG','\\uD835\\uDD60':'oopf','\\uD835\\uDD2C':'ofr','\\u2134':'oscr','\\uD835\\uDCAA':'Oscr','\\uD835\\uDD12':'Ofr','\\uD835\\uDD46':'Oopf','\\xBA':'ordm','\\xF3':'oacute','\\xD3':'Oacute','\\xF2':'ograve','\\xD2':'Ograve','\\xF4':'ocirc','\\xD4':'Ocirc','\\xF6':'ouml','\\xD6':'Ouml','\\u0151':'odblac','\\u0150':'Odblac','\\xF5':'otilde','\\xD5':'Otilde','\\xF8':'oslash','\\xD8':'Oslash','\\u014D':'omacr','\\u014C':'Omacr','\\u0153':'oelig','\\u0152':'OElig','\\uD835\\uDD2D':'pfr','\\uD835\\uDCC5':'pscr','\\uD835\\uDD61':'popf','\\u2119':'Popf','\\uD835\\uDD13':'Pfr','\\uD835\\uDCAB':'Pscr','\\uD835\\uDD62':'qopf','\\uD835\\uDD2E':'qfr','\\uD835\\uDCC6':'qscr','\\uD835\\uDCAC':'Qscr','\\uD835\\uDD14':'Qfr','\\u211A':'Qopf','\\u0138':'kgreen','\\uD835\\uDD2F':'rfr','\\uD835\\uDD63':'ropf','\\uD835\\uDCC7':'rscr','\\u211B':'Rscr','\\u211C':'Re','\\u211D':'Ropf','\\u0155':'racute','\\u0154':'Racute','\\u0159':'rcaron','\\u0158':'Rcaron','\\u0157':'rcedil','\\u0156':'Rcedil','\\uD835\\uDD64':'sopf','\\uD835\\uDCC8':'sscr','\\uD835\\uDD30':'sfr','\\uD835\\uDD4A':'Sopf','\\uD835\\uDD16':'Sfr','\\uD835\\uDCAE':'Sscr','\\u24C8':'oS','\\u015B':'sacute','\\u015A':'Sacute','\\u015D':'scirc','\\u015C':'Scirc','\\u0161':'scaron','\\u0160':'Scaron','\\u015F':'scedil','\\u015E':'Scedil','\\xDF':'szlig','\\uD835\\uDD31':'tfr','\\uD835\\uDCC9':'tscr','\\uD835\\uDD65':'topf','\\uD835\\uDCAF':'Tscr','\\uD835\\uDD17':'Tfr','\\uD835\\uDD4B':'Topf','\\u0165':'tcaron','\\u0164':'Tcaron','\\u0163':'tcedil','\\u0162':'Tcedil','\\u2122':'trade','\\u0167':'tstrok','\\u0166':'Tstrok','\\uD835\\uDCCA':'uscr','\\uD835\\uDD66':'uopf','\\uD835\\uDD32':'ufr','\\uD835\\uDD4C':'Uopf','\\uD835\\uDD18':'Ufr','\\uD835\\uDCB0':'Uscr','\\xFA':'uacute','\\xDA':'Uacute','\\xF9':'ugrave','\\xD9':'Ugrave','\\u016D':'ubreve','\\u016C':'Ubreve','\\xFB':'ucirc','\\xDB':'Ucirc','\\u016F':'uring','\\u016E':'Uring','\\xFC':'uuml','\\xDC':'Uuml','\\u0171':'udblac','\\u0170':'Udblac','\\u0169':'utilde','\\u0168':'Utilde','\\u0173':'uogon','\\u0172':'Uogon','\\u016B':'umacr','\\u016A':'Umacr','\\uD835\\uDD33':'vfr','\\uD835\\uDD67':'vopf','\\uD835\\uDCCB':'vscr','\\uD835\\uDD19':'Vfr','\\uD835\\uDD4D':'Vopf','\\uD835\\uDCB1':'Vscr','\\uD835\\uDD68':'wopf','\\uD835\\uDCCC':'wscr','\\uD835\\uDD34':'wfr','\\uD835\\uDCB2':'Wscr','\\uD835\\uDD4E':'Wopf','\\uD835\\uDD1A':'Wfr','\\u0175':'wcirc','\\u0174':'Wcirc','\\uD835\\uDD35':'xfr','\\uD835\\uDCCD':'xscr','\\uD835\\uDD69':'xopf','\\uD835\\uDD4F':'Xopf','\\uD835\\uDD1B':'Xfr','\\uD835\\uDCB3':'Xscr','\\uD835\\uDD36':'yfr','\\uD835\\uDCCE':'yscr','\\uD835\\uDD6A':'yopf','\\uD835\\uDCB4':'Yscr','\\uD835\\uDD1C':'Yfr','\\uD835\\uDD50':'Yopf','\\xFD':'yacute','\\xDD':'Yacute','\\u0177':'ycirc','\\u0176':'Ycirc','\\xFF':'yuml','\\u0178':'Yuml','\\uD835\\uDCCF':'zscr','\\uD835\\uDD37':'zfr','\\uD835\\uDD6B':'zopf','\\u2128':'Zfr','\\u2124':'Zopf','\\uD835\\uDCB5':'Zscr','\\u017A':'zacute','\\u0179':'Zacute','\\u017E':'zcaron','\\u017D':'Zcaron','\\u017C':'zdot','\\u017B':'Zdot','\\u01B5':'imped','\\xFE':'thorn','\\xDE':'THORN','\\u0149':'napos','\\u03B1':'alpha','\\u0391':'Alpha','\\u03B2':'beta','\\u0392':'Beta','\\u03B3':'gamma','\\u0393':'Gamma','\\u03B4':'delta','\\u0394':'Delta','\\u03B5':'epsi','\\u03F5':'epsiv','\\u0395':'Epsilon','\\u03DD':'gammad','\\u03DC':'Gammad','\\u03B6':'zeta','\\u0396':'Zeta','\\u03B7':'eta','\\u0397':'Eta','\\u03B8':'theta','\\u03D1':'thetav','\\u0398':'Theta','\\u03B9':'iota','\\u0399':'Iota','\\u03BA':'kappa','\\u03F0':'kappav','\\u039A':'Kappa','\\u03BB':'lambda','\\u039B':'Lambda','\\u03BC':'mu','\\xB5':'micro','\\u039C':'Mu','\\u03BD':'nu','\\u039D':'Nu','\\u03BE':'xi','\\u039E':'Xi','\\u03BF':'omicron','\\u039F':'Omicron','\\u03C0':'pi','\\u03D6':'piv','\\u03A0':'Pi','\\u03C1':'rho','\\u03F1':'rhov','\\u03A1':'Rho','\\u03C3':'sigma','\\u03A3':'Sigma','\\u03C2':'sigmaf','\\u03C4':'tau','\\u03A4':'Tau','\\u03C5':'upsi','\\u03A5':'Upsilon','\\u03D2':'Upsi','\\u03C6':'phi','\\u03D5':'phiv','\\u03A6':'Phi','\\u03C7':'chi','\\u03A7':'Chi','\\u03C8':'psi','\\u03A8':'Psi','\\u03C9':'omega','\\u03A9':'ohm','\\u0430':'acy','\\u0410':'Acy','\\u0431':'bcy','\\u0411':'Bcy','\\u0432':'vcy','\\u0412':'Vcy','\\u0433':'gcy','\\u0413':'Gcy','\\u0453':'gjcy','\\u0403':'GJcy','\\u0434':'dcy','\\u0414':'Dcy','\\u0452':'djcy','\\u0402':'DJcy','\\u0435':'iecy','\\u0415':'IEcy','\\u0451':'iocy','\\u0401':'IOcy','\\u0454':'jukcy','\\u0404':'Jukcy','\\u0436':'zhcy','\\u0416':'ZHcy','\\u0437':'zcy','\\u0417':'Zcy','\\u0455':'dscy','\\u0405':'DScy','\\u0438':'icy','\\u0418':'Icy','\\u0456':'iukcy','\\u0406':'Iukcy','\\u0457':'yicy','\\u0407':'YIcy','\\u0439':'jcy','\\u0419':'Jcy','\\u0458':'jsercy','\\u0408':'Jsercy','\\u043A':'kcy','\\u041A':'Kcy','\\u045C':'kjcy','\\u040C':'KJcy','\\u043B':'lcy','\\u041B':'Lcy','\\u0459':'ljcy','\\u0409':'LJcy','\\u043C':'mcy','\\u041C':'Mcy','\\u043D':'ncy','\\u041D':'Ncy','\\u045A':'njcy','\\u040A':'NJcy','\\u043E':'ocy','\\u041E':'Ocy','\\u043F':'pcy','\\u041F':'Pcy','\\u0440':'rcy','\\u0420':'Rcy','\\u0441':'scy','\\u0421':'Scy','\\u0442':'tcy','\\u0422':'Tcy','\\u045B':'tshcy','\\u040B':'TSHcy','\\u0443':'ucy','\\u0423':'Ucy','\\u045E':'ubrcy','\\u040E':'Ubrcy','\\u0444':'fcy','\\u0424':'Fcy','\\u0445':'khcy','\\u0425':'KHcy','\\u0446':'tscy','\\u0426':'TScy','\\u0447':'chcy','\\u0427':'CHcy','\\u045F':'dzcy','\\u040F':'DZcy','\\u0448':'shcy','\\u0428':'SHcy','\\u0449':'shchcy','\\u0429':'SHCHcy','\\u044A':'hardcy','\\u042A':'HARDcy','\\u044B':'ycy','\\u042B':'Ycy','\\u044C':'softcy','\\u042C':'SOFTcy','\\u044D':'ecy','\\u042D':'Ecy','\\u044E':'yucy','\\u042E':'YUcy','\\u044F':'yacy','\\u042F':'YAcy','\\u2135':'aleph','\\u2136':'beth','\\u2137':'gimel','\\u2138':'daleth'};\n\n\tvar regexEscape = /[\"&'<>`]/g;\n\tvar escapeMap = {\n\t\t'\"': '&quot;',\n\t\t'&': '&amp;',\n\t\t'\\'': '&#x27;',\n\t\t'<': '&lt;',\n\t\t// See https://mathiasbynens.be/notes/ambiguous-ampersands: in HTML, the\n\t\t// following is not strictly necessary unless it’s part of a tag or an\n\t\t// unquoted attribute value. We’re only escaping it to support those\n\t\t// situations, and for XML support.\n\t\t'>': '&gt;',\n\t\t// In Internet Explorer ≤ 8, the backtick character can be used\n\t\t// to break out of (un)quoted attribute values or HTML comments.\n\t\t// See http://html5sec.org/#102, http://html5sec.org/#108, and\n\t\t// http://html5sec.org/#133.\n\t\t'`': '&#x60;'\n\t};\n\n\tvar regexInvalidEntity = /&#(?:[xX][^a-fA-F0-9]|[^0-9xX])/;\n\tvar regexInvalidRawCodePoint = /[\\0-\\x08\\x0B\\x0E-\\x1F\\x7F-\\x9F\\uFDD0-\\uFDEF\\uFFFE\\uFFFF]|[\\uD83F\\uD87F\\uD8BF\\uD8FF\\uD93F\\uD97F\\uD9BF\\uD9FF\\uDA3F\\uDA7F\\uDABF\\uDAFF\\uDB3F\\uDB7F\\uDBBF\\uDBFF][\\uDFFE\\uDFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF]/;\n\tvar regexDecode = /&#([0-9]+)(;?)|&#[xX]([a-fA-F0-9]+)(;?)|&([0-9a-zA-Z]+);|&(Aacute|Agrave|Atilde|Ccedil|Eacute|Egrave|Iacute|Igrave|Ntilde|Oacute|Ograve|Oslash|Otilde|Uacute|Ugrave|Yacute|aacute|agrave|atilde|brvbar|ccedil|curren|divide|eacute|egrave|frac12|frac14|frac34|iacute|igrave|iquest|middot|ntilde|oacute|ograve|oslash|otilde|plusmn|uacute|ugrave|yacute|AElig|Acirc|Aring|Ecirc|Icirc|Ocirc|THORN|Ucirc|acirc|acute|aelig|aring|cedil|ecirc|icirc|iexcl|laquo|micro|ocirc|pound|raquo|szlig|thorn|times|ucirc|Auml|COPY|Euml|Iuml|Ouml|QUOT|Uuml|auml|cent|copy|euml|iuml|macr|nbsp|ordf|ordm|ouml|para|quot|sect|sup1|sup2|sup3|uuml|yuml|AMP|ETH|REG|amp|deg|eth|not|reg|shy|uml|yen|GT|LT|gt|lt)([=a-zA-Z0-9])?/g;\n\tvar decodeMap = {'aacute':'\\xE1','Aacute':'\\xC1','abreve':'\\u0103','Abreve':'\\u0102','ac':'\\u223E','acd':'\\u223F','acE':'\\u223E\\u0333','acirc':'\\xE2','Acirc':'\\xC2','acute':'\\xB4','acy':'\\u0430','Acy':'\\u0410','aelig':'\\xE6','AElig':'\\xC6','af':'\\u2061','afr':'\\uD835\\uDD1E','Afr':'\\uD835\\uDD04','agrave':'\\xE0','Agrave':'\\xC0','alefsym':'\\u2135','aleph':'\\u2135','alpha':'\\u03B1','Alpha':'\\u0391','amacr':'\\u0101','Amacr':'\\u0100','amalg':'\\u2A3F','amp':'&','AMP':'&','and':'\\u2227','And':'\\u2A53','andand':'\\u2A55','andd':'\\u2A5C','andslope':'\\u2A58','andv':'\\u2A5A','ang':'\\u2220','ange':'\\u29A4','angle':'\\u2220','angmsd':'\\u2221','angmsdaa':'\\u29A8','angmsdab':'\\u29A9','angmsdac':'\\u29AA','angmsdad':'\\u29AB','angmsdae':'\\u29AC','angmsdaf':'\\u29AD','angmsdag':'\\u29AE','angmsdah':'\\u29AF','angrt':'\\u221F','angrtvb':'\\u22BE','angrtvbd':'\\u299D','angsph':'\\u2222','angst':'\\xC5','angzarr':'\\u237C','aogon':'\\u0105','Aogon':'\\u0104','aopf':'\\uD835\\uDD52','Aopf':'\\uD835\\uDD38','ap':'\\u2248','apacir':'\\u2A6F','ape':'\\u224A','apE':'\\u2A70','apid':'\\u224B','apos':'\\'','ApplyFunction':'\\u2061','approx':'\\u2248','approxeq':'\\u224A','aring':'\\xE5','Aring':'\\xC5','ascr':'\\uD835\\uDCB6','Ascr':'\\uD835\\uDC9C','Assign':'\\u2254','ast':'*','asymp':'\\u2248','asympeq':'\\u224D','atilde':'\\xE3','Atilde':'\\xC3','auml':'\\xE4','Auml':'\\xC4','awconint':'\\u2233','awint':'\\u2A11','backcong':'\\u224C','backepsilon':'\\u03F6','backprime':'\\u2035','backsim':'\\u223D','backsimeq':'\\u22CD','Backslash':'\\u2216','Barv':'\\u2AE7','barvee':'\\u22BD','barwed':'\\u2305','Barwed':'\\u2306','barwedge':'\\u2305','bbrk':'\\u23B5','bbrktbrk':'\\u23B6','bcong':'\\u224C','bcy':'\\u0431','Bcy':'\\u0411','bdquo':'\\u201E','becaus':'\\u2235','because':'\\u2235','Because':'\\u2235','bemptyv':'\\u29B0','bepsi':'\\u03F6','bernou':'\\u212C','Bernoullis':'\\u212C','beta':'\\u03B2','Beta':'\\u0392','beth':'\\u2136','between':'\\u226C','bfr':'\\uD835\\uDD1F','Bfr':'\\uD835\\uDD05','bigcap':'\\u22C2','bigcirc':'\\u25EF','bigcup':'\\u22C3','bigodot':'\\u2A00','bigoplus':'\\u2A01','bigotimes':'\\u2A02','bigsqcup':'\\u2A06','bigstar':'\\u2605','bigtriangledown':'\\u25BD','bigtriangleup':'\\u25B3','biguplus':'\\u2A04','bigvee':'\\u22C1','bigwedge':'\\u22C0','bkarow':'\\u290D','blacklozenge':'\\u29EB','blacksquare':'\\u25AA','blacktriangle':'\\u25B4','blacktriangledown':'\\u25BE','blacktriangleleft':'\\u25C2','blacktriangleright':'\\u25B8','blank':'\\u2423','blk12':'\\u2592','blk14':'\\u2591','blk34':'\\u2593','block':'\\u2588','bne':'=\\u20E5','bnequiv':'\\u2261\\u20E5','bnot':'\\u2310','bNot':'\\u2AED','bopf':'\\uD835\\uDD53','Bopf':'\\uD835\\uDD39','bot':'\\u22A5','bottom':'\\u22A5','bowtie':'\\u22C8','boxbox':'\\u29C9','boxdl':'\\u2510','boxdL':'\\u2555','boxDl':'\\u2556','boxDL':'\\u2557','boxdr':'\\u250C','boxdR':'\\u2552','boxDr':'\\u2553','boxDR':'\\u2554','boxh':'\\u2500','boxH':'\\u2550','boxhd':'\\u252C','boxhD':'\\u2565','boxHd':'\\u2564','boxHD':'\\u2566','boxhu':'\\u2534','boxhU':'\\u2568','boxHu':'\\u2567','boxHU':'\\u2569','boxminus':'\\u229F','boxplus':'\\u229E','boxtimes':'\\u22A0','boxul':'\\u2518','boxuL':'\\u255B','boxUl':'\\u255C','boxUL':'\\u255D','boxur':'\\u2514','boxuR':'\\u2558','boxUr':'\\u2559','boxUR':'\\u255A','boxv':'\\u2502','boxV':'\\u2551','boxvh':'\\u253C','boxvH':'\\u256A','boxVh':'\\u256B','boxVH':'\\u256C','boxvl':'\\u2524','boxvL':'\\u2561','boxVl':'\\u2562','boxVL':'\\u2563','boxvr':'\\u251C','boxvR':'\\u255E','boxVr':'\\u255F','boxVR':'\\u2560','bprime':'\\u2035','breve':'\\u02D8','Breve':'\\u02D8','brvbar':'\\xA6','bscr':'\\uD835\\uDCB7','Bscr':'\\u212C','bsemi':'\\u204F','bsim':'\\u223D','bsime':'\\u22CD','bsol':'\\\\','bsolb':'\\u29C5','bsolhsub':'\\u27C8','bull':'\\u2022','bullet':'\\u2022','bump':'\\u224E','bumpe':'\\u224F','bumpE':'\\u2AAE','bumpeq':'\\u224F','Bumpeq':'\\u224E','cacute':'\\u0107','Cacute':'\\u0106','cap':'\\u2229','Cap':'\\u22D2','capand':'\\u2A44','capbrcup':'\\u2A49','capcap':'\\u2A4B','capcup':'\\u2A47','capdot':'\\u2A40','CapitalDifferentialD':'\\u2145','caps':'\\u2229\\uFE00','caret':'\\u2041','caron':'\\u02C7','Cayleys':'\\u212D','ccaps':'\\u2A4D','ccaron':'\\u010D','Ccaron':'\\u010C','ccedil':'\\xE7','Ccedil':'\\xC7','ccirc':'\\u0109','Ccirc':'\\u0108','Cconint':'\\u2230','ccups':'\\u2A4C','ccupssm':'\\u2A50','cdot':'\\u010B','Cdot':'\\u010A','cedil':'\\xB8','Cedilla':'\\xB8','cemptyv':'\\u29B2','cent':'\\xA2','centerdot':'\\xB7','CenterDot':'\\xB7','cfr':'\\uD835\\uDD20','Cfr':'\\u212D','chcy':'\\u0447','CHcy':'\\u0427','check':'\\u2713','checkmark':'\\u2713','chi':'\\u03C7','Chi':'\\u03A7','cir':'\\u25CB','circ':'\\u02C6','circeq':'\\u2257','circlearrowleft':'\\u21BA','circlearrowright':'\\u21BB','circledast':'\\u229B','circledcirc':'\\u229A','circleddash':'\\u229D','CircleDot':'\\u2299','circledR':'\\xAE','circledS':'\\u24C8','CircleMinus':'\\u2296','CirclePlus':'\\u2295','CircleTimes':'\\u2297','cire':'\\u2257','cirE':'\\u29C3','cirfnint':'\\u2A10','cirmid':'\\u2AEF','cirscir':'\\u29C2','ClockwiseContourIntegral':'\\u2232','CloseCurlyDoubleQuote':'\\u201D','CloseCurlyQuote':'\\u2019','clubs':'\\u2663','clubsuit':'\\u2663','colon':':','Colon':'\\u2237','colone':'\\u2254','Colone':'\\u2A74','coloneq':'\\u2254','comma':',','commat':'@','comp':'\\u2201','compfn':'\\u2218','complement':'\\u2201','complexes':'\\u2102','cong':'\\u2245','congdot':'\\u2A6D','Congruent':'\\u2261','conint':'\\u222E','Conint':'\\u222F','ContourIntegral':'\\u222E','copf':'\\uD835\\uDD54','Copf':'\\u2102','coprod':'\\u2210','Coproduct':'\\u2210','copy':'\\xA9','COPY':'\\xA9','copysr':'\\u2117','CounterClockwiseContourIntegral':'\\u2233','crarr':'\\u21B5','cross':'\\u2717','Cross':'\\u2A2F','cscr':'\\uD835\\uDCB8','Cscr':'\\uD835\\uDC9E','csub':'\\u2ACF','csube':'\\u2AD1','csup':'\\u2AD0','csupe':'\\u2AD2','ctdot':'\\u22EF','cudarrl':'\\u2938','cudarrr':'\\u2935','cuepr':'\\u22DE','cuesc':'\\u22DF','cularr':'\\u21B6','cularrp':'\\u293D','cup':'\\u222A','Cup':'\\u22D3','cupbrcap':'\\u2A48','cupcap':'\\u2A46','CupCap':'\\u224D','cupcup':'\\u2A4A','cupdot':'\\u228D','cupor':'\\u2A45','cups':'\\u222A\\uFE00','curarr':'\\u21B7','curarrm':'\\u293C','curlyeqprec':'\\u22DE','curlyeqsucc':'\\u22DF','curlyvee':'\\u22CE','curlywedge':'\\u22CF','curren':'\\xA4','curvearrowleft':'\\u21B6','curvearrowright':'\\u21B7','cuvee':'\\u22CE','cuwed':'\\u22CF','cwconint':'\\u2232','cwint':'\\u2231','cylcty':'\\u232D','dagger':'\\u2020','Dagger':'\\u2021','daleth':'\\u2138','darr':'\\u2193','dArr':'\\u21D3','Darr':'\\u21A1','dash':'\\u2010','dashv':'\\u22A3','Dashv':'\\u2AE4','dbkarow':'\\u290F','dblac':'\\u02DD','dcaron':'\\u010F','Dcaron':'\\u010E','dcy':'\\u0434','Dcy':'\\u0414','dd':'\\u2146','DD':'\\u2145','ddagger':'\\u2021','ddarr':'\\u21CA','DDotrahd':'\\u2911','ddotseq':'\\u2A77','deg':'\\xB0','Del':'\\u2207','delta':'\\u03B4','Delta':'\\u0394','demptyv':'\\u29B1','dfisht':'\\u297F','dfr':'\\uD835\\uDD21','Dfr':'\\uD835\\uDD07','dHar':'\\u2965','dharl':'\\u21C3','dharr':'\\u21C2','DiacriticalAcute':'\\xB4','DiacriticalDot':'\\u02D9','DiacriticalDoubleAcute':'\\u02DD','DiacriticalGrave':'`','DiacriticalTilde':'\\u02DC','diam':'\\u22C4','diamond':'\\u22C4','Diamond':'\\u22C4','diamondsuit':'\\u2666','diams':'\\u2666','die':'\\xA8','DifferentialD':'\\u2146','digamma':'\\u03DD','disin':'\\u22F2','div':'\\xF7','divide':'\\xF7','divideontimes':'\\u22C7','divonx':'\\u22C7','djcy':'\\u0452','DJcy':'\\u0402','dlcorn':'\\u231E','dlcrop':'\\u230D','dollar':'$','dopf':'\\uD835\\uDD55','Dopf':'\\uD835\\uDD3B','dot':'\\u02D9','Dot':'\\xA8','DotDot':'\\u20DC','doteq':'\\u2250','doteqdot':'\\u2251','DotEqual':'\\u2250','dotminus':'\\u2238','dotplus':'\\u2214','dotsquare':'\\u22A1','doublebarwedge':'\\u2306','DoubleContourIntegral':'\\u222F','DoubleDot':'\\xA8','DoubleDownArrow':'\\u21D3','DoubleLeftArrow':'\\u21D0','DoubleLeftRightArrow':'\\u21D4','DoubleLeftTee':'\\u2AE4','DoubleLongLeftArrow':'\\u27F8','DoubleLongLeftRightArrow':'\\u27FA','DoubleLongRightArrow':'\\u27F9','DoubleRightArrow':'\\u21D2','DoubleRightTee':'\\u22A8','DoubleUpArrow':'\\u21D1','DoubleUpDownArrow':'\\u21D5','DoubleVerticalBar':'\\u2225','downarrow':'\\u2193','Downarrow':'\\u21D3','DownArrow':'\\u2193','DownArrowBar':'\\u2913','DownArrowUpArrow':'\\u21F5','DownBreve':'\\u0311','downdownarrows':'\\u21CA','downharpoonleft':'\\u21C3','downharpoonright':'\\u21C2','DownLeftRightVector':'\\u2950','DownLeftTeeVector':'\\u295E','DownLeftVector':'\\u21BD','DownLeftVectorBar':'\\u2956','DownRightTeeVector':'\\u295F','DownRightVector':'\\u21C1','DownRightVectorBar':'\\u2957','DownTee':'\\u22A4','DownTeeArrow':'\\u21A7','drbkarow':'\\u2910','drcorn':'\\u231F','drcrop':'\\u230C','dscr':'\\uD835\\uDCB9','Dscr':'\\uD835\\uDC9F','dscy':'\\u0455','DScy':'\\u0405','dsol':'\\u29F6','dstrok':'\\u0111','Dstrok':'\\u0110','dtdot':'\\u22F1','dtri':'\\u25BF','dtrif':'\\u25BE','duarr':'\\u21F5','duhar':'\\u296F','dwangle':'\\u29A6','dzcy':'\\u045F','DZcy':'\\u040F','dzigrarr':'\\u27FF','eacute':'\\xE9','Eacute':'\\xC9','easter':'\\u2A6E','ecaron':'\\u011B','Ecaron':'\\u011A','ecir':'\\u2256','ecirc':'\\xEA','Ecirc':'\\xCA','ecolon':'\\u2255','ecy':'\\u044D','Ecy':'\\u042D','eDDot':'\\u2A77','edot':'\\u0117','eDot':'\\u2251','Edot':'\\u0116','ee':'\\u2147','efDot':'\\u2252','efr':'\\uD835\\uDD22','Efr':'\\uD835\\uDD08','eg':'\\u2A9A','egrave':'\\xE8','Egrave':'\\xC8','egs':'\\u2A96','egsdot':'\\u2A98','el':'\\u2A99','Element':'\\u2208','elinters':'\\u23E7','ell':'\\u2113','els':'\\u2A95','elsdot':'\\u2A97','emacr':'\\u0113','Emacr':'\\u0112','empty':'\\u2205','emptyset':'\\u2205','EmptySmallSquare':'\\u25FB','emptyv':'\\u2205','EmptyVerySmallSquare':'\\u25AB','emsp':'\\u2003','emsp13':'\\u2004','emsp14':'\\u2005','eng':'\\u014B','ENG':'\\u014A','ensp':'\\u2002','eogon':'\\u0119','Eogon':'\\u0118','eopf':'\\uD835\\uDD56','Eopf':'\\uD835\\uDD3C','epar':'\\u22D5','eparsl':'\\u29E3','eplus':'\\u2A71','epsi':'\\u03B5','epsilon':'\\u03B5','Epsilon':'\\u0395','epsiv':'\\u03F5','eqcirc':'\\u2256','eqcolon':'\\u2255','eqsim':'\\u2242','eqslantgtr':'\\u2A96','eqslantless':'\\u2A95','Equal':'\\u2A75','equals':'=','EqualTilde':'\\u2242','equest':'\\u225F','Equilibrium':'\\u21CC','equiv':'\\u2261','equivDD':'\\u2A78','eqvparsl':'\\u29E5','erarr':'\\u2971','erDot':'\\u2253','escr':'\\u212F','Escr':'\\u2130','esdot':'\\u2250','esim':'\\u2242','Esim':'\\u2A73','eta':'\\u03B7','Eta':'\\u0397','eth':'\\xF0','ETH':'\\xD0','euml':'\\xEB','Euml':'\\xCB','euro':'\\u20AC','excl':'!','exist':'\\u2203','Exists':'\\u2203','expectation':'\\u2130','exponentiale':'\\u2147','ExponentialE':'\\u2147','fallingdotseq':'\\u2252','fcy':'\\u0444','Fcy':'\\u0424','female':'\\u2640','ffilig':'\\uFB03','fflig':'\\uFB00','ffllig':'\\uFB04','ffr':'\\uD835\\uDD23','Ffr':'\\uD835\\uDD09','filig':'\\uFB01','FilledSmallSquare':'\\u25FC','FilledVerySmallSquare':'\\u25AA','fjlig':'fj','flat':'\\u266D','fllig':'\\uFB02','fltns':'\\u25B1','fnof':'\\u0192','fopf':'\\uD835\\uDD57','Fopf':'\\uD835\\uDD3D','forall':'\\u2200','ForAll':'\\u2200','fork':'\\u22D4','forkv':'\\u2AD9','Fouriertrf':'\\u2131','fpartint':'\\u2A0D','frac12':'\\xBD','frac13':'\\u2153','frac14':'\\xBC','frac15':'\\u2155','frac16':'\\u2159','frac18':'\\u215B','frac23':'\\u2154','frac25':'\\u2156','frac34':'\\xBE','frac35':'\\u2157','frac38':'\\u215C','frac45':'\\u2158','frac56':'\\u215A','frac58':'\\u215D','frac78':'\\u215E','frasl':'\\u2044','frown':'\\u2322','fscr':'\\uD835\\uDCBB','Fscr':'\\u2131','gacute':'\\u01F5','gamma':'\\u03B3','Gamma':'\\u0393','gammad':'\\u03DD','Gammad':'\\u03DC','gap':'\\u2A86','gbreve':'\\u011F','Gbreve':'\\u011E','Gcedil':'\\u0122','gcirc':'\\u011D','Gcirc':'\\u011C','gcy':'\\u0433','Gcy':'\\u0413','gdot':'\\u0121','Gdot':'\\u0120','ge':'\\u2265','gE':'\\u2267','gel':'\\u22DB','gEl':'\\u2A8C','geq':'\\u2265','geqq':'\\u2267','geqslant':'\\u2A7E','ges':'\\u2A7E','gescc':'\\u2AA9','gesdot':'\\u2A80','gesdoto':'\\u2A82','gesdotol':'\\u2A84','gesl':'\\u22DB\\uFE00','gesles':'\\u2A94','gfr':'\\uD835\\uDD24','Gfr':'\\uD835\\uDD0A','gg':'\\u226B','Gg':'\\u22D9','ggg':'\\u22D9','gimel':'\\u2137','gjcy':'\\u0453','GJcy':'\\u0403','gl':'\\u2277','gla':'\\u2AA5','glE':'\\u2A92','glj':'\\u2AA4','gnap':'\\u2A8A','gnapprox':'\\u2A8A','gne':'\\u2A88','gnE':'\\u2269','gneq':'\\u2A88','gneqq':'\\u2269','gnsim':'\\u22E7','gopf':'\\uD835\\uDD58','Gopf':'\\uD835\\uDD3E','grave':'`','GreaterEqual':'\\u2265','GreaterEqualLess':'\\u22DB','GreaterFullEqual':'\\u2267','GreaterGreater':'\\u2AA2','GreaterLess':'\\u2277','GreaterSlantEqual':'\\u2A7E','GreaterTilde':'\\u2273','gscr':'\\u210A','Gscr':'\\uD835\\uDCA2','gsim':'\\u2273','gsime':'\\u2A8E','gsiml':'\\u2A90','gt':'>','Gt':'\\u226B','GT':'>','gtcc':'\\u2AA7','gtcir':'\\u2A7A','gtdot':'\\u22D7','gtlPar':'\\u2995','gtquest':'\\u2A7C','gtrapprox':'\\u2A86','gtrarr':'\\u2978','gtrdot':'\\u22D7','gtreqless':'\\u22DB','gtreqqless':'\\u2A8C','gtrless':'\\u2277','gtrsim':'\\u2273','gvertneqq':'\\u2269\\uFE00','gvnE':'\\u2269\\uFE00','Hacek':'\\u02C7','hairsp':'\\u200A','half':'\\xBD','hamilt':'\\u210B','hardcy':'\\u044A','HARDcy':'\\u042A','harr':'\\u2194','hArr':'\\u21D4','harrcir':'\\u2948','harrw':'\\u21AD','Hat':'^','hbar':'\\u210F','hcirc':'\\u0125','Hcirc':'\\u0124','hearts':'\\u2665','heartsuit':'\\u2665','hellip':'\\u2026','hercon':'\\u22B9','hfr':'\\uD835\\uDD25','Hfr':'\\u210C','HilbertSpace':'\\u210B','hksearow':'\\u2925','hkswarow':'\\u2926','hoarr':'\\u21FF','homtht':'\\u223B','hookleftarrow':'\\u21A9','hookrightarrow':'\\u21AA','hopf':'\\uD835\\uDD59','Hopf':'\\u210D','horbar':'\\u2015','HorizontalLine':'\\u2500','hscr':'\\uD835\\uDCBD','Hscr':'\\u210B','hslash':'\\u210F','hstrok':'\\u0127','Hstrok':'\\u0126','HumpDownHump':'\\u224E','HumpEqual':'\\u224F','hybull':'\\u2043','hyphen':'\\u2010','iacute':'\\xED','Iacute':'\\xCD','ic':'\\u2063','icirc':'\\xEE','Icirc':'\\xCE','icy':'\\u0438','Icy':'\\u0418','Idot':'\\u0130','iecy':'\\u0435','IEcy':'\\u0415','iexcl':'\\xA1','iff':'\\u21D4','ifr':'\\uD835\\uDD26','Ifr':'\\u2111','igrave':'\\xEC','Igrave':'\\xCC','ii':'\\u2148','iiiint':'\\u2A0C','iiint':'\\u222D','iinfin':'\\u29DC','iiota':'\\u2129','ijlig':'\\u0133','IJlig':'\\u0132','Im':'\\u2111','imacr':'\\u012B','Imacr':'\\u012A','image':'\\u2111','ImaginaryI':'\\u2148','imagline':'\\u2110','imagpart':'\\u2111','imath':'\\u0131','imof':'\\u22B7','imped':'\\u01B5','Implies':'\\u21D2','in':'\\u2208','incare':'\\u2105','infin':'\\u221E','infintie':'\\u29DD','inodot':'\\u0131','int':'\\u222B','Int':'\\u222C','intcal':'\\u22BA','integers':'\\u2124','Integral':'\\u222B','intercal':'\\u22BA','Intersection':'\\u22C2','intlarhk':'\\u2A17','intprod':'\\u2A3C','InvisibleComma':'\\u2063','InvisibleTimes':'\\u2062','iocy':'\\u0451','IOcy':'\\u0401','iogon':'\\u012F','Iogon':'\\u012E','iopf':'\\uD835\\uDD5A','Iopf':'\\uD835\\uDD40','iota':'\\u03B9','Iota':'\\u0399','iprod':'\\u2A3C','iquest':'\\xBF','iscr':'\\uD835\\uDCBE','Iscr':'\\u2110','isin':'\\u2208','isindot':'\\u22F5','isinE':'\\u22F9','isins':'\\u22F4','isinsv':'\\u22F3','isinv':'\\u2208','it':'\\u2062','itilde':'\\u0129','Itilde':'\\u0128','iukcy':'\\u0456','Iukcy':'\\u0406','iuml':'\\xEF','Iuml':'\\xCF','jcirc':'\\u0135','Jcirc':'\\u0134','jcy':'\\u0439','Jcy':'\\u0419','jfr':'\\uD835\\uDD27','Jfr':'\\uD835\\uDD0D','jmath':'\\u0237','jopf':'\\uD835\\uDD5B','Jopf':'\\uD835\\uDD41','jscr':'\\uD835\\uDCBF','Jscr':'\\uD835\\uDCA5','jsercy':'\\u0458','Jsercy':'\\u0408','jukcy':'\\u0454','Jukcy':'\\u0404','kappa':'\\u03BA','Kappa':'\\u039A','kappav':'\\u03F0','kcedil':'\\u0137','Kcedil':'\\u0136','kcy':'\\u043A','Kcy':'\\u041A','kfr':'\\uD835\\uDD28','Kfr':'\\uD835\\uDD0E','kgreen':'\\u0138','khcy':'\\u0445','KHcy':'\\u0425','kjcy':'\\u045C','KJcy':'\\u040C','kopf':'\\uD835\\uDD5C','Kopf':'\\uD835\\uDD42','kscr':'\\uD835\\uDCC0','Kscr':'\\uD835\\uDCA6','lAarr':'\\u21DA','lacute':'\\u013A','Lacute':'\\u0139','laemptyv':'\\u29B4','lagran':'\\u2112','lambda':'\\u03BB','Lambda':'\\u039B','lang':'\\u27E8','Lang':'\\u27EA','langd':'\\u2991','langle':'\\u27E8','lap':'\\u2A85','Laplacetrf':'\\u2112','laquo':'\\xAB','larr':'\\u2190','lArr':'\\u21D0','Larr':'\\u219E','larrb':'\\u21E4','larrbfs':'\\u291F','larrfs':'\\u291D','larrhk':'\\u21A9','larrlp':'\\u21AB','larrpl':'\\u2939','larrsim':'\\u2973','larrtl':'\\u21A2','lat':'\\u2AAB','latail':'\\u2919','lAtail':'\\u291B','late':'\\u2AAD','lates':'\\u2AAD\\uFE00','lbarr':'\\u290C','lBarr':'\\u290E','lbbrk':'\\u2772','lbrace':'{','lbrack':'[','lbrke':'\\u298B','lbrksld':'\\u298F','lbrkslu':'\\u298D','lcaron':'\\u013E','Lcaron':'\\u013D','lcedil':'\\u013C','Lcedil':'\\u013B','lceil':'\\u2308','lcub':'{','lcy':'\\u043B','Lcy':'\\u041B','ldca':'\\u2936','ldquo':'\\u201C','ldquor':'\\u201E','ldrdhar':'\\u2967','ldrushar':'\\u294B','ldsh':'\\u21B2','le':'\\u2264','lE':'\\u2266','LeftAngleBracket':'\\u27E8','leftarrow':'\\u2190','Leftarrow':'\\u21D0','LeftArrow':'\\u2190','LeftArrowBar':'\\u21E4','LeftArrowRightArrow':'\\u21C6','leftarrowtail':'\\u21A2','LeftCeiling':'\\u2308','LeftDoubleBracket':'\\u27E6','LeftDownTeeVector':'\\u2961','LeftDownVector':'\\u21C3','LeftDownVectorBar':'\\u2959','LeftFloor':'\\u230A','leftharpoondown':'\\u21BD','leftharpoonup':'\\u21BC','leftleftarrows':'\\u21C7','leftrightarrow':'\\u2194','Leftrightarrow':'\\u21D4','LeftRightArrow':'\\u2194','leftrightarrows':'\\u21C6','leftrightharpoons':'\\u21CB','leftrightsquigarrow':'\\u21AD','LeftRightVector':'\\u294E','LeftTee':'\\u22A3','LeftTeeArrow':'\\u21A4','LeftTeeVector':'\\u295A','leftthreetimes':'\\u22CB','LeftTriangle':'\\u22B2','LeftTriangleBar':'\\u29CF','LeftTriangleEqual':'\\u22B4','LeftUpDownVector':'\\u2951','LeftUpTeeVector':'\\u2960','LeftUpVector':'\\u21BF','LeftUpVectorBar':'\\u2958','LeftVector':'\\u21BC','LeftVectorBar':'\\u2952','leg':'\\u22DA','lEg':'\\u2A8B','leq':'\\u2264','leqq':'\\u2266','leqslant':'\\u2A7D','les':'\\u2A7D','lescc':'\\u2AA8','lesdot':'\\u2A7F','lesdoto':'\\u2A81','lesdotor':'\\u2A83','lesg':'\\u22DA\\uFE00','lesges':'\\u2A93','lessapprox':'\\u2A85','lessdot':'\\u22D6','lesseqgtr':'\\u22DA','lesseqqgtr':'\\u2A8B','LessEqualGreater':'\\u22DA','LessFullEqual':'\\u2266','LessGreater':'\\u2276','lessgtr':'\\u2276','LessLess':'\\u2AA1','lesssim':'\\u2272','LessSlantEqual':'\\u2A7D','LessTilde':'\\u2272','lfisht':'\\u297C','lfloor':'\\u230A','lfr':'\\uD835\\uDD29','Lfr':'\\uD835\\uDD0F','lg':'\\u2276','lgE':'\\u2A91','lHar':'\\u2962','lhard':'\\u21BD','lharu':'\\u21BC','lharul':'\\u296A','lhblk':'\\u2584','ljcy':'\\u0459','LJcy':'\\u0409','ll':'\\u226A','Ll':'\\u22D8','llarr':'\\u21C7','llcorner':'\\u231E','Lleftarrow':'\\u21DA','llhard':'\\u296B','lltri':'\\u25FA','lmidot':'\\u0140','Lmidot':'\\u013F','lmoust':'\\u23B0','lmoustache':'\\u23B0','lnap':'\\u2A89','lnapprox':'\\u2A89','lne':'\\u2A87','lnE':'\\u2268','lneq':'\\u2A87','lneqq':'\\u2268','lnsim':'\\u22E6','loang':'\\u27EC','loarr':'\\u21FD','lobrk':'\\u27E6','longleftarrow':'\\u27F5','Longleftarrow':'\\u27F8','LongLeftArrow':'\\u27F5','longleftrightarrow':'\\u27F7','Longleftrightarrow':'\\u27FA','LongLeftRightArrow':'\\u27F7','longmapsto':'\\u27FC','longrightarrow':'\\u27F6','Longrightarrow':'\\u27F9','LongRightArrow':'\\u27F6','looparrowleft':'\\u21AB','looparrowright':'\\u21AC','lopar':'\\u2985','lopf':'\\uD835\\uDD5D','Lopf':'\\uD835\\uDD43','loplus':'\\u2A2D','lotimes':'\\u2A34','lowast':'\\u2217','lowbar':'_','LowerLeftArrow':'\\u2199','LowerRightArrow':'\\u2198','loz':'\\u25CA','lozenge':'\\u25CA','lozf':'\\u29EB','lpar':'(','lparlt':'\\u2993','lrarr':'\\u21C6','lrcorner':'\\u231F','lrhar':'\\u21CB','lrhard':'\\u296D','lrm':'\\u200E','lrtri':'\\u22BF','lsaquo':'\\u2039','lscr':'\\uD835\\uDCC1','Lscr':'\\u2112','lsh':'\\u21B0','Lsh':'\\u21B0','lsim':'\\u2272','lsime':'\\u2A8D','lsimg':'\\u2A8F','lsqb':'[','lsquo':'\\u2018','lsquor':'\\u201A','lstrok':'\\u0142','Lstrok':'\\u0141','lt':'<','Lt':'\\u226A','LT':'<','ltcc':'\\u2AA6','ltcir':'\\u2A79','ltdot':'\\u22D6','lthree':'\\u22CB','ltimes':'\\u22C9','ltlarr':'\\u2976','ltquest':'\\u2A7B','ltri':'\\u25C3','ltrie':'\\u22B4','ltrif':'\\u25C2','ltrPar':'\\u2996','lurdshar':'\\u294A','luruhar':'\\u2966','lvertneqq':'\\u2268\\uFE00','lvnE':'\\u2268\\uFE00','macr':'\\xAF','male':'\\u2642','malt':'\\u2720','maltese':'\\u2720','map':'\\u21A6','Map':'\\u2905','mapsto':'\\u21A6','mapstodown':'\\u21A7','mapstoleft':'\\u21A4','mapstoup':'\\u21A5','marker':'\\u25AE','mcomma':'\\u2A29','mcy':'\\u043C','Mcy':'\\u041C','mdash':'\\u2014','mDDot':'\\u223A','measuredangle':'\\u2221','MediumSpace':'\\u205F','Mellintrf':'\\u2133','mfr':'\\uD835\\uDD2A','Mfr':'\\uD835\\uDD10','mho':'\\u2127','micro':'\\xB5','mid':'\\u2223','midast':'*','midcir':'\\u2AF0','middot':'\\xB7','minus':'\\u2212','minusb':'\\u229F','minusd':'\\u2238','minusdu':'\\u2A2A','MinusPlus':'\\u2213','mlcp':'\\u2ADB','mldr':'\\u2026','mnplus':'\\u2213','models':'\\u22A7','mopf':'\\uD835\\uDD5E','Mopf':'\\uD835\\uDD44','mp':'\\u2213','mscr':'\\uD835\\uDCC2','Mscr':'\\u2133','mstpos':'\\u223E','mu':'\\u03BC','Mu':'\\u039C','multimap':'\\u22B8','mumap':'\\u22B8','nabla':'\\u2207','nacute':'\\u0144','Nacute':'\\u0143','nang':'\\u2220\\u20D2','nap':'\\u2249','napE':'\\u2A70\\u0338','napid':'\\u224B\\u0338','napos':'\\u0149','napprox':'\\u2249','natur':'\\u266E','natural':'\\u266E','naturals':'\\u2115','nbsp':'\\xA0','nbump':'\\u224E\\u0338','nbumpe':'\\u224F\\u0338','ncap':'\\u2A43','ncaron':'\\u0148','Ncaron':'\\u0147','ncedil':'\\u0146','Ncedil':'\\u0145','ncong':'\\u2247','ncongdot':'\\u2A6D\\u0338','ncup':'\\u2A42','ncy':'\\u043D','Ncy':'\\u041D','ndash':'\\u2013','ne':'\\u2260','nearhk':'\\u2924','nearr':'\\u2197','neArr':'\\u21D7','nearrow':'\\u2197','nedot':'\\u2250\\u0338','NegativeMediumSpace':'\\u200B','NegativeThickSpace':'\\u200B','NegativeThinSpace':'\\u200B','NegativeVeryThinSpace':'\\u200B','nequiv':'\\u2262','nesear':'\\u2928','nesim':'\\u2242\\u0338','NestedGreaterGreater':'\\u226B','NestedLessLess':'\\u226A','NewLine':'\\n','nexist':'\\u2204','nexists':'\\u2204','nfr':'\\uD835\\uDD2B','Nfr':'\\uD835\\uDD11','nge':'\\u2271','ngE':'\\u2267\\u0338','ngeq':'\\u2271','ngeqq':'\\u2267\\u0338','ngeqslant':'\\u2A7E\\u0338','nges':'\\u2A7E\\u0338','nGg':'\\u22D9\\u0338','ngsim':'\\u2275','ngt':'\\u226F','nGt':'\\u226B\\u20D2','ngtr':'\\u226F','nGtv':'\\u226B\\u0338','nharr':'\\u21AE','nhArr':'\\u21CE','nhpar':'\\u2AF2','ni':'\\u220B','nis':'\\u22FC','nisd':'\\u22FA','niv':'\\u220B','njcy':'\\u045A','NJcy':'\\u040A','nlarr':'\\u219A','nlArr':'\\u21CD','nldr':'\\u2025','nle':'\\u2270','nlE':'\\u2266\\u0338','nleftarrow':'\\u219A','nLeftarrow':'\\u21CD','nleftrightarrow':'\\u21AE','nLeftrightarrow':'\\u21CE','nleq':'\\u2270','nleqq':'\\u2266\\u0338','nleqslant':'\\u2A7D\\u0338','nles':'\\u2A7D\\u0338','nless':'\\u226E','nLl':'\\u22D8\\u0338','nlsim':'\\u2274','nlt':'\\u226E','nLt':'\\u226A\\u20D2','nltri':'\\u22EA','nltrie':'\\u22EC','nLtv':'\\u226A\\u0338','nmid':'\\u2224','NoBreak':'\\u2060','NonBreakingSpace':'\\xA0','nopf':'\\uD835\\uDD5F','Nopf':'\\u2115','not':'\\xAC','Not':'\\u2AEC','NotCongruent':'\\u2262','NotCupCap':'\\u226D','NotDoubleVerticalBar':'\\u2226','NotElement':'\\u2209','NotEqual':'\\u2260','NotEqualTilde':'\\u2242\\u0338','NotExists':'\\u2204','NotGreater':'\\u226F','NotGreaterEqual':'\\u2271','NotGreaterFullEqual':'\\u2267\\u0338','NotGreaterGreater':'\\u226B\\u0338','NotGreaterLess':'\\u2279','NotGreaterSlantEqual':'\\u2A7E\\u0338','NotGreaterTilde':'\\u2275','NotHumpDownHump':'\\u224E\\u0338','NotHumpEqual':'\\u224F\\u0338','notin':'\\u2209','notindot':'\\u22F5\\u0338','notinE':'\\u22F9\\u0338','notinva':'\\u2209','notinvb':'\\u22F7','notinvc':'\\u22F6','NotLeftTriangle':'\\u22EA','NotLeftTriangleBar':'\\u29CF\\u0338','NotLeftTriangleEqual':'\\u22EC','NotLess':'\\u226E','NotLessEqual':'\\u2270','NotLessGreater':'\\u2278','NotLessLess':'\\u226A\\u0338','NotLessSlantEqual':'\\u2A7D\\u0338','NotLessTilde':'\\u2274','NotNestedGreaterGreater':'\\u2AA2\\u0338','NotNestedLessLess':'\\u2AA1\\u0338','notni':'\\u220C','notniva':'\\u220C','notnivb':'\\u22FE','notnivc':'\\u22FD','NotPrecedes':'\\u2280','NotPrecedesEqual':'\\u2AAF\\u0338','NotPrecedesSlantEqual':'\\u22E0','NotReverseElement':'\\u220C','NotRightTriangle':'\\u22EB','NotRightTriangleBar':'\\u29D0\\u0338','NotRightTriangleEqual':'\\u22ED','NotSquareSubset':'\\u228F\\u0338','NotSquareSubsetEqual':'\\u22E2','NotSquareSuperset':'\\u2290\\u0338','NotSquareSupersetEqual':'\\u22E3','NotSubset':'\\u2282\\u20D2','NotSubsetEqual':'\\u2288','NotSucceeds':'\\u2281','NotSucceedsEqual':'\\u2AB0\\u0338','NotSucceedsSlantEqual':'\\u22E1','NotSucceedsTilde':'\\u227F\\u0338','NotSuperset':'\\u2283\\u20D2','NotSupersetEqual':'\\u2289','NotTilde':'\\u2241','NotTildeEqual':'\\u2244','NotTildeFullEqual':'\\u2247','NotTildeTilde':'\\u2249','NotVerticalBar':'\\u2224','npar':'\\u2226','nparallel':'\\u2226','nparsl':'\\u2AFD\\u20E5','npart':'\\u2202\\u0338','npolint':'\\u2A14','npr':'\\u2280','nprcue':'\\u22E0','npre':'\\u2AAF\\u0338','nprec':'\\u2280','npreceq':'\\u2AAF\\u0338','nrarr':'\\u219B','nrArr':'\\u21CF','nrarrc':'\\u2933\\u0338','nrarrw':'\\u219D\\u0338','nrightarrow':'\\u219B','nRightarrow':'\\u21CF','nrtri':'\\u22EB','nrtrie':'\\u22ED','nsc':'\\u2281','nsccue':'\\u22E1','nsce':'\\u2AB0\\u0338','nscr':'\\uD835\\uDCC3','Nscr':'\\uD835\\uDCA9','nshortmid':'\\u2224','nshortparallel':'\\u2226','nsim':'\\u2241','nsime':'\\u2244','nsimeq':'\\u2244','nsmid':'\\u2224','nspar':'\\u2226','nsqsube':'\\u22E2','nsqsupe':'\\u22E3','nsub':'\\u2284','nsube':'\\u2288','nsubE':'\\u2AC5\\u0338','nsubset':'\\u2282\\u20D2','nsubseteq':'\\u2288','nsubseteqq':'\\u2AC5\\u0338','nsucc':'\\u2281','nsucceq':'\\u2AB0\\u0338','nsup':'\\u2285','nsupe':'\\u2289','nsupE':'\\u2AC6\\u0338','nsupset':'\\u2283\\u20D2','nsupseteq':'\\u2289','nsupseteqq':'\\u2AC6\\u0338','ntgl':'\\u2279','ntilde':'\\xF1','Ntilde':'\\xD1','ntlg':'\\u2278','ntriangleleft':'\\u22EA','ntrianglelefteq':'\\u22EC','ntriangleright':'\\u22EB','ntrianglerighteq':'\\u22ED','nu':'\\u03BD','Nu':'\\u039D','num':'#','numero':'\\u2116','numsp':'\\u2007','nvap':'\\u224D\\u20D2','nvdash':'\\u22AC','nvDash':'\\u22AD','nVdash':'\\u22AE','nVDash':'\\u22AF','nvge':'\\u2265\\u20D2','nvgt':'>\\u20D2','nvHarr':'\\u2904','nvinfin':'\\u29DE','nvlArr':'\\u2902','nvle':'\\u2264\\u20D2','nvlt':'<\\u20D2','nvltrie':'\\u22B4\\u20D2','nvrArr':'\\u2903','nvrtrie':'\\u22B5\\u20D2','nvsim':'\\u223C\\u20D2','nwarhk':'\\u2923','nwarr':'\\u2196','nwArr':'\\u21D6','nwarrow':'\\u2196','nwnear':'\\u2927','oacute':'\\xF3','Oacute':'\\xD3','oast':'\\u229B','ocir':'\\u229A','ocirc':'\\xF4','Ocirc':'\\xD4','ocy':'\\u043E','Ocy':'\\u041E','odash':'\\u229D','odblac':'\\u0151','Odblac':'\\u0150','odiv':'\\u2A38','odot':'\\u2299','odsold':'\\u29BC','oelig':'\\u0153','OElig':'\\u0152','ofcir':'\\u29BF','ofr':'\\uD835\\uDD2C','Ofr':'\\uD835\\uDD12','ogon':'\\u02DB','ograve':'\\xF2','Ograve':'\\xD2','ogt':'\\u29C1','ohbar':'\\u29B5','ohm':'\\u03A9','oint':'\\u222E','olarr':'\\u21BA','olcir':'\\u29BE','olcross':'\\u29BB','oline':'\\u203E','olt':'\\u29C0','omacr':'\\u014D','Omacr':'\\u014C','omega':'\\u03C9','Omega':'\\u03A9','omicron':'\\u03BF','Omicron':'\\u039F','omid':'\\u29B6','ominus':'\\u2296','oopf':'\\uD835\\uDD60','Oopf':'\\uD835\\uDD46','opar':'\\u29B7','OpenCurlyDoubleQuote':'\\u201C','OpenCurlyQuote':'\\u2018','operp':'\\u29B9','oplus':'\\u2295','or':'\\u2228','Or':'\\u2A54','orarr':'\\u21BB','ord':'\\u2A5D','order':'\\u2134','orderof':'\\u2134','ordf':'\\xAA','ordm':'\\xBA','origof':'\\u22B6','oror':'\\u2A56','orslope':'\\u2A57','orv':'\\u2A5B','oS':'\\u24C8','oscr':'\\u2134','Oscr':'\\uD835\\uDCAA','oslash':'\\xF8','Oslash':'\\xD8','osol':'\\u2298','otilde':'\\xF5','Otilde':'\\xD5','otimes':'\\u2297','Otimes':'\\u2A37','otimesas':'\\u2A36','ouml':'\\xF6','Ouml':'\\xD6','ovbar':'\\u233D','OverBar':'\\u203E','OverBrace':'\\u23DE','OverBracket':'\\u23B4','OverParenthesis':'\\u23DC','par':'\\u2225','para':'\\xB6','parallel':'\\u2225','parsim':'\\u2AF3','parsl':'\\u2AFD','part':'\\u2202','PartialD':'\\u2202','pcy':'\\u043F','Pcy':'\\u041F','percnt':'%','period':'.','permil':'\\u2030','perp':'\\u22A5','pertenk':'\\u2031','pfr':'\\uD835\\uDD2D','Pfr':'\\uD835\\uDD13','phi':'\\u03C6','Phi':'\\u03A6','phiv':'\\u03D5','phmmat':'\\u2133','phone':'\\u260E','pi':'\\u03C0','Pi':'\\u03A0','pitchfork':'\\u22D4','piv':'\\u03D6','planck':'\\u210F','planckh':'\\u210E','plankv':'\\u210F','plus':'+','plusacir':'\\u2A23','plusb':'\\u229E','pluscir':'\\u2A22','plusdo':'\\u2214','plusdu':'\\u2A25','pluse':'\\u2A72','PlusMinus':'\\xB1','plusmn':'\\xB1','plussim':'\\u2A26','plustwo':'\\u2A27','pm':'\\xB1','Poincareplane':'\\u210C','pointint':'\\u2A15','popf':'\\uD835\\uDD61','Popf':'\\u2119','pound':'\\xA3','pr':'\\u227A','Pr':'\\u2ABB','prap':'\\u2AB7','prcue':'\\u227C','pre':'\\u2AAF','prE':'\\u2AB3','prec':'\\u227A','precapprox':'\\u2AB7','preccurlyeq':'\\u227C','Precedes':'\\u227A','PrecedesEqual':'\\u2AAF','PrecedesSlantEqual':'\\u227C','PrecedesTilde':'\\u227E','preceq':'\\u2AAF','precnapprox':'\\u2AB9','precneqq':'\\u2AB5','precnsim':'\\u22E8','precsim':'\\u227E','prime':'\\u2032','Prime':'\\u2033','primes':'\\u2119','prnap':'\\u2AB9','prnE':'\\u2AB5','prnsim':'\\u22E8','prod':'\\u220F','Product':'\\u220F','profalar':'\\u232E','profline':'\\u2312','profsurf':'\\u2313','prop':'\\u221D','Proportion':'\\u2237','Proportional':'\\u221D','propto':'\\u221D','prsim':'\\u227E','prurel':'\\u22B0','pscr':'\\uD835\\uDCC5','Pscr':'\\uD835\\uDCAB','psi':'\\u03C8','Psi':'\\u03A8','puncsp':'\\u2008','qfr':'\\uD835\\uDD2E','Qfr':'\\uD835\\uDD14','qint':'\\u2A0C','qopf':'\\uD835\\uDD62','Qopf':'\\u211A','qprime':'\\u2057','qscr':'\\uD835\\uDCC6','Qscr':'\\uD835\\uDCAC','quaternions':'\\u210D','quatint':'\\u2A16','quest':'?','questeq':'\\u225F','quot':'\"','QUOT':'\"','rAarr':'\\u21DB','race':'\\u223D\\u0331','racute':'\\u0155','Racute':'\\u0154','radic':'\\u221A','raemptyv':'\\u29B3','rang':'\\u27E9','Rang':'\\u27EB','rangd':'\\u2992','range':'\\u29A5','rangle':'\\u27E9','raquo':'\\xBB','rarr':'\\u2192','rArr':'\\u21D2','Rarr':'\\u21A0','rarrap':'\\u2975','rarrb':'\\u21E5','rarrbfs':'\\u2920','rarrc':'\\u2933','rarrfs':'\\u291E','rarrhk':'\\u21AA','rarrlp':'\\u21AC','rarrpl':'\\u2945','rarrsim':'\\u2974','rarrtl':'\\u21A3','Rarrtl':'\\u2916','rarrw':'\\u219D','ratail':'\\u291A','rAtail':'\\u291C','ratio':'\\u2236','rationals':'\\u211A','rbarr':'\\u290D','rBarr':'\\u290F','RBarr':'\\u2910','rbbrk':'\\u2773','rbrace':'}','rbrack':']','rbrke':'\\u298C','rbrksld':'\\u298E','rbrkslu':'\\u2990','rcaron':'\\u0159','Rcaron':'\\u0158','rcedil':'\\u0157','Rcedil':'\\u0156','rceil':'\\u2309','rcub':'}','rcy':'\\u0440','Rcy':'\\u0420','rdca':'\\u2937','rdldhar':'\\u2969','rdquo':'\\u201D','rdquor':'\\u201D','rdsh':'\\u21B3','Re':'\\u211C','real':'\\u211C','realine':'\\u211B','realpart':'\\u211C','reals':'\\u211D','rect':'\\u25AD','reg':'\\xAE','REG':'\\xAE','ReverseElement':'\\u220B','ReverseEquilibrium':'\\u21CB','ReverseUpEquilibrium':'\\u296F','rfisht':'\\u297D','rfloor':'\\u230B','rfr':'\\uD835\\uDD2F','Rfr':'\\u211C','rHar':'\\u2964','rhard':'\\u21C1','rharu':'\\u21C0','rharul':'\\u296C','rho':'\\u03C1','Rho':'\\u03A1','rhov':'\\u03F1','RightAngleBracket':'\\u27E9','rightarrow':'\\u2192','Rightarrow':'\\u21D2','RightArrow':'\\u2192','RightArrowBar':'\\u21E5','RightArrowLeftArrow':'\\u21C4','rightarrowtail':'\\u21A3','RightCeiling':'\\u2309','RightDoubleBracket':'\\u27E7','RightDownTeeVector':'\\u295D','RightDownVector':'\\u21C2','RightDownVectorBar':'\\u2955','RightFloor':'\\u230B','rightharpoondown':'\\u21C1','rightharpoonup':'\\u21C0','rightleftarrows':'\\u21C4','rightleftharpoons':'\\u21CC','rightrightarrows':'\\u21C9','rightsquigarrow':'\\u219D','RightTee':'\\u22A2','RightTeeArrow':'\\u21A6','RightTeeVector':'\\u295B','rightthreetimes':'\\u22CC','RightTriangle':'\\u22B3','RightTriangleBar':'\\u29D0','RightTriangleEqual':'\\u22B5','RightUpDownVector':'\\u294F','RightUpTeeVector':'\\u295C','RightUpVector':'\\u21BE','RightUpVectorBar':'\\u2954','RightVector':'\\u21C0','RightVectorBar':'\\u2953','ring':'\\u02DA','risingdotseq':'\\u2253','rlarr':'\\u21C4','rlhar':'\\u21CC','rlm':'\\u200F','rmoust':'\\u23B1','rmoustache':'\\u23B1','rnmid':'\\u2AEE','roang':'\\u27ED','roarr':'\\u21FE','robrk':'\\u27E7','ropar':'\\u2986','ropf':'\\uD835\\uDD63','Ropf':'\\u211D','roplus':'\\u2A2E','rotimes':'\\u2A35','RoundImplies':'\\u2970','rpar':')','rpargt':'\\u2994','rppolint':'\\u2A12','rrarr':'\\u21C9','Rrightarrow':'\\u21DB','rsaquo':'\\u203A','rscr':'\\uD835\\uDCC7','Rscr':'\\u211B','rsh':'\\u21B1','Rsh':'\\u21B1','rsqb':']','rsquo':'\\u2019','rsquor':'\\u2019','rthree':'\\u22CC','rtimes':'\\u22CA','rtri':'\\u25B9','rtrie':'\\u22B5','rtrif':'\\u25B8','rtriltri':'\\u29CE','RuleDelayed':'\\u29F4','ruluhar':'\\u2968','rx':'\\u211E','sacute':'\\u015B','Sacute':'\\u015A','sbquo':'\\u201A','sc':'\\u227B','Sc':'\\u2ABC','scap':'\\u2AB8','scaron':'\\u0161','Scaron':'\\u0160','sccue':'\\u227D','sce':'\\u2AB0','scE':'\\u2AB4','scedil':'\\u015F','Scedil':'\\u015E','scirc':'\\u015D','Scirc':'\\u015C','scnap':'\\u2ABA','scnE':'\\u2AB6','scnsim':'\\u22E9','scpolint':'\\u2A13','scsim':'\\u227F','scy':'\\u0441','Scy':'\\u0421','sdot':'\\u22C5','sdotb':'\\u22A1','sdote':'\\u2A66','searhk':'\\u2925','searr':'\\u2198','seArr':'\\u21D8','searrow':'\\u2198','sect':'\\xA7','semi':';','seswar':'\\u2929','setminus':'\\u2216','setmn':'\\u2216','sext':'\\u2736','sfr':'\\uD835\\uDD30','Sfr':'\\uD835\\uDD16','sfrown':'\\u2322','sharp':'\\u266F','shchcy':'\\u0449','SHCHcy':'\\u0429','shcy':'\\u0448','SHcy':'\\u0428','ShortDownArrow':'\\u2193','ShortLeftArrow':'\\u2190','shortmid':'\\u2223','shortparallel':'\\u2225','ShortRightArrow':'\\u2192','ShortUpArrow':'\\u2191','shy':'\\xAD','sigma':'\\u03C3','Sigma':'\\u03A3','sigmaf':'\\u03C2','sigmav':'\\u03C2','sim':'\\u223C','simdot':'\\u2A6A','sime':'\\u2243','simeq':'\\u2243','simg':'\\u2A9E','simgE':'\\u2AA0','siml':'\\u2A9D','simlE':'\\u2A9F','simne':'\\u2246','simplus':'\\u2A24','simrarr':'\\u2972','slarr':'\\u2190','SmallCircle':'\\u2218','smallsetminus':'\\u2216','smashp':'\\u2A33','smeparsl':'\\u29E4','smid':'\\u2223','smile':'\\u2323','smt':'\\u2AAA','smte':'\\u2AAC','smtes':'\\u2AAC\\uFE00','softcy':'\\u044C','SOFTcy':'\\u042C','sol':'/','solb':'\\u29C4','solbar':'\\u233F','sopf':'\\uD835\\uDD64','Sopf':'\\uD835\\uDD4A','spades':'\\u2660','spadesuit':'\\u2660','spar':'\\u2225','sqcap':'\\u2293','sqcaps':'\\u2293\\uFE00','sqcup':'\\u2294','sqcups':'\\u2294\\uFE00','Sqrt':'\\u221A','sqsub':'\\u228F','sqsube':'\\u2291','sqsubset':'\\u228F','sqsubseteq':'\\u2291','sqsup':'\\u2290','sqsupe':'\\u2292','sqsupset':'\\u2290','sqsupseteq':'\\u2292','squ':'\\u25A1','square':'\\u25A1','Square':'\\u25A1','SquareIntersection':'\\u2293','SquareSubset':'\\u228F','SquareSubsetEqual':'\\u2291','SquareSuperset':'\\u2290','SquareSupersetEqual':'\\u2292','SquareUnion':'\\u2294','squarf':'\\u25AA','squf':'\\u25AA','srarr':'\\u2192','sscr':'\\uD835\\uDCC8','Sscr':'\\uD835\\uDCAE','ssetmn':'\\u2216','ssmile':'\\u2323','sstarf':'\\u22C6','star':'\\u2606','Star':'\\u22C6','starf':'\\u2605','straightepsilon':'\\u03F5','straightphi':'\\u03D5','strns':'\\xAF','sub':'\\u2282','Sub':'\\u22D0','subdot':'\\u2ABD','sube':'\\u2286','subE':'\\u2AC5','subedot':'\\u2AC3','submult':'\\u2AC1','subne':'\\u228A','subnE':'\\u2ACB','subplus':'\\u2ABF','subrarr':'\\u2979','subset':'\\u2282','Subset':'\\u22D0','subseteq':'\\u2286','subseteqq':'\\u2AC5','SubsetEqual':'\\u2286','subsetneq':'\\u228A','subsetneqq':'\\u2ACB','subsim':'\\u2AC7','subsub':'\\u2AD5','subsup':'\\u2AD3','succ':'\\u227B','succapprox':'\\u2AB8','succcurlyeq':'\\u227D','Succeeds':'\\u227B','SucceedsEqual':'\\u2AB0','SucceedsSlantEqual':'\\u227D','SucceedsTilde':'\\u227F','succeq':'\\u2AB0','succnapprox':'\\u2ABA','succneqq':'\\u2AB6','succnsim':'\\u22E9','succsim':'\\u227F','SuchThat':'\\u220B','sum':'\\u2211','Sum':'\\u2211','sung':'\\u266A','sup':'\\u2283','Sup':'\\u22D1','sup1':'\\xB9','sup2':'\\xB2','sup3':'\\xB3','supdot':'\\u2ABE','supdsub':'\\u2AD8','supe':'\\u2287','supE':'\\u2AC6','supedot':'\\u2AC4','Superset':'\\u2283','SupersetEqual':'\\u2287','suphsol':'\\u27C9','suphsub':'\\u2AD7','suplarr':'\\u297B','supmult':'\\u2AC2','supne':'\\u228B','supnE':'\\u2ACC','supplus':'\\u2AC0','supset':'\\u2283','Supset':'\\u22D1','supseteq':'\\u2287','supseteqq':'\\u2AC6','supsetneq':'\\u228B','supsetneqq':'\\u2ACC','supsim':'\\u2AC8','supsub':'\\u2AD4','supsup':'\\u2AD6','swarhk':'\\u2926','swarr':'\\u2199','swArr':'\\u21D9','swarrow':'\\u2199','swnwar':'\\u292A','szlig':'\\xDF','Tab':'\\t','target':'\\u2316','tau':'\\u03C4','Tau':'\\u03A4','tbrk':'\\u23B4','tcaron':'\\u0165','Tcaron':'\\u0164','tcedil':'\\u0163','Tcedil':'\\u0162','tcy':'\\u0442','Tcy':'\\u0422','tdot':'\\u20DB','telrec':'\\u2315','tfr':'\\uD835\\uDD31','Tfr':'\\uD835\\uDD17','there4':'\\u2234','therefore':'\\u2234','Therefore':'\\u2234','theta':'\\u03B8','Theta':'\\u0398','thetasym':'\\u03D1','thetav':'\\u03D1','thickapprox':'\\u2248','thicksim':'\\u223C','ThickSpace':'\\u205F\\u200A','thinsp':'\\u2009','ThinSpace':'\\u2009','thkap':'\\u2248','thksim':'\\u223C','thorn':'\\xFE','THORN':'\\xDE','tilde':'\\u02DC','Tilde':'\\u223C','TildeEqual':'\\u2243','TildeFullEqual':'\\u2245','TildeTilde':'\\u2248','times':'\\xD7','timesb':'\\u22A0','timesbar':'\\u2A31','timesd':'\\u2A30','tint':'\\u222D','toea':'\\u2928','top':'\\u22A4','topbot':'\\u2336','topcir':'\\u2AF1','topf':'\\uD835\\uDD65','Topf':'\\uD835\\uDD4B','topfork':'\\u2ADA','tosa':'\\u2929','tprime':'\\u2034','trade':'\\u2122','TRADE':'\\u2122','triangle':'\\u25B5','triangledown':'\\u25BF','triangleleft':'\\u25C3','trianglelefteq':'\\u22B4','triangleq':'\\u225C','triangleright':'\\u25B9','trianglerighteq':'\\u22B5','tridot':'\\u25EC','trie':'\\u225C','triminus':'\\u2A3A','TripleDot':'\\u20DB','triplus':'\\u2A39','trisb':'\\u29CD','tritime':'\\u2A3B','trpezium':'\\u23E2','tscr':'\\uD835\\uDCC9','Tscr':'\\uD835\\uDCAF','tscy':'\\u0446','TScy':'\\u0426','tshcy':'\\u045B','TSHcy':'\\u040B','tstrok':'\\u0167','Tstrok':'\\u0166','twixt':'\\u226C','twoheadleftarrow':'\\u219E','twoheadrightarrow':'\\u21A0','uacute':'\\xFA','Uacute':'\\xDA','uarr':'\\u2191','uArr':'\\u21D1','Uarr':'\\u219F','Uarrocir':'\\u2949','ubrcy':'\\u045E','Ubrcy':'\\u040E','ubreve':'\\u016D','Ubreve':'\\u016C','ucirc':'\\xFB','Ucirc':'\\xDB','ucy':'\\u0443','Ucy':'\\u0423','udarr':'\\u21C5','udblac':'\\u0171','Udblac':'\\u0170','udhar':'\\u296E','ufisht':'\\u297E','ufr':'\\uD835\\uDD32','Ufr':'\\uD835\\uDD18','ugrave':'\\xF9','Ugrave':'\\xD9','uHar':'\\u2963','uharl':'\\u21BF','uharr':'\\u21BE','uhblk':'\\u2580','ulcorn':'\\u231C','ulcorner':'\\u231C','ulcrop':'\\u230F','ultri':'\\u25F8','umacr':'\\u016B','Umacr':'\\u016A','uml':'\\xA8','UnderBar':'_','UnderBrace':'\\u23DF','UnderBracket':'\\u23B5','UnderParenthesis':'\\u23DD','Union':'\\u22C3','UnionPlus':'\\u228E','uogon':'\\u0173','Uogon':'\\u0172','uopf':'\\uD835\\uDD66','Uopf':'\\uD835\\uDD4C','uparrow':'\\u2191','Uparrow':'\\u21D1','UpArrow':'\\u2191','UpArrowBar':'\\u2912','UpArrowDownArrow':'\\u21C5','updownarrow':'\\u2195','Updownarrow':'\\u21D5','UpDownArrow':'\\u2195','UpEquilibrium':'\\u296E','upharpoonleft':'\\u21BF','upharpoonright':'\\u21BE','uplus':'\\u228E','UpperLeftArrow':'\\u2196','UpperRightArrow':'\\u2197','upsi':'\\u03C5','Upsi':'\\u03D2','upsih':'\\u03D2','upsilon':'\\u03C5','Upsilon':'\\u03A5','UpTee':'\\u22A5','UpTeeArrow':'\\u21A5','upuparrows':'\\u21C8','urcorn':'\\u231D','urcorner':'\\u231D','urcrop':'\\u230E','uring':'\\u016F','Uring':'\\u016E','urtri':'\\u25F9','uscr':'\\uD835\\uDCCA','Uscr':'\\uD835\\uDCB0','utdot':'\\u22F0','utilde':'\\u0169','Utilde':'\\u0168','utri':'\\u25B5','utrif':'\\u25B4','uuarr':'\\u21C8','uuml':'\\xFC','Uuml':'\\xDC','uwangle':'\\u29A7','vangrt':'\\u299C','varepsilon':'\\u03F5','varkappa':'\\u03F0','varnothing':'\\u2205','varphi':'\\u03D5','varpi':'\\u03D6','varpropto':'\\u221D','varr':'\\u2195','vArr':'\\u21D5','varrho':'\\u03F1','varsigma':'\\u03C2','varsubsetneq':'\\u228A\\uFE00','varsubsetneqq':'\\u2ACB\\uFE00','varsupsetneq':'\\u228B\\uFE00','varsupsetneqq':'\\u2ACC\\uFE00','vartheta':'\\u03D1','vartriangleleft':'\\u22B2','vartriangleright':'\\u22B3','vBar':'\\u2AE8','Vbar':'\\u2AEB','vBarv':'\\u2AE9','vcy':'\\u0432','Vcy':'\\u0412','vdash':'\\u22A2','vDash':'\\u22A8','Vdash':'\\u22A9','VDash':'\\u22AB','Vdashl':'\\u2AE6','vee':'\\u2228','Vee':'\\u22C1','veebar':'\\u22BB','veeeq':'\\u225A','vellip':'\\u22EE','verbar':'|','Verbar':'\\u2016','vert':'|','Vert':'\\u2016','VerticalBar':'\\u2223','VerticalLine':'|','VerticalSeparator':'\\u2758','VerticalTilde':'\\u2240','VeryThinSpace':'\\u200A','vfr':'\\uD835\\uDD33','Vfr':'\\uD835\\uDD19','vltri':'\\u22B2','vnsub':'\\u2282\\u20D2','vnsup':'\\u2283\\u20D2','vopf':'\\uD835\\uDD67','Vopf':'\\uD835\\uDD4D','vprop':'\\u221D','vrtri':'\\u22B3','vscr':'\\uD835\\uDCCB','Vscr':'\\uD835\\uDCB1','vsubne':'\\u228A\\uFE00','vsubnE':'\\u2ACB\\uFE00','vsupne':'\\u228B\\uFE00','vsupnE':'\\u2ACC\\uFE00','Vvdash':'\\u22AA','vzigzag':'\\u299A','wcirc':'\\u0175','Wcirc':'\\u0174','wedbar':'\\u2A5F','wedge':'\\u2227','Wedge':'\\u22C0','wedgeq':'\\u2259','weierp':'\\u2118','wfr':'\\uD835\\uDD34','Wfr':'\\uD835\\uDD1A','wopf':'\\uD835\\uDD68','Wopf':'\\uD835\\uDD4E','wp':'\\u2118','wr':'\\u2240','wreath':'\\u2240','wscr':'\\uD835\\uDCCC','Wscr':'\\uD835\\uDCB2','xcap':'\\u22C2','xcirc':'\\u25EF','xcup':'\\u22C3','xdtri':'\\u25BD','xfr':'\\uD835\\uDD35','Xfr':'\\uD835\\uDD1B','xharr':'\\u27F7','xhArr':'\\u27FA','xi':'\\u03BE','Xi':'\\u039E','xlarr':'\\u27F5','xlArr':'\\u27F8','xmap':'\\u27FC','xnis':'\\u22FB','xodot':'\\u2A00','xopf':'\\uD835\\uDD69','Xopf':'\\uD835\\uDD4F','xoplus':'\\u2A01','xotime':'\\u2A02','xrarr':'\\u27F6','xrArr':'\\u27F9','xscr':'\\uD835\\uDCCD','Xscr':'\\uD835\\uDCB3','xsqcup':'\\u2A06','xuplus':'\\u2A04','xutri':'\\u25B3','xvee':'\\u22C1','xwedge':'\\u22C0','yacute':'\\xFD','Yacute':'\\xDD','yacy':'\\u044F','YAcy':'\\u042F','ycirc':'\\u0177','Ycirc':'\\u0176','ycy':'\\u044B','Ycy':'\\u042B','yen':'\\xA5','yfr':'\\uD835\\uDD36','Yfr':'\\uD835\\uDD1C','yicy':'\\u0457','YIcy':'\\u0407','yopf':'\\uD835\\uDD6A','Yopf':'\\uD835\\uDD50','yscr':'\\uD835\\uDCCE','Yscr':'\\uD835\\uDCB4','yucy':'\\u044E','YUcy':'\\u042E','yuml':'\\xFF','Yuml':'\\u0178','zacute':'\\u017A','Zacute':'\\u0179','zcaron':'\\u017E','Zcaron':'\\u017D','zcy':'\\u0437','Zcy':'\\u0417','zdot':'\\u017C','Zdot':'\\u017B','zeetrf':'\\u2128','ZeroWidthSpace':'\\u200B','zeta':'\\u03B6','Zeta':'\\u0396','zfr':'\\uD835\\uDD37','Zfr':'\\u2128','zhcy':'\\u0436','ZHcy':'\\u0416','zigrarr':'\\u21DD','zopf':'\\uD835\\uDD6B','Zopf':'\\u2124','zscr':'\\uD835\\uDCCF','Zscr':'\\uD835\\uDCB5','zwj':'\\u200D','zwnj':'\\u200C'};\n\tvar decodeMapLegacy = {'aacute':'\\xE1','Aacute':'\\xC1','acirc':'\\xE2','Acirc':'\\xC2','acute':'\\xB4','aelig':'\\xE6','AElig':'\\xC6','agrave':'\\xE0','Agrave':'\\xC0','amp':'&','AMP':'&','aring':'\\xE5','Aring':'\\xC5','atilde':'\\xE3','Atilde':'\\xC3','auml':'\\xE4','Auml':'\\xC4','brvbar':'\\xA6','ccedil':'\\xE7','Ccedil':'\\xC7','cedil':'\\xB8','cent':'\\xA2','copy':'\\xA9','COPY':'\\xA9','curren':'\\xA4','deg':'\\xB0','divide':'\\xF7','eacute':'\\xE9','Eacute':'\\xC9','ecirc':'\\xEA','Ecirc':'\\xCA','egrave':'\\xE8','Egrave':'\\xC8','eth':'\\xF0','ETH':'\\xD0','euml':'\\xEB','Euml':'\\xCB','frac12':'\\xBD','frac14':'\\xBC','frac34':'\\xBE','gt':'>','GT':'>','iacute':'\\xED','Iacute':'\\xCD','icirc':'\\xEE','Icirc':'\\xCE','iexcl':'\\xA1','igrave':'\\xEC','Igrave':'\\xCC','iquest':'\\xBF','iuml':'\\xEF','Iuml':'\\xCF','laquo':'\\xAB','lt':'<','LT':'<','macr':'\\xAF','micro':'\\xB5','middot':'\\xB7','nbsp':'\\xA0','not':'\\xAC','ntilde':'\\xF1','Ntilde':'\\xD1','oacute':'\\xF3','Oacute':'\\xD3','ocirc':'\\xF4','Ocirc':'\\xD4','ograve':'\\xF2','Ograve':'\\xD2','ordf':'\\xAA','ordm':'\\xBA','oslash':'\\xF8','Oslash':'\\xD8','otilde':'\\xF5','Otilde':'\\xD5','ouml':'\\xF6','Ouml':'\\xD6','para':'\\xB6','plusmn':'\\xB1','pound':'\\xA3','quot':'\"','QUOT':'\"','raquo':'\\xBB','reg':'\\xAE','REG':'\\xAE','sect':'\\xA7','shy':'\\xAD','sup1':'\\xB9','sup2':'\\xB2','sup3':'\\xB3','szlig':'\\xDF','thorn':'\\xFE','THORN':'\\xDE','times':'\\xD7','uacute':'\\xFA','Uacute':'\\xDA','ucirc':'\\xFB','Ucirc':'\\xDB','ugrave':'\\xF9','Ugrave':'\\xD9','uml':'\\xA8','uuml':'\\xFC','Uuml':'\\xDC','yacute':'\\xFD','Yacute':'\\xDD','yen':'\\xA5','yuml':'\\xFF'};\n\tvar decodeMapNumeric = {'0':'\\uFFFD','128':'\\u20AC','130':'\\u201A','131':'\\u0192','132':'\\u201E','133':'\\u2026','134':'\\u2020','135':'\\u2021','136':'\\u02C6','137':'\\u2030','138':'\\u0160','139':'\\u2039','140':'\\u0152','142':'\\u017D','145':'\\u2018','146':'\\u2019','147':'\\u201C','148':'\\u201D','149':'\\u2022','150':'\\u2013','151':'\\u2014','152':'\\u02DC','153':'\\u2122','154':'\\u0161','155':'\\u203A','156':'\\u0153','158':'\\u017E','159':'\\u0178'};\n\tvar invalidReferenceCodePoints = [1,2,3,4,5,6,7,8,11,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,64976,64977,64978,64979,64980,64981,64982,64983,64984,64985,64986,64987,64988,64989,64990,64991,64992,64993,64994,64995,64996,64997,64998,64999,65000,65001,65002,65003,65004,65005,65006,65007,65534,65535,131070,131071,196606,196607,262142,262143,327678,327679,393214,393215,458750,458751,524286,524287,589822,589823,655358,655359,720894,720895,786430,786431,851966,851967,917502,917503,983038,983039,1048574,1048575,1114110,1114111];\n\n\t/*--------------------------------------------------------------------------*/\n\n\tvar stringFromCharCode = String.fromCharCode;\n\n\tvar object = {};\n\tvar hasOwnProperty = object.hasOwnProperty;\n\tvar has = function(object, propertyName) {\n\t\treturn hasOwnProperty.call(object, propertyName);\n\t};\n\n\tvar contains = function(array, value) {\n\t\tvar index = -1;\n\t\tvar length = array.length;\n\t\twhile (++index < length) {\n\t\t\tif (array[index] == value) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t};\n\n\tvar merge = function(options, defaults) {\n\t\tif (!options) {\n\t\t\treturn defaults;\n\t\t}\n\t\tvar result = {};\n\t\tvar key;\n\t\tfor (key in defaults) {\n\t\t\t// A `hasOwnProperty` check is not needed here, since only recognized\n\t\t\t// option names are used anyway. Any others are ignored.\n\t\t\tresult[key] = has(options, key) ? options[key] : defaults[key];\n\t\t}\n\t\treturn result;\n\t};\n\n\t// Modified version of `ucs2encode`; see https://mths.be/punycode.\n\tvar codePointToSymbol = function(codePoint, strict) {\n\t\tvar output = '';\n\t\tif ((codePoint >= 0xD800 && codePoint <= 0xDFFF) || codePoint > 0x10FFFF) {\n\t\t\t// See issue #4:\n\t\t\t// “Otherwise, if the number is in the range 0xD800 to 0xDFFF or is\n\t\t\t// greater than 0x10FFFF, then this is a parse error. Return a U+FFFD\n\t\t\t// REPLACEMENT CHARACTER.”\n\t\t\tif (strict) {\n\t\t\t\tparseError('character reference outside the permissible Unicode range');\n\t\t\t}\n\t\t\treturn '\\uFFFD';\n\t\t}\n\t\tif (has(decodeMapNumeric, codePoint)) {\n\t\t\tif (strict) {\n\t\t\t\tparseError('disallowed character reference');\n\t\t\t}\n\t\t\treturn decodeMapNumeric[codePoint];\n\t\t}\n\t\tif (strict && contains(invalidReferenceCodePoints, codePoint)) {\n\t\t\tparseError('disallowed character reference');\n\t\t}\n\t\tif (codePoint > 0xFFFF) {\n\t\t\tcodePoint -= 0x10000;\n\t\t\toutput += stringFromCharCode(codePoint >>> 10 & 0x3FF | 0xD800);\n\t\t\tcodePoint = 0xDC00 | codePoint & 0x3FF;\n\t\t}\n\t\toutput += stringFromCharCode(codePoint);\n\t\treturn output;\n\t};\n\n\tvar hexEscape = function(codePoint) {\n\t\treturn '&#x' + codePoint.toString(16).toUpperCase() + ';';\n\t};\n\n\tvar decEscape = function(codePoint) {\n\t\treturn '&#' + codePoint + ';';\n\t};\n\n\tvar parseError = function(message) {\n\t\tthrow Error('Parse error: ' + message);\n\t};\n\n\t/*--------------------------------------------------------------------------*/\n\n\tvar encode = function(string, options) {\n\t\toptions = merge(options, encode.options);\n\t\tvar strict = options.strict;\n\t\tif (strict && regexInvalidRawCodePoint.test(string)) {\n\t\t\tparseError('forbidden code point');\n\t\t}\n\t\tvar encodeEverything = options.encodeEverything;\n\t\tvar useNamedReferences = options.useNamedReferences;\n\t\tvar allowUnsafeSymbols = options.allowUnsafeSymbols;\n\t\tvar escapeCodePoint = options.decimal ? decEscape : hexEscape;\n\n\t\tvar escapeBmpSymbol = function(symbol) {\n\t\t\treturn escapeCodePoint(symbol.charCodeAt(0));\n\t\t};\n\n\t\tif (encodeEverything) {\n\t\t\t// Encode ASCII symbols.\n\t\t\tstring = string.replace(regexAsciiWhitelist, function(symbol) {\n\t\t\t\t// Use named references if requested & possible.\n\t\t\t\tif (useNamedReferences && has(encodeMap, symbol)) {\n\t\t\t\t\treturn '&' + encodeMap[symbol] + ';';\n\t\t\t\t}\n\t\t\t\treturn escapeBmpSymbol(symbol);\n\t\t\t});\n\t\t\t// Shorten a few escapes that represent two symbols, of which at least one\n\t\t\t// is within the ASCII range.\n\t\t\tif (useNamedReferences) {\n\t\t\t\tstring = string\n\t\t\t\t\t.replace(/&gt;\\u20D2/g, '&nvgt;')\n\t\t\t\t\t.replace(/&lt;\\u20D2/g, '&nvlt;')\n\t\t\t\t\t.replace(/&#x66;&#x6A;/g, '&fjlig;');\n\t\t\t}\n\t\t\t// Encode non-ASCII symbols.\n\t\t\tif (useNamedReferences) {\n\t\t\t\t// Encode non-ASCII symbols that can be replaced with a named reference.\n\t\t\t\tstring = string.replace(regexEncodeNonAscii, function(string) {\n\t\t\t\t\t// Note: there is no need to check `has(encodeMap, string)` here.\n\t\t\t\t\treturn '&' + encodeMap[string] + ';';\n\t\t\t\t});\n\t\t\t}\n\t\t\t// Note: any remaining non-ASCII symbols are handled outside of the `if`.\n\t\t} else if (useNamedReferences) {\n\t\t\t// Apply named character references.\n\t\t\t// Encode `<>\"'&` using named character references.\n\t\t\tif (!allowUnsafeSymbols) {\n\t\t\t\tstring = string.replace(regexEscape, function(string) {\n\t\t\t\t\treturn '&' + encodeMap[string] + ';'; // no need to check `has()` here\n\t\t\t\t});\n\t\t\t}\n\t\t\t// Shorten escapes that represent two symbols, of which at least one is\n\t\t\t// `<>\"'&`.\n\t\t\tstring = string\n\t\t\t\t.replace(/&gt;\\u20D2/g, '&nvgt;')\n\t\t\t\t.replace(/&lt;\\u20D2/g, '&nvlt;');\n\t\t\t// Encode non-ASCII symbols that can be replaced with a named reference.\n\t\t\tstring = string.replace(regexEncodeNonAscii, function(string) {\n\t\t\t\t// Note: there is no need to check `has(encodeMap, string)` here.\n\t\t\t\treturn '&' + encodeMap[string] + ';';\n\t\t\t});\n\t\t} else if (!allowUnsafeSymbols) {\n\t\t\t// Encode `<>\"'&` using hexadecimal escapes, now that they’re not handled\n\t\t\t// using named character references.\n\t\t\tstring = string.replace(regexEscape, escapeBmpSymbol);\n\t\t}\n\t\treturn string\n\t\t\t// Encode astral symbols.\n\t\t\t.replace(regexAstralSymbols, function($0) {\n\t\t\t\t// https://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae\n\t\t\t\tvar high = $0.charCodeAt(0);\n\t\t\t\tvar low = $0.charCodeAt(1);\n\t\t\t\tvar codePoint = (high - 0xD800) * 0x400 + low - 0xDC00 + 0x10000;\n\t\t\t\treturn escapeCodePoint(codePoint);\n\t\t\t})\n\t\t\t// Encode any remaining BMP symbols that are not printable ASCII symbols\n\t\t\t// using a hexadecimal escape.\n\t\t\t.replace(regexBmpWhitelist, escapeBmpSymbol);\n\t};\n\t// Expose default options (so they can be overridden globally).\n\tencode.options = {\n\t\t'allowUnsafeSymbols': false,\n\t\t'encodeEverything': false,\n\t\t'strict': false,\n\t\t'useNamedReferences': false,\n\t\t'decimal' : false\n\t};\n\n\tvar decode = function(html, options) {\n\t\toptions = merge(options, decode.options);\n\t\tvar strict = options.strict;\n\t\tif (strict && regexInvalidEntity.test(html)) {\n\t\t\tparseError('malformed character reference');\n\t\t}\n\t\treturn html.replace(regexDecode, function($0, $1, $2, $3, $4, $5, $6, $7) {\n\t\t\tvar codePoint;\n\t\t\tvar semicolon;\n\t\t\tvar decDigits;\n\t\t\tvar hexDigits;\n\t\t\tvar reference;\n\t\t\tvar next;\n\t\t\tif ($1) {\n\t\t\t\t// Decode decimal escapes, e.g. `&#119558;`.\n\t\t\t\tdecDigits = $1;\n\t\t\t\tsemicolon = $2;\n\t\t\t\tif (strict && !semicolon) {\n\t\t\t\t\tparseError('character reference was not terminated by a semicolon');\n\t\t\t\t}\n\t\t\t\tcodePoint = parseInt(decDigits, 10);\n\t\t\t\treturn codePointToSymbol(codePoint, strict);\n\t\t\t}\n\t\t\tif ($3) {\n\t\t\t\t// Decode hexadecimal escapes, e.g. `&#x1D306;`.\n\t\t\t\thexDigits = $3;\n\t\t\t\tsemicolon = $4;\n\t\t\t\tif (strict && !semicolon) {\n\t\t\t\t\tparseError('character reference was not terminated by a semicolon');\n\t\t\t\t}\n\t\t\t\tcodePoint = parseInt(hexDigits, 16);\n\t\t\t\treturn codePointToSymbol(codePoint, strict);\n\t\t\t}\n\t\t\tif ($5) {\n\t\t\t\t// Decode named character references with trailing `;`, e.g. `&copy;`.\n\t\t\t\treference = $5;\n\t\t\t\tif (has(decodeMap, reference)) {\n\t\t\t\t\treturn decodeMap[reference];\n\t\t\t\t} else {\n\t\t\t\t\t// Ambiguous ampersand. https://mths.be/notes/ambiguous-ampersands\n\t\t\t\t\tif (strict) {\n\t\t\t\t\t\tparseError(\n\t\t\t\t\t\t\t'named character reference was not terminated by a semicolon'\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t\treturn $0;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// If we’re still here, it’s a legacy reference for sure. No need for an\n\t\t\t// extra `if` check.\n\t\t\t// Decode named character references without trailing `;`, e.g. `&amp`\n\t\t\t// This is only a parse error if it gets converted to `&`, or if it is\n\t\t\t// followed by `=` in an attribute context.\n\t\t\treference = $6;\n\t\t\tnext = $7;\n\t\t\tif (next && options.isAttributeValue) {\n\t\t\t\tif (strict && next == '=') {\n\t\t\t\t\tparseError('`&` did not start a character reference');\n\t\t\t\t}\n\t\t\t\treturn $0;\n\t\t\t} else {\n\t\t\t\tif (strict) {\n\t\t\t\t\tparseError(\n\t\t\t\t\t\t'named character reference was not terminated by a semicolon'\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\t// Note: there is no need to check `has(decodeMapLegacy, reference)`.\n\t\t\t\treturn decodeMapLegacy[reference] + (next || '');\n\t\t\t}\n\t\t});\n\t};\n\t// Expose default options (so they can be overridden globally).\n\tdecode.options = {\n\t\t'isAttributeValue': false,\n\t\t'strict': false\n\t};\n\n\tvar escape = function(string) {\n\t\treturn string.replace(regexEscape, function($0) {\n\t\t\t// Note: there is no need to check `has(escapeMap, $0)` here.\n\t\t\treturn escapeMap[$0];\n\t\t});\n\t};\n\n\t/*--------------------------------------------------------------------------*/\n\n\tvar he = {\n\t\t'version': '1.1.1',\n\t\t'encode': encode,\n\t\t'decode': decode,\n\t\t'escape': escape,\n\t\t'unescape': decode\n\t};\n\n\t// Some AMD build optimizers, like r.js, check for specific condition patterns\n\t// like the following:\n\tif (\n\t\tfalse\n\t) {\n\t\tdefine(function() {\n\t\t\treturn he;\n\t\t});\n\t}\telse if (freeExports && !freeExports.nodeType) {\n\t\tif (freeModule) { // in Node.js, io.js, or RingoJS v0.8.0+\n\t\t\tfreeModule.exports = he;\n\t\t} else { // in Narwhal or RingoJS v0.7.0-\n\t\t\tfor (var key in he) {\n\t\t\t\thas(he, key) && (freeExports[key] = he[key]);\n\t\t\t}\n\t\t}\n\t} else { // in Rhino or a web browser\n\t\troot.he = he;\n\t}\n\n}(this));\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n},{}],65:[function(require,module,exports){\nexports.read = function (buffer, offset, isLE, mLen, nBytes) {\n  var e, m\n  var eLen = nBytes * 8 - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var nBits = -7\n  var i = isLE ? (nBytes - 1) : 0\n  var d = isLE ? -1 : 1\n  var s = buffer[offset + i]\n\n  i += d\n\n  e = s & ((1 << (-nBits)) - 1)\n  s >>= (-nBits)\n  nBits += eLen\n  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}\n\n  m = e & ((1 << (-nBits)) - 1)\n  e >>= (-nBits)\n  nBits += mLen\n  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}\n\n  if (e === 0) {\n    e = 1 - eBias\n  } else if (e === eMax) {\n    return m ? NaN : ((s ? -1 : 1) * Infinity)\n  } else {\n    m = m + Math.pow(2, mLen)\n    e = e - eBias\n  }\n  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)\n}\n\nexports.write = function (buffer, value, offset, isLE, mLen, nBytes) {\n  var e, m, c\n  var eLen = nBytes * 8 - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)\n  var i = isLE ? 0 : (nBytes - 1)\n  var d = isLE ? 1 : -1\n  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0\n\n  value = Math.abs(value)\n\n  if (isNaN(value) || value === Infinity) {\n    m = isNaN(value) ? 1 : 0\n    e = eMax\n  } else {\n    e = Math.floor(Math.log(value) / Math.LN2)\n    if (value * (c = Math.pow(2, -e)) < 1) {\n      e--\n      c *= 2\n    }\n    if (e + eBias >= 1) {\n      value += rt / c\n    } else {\n      value += rt * Math.pow(2, 1 - eBias)\n    }\n    if (value * c >= 2) {\n      e++\n      c /= 2\n    }\n\n    if (e + eBias >= eMax) {\n      m = 0\n      e = eMax\n    } else if (e + eBias >= 1) {\n      m = (value * c - 1) * Math.pow(2, mLen)\n      e = e + eBias\n    } else {\n      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)\n      e = 0\n    }\n  }\n\n  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\n\n  e = (e << mLen) | m\n  eLen += mLen\n  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\n\n  buffer[offset + i - d] |= s * 128\n}\n\n},{}],66:[function(require,module,exports){\nif (typeof Object.create === 'function') {\n  // implementation from standard node.js 'util' module\n  module.exports = function inherits(ctor, superCtor) {\n    ctor.super_ = superCtor\n    ctor.prototype = Object.create(superCtor.prototype, {\n      constructor: {\n        value: ctor,\n        enumerable: false,\n        writable: true,\n        configurable: true\n      }\n    });\n  };\n} else {\n  // old school shim for old browsers\n  module.exports = function inherits(ctor, superCtor) {\n    ctor.super_ = superCtor\n    var TempCtor = function () {}\n    TempCtor.prototype = superCtor.prototype\n    ctor.prototype = new TempCtor()\n    ctor.prototype.constructor = ctor\n  }\n}\n\n},{}],67:[function(require,module,exports){\n/*!\n * Determine if an object is a Buffer\n *\n * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>\n * @license  MIT\n */\n\n// The _isBuffer check is for Safari 5-7 support, because it's missing\n// Object.prototype.constructor. Remove this eventually\nmodule.exports = function (obj) {\n  return obj != null && (isBuffer(obj) || isSlowBuffer(obj) || !!obj._isBuffer)\n}\n\nfunction isBuffer (obj) {\n  return !!obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj)\n}\n\n// For Node v0.10 support. Remove this eventually.\nfunction isSlowBuffer (obj) {\n  return typeof obj.readFloatLE === 'function' && typeof obj.slice === 'function' && isBuffer(obj.slice(0, 0))\n}\n\n},{}],68:[function(require,module,exports){\nvar toString = {}.toString;\n\nmodule.exports = Array.isArray || function (arr) {\n  return toString.call(arr) == '[object Array]';\n};\n\n},{}],69:[function(require,module,exports){\n(function (global){\n/*! JSON v3.3.2 | http://bestiejs.github.io/json3 | Copyright 2012-2014, Kit Cambridge | http://kit.mit-license.org */\n;(function () {\n  // Detect the `define` function exposed by asynchronous module loaders. The\n  // strict `define` check is necessary for compatibility with `r.js`.\n  var isLoader = false;\n\n  // A set of types used to distinguish objects from primitives.\n  var objectTypes = {\n    \"function\": true,\n    \"object\": true\n  };\n\n  // Detect the `exports` object exposed by CommonJS implementations.\n  var freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports;\n\n  // Use the `global` object exposed by Node (including Browserify via\n  // `insert-module-globals`), Narwhal, and Ringo as the default context,\n  // and the `window` object in browsers. Rhino exports a `global` function\n  // instead.\n  var root = objectTypes[typeof window] && window || this,\n      freeGlobal = freeExports && objectTypes[typeof module] && module && !module.nodeType && typeof global == \"object\" && global;\n\n  if (freeGlobal && (freeGlobal[\"global\"] === freeGlobal || freeGlobal[\"window\"] === freeGlobal || freeGlobal[\"self\"] === freeGlobal)) {\n    root = freeGlobal;\n  }\n\n  // Public: Initializes JSON 3 using the given `context` object, attaching the\n  // `stringify` and `parse` functions to the specified `exports` object.\n  function runInContext(context, exports) {\n    context || (context = root[\"Object\"]());\n    exports || (exports = root[\"Object\"]());\n\n    // Native constructor aliases.\n    var Number = context[\"Number\"] || root[\"Number\"],\n        String = context[\"String\"] || root[\"String\"],\n        Object = context[\"Object\"] || root[\"Object\"],\n        Date = context[\"Date\"] || root[\"Date\"],\n        SyntaxError = context[\"SyntaxError\"] || root[\"SyntaxError\"],\n        TypeError = context[\"TypeError\"] || root[\"TypeError\"],\n        Math = context[\"Math\"] || root[\"Math\"],\n        nativeJSON = context[\"JSON\"] || root[\"JSON\"];\n\n    // Delegate to the native `stringify` and `parse` implementations.\n    if (typeof nativeJSON == \"object\" && nativeJSON) {\n      exports.stringify = nativeJSON.stringify;\n      exports.parse = nativeJSON.parse;\n    }\n\n    // Convenience aliases.\n    var objectProto = Object.prototype,\n        getClass = objectProto.toString,\n        isProperty, forEach, undef;\n\n    // Test the `Date#getUTC*` methods. Based on work by @Yaffle.\n    var isExtended = new Date(-3509827334573292);\n    try {\n      // The `getUTCFullYear`, `Month`, and `Date` methods return nonsensical\n      // results for certain dates in Opera >= 10.53.\n      isExtended = isExtended.getUTCFullYear() == -109252 && isExtended.getUTCMonth() === 0 && isExtended.getUTCDate() === 1 &&\n        // Safari < 2.0.2 stores the internal millisecond time value correctly,\n        // but clips the values returned by the date methods to the range of\n        // signed 32-bit integers ([-2 ** 31, 2 ** 31 - 1]).\n        isExtended.getUTCHours() == 10 && isExtended.getUTCMinutes() == 37 && isExtended.getUTCSeconds() == 6 && isExtended.getUTCMilliseconds() == 708;\n    } catch (exception) {}\n\n    // Internal: Determines whether the native `JSON.stringify` and `parse`\n    // implementations are spec-compliant. Based on work by Ken Snyder.\n    function has(name) {\n      if (has[name] !== undef) {\n        // Return cached feature test result.\n        return has[name];\n      }\n      var isSupported;\n      if (name == \"bug-string-char-index\") {\n        // IE <= 7 doesn't support accessing string characters using square\n        // bracket notation. IE 8 only supports this for primitives.\n        isSupported = \"a\"[0] != \"a\";\n      } else if (name == \"json\") {\n        // Indicates whether both `JSON.stringify` and `JSON.parse` are\n        // supported.\n        isSupported = has(\"json-stringify\") && has(\"json-parse\");\n      } else {\n        var value, serialized = '{\"a\":[1,true,false,null,\"\\\\u0000\\\\b\\\\n\\\\f\\\\r\\\\t\"]}';\n        // Test `JSON.stringify`.\n        if (name == \"json-stringify\") {\n          var stringify = exports.stringify, stringifySupported = typeof stringify == \"function\" && isExtended;\n          if (stringifySupported) {\n            // A test function object with a custom `toJSON` method.\n            (value = function () {\n              return 1;\n            }).toJSON = value;\n            try {\n              stringifySupported =\n                // Firefox 3.1b1 and b2 serialize string, number, and boolean\n                // primitives as object literals.\n                stringify(0) === \"0\" &&\n                // FF 3.1b1, b2, and JSON 2 serialize wrapped primitives as object\n                // literals.\n                stringify(new Number()) === \"0\" &&\n                stringify(new String()) == '\"\"' &&\n                // FF 3.1b1, 2 throw an error if the value is `null`, `undefined`, or\n                // does not define a canonical JSON representation (this applies to\n                // objects with `toJSON` properties as well, *unless* they are nested\n                // within an object or array).\n                stringify(getClass) === undef &&\n                // IE 8 serializes `undefined` as `\"undefined\"`. Safari <= 5.1.7 and\n                // FF 3.1b3 pass this test.\n                stringify(undef) === undef &&\n                // Safari <= 5.1.7 and FF 3.1b3 throw `Error`s and `TypeError`s,\n                // respectively, if the value is omitted entirely.\n                stringify() === undef &&\n                // FF 3.1b1, 2 throw an error if the given value is not a number,\n                // string, array, object, Boolean, or `null` literal. This applies to\n                // objects with custom `toJSON` methods as well, unless they are nested\n                // inside object or array literals. YUI 3.0.0b1 ignores custom `toJSON`\n                // methods entirely.\n                stringify(value) === \"1\" &&\n                stringify([value]) == \"[1]\" &&\n                // Prototype <= 1.6.1 serializes `[undefined]` as `\"[]\"` instead of\n                // `\"[null]\"`.\n                stringify([undef]) == \"[null]\" &&\n                // YUI 3.0.0b1 fails to serialize `null` literals.\n                stringify(null) == \"null\" &&\n                // FF 3.1b1, 2 halts serialization if an array contains a function:\n                // `[1, true, getClass, 1]` serializes as \"[1,true,],\". FF 3.1b3\n                // elides non-JSON values from objects and arrays, unless they\n                // define custom `toJSON` methods.\n                stringify([undef, getClass, null]) == \"[null,null,null]\" &&\n                // Simple serialization test. FF 3.1b1 uses Unicode escape sequences\n                // where character escape codes are expected (e.g., `\\b` => `\\u0008`).\n                stringify({ \"a\": [value, true, false, null, \"\\x00\\b\\n\\f\\r\\t\"] }) == serialized &&\n                // FF 3.1b1 and b2 ignore the `filter` and `width` arguments.\n                stringify(null, value) === \"1\" &&\n                stringify([1, 2], null, 1) == \"[\\n 1,\\n 2\\n]\" &&\n                // JSON 2, Prototype <= 1.7, and older WebKit builds incorrectly\n                // serialize extended years.\n                stringify(new Date(-8.64e15)) == '\"-271821-04-20T00:00:00.000Z\"' &&\n                // The milliseconds are optional in ES 5, but required in 5.1.\n                stringify(new Date(8.64e15)) == '\"+275760-09-13T00:00:00.000Z\"' &&\n                // Firefox <= 11.0 incorrectly serializes years prior to 0 as negative\n                // four-digit years instead of six-digit years. Credits: @Yaffle.\n                stringify(new Date(-621987552e5)) == '\"-000001-01-01T00:00:00.000Z\"' &&\n                // Safari <= 5.1.5 and Opera >= 10.53 incorrectly serialize millisecond\n                // values less than 1000. Credits: @Yaffle.\n                stringify(new Date(-1)) == '\"1969-12-31T23:59:59.999Z\"';\n            } catch (exception) {\n              stringifySupported = false;\n            }\n          }\n          isSupported = stringifySupported;\n        }\n        // Test `JSON.parse`.\n        if (name == \"json-parse\") {\n          var parse = exports.parse;\n          if (typeof parse == \"function\") {\n            try {\n              // FF 3.1b1, b2 will throw an exception if a bare literal is provided.\n              // Conforming implementations should also coerce the initial argument to\n              // a string prior to parsing.\n              if (parse(\"0\") === 0 && !parse(false)) {\n                // Simple parsing test.\n                value = parse(serialized);\n                var parseSupported = value[\"a\"].length == 5 && value[\"a\"][0] === 1;\n                if (parseSupported) {\n                  try {\n                    // Safari <= 5.1.2 and FF 3.1b1 allow unescaped tabs in strings.\n                    parseSupported = !parse('\"\\t\"');\n                  } catch (exception) {}\n                  if (parseSupported) {\n                    try {\n                      // FF 4.0 and 4.0.1 allow leading `+` signs and leading\n                      // decimal points. FF 4.0, 4.0.1, and IE 9-10 also allow\n                      // certain octal literals.\n                      parseSupported = parse(\"01\") !== 1;\n                    } catch (exception) {}\n                  }\n                  if (parseSupported) {\n                    try {\n                      // FF 4.0, 4.0.1, and Rhino 1.7R3-R4 allow trailing decimal\n                      // points. These environments, along with FF 3.1b1 and 2,\n                      // also allow trailing commas in JSON objects and arrays.\n                      parseSupported = parse(\"1.\") !== 1;\n                    } catch (exception) {}\n                  }\n                }\n              }\n            } catch (exception) {\n              parseSupported = false;\n            }\n          }\n          isSupported = parseSupported;\n        }\n      }\n      return has[name] = !!isSupported;\n    }\n\n    if (!has(\"json\")) {\n      // Common `[[Class]]` name aliases.\n      var functionClass = \"[object Function]\",\n          dateClass = \"[object Date]\",\n          numberClass = \"[object Number]\",\n          stringClass = \"[object String]\",\n          arrayClass = \"[object Array]\",\n          booleanClass = \"[object Boolean]\";\n\n      // Detect incomplete support for accessing string characters by index.\n      var charIndexBuggy = has(\"bug-string-char-index\");\n\n      // Define additional utility methods if the `Date` methods are buggy.\n      if (!isExtended) {\n        var floor = Math.floor;\n        // A mapping between the months of the year and the number of days between\n        // January 1st and the first of the respective month.\n        var Months = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334];\n        // Internal: Calculates the number of days between the Unix epoch and the\n        // first day of the given month.\n        var getDay = function (year, month) {\n          return Months[month] + 365 * (year - 1970) + floor((year - 1969 + (month = +(month > 1))) / 4) - floor((year - 1901 + month) / 100) + floor((year - 1601 + month) / 400);\n        };\n      }\n\n      // Internal: Determines if a property is a direct property of the given\n      // object. Delegates to the native `Object#hasOwnProperty` method.\n      if (!(isProperty = objectProto.hasOwnProperty)) {\n        isProperty = function (property) {\n          var members = {}, constructor;\n          if ((members.__proto__ = null, members.__proto__ = {\n            // The *proto* property cannot be set multiple times in recent\n            // versions of Firefox and SeaMonkey.\n            \"toString\": 1\n          }, members).toString != getClass) {\n            // Safari <= 2.0.3 doesn't implement `Object#hasOwnProperty`, but\n            // supports the mutable *proto* property.\n            isProperty = function (property) {\n              // Capture and break the object's prototype chain (see section 8.6.2\n              // of the ES 5.1 spec). The parenthesized expression prevents an\n              // unsafe transformation by the Closure Compiler.\n              var original = this.__proto__, result = property in (this.__proto__ = null, this);\n              // Restore the original prototype chain.\n              this.__proto__ = original;\n              return result;\n            };\n          } else {\n            // Capture a reference to the top-level `Object` constructor.\n            constructor = members.constructor;\n            // Use the `constructor` property to simulate `Object#hasOwnProperty` in\n            // other environments.\n            isProperty = function (property) {\n              var parent = (this.constructor || constructor).prototype;\n              return property in this && !(property in parent && this[property] === parent[property]);\n            };\n          }\n          members = null;\n          return isProperty.call(this, property);\n        };\n      }\n\n      // Internal: Normalizes the `for...in` iteration algorithm across\n      // environments. Each enumerated key is yielded to a `callback` function.\n      forEach = function (object, callback) {\n        var size = 0, Properties, members, property;\n\n        // Tests for bugs in the current environment's `for...in` algorithm. The\n        // `valueOf` property inherits the non-enumerable flag from\n        // `Object.prototype` in older versions of IE, Netscape, and Mozilla.\n        (Properties = function () {\n          this.valueOf = 0;\n        }).prototype.valueOf = 0;\n\n        // Iterate over a new instance of the `Properties` class.\n        members = new Properties();\n        for (property in members) {\n          // Ignore all properties inherited from `Object.prototype`.\n          if (isProperty.call(members, property)) {\n            size++;\n          }\n        }\n        Properties = members = null;\n\n        // Normalize the iteration algorithm.\n        if (!size) {\n          // A list of non-enumerable properties inherited from `Object.prototype`.\n          members = [\"valueOf\", \"toString\", \"toLocaleString\", \"propertyIsEnumerable\", \"isPrototypeOf\", \"hasOwnProperty\", \"constructor\"];\n          // IE <= 8, Mozilla 1.0, and Netscape 6.2 ignore shadowed non-enumerable\n          // properties.\n          forEach = function (object, callback) {\n            var isFunction = getClass.call(object) == functionClass, property, length;\n            var hasProperty = !isFunction && typeof object.constructor != \"function\" && objectTypes[typeof object.hasOwnProperty] && object.hasOwnProperty || isProperty;\n            for (property in object) {\n              // Gecko <= 1.0 enumerates the `prototype` property of functions under\n              // certain conditions; IE does not.\n              if (!(isFunction && property == \"prototype\") && hasProperty.call(object, property)) {\n                callback(property);\n              }\n            }\n            // Manually invoke the callback for each non-enumerable property.\n            for (length = members.length; property = members[--length]; hasProperty.call(object, property) && callback(property));\n          };\n        } else if (size == 2) {\n          // Safari <= 2.0.4 enumerates shadowed properties twice.\n          forEach = function (object, callback) {\n            // Create a set of iterated properties.\n            var members = {}, isFunction = getClass.call(object) == functionClass, property;\n            for (property in object) {\n              // Store each property name to prevent double enumeration. The\n              // `prototype` property of functions is not enumerated due to cross-\n              // environment inconsistencies.\n              if (!(isFunction && property == \"prototype\") && !isProperty.call(members, property) && (members[property] = 1) && isProperty.call(object, property)) {\n                callback(property);\n              }\n            }\n          };\n        } else {\n          // No bugs detected; use the standard `for...in` algorithm.\n          forEach = function (object, callback) {\n            var isFunction = getClass.call(object) == functionClass, property, isConstructor;\n            for (property in object) {\n              if (!(isFunction && property == \"prototype\") && isProperty.call(object, property) && !(isConstructor = property === \"constructor\")) {\n                callback(property);\n              }\n            }\n            // Manually invoke the callback for the `constructor` property due to\n            // cross-environment inconsistencies.\n            if (isConstructor || isProperty.call(object, (property = \"constructor\"))) {\n              callback(property);\n            }\n          };\n        }\n        return forEach(object, callback);\n      };\n\n      // Public: Serializes a JavaScript `value` as a JSON string. The optional\n      // `filter` argument may specify either a function that alters how object and\n      // array members are serialized, or an array of strings and numbers that\n      // indicates which properties should be serialized. The optional `width`\n      // argument may be either a string or number that specifies the indentation\n      // level of the output.\n      if (!has(\"json-stringify\")) {\n        // Internal: A map of control characters and their escaped equivalents.\n        var Escapes = {\n          92: \"\\\\\\\\\",\n          34: '\\\\\"',\n          8: \"\\\\b\",\n          12: \"\\\\f\",\n          10: \"\\\\n\",\n          13: \"\\\\r\",\n          9: \"\\\\t\"\n        };\n\n        // Internal: Converts `value` into a zero-padded string such that its\n        // length is at least equal to `width`. The `width` must be <= 6.\n        var leadingZeroes = \"000000\";\n        var toPaddedString = function (width, value) {\n          // The `|| 0` expression is necessary to work around a bug in\n          // Opera <= 7.54u2 where `0 == -0`, but `String(-0) !== \"0\"`.\n          return (leadingZeroes + (value || 0)).slice(-width);\n        };\n\n        // Internal: Double-quotes a string `value`, replacing all ASCII control\n        // characters (characters with code unit values between 0 and 31) with\n        // their escaped equivalents. This is an implementation of the\n        // `Quote(value)` operation defined in ES 5.1 section 15.12.3.\n        var unicodePrefix = \"\\\\u00\";\n        var quote = function (value) {\n          var result = '\"', index = 0, length = value.length, useCharIndex = !charIndexBuggy || length > 10;\n          var symbols = useCharIndex && (charIndexBuggy ? value.split(\"\") : value);\n          for (; index < length; index++) {\n            var charCode = value.charCodeAt(index);\n            // If the character is a control character, append its Unicode or\n            // shorthand escape sequence; otherwise, append the character as-is.\n            switch (charCode) {\n              case 8: case 9: case 10: case 12: case 13: case 34: case 92:\n                result += Escapes[charCode];\n                break;\n              default:\n                if (charCode < 32) {\n                  result += unicodePrefix + toPaddedString(2, charCode.toString(16));\n                  break;\n                }\n                result += useCharIndex ? symbols[index] : value.charAt(index);\n            }\n          }\n          return result + '\"';\n        };\n\n        // Internal: Recursively serializes an object. Implements the\n        // `Str(key, holder)`, `JO(value)`, and `JA(value)` operations.\n        var serialize = function (property, object, callback, properties, whitespace, indentation, stack) {\n          var value, className, year, month, date, time, hours, minutes, seconds, milliseconds, results, element, index, length, prefix, result;\n          try {\n            // Necessary for host object support.\n            value = object[property];\n          } catch (exception) {}\n          if (typeof value == \"object\" && value) {\n            className = getClass.call(value);\n            if (className == dateClass && !isProperty.call(value, \"toJSON\")) {\n              if (value > -1 / 0 && value < 1 / 0) {\n                // Dates are serialized according to the `Date#toJSON` method\n                // specified in ES 5.1 section 15.9.5.44. See section 15.9.1.15\n                // for the ISO 8601 date time string format.\n                if (getDay) {\n                  // Manually compute the year, month, date, hours, minutes,\n                  // seconds, and milliseconds if the `getUTC*` methods are\n                  // buggy. Adapted from @Yaffle's `date-shim` project.\n                  date = floor(value / 864e5);\n                  for (year = floor(date / 365.2425) + 1970 - 1; getDay(year + 1, 0) <= date; year++);\n                  for (month = floor((date - getDay(year, 0)) / 30.42); getDay(year, month + 1) <= date; month++);\n                  date = 1 + date - getDay(year, month);\n                  // The `time` value specifies the time within the day (see ES\n                  // 5.1 section 15.9.1.2). The formula `(A % B + B) % B` is used\n                  // to compute `A modulo B`, as the `%` operator does not\n                  // correspond to the `modulo` operation for negative numbers.\n                  time = (value % 864e5 + 864e5) % 864e5;\n                  // The hours, minutes, seconds, and milliseconds are obtained by\n                  // decomposing the time within the day. See section 15.9.1.10.\n                  hours = floor(time / 36e5) % 24;\n                  minutes = floor(time / 6e4) % 60;\n                  seconds = floor(time / 1e3) % 60;\n                  milliseconds = time % 1e3;\n                } else {\n                  year = value.getUTCFullYear();\n                  month = value.getUTCMonth();\n                  date = value.getUTCDate();\n                  hours = value.getUTCHours();\n                  minutes = value.getUTCMinutes();\n                  seconds = value.getUTCSeconds();\n                  milliseconds = value.getUTCMilliseconds();\n                }\n                // Serialize extended years correctly.\n                value = (year <= 0 || year >= 1e4 ? (year < 0 ? \"-\" : \"+\") + toPaddedString(6, year < 0 ? -year : year) : toPaddedString(4, year)) +\n                  \"-\" + toPaddedString(2, month + 1) + \"-\" + toPaddedString(2, date) +\n                  // Months, dates, hours, minutes, and seconds should have two\n                  // digits; milliseconds should have three.\n                  \"T\" + toPaddedString(2, hours) + \":\" + toPaddedString(2, minutes) + \":\" + toPaddedString(2, seconds) +\n                  // Milliseconds are optional in ES 5.0, but required in 5.1.\n                  \".\" + toPaddedString(3, milliseconds) + \"Z\";\n              } else {\n                value = null;\n              }\n            } else if (typeof value.toJSON == \"function\" && ((className != numberClass && className != stringClass && className != arrayClass) || isProperty.call(value, \"toJSON\"))) {\n              // Prototype <= 1.6.1 adds non-standard `toJSON` methods to the\n              // `Number`, `String`, `Date`, and `Array` prototypes. JSON 3\n              // ignores all `toJSON` methods on these objects unless they are\n              // defined directly on an instance.\n              value = value.toJSON(property);\n            }\n          }\n          if (callback) {\n            // If a replacement function was provided, call it to obtain the value\n            // for serialization.\n            value = callback.call(object, property, value);\n          }\n          if (value === null) {\n            return \"null\";\n          }\n          className = getClass.call(value);\n          if (className == booleanClass) {\n            // Booleans are represented literally.\n            return \"\" + value;\n          } else if (className == numberClass) {\n            // JSON numbers must be finite. `Infinity` and `NaN` are serialized as\n            // `\"null\"`.\n            return value > -1 / 0 && value < 1 / 0 ? \"\" + value : \"null\";\n          } else if (className == stringClass) {\n            // Strings are double-quoted and escaped.\n            return quote(\"\" + value);\n          }\n          // Recursively serialize objects and arrays.\n          if (typeof value == \"object\") {\n            // Check for cyclic structures. This is a linear search; performance\n            // is inversely proportional to the number of unique nested objects.\n            for (length = stack.length; length--;) {\n              if (stack[length] === value) {\n                // Cyclic structures cannot be serialized by `JSON.stringify`.\n                throw TypeError();\n              }\n            }\n            // Add the object to the stack of traversed objects.\n            stack.push(value);\n            results = [];\n            // Save the current indentation level and indent one additional level.\n            prefix = indentation;\n            indentation += whitespace;\n            if (className == arrayClass) {\n              // Recursively serialize array elements.\n              for (index = 0, length = value.length; index < length; index++) {\n                element = serialize(index, value, callback, properties, whitespace, indentation, stack);\n                results.push(element === undef ? \"null\" : element);\n              }\n              result = results.length ? (whitespace ? \"[\\n\" + indentation + results.join(\",\\n\" + indentation) + \"\\n\" + prefix + \"]\" : (\"[\" + results.join(\",\") + \"]\")) : \"[]\";\n            } else {\n              // Recursively serialize object members. Members are selected from\n              // either a user-specified list of property names, or the object\n              // itself.\n              forEach(properties || value, function (property) {\n                var element = serialize(property, value, callback, properties, whitespace, indentation, stack);\n                if (element !== undef) {\n                  // According to ES 5.1 section 15.12.3: \"If `gap` {whitespace}\n                  // is not the empty string, let `member` {quote(property) + \":\"}\n                  // be the concatenation of `member` and the `space` character.\"\n                  // The \"`space` character\" refers to the literal space\n                  // character, not the `space` {width} argument provided to\n                  // `JSON.stringify`.\n                  results.push(quote(property) + \":\" + (whitespace ? \" \" : \"\") + element);\n                }\n              });\n              result = results.length ? (whitespace ? \"{\\n\" + indentation + results.join(\",\\n\" + indentation) + \"\\n\" + prefix + \"}\" : (\"{\" + results.join(\",\") + \"}\")) : \"{}\";\n            }\n            // Remove the object from the traversed object stack.\n            stack.pop();\n            return result;\n          }\n        };\n\n        // Public: `JSON.stringify`. See ES 5.1 section 15.12.3.\n        exports.stringify = function (source, filter, width) {\n          var whitespace, callback, properties, className;\n          if (objectTypes[typeof filter] && filter) {\n            if ((className = getClass.call(filter)) == functionClass) {\n              callback = filter;\n            } else if (className == arrayClass) {\n              // Convert the property names array into a makeshift set.\n              properties = {};\n              for (var index = 0, length = filter.length, value; index < length; value = filter[index++], ((className = getClass.call(value)), className == stringClass || className == numberClass) && (properties[value] = 1));\n            }\n          }\n          if (width) {\n            if ((className = getClass.call(width)) == numberClass) {\n              // Convert the `width` to an integer and create a string containing\n              // `width` number of space characters.\n              if ((width -= width % 1) > 0) {\n                for (whitespace = \"\", width > 10 && (width = 10); whitespace.length < width; whitespace += \" \");\n              }\n            } else if (className == stringClass) {\n              whitespace = width.length <= 10 ? width : width.slice(0, 10);\n            }\n          }\n          // Opera <= 7.54u2 discards the values associated with empty string keys\n          // (`\"\"`) only if they are used directly within an object member list\n          // (e.g., `!(\"\" in { \"\": 1})`).\n          return serialize(\"\", (value = {}, value[\"\"] = source, value), callback, properties, whitespace, \"\", []);\n        };\n      }\n\n      // Public: Parses a JSON source string.\n      if (!has(\"json-parse\")) {\n        var fromCharCode = String.fromCharCode;\n\n        // Internal: A map of escaped control characters and their unescaped\n        // equivalents.\n        var Unescapes = {\n          92: \"\\\\\",\n          34: '\"',\n          47: \"/\",\n          98: \"\\b\",\n          116: \"\\t\",\n          110: \"\\n\",\n          102: \"\\f\",\n          114: \"\\r\"\n        };\n\n        // Internal: Stores the parser state.\n        var Index, Source;\n\n        // Internal: Resets the parser state and throws a `SyntaxError`.\n        var abort = function () {\n          Index = Source = null;\n          throw SyntaxError();\n        };\n\n        // Internal: Returns the next token, or `\"$\"` if the parser has reached\n        // the end of the source string. A token may be a string, number, `null`\n        // literal, or Boolean literal.\n        var lex = function () {\n          var source = Source, length = source.length, value, begin, position, isSigned, charCode;\n          while (Index < length) {\n            charCode = source.charCodeAt(Index);\n            switch (charCode) {\n              case 9: case 10: case 13: case 32:\n                // Skip whitespace tokens, including tabs, carriage returns, line\n                // feeds, and space characters.\n                Index++;\n                break;\n              case 123: case 125: case 91: case 93: case 58: case 44:\n                // Parse a punctuator token (`{`, `}`, `[`, `]`, `:`, or `,`) at\n                // the current position.\n                value = charIndexBuggy ? source.charAt(Index) : source[Index];\n                Index++;\n                return value;\n              case 34:\n                // `\"` delimits a JSON string; advance to the next character and\n                // begin parsing the string. String tokens are prefixed with the\n                // sentinel `@` character to distinguish them from punctuators and\n                // end-of-string tokens.\n                for (value = \"@\", Index++; Index < length;) {\n                  charCode = source.charCodeAt(Index);\n                  if (charCode < 32) {\n                    // Unescaped ASCII control characters (those with a code unit\n                    // less than the space character) are not permitted.\n                    abort();\n                  } else if (charCode == 92) {\n                    // A reverse solidus (`\\`) marks the beginning of an escaped\n                    // control character (including `\"`, `\\`, and `/`) or Unicode\n                    // escape sequence.\n                    charCode = source.charCodeAt(++Index);\n                    switch (charCode) {\n                      case 92: case 34: case 47: case 98: case 116: case 110: case 102: case 114:\n                        // Revive escaped control characters.\n                        value += Unescapes[charCode];\n                        Index++;\n                        break;\n                      case 117:\n                        // `\\u` marks the beginning of a Unicode escape sequence.\n                        // Advance to the first character and validate the\n                        // four-digit code point.\n                        begin = ++Index;\n                        for (position = Index + 4; Index < position; Index++) {\n                          charCode = source.charCodeAt(Index);\n                          // A valid sequence comprises four hexdigits (case-\n                          // insensitive) that form a single hexadecimal value.\n                          if (!(charCode >= 48 && charCode <= 57 || charCode >= 97 && charCode <= 102 || charCode >= 65 && charCode <= 70)) {\n                            // Invalid Unicode escape sequence.\n                            abort();\n                          }\n                        }\n                        // Revive the escaped character.\n                        value += fromCharCode(\"0x\" + source.slice(begin, Index));\n                        break;\n                      default:\n                        // Invalid escape sequence.\n                        abort();\n                    }\n                  } else {\n                    if (charCode == 34) {\n                      // An unescaped double-quote character marks the end of the\n                      // string.\n                      break;\n                    }\n                    charCode = source.charCodeAt(Index);\n                    begin = Index;\n                    // Optimize for the common case where a string is valid.\n                    while (charCode >= 32 && charCode != 92 && charCode != 34) {\n                      charCode = source.charCodeAt(++Index);\n                    }\n                    // Append the string as-is.\n                    value += source.slice(begin, Index);\n                  }\n                }\n                if (source.charCodeAt(Index) == 34) {\n                  // Advance to the next character and return the revived string.\n                  Index++;\n                  return value;\n                }\n                // Unterminated string.\n                abort();\n              default:\n                // Parse numbers and literals.\n                begin = Index;\n                // Advance past the negative sign, if one is specified.\n                if (charCode == 45) {\n                  isSigned = true;\n                  charCode = source.charCodeAt(++Index);\n                }\n                // Parse an integer or floating-point value.\n                if (charCode >= 48 && charCode <= 57) {\n                  // Leading zeroes are interpreted as octal literals.\n                  if (charCode == 48 && ((charCode = source.charCodeAt(Index + 1)), charCode >= 48 && charCode <= 57)) {\n                    // Illegal octal literal.\n                    abort();\n                  }\n                  isSigned = false;\n                  // Parse the integer component.\n                  for (; Index < length && ((charCode = source.charCodeAt(Index)), charCode >= 48 && charCode <= 57); Index++);\n                  // Floats cannot contain a leading decimal point; however, this\n                  // case is already accounted for by the parser.\n                  if (source.charCodeAt(Index) == 46) {\n                    position = ++Index;\n                    // Parse the decimal component.\n                    for (; position < length && ((charCode = source.charCodeAt(position)), charCode >= 48 && charCode <= 57); position++);\n                    if (position == Index) {\n                      // Illegal trailing decimal.\n                      abort();\n                    }\n                    Index = position;\n                  }\n                  // Parse exponents. The `e` denoting the exponent is\n                  // case-insensitive.\n                  charCode = source.charCodeAt(Index);\n                  if (charCode == 101 || charCode == 69) {\n                    charCode = source.charCodeAt(++Index);\n                    // Skip past the sign following the exponent, if one is\n                    // specified.\n                    if (charCode == 43 || charCode == 45) {\n                      Index++;\n                    }\n                    // Parse the exponential component.\n                    for (position = Index; position < length && ((charCode = source.charCodeAt(position)), charCode >= 48 && charCode <= 57); position++);\n                    if (position == Index) {\n                      // Illegal empty exponent.\n                      abort();\n                    }\n                    Index = position;\n                  }\n                  // Coerce the parsed value to a JavaScript number.\n                  return +source.slice(begin, Index);\n                }\n                // A negative sign may only precede numbers.\n                if (isSigned) {\n                  abort();\n                }\n                // `true`, `false`, and `null` literals.\n                if (source.slice(Index, Index + 4) == \"true\") {\n                  Index += 4;\n                  return true;\n                } else if (source.slice(Index, Index + 5) == \"false\") {\n                  Index += 5;\n                  return false;\n                } else if (source.slice(Index, Index + 4) == \"null\") {\n                  Index += 4;\n                  return null;\n                }\n                // Unrecognized token.\n                abort();\n            }\n          }\n          // Return the sentinel `$` character if the parser has reached the end\n          // of the source string.\n          return \"$\";\n        };\n\n        // Internal: Parses a JSON `value` token.\n        var get = function (value) {\n          var results, hasMembers;\n          if (value == \"$\") {\n            // Unexpected end of input.\n            abort();\n          }\n          if (typeof value == \"string\") {\n            if ((charIndexBuggy ? value.charAt(0) : value[0]) == \"@\") {\n              // Remove the sentinel `@` character.\n              return value.slice(1);\n            }\n            // Parse object and array literals.\n            if (value == \"[\") {\n              // Parses a JSON array, returning a new JavaScript array.\n              results = [];\n              for (;; hasMembers || (hasMembers = true)) {\n                value = lex();\n                // A closing square bracket marks the end of the array literal.\n                if (value == \"]\") {\n                  break;\n                }\n                // If the array literal contains elements, the current token\n                // should be a comma separating the previous element from the\n                // next.\n                if (hasMembers) {\n                  if (value == \",\") {\n                    value = lex();\n                    if (value == \"]\") {\n                      // Unexpected trailing `,` in array literal.\n                      abort();\n                    }\n                  } else {\n                    // A `,` must separate each array element.\n                    abort();\n                  }\n                }\n                // Elisions and leading commas are not permitted.\n                if (value == \",\") {\n                  abort();\n                }\n                results.push(get(value));\n              }\n              return results;\n            } else if (value == \"{\") {\n              // Parses a JSON object, returning a new JavaScript object.\n              results = {};\n              for (;; hasMembers || (hasMembers = true)) {\n                value = lex();\n                // A closing curly brace marks the end of the object literal.\n                if (value == \"}\") {\n                  break;\n                }\n                // If the object literal contains members, the current token\n                // should be a comma separator.\n                if (hasMembers) {\n                  if (value == \",\") {\n                    value = lex();\n                    if (value == \"}\") {\n                      // Unexpected trailing `,` in object literal.\n                      abort();\n                    }\n                  } else {\n                    // A `,` must separate each object member.\n                    abort();\n                  }\n                }\n                // Leading commas are not permitted, object property names must be\n                // double-quoted strings, and a `:` must separate each property\n                // name and value.\n                if (value == \",\" || typeof value != \"string\" || (charIndexBuggy ? value.charAt(0) : value[0]) != \"@\" || lex() != \":\") {\n                  abort();\n                }\n                results[value.slice(1)] = get(lex());\n              }\n              return results;\n            }\n            // Unexpected token encountered.\n            abort();\n          }\n          return value;\n        };\n\n        // Internal: Updates a traversed object member.\n        var update = function (source, property, callback) {\n          var element = walk(source, property, callback);\n          if (element === undef) {\n            delete source[property];\n          } else {\n            source[property] = element;\n          }\n        };\n\n        // Internal: Recursively traverses a parsed JSON object, invoking the\n        // `callback` function for each value. This is an implementation of the\n        // `Walk(holder, name)` operation defined in ES 5.1 section 15.12.2.\n        var walk = function (source, property, callback) {\n          var value = source[property], length;\n          if (typeof value == \"object\" && value) {\n            // `forEach` can't be used to traverse an array in Opera <= 8.54\n            // because its `Object#hasOwnProperty` implementation returns `false`\n            // for array indices (e.g., `![1, 2, 3].hasOwnProperty(\"0\")`).\n            if (getClass.call(value) == arrayClass) {\n              for (length = value.length; length--;) {\n                update(value, length, callback);\n              }\n            } else {\n              forEach(value, function (property) {\n                update(value, property, callback);\n              });\n            }\n          }\n          return callback.call(source, property, value);\n        };\n\n        // Public: `JSON.parse`. See ES 5.1 section 15.12.2.\n        exports.parse = function (source, callback) {\n          var result, value;\n          Index = 0;\n          Source = \"\" + source;\n          result = get(lex());\n          // If a JSON string contains multiple tokens, it is invalid.\n          if (lex() != \"$\") {\n            abort();\n          }\n          // Reset the parser state.\n          Index = Source = null;\n          return callback && getClass.call(callback) == functionClass ? walk((value = {}, value[\"\"] = result, value), \"\", callback) : result;\n        };\n      }\n    }\n\n    exports[\"runInContext\"] = runInContext;\n    return exports;\n  }\n\n  if (freeExports && !isLoader) {\n    // Export for CommonJS environments.\n    runInContext(root, freeExports);\n  } else {\n    // Export for web browsers and JavaScript engines.\n    var nativeJSON = root.JSON,\n        previousJSON = root[\"JSON3\"],\n        isRestored = false;\n\n    var JSON3 = runInContext(root, (root[\"JSON3\"] = {\n      // Public: Restores the original value of the global `JSON` object and\n      // returns a reference to the `JSON3` object.\n      \"noConflict\": function () {\n        if (!isRestored) {\n          isRestored = true;\n          root.JSON = nativeJSON;\n          root[\"JSON3\"] = previousJSON;\n          nativeJSON = previousJSON = null;\n        }\n        return JSON3;\n      }\n    }));\n\n    root.JSON = {\n      \"parse\": JSON3.parse,\n      \"stringify\": JSON3.stringify\n    };\n  }\n\n  // Export for asynchronous module loaders.\n  if (isLoader) {\n    define(function () {\n      return JSON3;\n    });\n  }\n}).call(this);\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n},{}],70:[function(require,module,exports){\n/**\n * lodash 3.2.0 (Custom Build) <https://lodash.com/>\n * Build: `lodash modern modularize exports=\"npm\" -o ./`\n * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>\n * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>\n * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n * Available under MIT license <https://lodash.com/license>\n */\nvar baseCopy = require('lodash._basecopy'),\n    keys = require('lodash.keys');\n\n/**\n * The base implementation of `_.assign` without support for argument juggling,\n * multiple sources, and `customizer` functions.\n *\n * @private\n * @param {Object} object The destination object.\n * @param {Object} source The source object.\n * @returns {Object} Returns `object`.\n */\nfunction baseAssign(object, source) {\n  return source == null\n    ? object\n    : baseCopy(source, keys(source), object);\n}\n\nmodule.exports = baseAssign;\n\n},{\"lodash._basecopy\":71,\"lodash.keys\":78}],71:[function(require,module,exports){\n/**\n * lodash 3.0.1 (Custom Build) <https://lodash.com/>\n * Build: `lodash modern modularize exports=\"npm\" -o ./`\n * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>\n * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>\n * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n * Available under MIT license <https://lodash.com/license>\n */\n\n/**\n * Copies properties of `source` to `object`.\n *\n * @private\n * @param {Object} source The object to copy properties from.\n * @param {Array} props The property names to copy.\n * @param {Object} [object={}] The object to copy properties to.\n * @returns {Object} Returns `object`.\n */\nfunction baseCopy(source, props, object) {\n  object || (object = {});\n\n  var index = -1,\n      length = props.length;\n\n  while (++index < length) {\n    var key = props[index];\n    object[key] = source[key];\n  }\n  return object;\n}\n\nmodule.exports = baseCopy;\n\n},{}],72:[function(require,module,exports){\n/**\n * lodash 3.0.3 (Custom Build) <https://lodash.com/>\n * Build: `lodash modern modularize exports=\"npm\" -o ./`\n * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>\n * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>\n * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n * Available under MIT license <https://lodash.com/license>\n */\n\n/**\n * The base implementation of `_.create` without support for assigning\n * properties to the created object.\n *\n * @private\n * @param {Object} prototype The object to inherit from.\n * @returns {Object} Returns the new object.\n */\nvar baseCreate = (function() {\n  function object() {}\n  return function(prototype) {\n    if (isObject(prototype)) {\n      object.prototype = prototype;\n      var result = new object;\n      object.prototype = undefined;\n    }\n    return result || {};\n  };\n}());\n\n/**\n * Checks if `value` is the [language type](https://es5.github.io/#x8) of `Object`.\n * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @static\n * @memberOf _\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n * _.isObject({});\n * // => true\n *\n * _.isObject([1, 2, 3]);\n * // => true\n *\n * _.isObject(1);\n * // => false\n */\nfunction isObject(value) {\n  // Avoid a V8 JIT bug in Chrome 19-20.\n  // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.\n  var type = typeof value;\n  return !!value && (type == 'object' || type == 'function');\n}\n\nmodule.exports = baseCreate;\n\n},{}],73:[function(require,module,exports){\n/**\n * lodash 3.9.1 (Custom Build) <https://lodash.com/>\n * Build: `lodash modern modularize exports=\"npm\" -o ./`\n * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>\n * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>\n * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n * Available under MIT license <https://lodash.com/license>\n */\n\n/** `Object#toString` result references. */\nvar funcTag = '[object Function]';\n\n/** Used to detect host constructors (Safari > 5). */\nvar reIsHostCtor = /^\\[object .+?Constructor\\]$/;\n\n/**\n * Checks if `value` is object-like.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n */\nfunction isObjectLike(value) {\n  return !!value && typeof value == 'object';\n}\n\n/** Used for native method references. */\nvar objectProto = Object.prototype;\n\n/** Used to resolve the decompiled source of functions. */\nvar fnToString = Function.prototype.toString;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Used to resolve the [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar objToString = objectProto.toString;\n\n/** Used to detect if a method is native. */\nvar reIsNative = RegExp('^' +\n  fnToString.call(hasOwnProperty).replace(/[\\\\^$.*+?()[\\]{}|]/g, '\\\\$&')\n  .replace(/hasOwnProperty|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$'\n);\n\n/**\n * Gets the native function at `key` of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {string} key The key of the method to get.\n * @returns {*} Returns the function if it's native, else `undefined`.\n */\nfunction getNative(object, key) {\n  var value = object == null ? undefined : object[key];\n  return isNative(value) ? value : undefined;\n}\n\n/**\n * Checks if `value` is classified as a `Function` object.\n *\n * @static\n * @memberOf _\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.\n * @example\n *\n * _.isFunction(_);\n * // => true\n *\n * _.isFunction(/abc/);\n * // => false\n */\nfunction isFunction(value) {\n  // The use of `Object#toString` avoids issues with the `typeof` operator\n  // in older versions of Chrome and Safari which return 'function' for regexes\n  // and Safari 8 equivalents which return 'object' for typed array constructors.\n  return isObject(value) && objToString.call(value) == funcTag;\n}\n\n/**\n * Checks if `value` is the [language type](https://es5.github.io/#x8) of `Object`.\n * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @static\n * @memberOf _\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n * _.isObject({});\n * // => true\n *\n * _.isObject([1, 2, 3]);\n * // => true\n *\n * _.isObject(1);\n * // => false\n */\nfunction isObject(value) {\n  // Avoid a V8 JIT bug in Chrome 19-20.\n  // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.\n  var type = typeof value;\n  return !!value && (type == 'object' || type == 'function');\n}\n\n/**\n * Checks if `value` is a native function.\n *\n * @static\n * @memberOf _\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a native function, else `false`.\n * @example\n *\n * _.isNative(Array.prototype.push);\n * // => true\n *\n * _.isNative(_);\n * // => false\n */\nfunction isNative(value) {\n  if (value == null) {\n    return false;\n  }\n  if (isFunction(value)) {\n    return reIsNative.test(fnToString.call(value));\n  }\n  return isObjectLike(value) && reIsHostCtor.test(value);\n}\n\nmodule.exports = getNative;\n\n},{}],74:[function(require,module,exports){\n/**\n * lodash 3.0.9 (Custom Build) <https://lodash.com/>\n * Build: `lodash modern modularize exports=\"npm\" -o ./`\n * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>\n * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>\n * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n * Available under MIT license <https://lodash.com/license>\n */\n\n/** Used to detect unsigned integer values. */\nvar reIsUint = /^\\d+$/;\n\n/**\n * Used as the [maximum length](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-number.max_safe_integer)\n * of an array-like value.\n */\nvar MAX_SAFE_INTEGER = 9007199254740991;\n\n/**\n * The base implementation of `_.property` without support for deep paths.\n *\n * @private\n * @param {string} key The key of the property to get.\n * @returns {Function} Returns the new function.\n */\nfunction baseProperty(key) {\n  return function(object) {\n    return object == null ? undefined : object[key];\n  };\n}\n\n/**\n * Gets the \"length\" property value of `object`.\n *\n * **Note:** This function is used to avoid a [JIT bug](https://bugs.webkit.org/show_bug.cgi?id=142792)\n * that affects Safari on at least iOS 8.1-8.3 ARM64.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {*} Returns the \"length\" value.\n */\nvar getLength = baseProperty('length');\n\n/**\n * Checks if `value` is array-like.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is array-like, else `false`.\n */\nfunction isArrayLike(value) {\n  return value != null && isLength(getLength(value));\n}\n\n/**\n * Checks if `value` is a valid array-like index.\n *\n * @private\n * @param {*} value The value to check.\n * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.\n * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.\n */\nfunction isIndex(value, length) {\n  value = (typeof value == 'number' || reIsUint.test(value)) ? +value : -1;\n  length = length == null ? MAX_SAFE_INTEGER : length;\n  return value > -1 && value % 1 == 0 && value < length;\n}\n\n/**\n * Checks if the provided arguments are from an iteratee call.\n *\n * @private\n * @param {*} value The potential iteratee value argument.\n * @param {*} index The potential iteratee index or key argument.\n * @param {*} object The potential iteratee object argument.\n * @returns {boolean} Returns `true` if the arguments are from an iteratee call, else `false`.\n */\nfunction isIterateeCall(value, index, object) {\n  if (!isObject(object)) {\n    return false;\n  }\n  var type = typeof index;\n  if (type == 'number'\n      ? (isArrayLike(object) && isIndex(index, object.length))\n      : (type == 'string' && index in object)) {\n    var other = object[index];\n    return value === value ? (value === other) : (other !== other);\n  }\n  return false;\n}\n\n/**\n * Checks if `value` is a valid array-like length.\n *\n * **Note:** This function is based on [`ToLength`](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-tolength).\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.\n */\nfunction isLength(value) {\n  return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;\n}\n\n/**\n * Checks if `value` is the [language type](https://es5.github.io/#x8) of `Object`.\n * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @static\n * @memberOf _\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n * _.isObject({});\n * // => true\n *\n * _.isObject([1, 2, 3]);\n * // => true\n *\n * _.isObject(1);\n * // => false\n */\nfunction isObject(value) {\n  // Avoid a V8 JIT bug in Chrome 19-20.\n  // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.\n  var type = typeof value;\n  return !!value && (type == 'object' || type == 'function');\n}\n\nmodule.exports = isIterateeCall;\n\n},{}],75:[function(require,module,exports){\n/**\n * lodash 3.1.1 (Custom Build) <https://lodash.com/>\n * Build: `lodash modern modularize exports=\"npm\" -o ./`\n * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>\n * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>\n * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n * Available under MIT license <https://lodash.com/license>\n */\nvar baseAssign = require('lodash._baseassign'),\n    baseCreate = require('lodash._basecreate'),\n    isIterateeCall = require('lodash._isiterateecall');\n\n/**\n * Creates an object that inherits from the given `prototype` object. If a\n * `properties` object is provided its own enumerable properties are assigned\n * to the created object.\n *\n * @static\n * @memberOf _\n * @category Object\n * @param {Object} prototype The object to inherit from.\n * @param {Object} [properties] The properties to assign to the object.\n * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.\n * @returns {Object} Returns the new object.\n * @example\n *\n * function Shape() {\n *   this.x = 0;\n *   this.y = 0;\n * }\n *\n * function Circle() {\n *   Shape.call(this);\n * }\n *\n * Circle.prototype = _.create(Shape.prototype, {\n *   'constructor': Circle\n * });\n *\n * var circle = new Circle;\n * circle instanceof Circle;\n * // => true\n *\n * circle instanceof Shape;\n * // => true\n */\nfunction create(prototype, properties, guard) {\n  var result = baseCreate(prototype);\n  if (guard && isIterateeCall(prototype, properties, guard)) {\n    properties = undefined;\n  }\n  return properties ? baseAssign(result, properties) : result;\n}\n\nmodule.exports = create;\n\n},{\"lodash._baseassign\":70,\"lodash._basecreate\":72,\"lodash._isiterateecall\":74}],76:[function(require,module,exports){\n/**\n * lodash (Custom Build) <https://lodash.com/>\n * Build: `lodash modularize exports=\"npm\" -o ./`\n * Copyright jQuery Foundation and other contributors <https://jquery.org/>\n * Released under MIT license <https://lodash.com/license>\n * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>\n * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n */\n\n/** Used as references for various `Number` constants. */\nvar MAX_SAFE_INTEGER = 9007199254740991;\n\n/** `Object#toString` result references. */\nvar argsTag = '[object Arguments]',\n    funcTag = '[object Function]',\n    genTag = '[object GeneratorFunction]';\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar objectToString = objectProto.toString;\n\n/** Built-in value references. */\nvar propertyIsEnumerable = objectProto.propertyIsEnumerable;\n\n/**\n * Checks if `value` is likely an `arguments` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an `arguments` object,\n *  else `false`.\n * @example\n *\n * _.isArguments(function() { return arguments; }());\n * // => true\n *\n * _.isArguments([1, 2, 3]);\n * // => false\n */\nfunction isArguments(value) {\n  // Safari 8.1 makes `arguments.callee` enumerable in strict mode.\n  return isArrayLikeObject(value) && hasOwnProperty.call(value, 'callee') &&\n    (!propertyIsEnumerable.call(value, 'callee') || objectToString.call(value) == argsTag);\n}\n\n/**\n * Checks if `value` is array-like. A value is considered array-like if it's\n * not a function and has a `value.length` that's an integer greater than or\n * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is array-like, else `false`.\n * @example\n *\n * _.isArrayLike([1, 2, 3]);\n * // => true\n *\n * _.isArrayLike(document.body.children);\n * // => true\n *\n * _.isArrayLike('abc');\n * // => true\n *\n * _.isArrayLike(_.noop);\n * // => false\n */\nfunction isArrayLike(value) {\n  return value != null && isLength(value.length) && !isFunction(value);\n}\n\n/**\n * This method is like `_.isArrayLike` except that it also checks if `value`\n * is an object.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an array-like object,\n *  else `false`.\n * @example\n *\n * _.isArrayLikeObject([1, 2, 3]);\n * // => true\n *\n * _.isArrayLikeObject(document.body.children);\n * // => true\n *\n * _.isArrayLikeObject('abc');\n * // => false\n *\n * _.isArrayLikeObject(_.noop);\n * // => false\n */\nfunction isArrayLikeObject(value) {\n  return isObjectLike(value) && isArrayLike(value);\n}\n\n/**\n * Checks if `value` is classified as a `Function` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a function, else `false`.\n * @example\n *\n * _.isFunction(_);\n * // => true\n *\n * _.isFunction(/abc/);\n * // => false\n */\nfunction isFunction(value) {\n  // The use of `Object#toString` avoids issues with the `typeof` operator\n  // in Safari 8-9 which returns 'object' for typed array and other constructors.\n  var tag = isObject(value) ? objectToString.call(value) : '';\n  return tag == funcTag || tag == genTag;\n}\n\n/**\n * Checks if `value` is a valid array-like length.\n *\n * **Note:** This method is loosely based on\n * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.\n * @example\n *\n * _.isLength(3);\n * // => true\n *\n * _.isLength(Number.MIN_VALUE);\n * // => false\n *\n * _.isLength(Infinity);\n * // => false\n *\n * _.isLength('3');\n * // => false\n */\nfunction isLength(value) {\n  return typeof value == 'number' &&\n    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;\n}\n\n/**\n * Checks if `value` is the\n * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n * _.isObject({});\n * // => true\n *\n * _.isObject([1, 2, 3]);\n * // => true\n *\n * _.isObject(_.noop);\n * // => true\n *\n * _.isObject(null);\n * // => false\n */\nfunction isObject(value) {\n  var type = typeof value;\n  return !!value && (type == 'object' || type == 'function');\n}\n\n/**\n * Checks if `value` is object-like. A value is object-like if it's not `null`\n * and has a `typeof` result of \"object\".\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n * @example\n *\n * _.isObjectLike({});\n * // => true\n *\n * _.isObjectLike([1, 2, 3]);\n * // => true\n *\n * _.isObjectLike(_.noop);\n * // => false\n *\n * _.isObjectLike(null);\n * // => false\n */\nfunction isObjectLike(value) {\n  return !!value && typeof value == 'object';\n}\n\nmodule.exports = isArguments;\n\n},{}],77:[function(require,module,exports){\n/**\n * lodash 3.0.4 (Custom Build) <https://lodash.com/>\n * Build: `lodash modern modularize exports=\"npm\" -o ./`\n * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>\n * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>\n * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n * Available under MIT license <https://lodash.com/license>\n */\n\n/** `Object#toString` result references. */\nvar arrayTag = '[object Array]',\n    funcTag = '[object Function]';\n\n/** Used to detect host constructors (Safari > 5). */\nvar reIsHostCtor = /^\\[object .+?Constructor\\]$/;\n\n/**\n * Checks if `value` is object-like.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n */\nfunction isObjectLike(value) {\n  return !!value && typeof value == 'object';\n}\n\n/** Used for native method references. */\nvar objectProto = Object.prototype;\n\n/** Used to resolve the decompiled source of functions. */\nvar fnToString = Function.prototype.toString;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Used to resolve the [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar objToString = objectProto.toString;\n\n/** Used to detect if a method is native. */\nvar reIsNative = RegExp('^' +\n  fnToString.call(hasOwnProperty).replace(/[\\\\^$.*+?()[\\]{}|]/g, '\\\\$&')\n  .replace(/hasOwnProperty|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$'\n);\n\n/* Native method references for those with the same name as other `lodash` methods. */\nvar nativeIsArray = getNative(Array, 'isArray');\n\n/**\n * Used as the [maximum length](http://ecma-international.org/ecma-262/6.0/#sec-number.max_safe_integer)\n * of an array-like value.\n */\nvar MAX_SAFE_INTEGER = 9007199254740991;\n\n/**\n * Gets the native function at `key` of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {string} key The key of the method to get.\n * @returns {*} Returns the function if it's native, else `undefined`.\n */\nfunction getNative(object, key) {\n  var value = object == null ? undefined : object[key];\n  return isNative(value) ? value : undefined;\n}\n\n/**\n * Checks if `value` is a valid array-like length.\n *\n * **Note:** This function is based on [`ToLength`](http://ecma-international.org/ecma-262/6.0/#sec-tolength).\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.\n */\nfunction isLength(value) {\n  return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;\n}\n\n/**\n * Checks if `value` is classified as an `Array` object.\n *\n * @static\n * @memberOf _\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.\n * @example\n *\n * _.isArray([1, 2, 3]);\n * // => true\n *\n * _.isArray(function() { return arguments; }());\n * // => false\n */\nvar isArray = nativeIsArray || function(value) {\n  return isObjectLike(value) && isLength(value.length) && objToString.call(value) == arrayTag;\n};\n\n/**\n * Checks if `value` is classified as a `Function` object.\n *\n * @static\n * @memberOf _\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.\n * @example\n *\n * _.isFunction(_);\n * // => true\n *\n * _.isFunction(/abc/);\n * // => false\n */\nfunction isFunction(value) {\n  // The use of `Object#toString` avoids issues with the `typeof` operator\n  // in older versions of Chrome and Safari which return 'function' for regexes\n  // and Safari 8 equivalents which return 'object' for typed array constructors.\n  return isObject(value) && objToString.call(value) == funcTag;\n}\n\n/**\n * Checks if `value` is the [language type](https://es5.github.io/#x8) of `Object`.\n * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @static\n * @memberOf _\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n * _.isObject({});\n * // => true\n *\n * _.isObject([1, 2, 3]);\n * // => true\n *\n * _.isObject(1);\n * // => false\n */\nfunction isObject(value) {\n  // Avoid a V8 JIT bug in Chrome 19-20.\n  // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.\n  var type = typeof value;\n  return !!value && (type == 'object' || type == 'function');\n}\n\n/**\n * Checks if `value` is a native function.\n *\n * @static\n * @memberOf _\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a native function, else `false`.\n * @example\n *\n * _.isNative(Array.prototype.push);\n * // => true\n *\n * _.isNative(_);\n * // => false\n */\nfunction isNative(value) {\n  if (value == null) {\n    return false;\n  }\n  if (isFunction(value)) {\n    return reIsNative.test(fnToString.call(value));\n  }\n  return isObjectLike(value) && reIsHostCtor.test(value);\n}\n\nmodule.exports = isArray;\n\n},{}],78:[function(require,module,exports){\n/**\n * lodash 3.1.2 (Custom Build) <https://lodash.com/>\n * Build: `lodash modern modularize exports=\"npm\" -o ./`\n * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>\n * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>\n * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n * Available under MIT license <https://lodash.com/license>\n */\nvar getNative = require('lodash._getnative'),\n    isArguments = require('lodash.isarguments'),\n    isArray = require('lodash.isarray');\n\n/** Used to detect unsigned integer values. */\nvar reIsUint = /^\\d+$/;\n\n/** Used for native method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/* Native method references for those with the same name as other `lodash` methods. */\nvar nativeKeys = getNative(Object, 'keys');\n\n/**\n * Used as the [maximum length](http://ecma-international.org/ecma-262/6.0/#sec-number.max_safe_integer)\n * of an array-like value.\n */\nvar MAX_SAFE_INTEGER = 9007199254740991;\n\n/**\n * The base implementation of `_.property` without support for deep paths.\n *\n * @private\n * @param {string} key The key of the property to get.\n * @returns {Function} Returns the new function.\n */\nfunction baseProperty(key) {\n  return function(object) {\n    return object == null ? undefined : object[key];\n  };\n}\n\n/**\n * Gets the \"length\" property value of `object`.\n *\n * **Note:** This function is used to avoid a [JIT bug](https://bugs.webkit.org/show_bug.cgi?id=142792)\n * that affects Safari on at least iOS 8.1-8.3 ARM64.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {*} Returns the \"length\" value.\n */\nvar getLength = baseProperty('length');\n\n/**\n * Checks if `value` is array-like.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is array-like, else `false`.\n */\nfunction isArrayLike(value) {\n  return value != null && isLength(getLength(value));\n}\n\n/**\n * Checks if `value` is a valid array-like index.\n *\n * @private\n * @param {*} value The value to check.\n * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.\n * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.\n */\nfunction isIndex(value, length) {\n  value = (typeof value == 'number' || reIsUint.test(value)) ? +value : -1;\n  length = length == null ? MAX_SAFE_INTEGER : length;\n  return value > -1 && value % 1 == 0 && value < length;\n}\n\n/**\n * Checks if `value` is a valid array-like length.\n *\n * **Note:** This function is based on [`ToLength`](http://ecma-international.org/ecma-262/6.0/#sec-tolength).\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.\n */\nfunction isLength(value) {\n  return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;\n}\n\n/**\n * A fallback implementation of `Object.keys` which creates an array of the\n * own enumerable property names of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n */\nfunction shimKeys(object) {\n  var props = keysIn(object),\n      propsLength = props.length,\n      length = propsLength && object.length;\n\n  var allowIndexes = !!length && isLength(length) &&\n    (isArray(object) || isArguments(object));\n\n  var index = -1,\n      result = [];\n\n  while (++index < propsLength) {\n    var key = props[index];\n    if ((allowIndexes && isIndex(key, length)) || hasOwnProperty.call(object, key)) {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\n/**\n * Checks if `value` is the [language type](https://es5.github.io/#x8) of `Object`.\n * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @static\n * @memberOf _\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n * _.isObject({});\n * // => true\n *\n * _.isObject([1, 2, 3]);\n * // => true\n *\n * _.isObject(1);\n * // => false\n */\nfunction isObject(value) {\n  // Avoid a V8 JIT bug in Chrome 19-20.\n  // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.\n  var type = typeof value;\n  return !!value && (type == 'object' || type == 'function');\n}\n\n/**\n * Creates an array of the own enumerable property names of `object`.\n *\n * **Note:** Non-object values are coerced to objects. See the\n * [ES spec](http://ecma-international.org/ecma-262/6.0/#sec-object.keys)\n * for more details.\n *\n * @static\n * @memberOf _\n * @category Object\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n * @example\n *\n * function Foo() {\n *   this.a = 1;\n *   this.b = 2;\n * }\n *\n * Foo.prototype.c = 3;\n *\n * _.keys(new Foo);\n * // => ['a', 'b'] (iteration order is not guaranteed)\n *\n * _.keys('hi');\n * // => ['0', '1']\n */\nvar keys = !nativeKeys ? shimKeys : function(object) {\n  var Ctor = object == null ? undefined : object.constructor;\n  if ((typeof Ctor == 'function' && Ctor.prototype === object) ||\n      (typeof object != 'function' && isArrayLike(object))) {\n    return shimKeys(object);\n  }\n  return isObject(object) ? nativeKeys(object) : [];\n};\n\n/**\n * Creates an array of the own and inherited enumerable property names of `object`.\n *\n * **Note:** Non-object values are coerced to objects.\n *\n * @static\n * @memberOf _\n * @category Object\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n * @example\n *\n * function Foo() {\n *   this.a = 1;\n *   this.b = 2;\n * }\n *\n * Foo.prototype.c = 3;\n *\n * _.keysIn(new Foo);\n * // => ['a', 'b', 'c'] (iteration order is not guaranteed)\n */\nfunction keysIn(object) {\n  if (object == null) {\n    return [];\n  }\n  if (!isObject(object)) {\n    object = Object(object);\n  }\n  var length = object.length;\n  length = (length && isLength(length) &&\n    (isArray(object) || isArguments(object)) && length) || 0;\n\n  var Ctor = object.constructor,\n      index = -1,\n      isProto = typeof Ctor == 'function' && Ctor.prototype === object,\n      result = Array(length),\n      skipIndexes = length > 0;\n\n  while (++index < length) {\n    result[index] = (index + '');\n  }\n  for (var key in object) {\n    if (!(skipIndexes && isIndex(key, length)) &&\n        !(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\nmodule.exports = keys;\n\n},{\"lodash._getnative\":73,\"lodash.isarguments\":76,\"lodash.isarray\":77}],79:[function(require,module,exports){\n(function (process){\nvar path = require('path');\nvar fs = require('fs');\nvar _0777 = parseInt('0777', 8);\n\nmodule.exports = mkdirP.mkdirp = mkdirP.mkdirP = mkdirP;\n\nfunction mkdirP (p, opts, f, made) {\n    if (typeof opts === 'function') {\n        f = opts;\n        opts = {};\n    }\n    else if (!opts || typeof opts !== 'object') {\n        opts = { mode: opts };\n    }\n    \n    var mode = opts.mode;\n    var xfs = opts.fs || fs;\n    \n    if (mode === undefined) {\n        mode = _0777 & (~process.umask());\n    }\n    if (!made) made = null;\n    \n    var cb = f || function () {};\n    p = path.resolve(p);\n    \n    xfs.mkdir(p, mode, function (er) {\n        if (!er) {\n            made = made || p;\n            return cb(null, made);\n        }\n        switch (er.code) {\n            case 'ENOENT':\n                mkdirP(path.dirname(p), opts, function (er, made) {\n                    if (er) cb(er, made);\n                    else mkdirP(p, opts, cb, made);\n                });\n                break;\n\n            // In the case of any other error, just see if there's a dir\n            // there already.  If so, then hooray!  If not, then something\n            // is borked.\n            default:\n                xfs.stat(p, function (er2, stat) {\n                    // if the stat fails, then that's super weird.\n                    // let the original error be the failure reason.\n                    if (er2 || !stat.isDirectory()) cb(er, made)\n                    else cb(null, made);\n                });\n                break;\n        }\n    });\n}\n\nmkdirP.sync = function sync (p, opts, made) {\n    if (!opts || typeof opts !== 'object') {\n        opts = { mode: opts };\n    }\n    \n    var mode = opts.mode;\n    var xfs = opts.fs || fs;\n    \n    if (mode === undefined) {\n        mode = _0777 & (~process.umask());\n    }\n    if (!made) made = null;\n\n    p = path.resolve(p);\n\n    try {\n        xfs.mkdirSync(p, mode);\n        made = made || p;\n    }\n    catch (err0) {\n        switch (err0.code) {\n            case 'ENOENT' :\n                made = sync(path.dirname(p), opts, made);\n                sync(p, opts, made);\n                break;\n\n            // In the case of any other error, just see if there's a dir\n            // there already.  If so, then hooray!  If not, then something\n            // is borked.\n            default:\n                var stat;\n                try {\n                    stat = xfs.statSync(p);\n                }\n                catch (err1) {\n                    throw err0;\n                }\n                if (!stat.isDirectory()) throw err0;\n                break;\n        }\n    }\n\n    return made;\n};\n\n}).call(this,require('_process'))\n},{\"_process\":82,\"fs\":42,\"path\":42}],80:[function(require,module,exports){\nexports.endianness = function () { return 'LE' };\n\nexports.hostname = function () {\n    if (typeof location !== 'undefined') {\n        return location.hostname\n    }\n    else return '';\n};\n\nexports.loadavg = function () { return [] };\n\nexports.uptime = function () { return 0 };\n\nexports.freemem = function () {\n    return Number.MAX_VALUE;\n};\n\nexports.totalmem = function () {\n    return Number.MAX_VALUE;\n};\n\nexports.cpus = function () { return [] };\n\nexports.type = function () { return 'Browser' };\n\nexports.release = function () {\n    if (typeof navigator !== 'undefined') {\n        return navigator.appVersion;\n    }\n    return '';\n};\n\nexports.networkInterfaces\n= exports.getNetworkInterfaces\n= function () { return {} };\n\nexports.arch = function () { return 'javascript' };\n\nexports.platform = function () { return 'browser' };\n\nexports.tmpdir = exports.tmpDir = function () {\n    return '/tmp';\n};\n\nexports.EOL = '\\n';\n\n},{}],81:[function(require,module,exports){\n(function (process){\n'use strict';\n\nif (!process.version ||\n    process.version.indexOf('v0.') === 0 ||\n    process.version.indexOf('v1.') === 0 && process.version.indexOf('v1.8.') !== 0) {\n  module.exports = nextTick;\n} else {\n  module.exports = process.nextTick;\n}\n\nfunction nextTick(fn, arg1, arg2, arg3) {\n  if (typeof fn !== 'function') {\n    throw new TypeError('\"callback\" argument must be a function');\n  }\n  var len = arguments.length;\n  var args, i;\n  switch (len) {\n  case 0:\n  case 1:\n    return process.nextTick(fn);\n  case 2:\n    return process.nextTick(function afterTickOne() {\n      fn.call(null, arg1);\n    });\n  case 3:\n    return process.nextTick(function afterTickTwo() {\n      fn.call(null, arg1, arg2);\n    });\n  case 4:\n    return process.nextTick(function afterTickThree() {\n      fn.call(null, arg1, arg2, arg3);\n    });\n  default:\n    args = new Array(len - 1);\n    i = 0;\n    while (i < args.length) {\n      args[i++] = arguments[i];\n    }\n    return process.nextTick(function afterTick() {\n      fn.apply(null, args);\n    });\n  }\n}\n\n}).call(this,require('_process'))\n},{\"_process\":82}],82:[function(require,module,exports){\n// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n},{}],83:[function(require,module,exports){\nmodule.exports = require('./lib/_stream_duplex.js');\n\n},{\"./lib/_stream_duplex.js\":84}],84:[function(require,module,exports){\n// a duplex stream is just a stream that is both readable and writable.\n// Since JS doesn't have multiple prototypal inheritance, this class\n// prototypally inherits from Readable, and then parasitically from\n// Writable.\n\n'use strict';\n\n/*<replacement>*/\n\nvar objectKeys = Object.keys || function (obj) {\n  var keys = [];\n  for (var key in obj) {\n    keys.push(key);\n  }return keys;\n};\n/*</replacement>*/\n\nmodule.exports = Duplex;\n\n/*<replacement>*/\nvar processNextTick = require('process-nextick-args');\n/*</replacement>*/\n\n/*<replacement>*/\nvar util = require('core-util-is');\nutil.inherits = require('inherits');\n/*</replacement>*/\n\nvar Readable = require('./_stream_readable');\nvar Writable = require('./_stream_writable');\n\nutil.inherits(Duplex, Readable);\n\nvar keys = objectKeys(Writable.prototype);\nfor (var v = 0; v < keys.length; v++) {\n  var method = keys[v];\n  if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];\n}\n\nfunction Duplex(options) {\n  if (!(this instanceof Duplex)) return new Duplex(options);\n\n  Readable.call(this, options);\n  Writable.call(this, options);\n\n  if (options && options.readable === false) this.readable = false;\n\n  if (options && options.writable === false) this.writable = false;\n\n  this.allowHalfOpen = true;\n  if (options && options.allowHalfOpen === false) this.allowHalfOpen = false;\n\n  this.once('end', onend);\n}\n\n// the no-half-open enforcer\nfunction onend() {\n  // if we allow half-open state, or if the writable side ended,\n  // then we're ok.\n  if (this.allowHalfOpen || this._writableState.ended) return;\n\n  // no more data can be written.\n  // But allow more writes to happen in this tick.\n  processNextTick(onEndNT, this);\n}\n\nfunction onEndNT(self) {\n  self.end();\n}\n\nfunction forEach(xs, f) {\n  for (var i = 0, l = xs.length; i < l; i++) {\n    f(xs[i], i);\n  }\n}\n},{\"./_stream_readable\":86,\"./_stream_writable\":88,\"core-util-is\":44,\"inherits\":66,\"process-nextick-args\":81}],85:[function(require,module,exports){\n// a passthrough stream.\n// basically just the most minimal sort of Transform stream.\n// Every written chunk gets output as-is.\n\n'use strict';\n\nmodule.exports = PassThrough;\n\nvar Transform = require('./_stream_transform');\n\n/*<replacement>*/\nvar util = require('core-util-is');\nutil.inherits = require('inherits');\n/*</replacement>*/\n\nutil.inherits(PassThrough, Transform);\n\nfunction PassThrough(options) {\n  if (!(this instanceof PassThrough)) return new PassThrough(options);\n\n  Transform.call(this, options);\n}\n\nPassThrough.prototype._transform = function (chunk, encoding, cb) {\n  cb(null, chunk);\n};\n},{\"./_stream_transform\":87,\"core-util-is\":44,\"inherits\":66}],86:[function(require,module,exports){\n(function (process){\n'use strict';\n\nmodule.exports = Readable;\n\n/*<replacement>*/\nvar processNextTick = require('process-nextick-args');\n/*</replacement>*/\n\n/*<replacement>*/\nvar isArray = require('isarray');\n/*</replacement>*/\n\n/*<replacement>*/\nvar Duplex;\n/*</replacement>*/\n\nReadable.ReadableState = ReadableState;\n\n/*<replacement>*/\nvar EE = require('events').EventEmitter;\n\nvar EElistenerCount = function (emitter, type) {\n  return emitter.listeners(type).length;\n};\n/*</replacement>*/\n\n/*<replacement>*/\nvar Stream = require('./internal/streams/stream');\n/*</replacement>*/\n\n/*<replacement>*/\nvar Buffer = require('safe-buffer').Buffer;\n/*</replacement>*/\n\n/*<replacement>*/\nvar util = require('core-util-is');\nutil.inherits = require('inherits');\n/*</replacement>*/\n\n/*<replacement>*/\nvar debugUtil = require('util');\nvar debug = void 0;\nif (debugUtil && debugUtil.debuglog) {\n  debug = debugUtil.debuglog('stream');\n} else {\n  debug = function () {};\n}\n/*</replacement>*/\n\nvar BufferList = require('./internal/streams/BufferList');\nvar StringDecoder;\n\nutil.inherits(Readable, Stream);\n\nvar kProxyEvents = ['error', 'close', 'destroy', 'pause', 'resume'];\n\nfunction prependListener(emitter, event, fn) {\n  // Sadly this is not cacheable as some libraries bundle their own\n  // event emitter implementation with them.\n  if (typeof emitter.prependListener === 'function') {\n    return emitter.prependListener(event, fn);\n  } else {\n    // This is a hack to make sure that our error handler is attached before any\n    // userland ones.  NEVER DO THIS. This is here only because this code needs\n    // to continue to work with older versions of Node.js that do not include\n    // the prependListener() method. The goal is to eventually remove this hack.\n    if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);else if (isArray(emitter._events[event])) emitter._events[event].unshift(fn);else emitter._events[event] = [fn, emitter._events[event]];\n  }\n}\n\nfunction ReadableState(options, stream) {\n  Duplex = Duplex || require('./_stream_duplex');\n\n  options = options || {};\n\n  // object stream flag. Used to make read(n) ignore n and to\n  // make all the buffer merging and length checks go away\n  this.objectMode = !!options.objectMode;\n\n  if (stream instanceof Duplex) this.objectMode = this.objectMode || !!options.readableObjectMode;\n\n  // the point at which it stops calling _read() to fill the buffer\n  // Note: 0 is a valid value, means \"don't call _read preemptively ever\"\n  var hwm = options.highWaterMark;\n  var defaultHwm = this.objectMode ? 16 : 16 * 1024;\n  this.highWaterMark = hwm || hwm === 0 ? hwm : defaultHwm;\n\n  // cast to ints.\n  this.highWaterMark = ~~this.highWaterMark;\n\n  // A linked list is used to store data chunks instead of an array because the\n  // linked list can remove elements from the beginning faster than\n  // array.shift()\n  this.buffer = new BufferList();\n  this.length = 0;\n  this.pipes = null;\n  this.pipesCount = 0;\n  this.flowing = null;\n  this.ended = false;\n  this.endEmitted = false;\n  this.reading = false;\n\n  // a flag to be able to tell if the onwrite cb is called immediately,\n  // or on a later tick.  We set this to true at first, because any\n  // actions that shouldn't happen until \"later\" should generally also\n  // not happen before the first write call.\n  this.sync = true;\n\n  // whenever we return null, then we set a flag to say\n  // that we're awaiting a 'readable' event emission.\n  this.needReadable = false;\n  this.emittedReadable = false;\n  this.readableListening = false;\n  this.resumeScheduled = false;\n\n  // Crypto is kind of old and crusty.  Historically, its default string\n  // encoding is 'binary' so we have to make this configurable.\n  // Everything else in the universe uses 'utf8', though.\n  this.defaultEncoding = options.defaultEncoding || 'utf8';\n\n  // when piping, we only care about 'readable' events that happen\n  // after read()ing all the bytes and not getting any pushback.\n  this.ranOut = false;\n\n  // the number of writers that are awaiting a drain event in .pipe()s\n  this.awaitDrain = 0;\n\n  // if true, a maybeReadMore has been scheduled\n  this.readingMore = false;\n\n  this.decoder = null;\n  this.encoding = null;\n  if (options.encoding) {\n    if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;\n    this.decoder = new StringDecoder(options.encoding);\n    this.encoding = options.encoding;\n  }\n}\n\nfunction Readable(options) {\n  Duplex = Duplex || require('./_stream_duplex');\n\n  if (!(this instanceof Readable)) return new Readable(options);\n\n  this._readableState = new ReadableState(options, this);\n\n  // legacy\n  this.readable = true;\n\n  if (options && typeof options.read === 'function') this._read = options.read;\n\n  Stream.call(this);\n}\n\n// Manually shove something into the read() buffer.\n// This returns true if the highWaterMark has not been hit yet,\n// similar to how Writable.write() returns true if you should\n// write() some more.\nReadable.prototype.push = function (chunk, encoding) {\n  var state = this._readableState;\n\n  if (!state.objectMode && typeof chunk === 'string') {\n    encoding = encoding || state.defaultEncoding;\n    if (encoding !== state.encoding) {\n      chunk = Buffer.from(chunk, encoding);\n      encoding = '';\n    }\n  }\n\n  return readableAddChunk(this, state, chunk, encoding, false);\n};\n\n// Unshift should *always* be something directly out of read()\nReadable.prototype.unshift = function (chunk) {\n  var state = this._readableState;\n  return readableAddChunk(this, state, chunk, '', true);\n};\n\nReadable.prototype.isPaused = function () {\n  return this._readableState.flowing === false;\n};\n\nfunction readableAddChunk(stream, state, chunk, encoding, addToFront) {\n  var er = chunkInvalid(state, chunk);\n  if (er) {\n    stream.emit('error', er);\n  } else if (chunk === null) {\n    state.reading = false;\n    onEofChunk(stream, state);\n  } else if (state.objectMode || chunk && chunk.length > 0) {\n    if (state.ended && !addToFront) {\n      var e = new Error('stream.push() after EOF');\n      stream.emit('error', e);\n    } else if (state.endEmitted && addToFront) {\n      var _e = new Error('stream.unshift() after end event');\n      stream.emit('error', _e);\n    } else {\n      var skipAdd;\n      if (state.decoder && !addToFront && !encoding) {\n        chunk = state.decoder.write(chunk);\n        skipAdd = !state.objectMode && chunk.length === 0;\n      }\n\n      if (!addToFront) state.reading = false;\n\n      // Don't add to the buffer if we've decoded to an empty string chunk and\n      // we're not in object mode\n      if (!skipAdd) {\n        // if we want the data now, just emit it.\n        if (state.flowing && state.length === 0 && !state.sync) {\n          stream.emit('data', chunk);\n          stream.read(0);\n        } else {\n          // update the buffer info.\n          state.length += state.objectMode ? 1 : chunk.length;\n          if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);\n\n          if (state.needReadable) emitReadable(stream);\n        }\n      }\n\n      maybeReadMore(stream, state);\n    }\n  } else if (!addToFront) {\n    state.reading = false;\n  }\n\n  return needMoreData(state);\n}\n\n// if it's past the high water mark, we can push in some more.\n// Also, if we have no data yet, we can stand some\n// more bytes.  This is to work around cases where hwm=0,\n// such as the repl.  Also, if the push() triggered a\n// readable event, and the user called read(largeNumber) such that\n// needReadable was set, then we ought to push more, so that another\n// 'readable' event will be triggered.\nfunction needMoreData(state) {\n  return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);\n}\n\n// backwards compatibility.\nReadable.prototype.setEncoding = function (enc) {\n  if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;\n  this._readableState.decoder = new StringDecoder(enc);\n  this._readableState.encoding = enc;\n  return this;\n};\n\n// Don't raise the hwm > 8MB\nvar MAX_HWM = 0x800000;\nfunction computeNewHighWaterMark(n) {\n  if (n >= MAX_HWM) {\n    n = MAX_HWM;\n  } else {\n    // Get the next highest power of 2 to prevent increasing hwm excessively in\n    // tiny amounts\n    n--;\n    n |= n >>> 1;\n    n |= n >>> 2;\n    n |= n >>> 4;\n    n |= n >>> 8;\n    n |= n >>> 16;\n    n++;\n  }\n  return n;\n}\n\n// This function is designed to be inlinable, so please take care when making\n// changes to the function body.\nfunction howMuchToRead(n, state) {\n  if (n <= 0 || state.length === 0 && state.ended) return 0;\n  if (state.objectMode) return 1;\n  if (n !== n) {\n    // Only flow one buffer at a time\n    if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;\n  }\n  // If we're asking for more than the current hwm, then raise the hwm.\n  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);\n  if (n <= state.length) return n;\n  // Don't have enough\n  if (!state.ended) {\n    state.needReadable = true;\n    return 0;\n  }\n  return state.length;\n}\n\n// you can override either this method, or the async _read(n) below.\nReadable.prototype.read = function (n) {\n  debug('read', n);\n  n = parseInt(n, 10);\n  var state = this._readableState;\n  var nOrig = n;\n\n  if (n !== 0) state.emittedReadable = false;\n\n  // if we're doing read(0) to trigger a readable event, but we\n  // already have a bunch of data in the buffer, then just trigger\n  // the 'readable' event and move on.\n  if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {\n    debug('read: emitReadable', state.length, state.ended);\n    if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);\n    return null;\n  }\n\n  n = howMuchToRead(n, state);\n\n  // if we've ended, and we're now clear, then finish it up.\n  if (n === 0 && state.ended) {\n    if (state.length === 0) endReadable(this);\n    return null;\n  }\n\n  // All the actual chunk generation logic needs to be\n  // *below* the call to _read.  The reason is that in certain\n  // synthetic stream cases, such as passthrough streams, _read\n  // may be a completely synchronous operation which may change\n  // the state of the read buffer, providing enough data when\n  // before there was *not* enough.\n  //\n  // So, the steps are:\n  // 1. Figure out what the state of things will be after we do\n  // a read from the buffer.\n  //\n  // 2. If that resulting state will trigger a _read, then call _read.\n  // Note that this may be asynchronous, or synchronous.  Yes, it is\n  // deeply ugly to write APIs this way, but that still doesn't mean\n  // that the Readable class should behave improperly, as streams are\n  // designed to be sync/async agnostic.\n  // Take note if the _read call is sync or async (ie, if the read call\n  // has returned yet), so that we know whether or not it's safe to emit\n  // 'readable' etc.\n  //\n  // 3. Actually pull the requested chunks out of the buffer and return.\n\n  // if we need a readable event, then we need to do some reading.\n  var doRead = state.needReadable;\n  debug('need readable', doRead);\n\n  // if we currently have less than the highWaterMark, then also read some\n  if (state.length === 0 || state.length - n < state.highWaterMark) {\n    doRead = true;\n    debug('length less than watermark', doRead);\n  }\n\n  // however, if we've ended, then there's no point, and if we're already\n  // reading, then it's unnecessary.\n  if (state.ended || state.reading) {\n    doRead = false;\n    debug('reading or ended', doRead);\n  } else if (doRead) {\n    debug('do read');\n    state.reading = true;\n    state.sync = true;\n    // if the length is currently zero, then we *need* a readable event.\n    if (state.length === 0) state.needReadable = true;\n    // call internal read method\n    this._read(state.highWaterMark);\n    state.sync = false;\n    // If _read pushed data synchronously, then `reading` will be false,\n    // and we need to re-evaluate how much data we can return to the user.\n    if (!state.reading) n = howMuchToRead(nOrig, state);\n  }\n\n  var ret;\n  if (n > 0) ret = fromList(n, state);else ret = null;\n\n  if (ret === null) {\n    state.needReadable = true;\n    n = 0;\n  } else {\n    state.length -= n;\n  }\n\n  if (state.length === 0) {\n    // If we have nothing in the buffer, then we want to know\n    // as soon as we *do* get something into the buffer.\n    if (!state.ended) state.needReadable = true;\n\n    // If we tried to read() past the EOF, then emit end on the next tick.\n    if (nOrig !== n && state.ended) endReadable(this);\n  }\n\n  if (ret !== null) this.emit('data', ret);\n\n  return ret;\n};\n\nfunction chunkInvalid(state, chunk) {\n  var er = null;\n  if (!Buffer.isBuffer(chunk) && typeof chunk !== 'string' && chunk !== null && chunk !== undefined && !state.objectMode) {\n    er = new TypeError('Invalid non-string/buffer chunk');\n  }\n  return er;\n}\n\nfunction onEofChunk(stream, state) {\n  if (state.ended) return;\n  if (state.decoder) {\n    var chunk = state.decoder.end();\n    if (chunk && chunk.length) {\n      state.buffer.push(chunk);\n      state.length += state.objectMode ? 1 : chunk.length;\n    }\n  }\n  state.ended = true;\n\n  // emit 'readable' now to make sure it gets picked up.\n  emitReadable(stream);\n}\n\n// Don't emit readable right away in sync mode, because this can trigger\n// another read() call => stack overflow.  This way, it might trigger\n// a nextTick recursion warning, but that's not so bad.\nfunction emitReadable(stream) {\n  var state = stream._readableState;\n  state.needReadable = false;\n  if (!state.emittedReadable) {\n    debug('emitReadable', state.flowing);\n    state.emittedReadable = true;\n    if (state.sync) processNextTick(emitReadable_, stream);else emitReadable_(stream);\n  }\n}\n\nfunction emitReadable_(stream) {\n  debug('emit readable');\n  stream.emit('readable');\n  flow(stream);\n}\n\n// at this point, the user has presumably seen the 'readable' event,\n// and called read() to consume some data.  that may have triggered\n// in turn another _read(n) call, in which case reading = true if\n// it's in progress.\n// However, if we're not ended, or reading, and the length < hwm,\n// then go ahead and try to read some more preemptively.\nfunction maybeReadMore(stream, state) {\n  if (!state.readingMore) {\n    state.readingMore = true;\n    processNextTick(maybeReadMore_, stream, state);\n  }\n}\n\nfunction maybeReadMore_(stream, state) {\n  var len = state.length;\n  while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {\n    debug('maybeReadMore read 0');\n    stream.read(0);\n    if (len === state.length)\n      // didn't get any data, stop spinning.\n      break;else len = state.length;\n  }\n  state.readingMore = false;\n}\n\n// abstract method.  to be overridden in specific implementation classes.\n// call cb(er, data) where data is <= n in length.\n// for virtual (non-string, non-buffer) streams, \"length\" is somewhat\n// arbitrary, and perhaps not very meaningful.\nReadable.prototype._read = function (n) {\n  this.emit('error', new Error('_read() is not implemented'));\n};\n\nReadable.prototype.pipe = function (dest, pipeOpts) {\n  var src = this;\n  var state = this._readableState;\n\n  switch (state.pipesCount) {\n    case 0:\n      state.pipes = dest;\n      break;\n    case 1:\n      state.pipes = [state.pipes, dest];\n      break;\n    default:\n      state.pipes.push(dest);\n      break;\n  }\n  state.pipesCount += 1;\n  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);\n\n  var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;\n\n  var endFn = doEnd ? onend : unpipe;\n  if (state.endEmitted) processNextTick(endFn);else src.once('end', endFn);\n\n  dest.on('unpipe', onunpipe);\n  function onunpipe(readable) {\n    debug('onunpipe');\n    if (readable === src) {\n      cleanup();\n    }\n  }\n\n  function onend() {\n    debug('onend');\n    dest.end();\n  }\n\n  // when the dest drains, it reduces the awaitDrain counter\n  // on the source.  This would be more elegant with a .once()\n  // handler in flow(), but adding and removing repeatedly is\n  // too slow.\n  var ondrain = pipeOnDrain(src);\n  dest.on('drain', ondrain);\n\n  var cleanedUp = false;\n  function cleanup() {\n    debug('cleanup');\n    // cleanup event handlers once the pipe is broken\n    dest.removeListener('close', onclose);\n    dest.removeListener('finish', onfinish);\n    dest.removeListener('drain', ondrain);\n    dest.removeListener('error', onerror);\n    dest.removeListener('unpipe', onunpipe);\n    src.removeListener('end', onend);\n    src.removeListener('end', unpipe);\n    src.removeListener('data', ondata);\n\n    cleanedUp = true;\n\n    // if the reader is waiting for a drain event from this\n    // specific writer, then it would cause it to never start\n    // flowing again.\n    // So, if this is awaiting a drain, then we just call it now.\n    // If we don't know, then assume that we are waiting for one.\n    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();\n  }\n\n  // If the user pushes more data while we're writing to dest then we'll end up\n  // in ondata again. However, we only want to increase awaitDrain once because\n  // dest will only emit one 'drain' event for the multiple writes.\n  // => Introduce a guard on increasing awaitDrain.\n  var increasedAwaitDrain = false;\n  src.on('data', ondata);\n  function ondata(chunk) {\n    debug('ondata');\n    increasedAwaitDrain = false;\n    var ret = dest.write(chunk);\n    if (false === ret && !increasedAwaitDrain) {\n      // If the user unpiped during `dest.write()`, it is possible\n      // to get stuck in a permanently paused state if that write\n      // also returned false.\n      // => Check whether `dest` is still a piping destination.\n      if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {\n        debug('false write response, pause', src._readableState.awaitDrain);\n        src._readableState.awaitDrain++;\n        increasedAwaitDrain = true;\n      }\n      src.pause();\n    }\n  }\n\n  // if the dest has an error, then stop piping into it.\n  // however, don't suppress the throwing behavior for this.\n  function onerror(er) {\n    debug('onerror', er);\n    unpipe();\n    dest.removeListener('error', onerror);\n    if (EElistenerCount(dest, 'error') === 0) dest.emit('error', er);\n  }\n\n  // Make sure our error handler is attached before userland ones.\n  prependListener(dest, 'error', onerror);\n\n  // Both close and finish should trigger unpipe, but only once.\n  function onclose() {\n    dest.removeListener('finish', onfinish);\n    unpipe();\n  }\n  dest.once('close', onclose);\n  function onfinish() {\n    debug('onfinish');\n    dest.removeListener('close', onclose);\n    unpipe();\n  }\n  dest.once('finish', onfinish);\n\n  function unpipe() {\n    debug('unpipe');\n    src.unpipe(dest);\n  }\n\n  // tell the dest that it's being piped to\n  dest.emit('pipe', src);\n\n  // start the flow if it hasn't been started already.\n  if (!state.flowing) {\n    debug('pipe resume');\n    src.resume();\n  }\n\n  return dest;\n};\n\nfunction pipeOnDrain(src) {\n  return function () {\n    var state = src._readableState;\n    debug('pipeOnDrain', state.awaitDrain);\n    if (state.awaitDrain) state.awaitDrain--;\n    if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {\n      state.flowing = true;\n      flow(src);\n    }\n  };\n}\n\nReadable.prototype.unpipe = function (dest) {\n  var state = this._readableState;\n\n  // if we're not piping anywhere, then do nothing.\n  if (state.pipesCount === 0) return this;\n\n  // just one destination.  most common case.\n  if (state.pipesCount === 1) {\n    // passed in one, but it's not the right one.\n    if (dest && dest !== state.pipes) return this;\n\n    if (!dest) dest = state.pipes;\n\n    // got a match.\n    state.pipes = null;\n    state.pipesCount = 0;\n    state.flowing = false;\n    if (dest) dest.emit('unpipe', this);\n    return this;\n  }\n\n  // slow case. multiple pipe destinations.\n\n  if (!dest) {\n    // remove all.\n    var dests = state.pipes;\n    var len = state.pipesCount;\n    state.pipes = null;\n    state.pipesCount = 0;\n    state.flowing = false;\n\n    for (var i = 0; i < len; i++) {\n      dests[i].emit('unpipe', this);\n    }return this;\n  }\n\n  // try to find the right one.\n  var index = indexOf(state.pipes, dest);\n  if (index === -1) return this;\n\n  state.pipes.splice(index, 1);\n  state.pipesCount -= 1;\n  if (state.pipesCount === 1) state.pipes = state.pipes[0];\n\n  dest.emit('unpipe', this);\n\n  return this;\n};\n\n// set up data events if they are asked for\n// Ensure readable listeners eventually get something\nReadable.prototype.on = function (ev, fn) {\n  var res = Stream.prototype.on.call(this, ev, fn);\n\n  if (ev === 'data') {\n    // Start flowing on next tick if stream isn't explicitly paused\n    if (this._readableState.flowing !== false) this.resume();\n  } else if (ev === 'readable') {\n    var state = this._readableState;\n    if (!state.endEmitted && !state.readableListening) {\n      state.readableListening = state.needReadable = true;\n      state.emittedReadable = false;\n      if (!state.reading) {\n        processNextTick(nReadingNextTick, this);\n      } else if (state.length) {\n        emitReadable(this, state);\n      }\n    }\n  }\n\n  return res;\n};\nReadable.prototype.addListener = Readable.prototype.on;\n\nfunction nReadingNextTick(self) {\n  debug('readable nexttick read 0');\n  self.read(0);\n}\n\n// pause() and resume() are remnants of the legacy readable stream API\n// If the user uses them, then switch into old mode.\nReadable.prototype.resume = function () {\n  var state = this._readableState;\n  if (!state.flowing) {\n    debug('resume');\n    state.flowing = true;\n    resume(this, state);\n  }\n  return this;\n};\n\nfunction resume(stream, state) {\n  if (!state.resumeScheduled) {\n    state.resumeScheduled = true;\n    processNextTick(resume_, stream, state);\n  }\n}\n\nfunction resume_(stream, state) {\n  if (!state.reading) {\n    debug('resume read 0');\n    stream.read(0);\n  }\n\n  state.resumeScheduled = false;\n  state.awaitDrain = 0;\n  stream.emit('resume');\n  flow(stream);\n  if (state.flowing && !state.reading) stream.read(0);\n}\n\nReadable.prototype.pause = function () {\n  debug('call pause flowing=%j', this._readableState.flowing);\n  if (false !== this._readableState.flowing) {\n    debug('pause');\n    this._readableState.flowing = false;\n    this.emit('pause');\n  }\n  return this;\n};\n\nfunction flow(stream) {\n  var state = stream._readableState;\n  debug('flow', state.flowing);\n  while (state.flowing && stream.read() !== null) {}\n}\n\n// wrap an old-style stream as the async data source.\n// This is *not* part of the readable stream interface.\n// It is an ugly unfortunate mess of history.\nReadable.prototype.wrap = function (stream) {\n  var state = this._readableState;\n  var paused = false;\n\n  var self = this;\n  stream.on('end', function () {\n    debug('wrapped end');\n    if (state.decoder && !state.ended) {\n      var chunk = state.decoder.end();\n      if (chunk && chunk.length) self.push(chunk);\n    }\n\n    self.push(null);\n  });\n\n  stream.on('data', function (chunk) {\n    debug('wrapped data');\n    if (state.decoder) chunk = state.decoder.write(chunk);\n\n    // don't skip over falsy values in objectMode\n    if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;\n\n    var ret = self.push(chunk);\n    if (!ret) {\n      paused = true;\n      stream.pause();\n    }\n  });\n\n  // proxy all the other methods.\n  // important when wrapping filters and duplexes.\n  for (var i in stream) {\n    if (this[i] === undefined && typeof stream[i] === 'function') {\n      this[i] = function (method) {\n        return function () {\n          return stream[method].apply(stream, arguments);\n        };\n      }(i);\n    }\n  }\n\n  // proxy certain important events.\n  for (var n = 0; n < kProxyEvents.length; n++) {\n    stream.on(kProxyEvents[n], self.emit.bind(self, kProxyEvents[n]));\n  }\n\n  // when we try to consume some more bytes, simply unpause the\n  // underlying stream.\n  self._read = function (n) {\n    debug('wrapped _read', n);\n    if (paused) {\n      paused = false;\n      stream.resume();\n    }\n  };\n\n  return self;\n};\n\n// exposed for testing purposes only.\nReadable._fromList = fromList;\n\n// Pluck off n bytes from an array of buffers.\n// Length is the combined lengths of all the buffers in the list.\n// This function is designed to be inlinable, so please take care when making\n// changes to the function body.\nfunction fromList(n, state) {\n  // nothing buffered\n  if (state.length === 0) return null;\n\n  var ret;\n  if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {\n    // read it all, truncate the list\n    if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.head.data;else ret = state.buffer.concat(state.length);\n    state.buffer.clear();\n  } else {\n    // read part of list\n    ret = fromListPartial(n, state.buffer, state.decoder);\n  }\n\n  return ret;\n}\n\n// Extracts only enough buffered data to satisfy the amount requested.\n// This function is designed to be inlinable, so please take care when making\n// changes to the function body.\nfunction fromListPartial(n, list, hasStrings) {\n  var ret;\n  if (n < list.head.data.length) {\n    // slice is the same for buffers and strings\n    ret = list.head.data.slice(0, n);\n    list.head.data = list.head.data.slice(n);\n  } else if (n === list.head.data.length) {\n    // first chunk is a perfect match\n    ret = list.shift();\n  } else {\n    // result spans more than one buffer\n    ret = hasStrings ? copyFromBufferString(n, list) : copyFromBuffer(n, list);\n  }\n  return ret;\n}\n\n// Copies a specified amount of characters from the list of buffered data\n// chunks.\n// This function is designed to be inlinable, so please take care when making\n// changes to the function body.\nfunction copyFromBufferString(n, list) {\n  var p = list.head;\n  var c = 1;\n  var ret = p.data;\n  n -= ret.length;\n  while (p = p.next) {\n    var str = p.data;\n    var nb = n > str.length ? str.length : n;\n    if (nb === str.length) ret += str;else ret += str.slice(0, n);\n    n -= nb;\n    if (n === 0) {\n      if (nb === str.length) {\n        ++c;\n        if (p.next) list.head = p.next;else list.head = list.tail = null;\n      } else {\n        list.head = p;\n        p.data = str.slice(nb);\n      }\n      break;\n    }\n    ++c;\n  }\n  list.length -= c;\n  return ret;\n}\n\n// Copies a specified amount of bytes from the list of buffered data chunks.\n// This function is designed to be inlinable, so please take care when making\n// changes to the function body.\nfunction copyFromBuffer(n, list) {\n  var ret = Buffer.allocUnsafe(n);\n  var p = list.head;\n  var c = 1;\n  p.data.copy(ret);\n  n -= p.data.length;\n  while (p = p.next) {\n    var buf = p.data;\n    var nb = n > buf.length ? buf.length : n;\n    buf.copy(ret, ret.length - n, 0, nb);\n    n -= nb;\n    if (n === 0) {\n      if (nb === buf.length) {\n        ++c;\n        if (p.next) list.head = p.next;else list.head = list.tail = null;\n      } else {\n        list.head = p;\n        p.data = buf.slice(nb);\n      }\n      break;\n    }\n    ++c;\n  }\n  list.length -= c;\n  return ret;\n}\n\nfunction endReadable(stream) {\n  var state = stream._readableState;\n\n  // If we get here before consuming all the bytes, then that is a\n  // bug in node.  Should never happen.\n  if (state.length > 0) throw new Error('\"endReadable()\" called on non-empty stream');\n\n  if (!state.endEmitted) {\n    state.ended = true;\n    processNextTick(endReadableNT, state, stream);\n  }\n}\n\nfunction endReadableNT(state, stream) {\n  // Check that we didn't get one last unshift.\n  if (!state.endEmitted && state.length === 0) {\n    state.endEmitted = true;\n    stream.readable = false;\n    stream.emit('end');\n  }\n}\n\nfunction forEach(xs, f) {\n  for (var i = 0, l = xs.length; i < l; i++) {\n    f(xs[i], i);\n  }\n}\n\nfunction indexOf(xs, x) {\n  for (var i = 0, l = xs.length; i < l; i++) {\n    if (xs[i] === x) return i;\n  }\n  return -1;\n}\n}).call(this,require('_process'))\n},{\"./_stream_duplex\":84,\"./internal/streams/BufferList\":89,\"./internal/streams/stream\":90,\"_process\":82,\"core-util-is\":44,\"events\":62,\"inherits\":66,\"isarray\":68,\"process-nextick-args\":81,\"safe-buffer\":95,\"string_decoder/\":97,\"util\":40}],87:[function(require,module,exports){\n// a transform stream is a readable/writable stream where you do\n// something with the data.  Sometimes it's called a \"filter\",\n// but that's not a great name for it, since that implies a thing where\n// some bits pass through, and others are simply ignored.  (That would\n// be a valid example of a transform, of course.)\n//\n// While the output is causally related to the input, it's not a\n// necessarily symmetric or synchronous transformation.  For example,\n// a zlib stream might take multiple plain-text writes(), and then\n// emit a single compressed chunk some time in the future.\n//\n// Here's how this works:\n//\n// The Transform stream has all the aspects of the readable and writable\n// stream classes.  When you write(chunk), that calls _write(chunk,cb)\n// internally, and returns false if there's a lot of pending writes\n// buffered up.  When you call read(), that calls _read(n) until\n// there's enough pending readable data buffered up.\n//\n// In a transform stream, the written data is placed in a buffer.  When\n// _read(n) is called, it transforms the queued up data, calling the\n// buffered _write cb's as it consumes chunks.  If consuming a single\n// written chunk would result in multiple output chunks, then the first\n// outputted bit calls the readcb, and subsequent chunks just go into\n// the read buffer, and will cause it to emit 'readable' if necessary.\n//\n// This way, back-pressure is actually determined by the reading side,\n// since _read has to be called to start processing a new chunk.  However,\n// a pathological inflate type of transform can cause excessive buffering\n// here.  For example, imagine a stream where every byte of input is\n// interpreted as an integer from 0-255, and then results in that many\n// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in\n// 1kb of data being output.  In this case, you could write a very small\n// amount of input, and end up with a very large amount of output.  In\n// such a pathological inflating mechanism, there'd be no way to tell\n// the system to stop doing the transform.  A single 4MB write could\n// cause the system to run out of memory.\n//\n// However, even in such a pathological case, only a single written chunk\n// would be consumed, and then the rest would wait (un-transformed) until\n// the results of the previous transformed chunk were consumed.\n\n'use strict';\n\nmodule.exports = Transform;\n\nvar Duplex = require('./_stream_duplex');\n\n/*<replacement>*/\nvar util = require('core-util-is');\nutil.inherits = require('inherits');\n/*</replacement>*/\n\nutil.inherits(Transform, Duplex);\n\nfunction TransformState(stream) {\n  this.afterTransform = function (er, data) {\n    return afterTransform(stream, er, data);\n  };\n\n  this.needTransform = false;\n  this.transforming = false;\n  this.writecb = null;\n  this.writechunk = null;\n  this.writeencoding = null;\n}\n\nfunction afterTransform(stream, er, data) {\n  var ts = stream._transformState;\n  ts.transforming = false;\n\n  var cb = ts.writecb;\n\n  if (!cb) return stream.emit('error', new Error('no writecb in Transform class'));\n\n  ts.writechunk = null;\n  ts.writecb = null;\n\n  if (data !== null && data !== undefined) stream.push(data);\n\n  cb(er);\n\n  var rs = stream._readableState;\n  rs.reading = false;\n  if (rs.needReadable || rs.length < rs.highWaterMark) {\n    stream._read(rs.highWaterMark);\n  }\n}\n\nfunction Transform(options) {\n  if (!(this instanceof Transform)) return new Transform(options);\n\n  Duplex.call(this, options);\n\n  this._transformState = new TransformState(this);\n\n  var stream = this;\n\n  // start out asking for a readable event once data is transformed.\n  this._readableState.needReadable = true;\n\n  // we have implemented the _read method, and done the other things\n  // that Readable wants before the first _read call, so unset the\n  // sync guard flag.\n  this._readableState.sync = false;\n\n  if (options) {\n    if (typeof options.transform === 'function') this._transform = options.transform;\n\n    if (typeof options.flush === 'function') this._flush = options.flush;\n  }\n\n  // When the writable side finishes, then flush out anything remaining.\n  this.once('prefinish', function () {\n    if (typeof this._flush === 'function') this._flush(function (er, data) {\n      done(stream, er, data);\n    });else done(stream);\n  });\n}\n\nTransform.prototype.push = function (chunk, encoding) {\n  this._transformState.needTransform = false;\n  return Duplex.prototype.push.call(this, chunk, encoding);\n};\n\n// This is the part where you do stuff!\n// override this function in implementation classes.\n// 'chunk' is an input chunk.\n//\n// Call `push(newChunk)` to pass along transformed output\n// to the readable side.  You may call 'push' zero or more times.\n//\n// Call `cb(err)` when you are done with this chunk.  If you pass\n// an error, then that'll put the hurt on the whole operation.  If you\n// never call cb(), then you'll never get another chunk.\nTransform.prototype._transform = function (chunk, encoding, cb) {\n  throw new Error('_transform() is not implemented');\n};\n\nTransform.prototype._write = function (chunk, encoding, cb) {\n  var ts = this._transformState;\n  ts.writecb = cb;\n  ts.writechunk = chunk;\n  ts.writeencoding = encoding;\n  if (!ts.transforming) {\n    var rs = this._readableState;\n    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);\n  }\n};\n\n// Doesn't matter what the args are here.\n// _transform does all the work.\n// That we got here means that the readable side wants more data.\nTransform.prototype._read = function (n) {\n  var ts = this._transformState;\n\n  if (ts.writechunk !== null && ts.writecb && !ts.transforming) {\n    ts.transforming = true;\n    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);\n  } else {\n    // mark that we need a transform, so that any data that comes in\n    // will get processed, now that we've asked for it.\n    ts.needTransform = true;\n  }\n};\n\nfunction done(stream, er, data) {\n  if (er) return stream.emit('error', er);\n\n  if (data !== null && data !== undefined) stream.push(data);\n\n  // if there's nothing in the write buffer, then that means\n  // that nothing more will ever be provided\n  var ws = stream._writableState;\n  var ts = stream._transformState;\n\n  if (ws.length) throw new Error('Calling transform done when ws.length != 0');\n\n  if (ts.transforming) throw new Error('Calling transform done when still transforming');\n\n  return stream.push(null);\n}\n},{\"./_stream_duplex\":84,\"core-util-is\":44,\"inherits\":66}],88:[function(require,module,exports){\n(function (process){\n// A bit simpler than readable streams.\n// Implement an async ._write(chunk, encoding, cb), and it'll handle all\n// the drain event emission and buffering.\n\n'use strict';\n\nmodule.exports = Writable;\n\n/*<replacement>*/\nvar processNextTick = require('process-nextick-args');\n/*</replacement>*/\n\n/*<replacement>*/\nvar asyncWrite = !process.browser && ['v0.10', 'v0.9.'].indexOf(process.version.slice(0, 5)) > -1 ? setImmediate : processNextTick;\n/*</replacement>*/\n\n/*<replacement>*/\nvar Duplex;\n/*</replacement>*/\n\nWritable.WritableState = WritableState;\n\n/*<replacement>*/\nvar util = require('core-util-is');\nutil.inherits = require('inherits');\n/*</replacement>*/\n\n/*<replacement>*/\nvar internalUtil = {\n  deprecate: require('util-deprecate')\n};\n/*</replacement>*/\n\n/*<replacement>*/\nvar Stream = require('./internal/streams/stream');\n/*</replacement>*/\n\n/*<replacement>*/\nvar Buffer = require('safe-buffer').Buffer;\n/*</replacement>*/\n\nutil.inherits(Writable, Stream);\n\nfunction nop() {}\n\nfunction WriteReq(chunk, encoding, cb) {\n  this.chunk = chunk;\n  this.encoding = encoding;\n  this.callback = cb;\n  this.next = null;\n}\n\nfunction WritableState(options, stream) {\n  Duplex = Duplex || require('./_stream_duplex');\n\n  options = options || {};\n\n  // object stream flag to indicate whether or not this stream\n  // contains buffers or objects.\n  this.objectMode = !!options.objectMode;\n\n  if (stream instanceof Duplex) this.objectMode = this.objectMode || !!options.writableObjectMode;\n\n  // the point at which write() starts returning false\n  // Note: 0 is a valid value, means that we always return false if\n  // the entire buffer is not flushed immediately on write()\n  var hwm = options.highWaterMark;\n  var defaultHwm = this.objectMode ? 16 : 16 * 1024;\n  this.highWaterMark = hwm || hwm === 0 ? hwm : defaultHwm;\n\n  // cast to ints.\n  this.highWaterMark = ~~this.highWaterMark;\n\n  // drain event flag.\n  this.needDrain = false;\n  // at the start of calling end()\n  this.ending = false;\n  // when end() has been called, and returned\n  this.ended = false;\n  // when 'finish' is emitted\n  this.finished = false;\n\n  // should we decode strings into buffers before passing to _write?\n  // this is here so that some node-core streams can optimize string\n  // handling at a lower level.\n  var noDecode = options.decodeStrings === false;\n  this.decodeStrings = !noDecode;\n\n  // Crypto is kind of old and crusty.  Historically, its default string\n  // encoding is 'binary' so we have to make this configurable.\n  // Everything else in the universe uses 'utf8', though.\n  this.defaultEncoding = options.defaultEncoding || 'utf8';\n\n  // not an actual buffer we keep track of, but a measurement\n  // of how much we're waiting to get pushed to some underlying\n  // socket or file.\n  this.length = 0;\n\n  // a flag to see when we're in the middle of a write.\n  this.writing = false;\n\n  // when true all writes will be buffered until .uncork() call\n  this.corked = 0;\n\n  // a flag to be able to tell if the onwrite cb is called immediately,\n  // or on a later tick.  We set this to true at first, because any\n  // actions that shouldn't happen until \"later\" should generally also\n  // not happen before the first write call.\n  this.sync = true;\n\n  // a flag to know if we're processing previously buffered items, which\n  // may call the _write() callback in the same tick, so that we don't\n  // end up in an overlapped onwrite situation.\n  this.bufferProcessing = false;\n\n  // the callback that's passed to _write(chunk,cb)\n  this.onwrite = function (er) {\n    onwrite(stream, er);\n  };\n\n  // the callback that the user supplies to write(chunk,encoding,cb)\n  this.writecb = null;\n\n  // the amount that is being written when _write is called.\n  this.writelen = 0;\n\n  this.bufferedRequest = null;\n  this.lastBufferedRequest = null;\n\n  // number of pending user-supplied write callbacks\n  // this must be 0 before 'finish' can be emitted\n  this.pendingcb = 0;\n\n  // emit prefinish if the only thing we're waiting for is _write cbs\n  // This is relevant for synchronous Transform streams\n  this.prefinished = false;\n\n  // True if the error was already emitted and should not be thrown again\n  this.errorEmitted = false;\n\n  // count buffered requests\n  this.bufferedRequestCount = 0;\n\n  // allocate the first CorkedRequest, there is always\n  // one allocated and free to use, and we maintain at most two\n  this.corkedRequestsFree = new CorkedRequest(this);\n}\n\nWritableState.prototype.getBuffer = function getBuffer() {\n  var current = this.bufferedRequest;\n  var out = [];\n  while (current) {\n    out.push(current);\n    current = current.next;\n  }\n  return out;\n};\n\n(function () {\n  try {\n    Object.defineProperty(WritableState.prototype, 'buffer', {\n      get: internalUtil.deprecate(function () {\n        return this.getBuffer();\n      }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.')\n    });\n  } catch (_) {}\n})();\n\n// Test _writableState for inheritance to account for Duplex streams,\n// whose prototype chain only points to Readable.\nvar realHasInstance;\nif (typeof Symbol === 'function' && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === 'function') {\n  realHasInstance = Function.prototype[Symbol.hasInstance];\n  Object.defineProperty(Writable, Symbol.hasInstance, {\n    value: function (object) {\n      if (realHasInstance.call(this, object)) return true;\n\n      return object && object._writableState instanceof WritableState;\n    }\n  });\n} else {\n  realHasInstance = function (object) {\n    return object instanceof this;\n  };\n}\n\nfunction Writable(options) {\n  Duplex = Duplex || require('./_stream_duplex');\n\n  // Writable ctor is applied to Duplexes, too.\n  // `realHasInstance` is necessary because using plain `instanceof`\n  // would return false, as no `_writableState` property is attached.\n\n  // Trying to use the custom `instanceof` for Writable here will also break the\n  // Node.js LazyTransform implementation, which has a non-trivial getter for\n  // `_writableState` that would lead to infinite recursion.\n  if (!realHasInstance.call(Writable, this) && !(this instanceof Duplex)) {\n    return new Writable(options);\n  }\n\n  this._writableState = new WritableState(options, this);\n\n  // legacy.\n  this.writable = true;\n\n  if (options) {\n    if (typeof options.write === 'function') this._write = options.write;\n\n    if (typeof options.writev === 'function') this._writev = options.writev;\n  }\n\n  Stream.call(this);\n}\n\n// Otherwise people can pipe Writable streams, which is just wrong.\nWritable.prototype.pipe = function () {\n  this.emit('error', new Error('Cannot pipe, not readable'));\n};\n\nfunction writeAfterEnd(stream, cb) {\n  var er = new Error('write after end');\n  // TODO: defer error events consistently everywhere, not just the cb\n  stream.emit('error', er);\n  processNextTick(cb, er);\n}\n\n// Checks that a user-supplied chunk is valid, especially for the particular\n// mode the stream is in. Currently this means that `null` is never accepted\n// and undefined/non-string values are only allowed in object mode.\nfunction validChunk(stream, state, chunk, cb) {\n  var valid = true;\n  var er = false;\n\n  if (chunk === null) {\n    er = new TypeError('May not write null values to stream');\n  } else if (typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {\n    er = new TypeError('Invalid non-string/buffer chunk');\n  }\n  if (er) {\n    stream.emit('error', er);\n    processNextTick(cb, er);\n    valid = false;\n  }\n  return valid;\n}\n\nWritable.prototype.write = function (chunk, encoding, cb) {\n  var state = this._writableState;\n  var ret = false;\n  var isBuf = Buffer.isBuffer(chunk);\n\n  if (typeof encoding === 'function') {\n    cb = encoding;\n    encoding = null;\n  }\n\n  if (isBuf) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;\n\n  if (typeof cb !== 'function') cb = nop;\n\n  if (state.ended) writeAfterEnd(this, cb);else if (isBuf || validChunk(this, state, chunk, cb)) {\n    state.pendingcb++;\n    ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);\n  }\n\n  return ret;\n};\n\nWritable.prototype.cork = function () {\n  var state = this._writableState;\n\n  state.corked++;\n};\n\nWritable.prototype.uncork = function () {\n  var state = this._writableState;\n\n  if (state.corked) {\n    state.corked--;\n\n    if (!state.writing && !state.corked && !state.finished && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);\n  }\n};\n\nWritable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {\n  // node::ParseEncoding() requires lower case.\n  if (typeof encoding === 'string') encoding = encoding.toLowerCase();\n  if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new TypeError('Unknown encoding: ' + encoding);\n  this._writableState.defaultEncoding = encoding;\n  return this;\n};\n\nfunction decodeChunk(state, chunk, encoding) {\n  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {\n    chunk = Buffer.from(chunk, encoding);\n  }\n  return chunk;\n}\n\n// if we're already writing something, then just put this\n// in the queue, and wait our turn.  Otherwise, call _write\n// If we return false, then we need a drain event, so set that flag.\nfunction writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {\n  if (!isBuf) {\n    chunk = decodeChunk(state, chunk, encoding);\n    if (Buffer.isBuffer(chunk)) encoding = 'buffer';\n  }\n  var len = state.objectMode ? 1 : chunk.length;\n\n  state.length += len;\n\n  var ret = state.length < state.highWaterMark;\n  // we must ensure that previous needDrain will not be reset to false.\n  if (!ret) state.needDrain = true;\n\n  if (state.writing || state.corked) {\n    var last = state.lastBufferedRequest;\n    state.lastBufferedRequest = new WriteReq(chunk, encoding, cb);\n    if (last) {\n      last.next = state.lastBufferedRequest;\n    } else {\n      state.bufferedRequest = state.lastBufferedRequest;\n    }\n    state.bufferedRequestCount += 1;\n  } else {\n    doWrite(stream, state, false, len, chunk, encoding, cb);\n  }\n\n  return ret;\n}\n\nfunction doWrite(stream, state, writev, len, chunk, encoding, cb) {\n  state.writelen = len;\n  state.writecb = cb;\n  state.writing = true;\n  state.sync = true;\n  if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);\n  state.sync = false;\n}\n\nfunction onwriteError(stream, state, sync, er, cb) {\n  --state.pendingcb;\n  if (sync) processNextTick(cb, er);else cb(er);\n\n  stream._writableState.errorEmitted = true;\n  stream.emit('error', er);\n}\n\nfunction onwriteStateUpdate(state) {\n  state.writing = false;\n  state.writecb = null;\n  state.length -= state.writelen;\n  state.writelen = 0;\n}\n\nfunction onwrite(stream, er) {\n  var state = stream._writableState;\n  var sync = state.sync;\n  var cb = state.writecb;\n\n  onwriteStateUpdate(state);\n\n  if (er) onwriteError(stream, state, sync, er, cb);else {\n    // Check if we're actually ready to finish, but don't emit yet\n    var finished = needFinish(state);\n\n    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {\n      clearBuffer(stream, state);\n    }\n\n    if (sync) {\n      /*<replacement>*/\n      asyncWrite(afterWrite, stream, state, finished, cb);\n      /*</replacement>*/\n    } else {\n      afterWrite(stream, state, finished, cb);\n    }\n  }\n}\n\nfunction afterWrite(stream, state, finished, cb) {\n  if (!finished) onwriteDrain(stream, state);\n  state.pendingcb--;\n  cb();\n  finishMaybe(stream, state);\n}\n\n// Must force callback to be called on nextTick, so that we don't\n// emit 'drain' before the write() consumer gets the 'false' return\n// value, and has a chance to attach a 'drain' listener.\nfunction onwriteDrain(stream, state) {\n  if (state.length === 0 && state.needDrain) {\n    state.needDrain = false;\n    stream.emit('drain');\n  }\n}\n\n// if there's something in the buffer waiting, then process it\nfunction clearBuffer(stream, state) {\n  state.bufferProcessing = true;\n  var entry = state.bufferedRequest;\n\n  if (stream._writev && entry && entry.next) {\n    // Fast case, write everything using _writev()\n    var l = state.bufferedRequestCount;\n    var buffer = new Array(l);\n    var holder = state.corkedRequestsFree;\n    holder.entry = entry;\n\n    var count = 0;\n    while (entry) {\n      buffer[count] = entry;\n      entry = entry.next;\n      count += 1;\n    }\n\n    doWrite(stream, state, true, state.length, buffer, '', holder.finish);\n\n    // doWrite is almost always async, defer these to save a bit of time\n    // as the hot path ends with doWrite\n    state.pendingcb++;\n    state.lastBufferedRequest = null;\n    if (holder.next) {\n      state.corkedRequestsFree = holder.next;\n      holder.next = null;\n    } else {\n      state.corkedRequestsFree = new CorkedRequest(state);\n    }\n  } else {\n    // Slow case, write chunks one-by-one\n    while (entry) {\n      var chunk = entry.chunk;\n      var encoding = entry.encoding;\n      var cb = entry.callback;\n      var len = state.objectMode ? 1 : chunk.length;\n\n      doWrite(stream, state, false, len, chunk, encoding, cb);\n      entry = entry.next;\n      // if we didn't call the onwrite immediately, then\n      // it means that we need to wait until it does.\n      // also, that means that the chunk and cb are currently\n      // being processed, so move the buffer counter past them.\n      if (state.writing) {\n        break;\n      }\n    }\n\n    if (entry === null) state.lastBufferedRequest = null;\n  }\n\n  state.bufferedRequestCount = 0;\n  state.bufferedRequest = entry;\n  state.bufferProcessing = false;\n}\n\nWritable.prototype._write = function (chunk, encoding, cb) {\n  cb(new Error('_write() is not implemented'));\n};\n\nWritable.prototype._writev = null;\n\nWritable.prototype.end = function (chunk, encoding, cb) {\n  var state = this._writableState;\n\n  if (typeof chunk === 'function') {\n    cb = chunk;\n    chunk = null;\n    encoding = null;\n  } else if (typeof encoding === 'function') {\n    cb = encoding;\n    encoding = null;\n  }\n\n  if (chunk !== null && chunk !== undefined) this.write(chunk, encoding);\n\n  // .end() fully uncorks\n  if (state.corked) {\n    state.corked = 1;\n    this.uncork();\n  }\n\n  // ignore unnecessary end() calls.\n  if (!state.ending && !state.finished) endWritable(this, state, cb);\n};\n\nfunction needFinish(state) {\n  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;\n}\n\nfunction prefinish(stream, state) {\n  if (!state.prefinished) {\n    state.prefinished = true;\n    stream.emit('prefinish');\n  }\n}\n\nfunction finishMaybe(stream, state) {\n  var need = needFinish(state);\n  if (need) {\n    if (state.pendingcb === 0) {\n      prefinish(stream, state);\n      state.finished = true;\n      stream.emit('finish');\n    } else {\n      prefinish(stream, state);\n    }\n  }\n  return need;\n}\n\nfunction endWritable(stream, state, cb) {\n  state.ending = true;\n  finishMaybe(stream, state);\n  if (cb) {\n    if (state.finished) processNextTick(cb);else stream.once('finish', cb);\n  }\n  state.ended = true;\n  stream.writable = false;\n}\n\n// It seems a linked list but it is not\n// there will be only 2 of these for each stream\nfunction CorkedRequest(state) {\n  var _this = this;\n\n  this.next = null;\n  this.entry = null;\n  this.finish = function (err) {\n    var entry = _this.entry;\n    _this.entry = null;\n    while (entry) {\n      var cb = entry.callback;\n      state.pendingcb--;\n      cb(err);\n      entry = entry.next;\n    }\n    if (state.corkedRequestsFree) {\n      state.corkedRequestsFree.next = _this;\n    } else {\n      state.corkedRequestsFree = _this;\n    }\n  };\n}\n}).call(this,require('_process'))\n},{\"./_stream_duplex\":84,\"./internal/streams/stream\":90,\"_process\":82,\"core-util-is\":44,\"inherits\":66,\"process-nextick-args\":81,\"safe-buffer\":95,\"util-deprecate\":99}],89:[function(require,module,exports){\n'use strict';\n\n/*<replacement>*/\n\nvar Buffer = require('safe-buffer').Buffer;\n/*</replacement>*/\n\nmodule.exports = BufferList;\n\nfunction BufferList() {\n  this.head = null;\n  this.tail = null;\n  this.length = 0;\n}\n\nBufferList.prototype.push = function (v) {\n  var entry = { data: v, next: null };\n  if (this.length > 0) this.tail.next = entry;else this.head = entry;\n  this.tail = entry;\n  ++this.length;\n};\n\nBufferList.prototype.unshift = function (v) {\n  var entry = { data: v, next: this.head };\n  if (this.length === 0) this.tail = entry;\n  this.head = entry;\n  ++this.length;\n};\n\nBufferList.prototype.shift = function () {\n  if (this.length === 0) return;\n  var ret = this.head.data;\n  if (this.length === 1) this.head = this.tail = null;else this.head = this.head.next;\n  --this.length;\n  return ret;\n};\n\nBufferList.prototype.clear = function () {\n  this.head = this.tail = null;\n  this.length = 0;\n};\n\nBufferList.prototype.join = function (s) {\n  if (this.length === 0) return '';\n  var p = this.head;\n  var ret = '' + p.data;\n  while (p = p.next) {\n    ret += s + p.data;\n  }return ret;\n};\n\nBufferList.prototype.concat = function (n) {\n  if (this.length === 0) return Buffer.alloc(0);\n  if (this.length === 1) return this.head.data;\n  var ret = Buffer.allocUnsafe(n >>> 0);\n  var p = this.head;\n  var i = 0;\n  while (p) {\n    p.data.copy(ret, i);\n    i += p.data.length;\n    p = p.next;\n  }\n  return ret;\n};\n},{\"safe-buffer\":95}],90:[function(require,module,exports){\nmodule.exports = require('events').EventEmitter;\n\n},{\"events\":62}],91:[function(require,module,exports){\nmodule.exports = require('./readable').PassThrough\n\n},{\"./readable\":92}],92:[function(require,module,exports){\nexports = module.exports = require('./lib/_stream_readable.js');\nexports.Stream = exports;\nexports.Readable = exports;\nexports.Writable = require('./lib/_stream_writable.js');\nexports.Duplex = require('./lib/_stream_duplex.js');\nexports.Transform = require('./lib/_stream_transform.js');\nexports.PassThrough = require('./lib/_stream_passthrough.js');\n\n},{\"./lib/_stream_duplex.js\":84,\"./lib/_stream_passthrough.js\":85,\"./lib/_stream_readable.js\":86,\"./lib/_stream_transform.js\":87,\"./lib/_stream_writable.js\":88}],93:[function(require,module,exports){\nmodule.exports = require('./readable').Transform\n\n},{\"./readable\":92}],94:[function(require,module,exports){\nmodule.exports = require('./lib/_stream_writable.js');\n\n},{\"./lib/_stream_writable.js\":88}],95:[function(require,module,exports){\nmodule.exports = require('buffer')\n\n},{\"buffer\":43}],96:[function(require,module,exports){\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nmodule.exports = Stream;\n\nvar EE = require('events').EventEmitter;\nvar inherits = require('inherits');\n\ninherits(Stream, EE);\nStream.Readable = require('readable-stream/readable.js');\nStream.Writable = require('readable-stream/writable.js');\nStream.Duplex = require('readable-stream/duplex.js');\nStream.Transform = require('readable-stream/transform.js');\nStream.PassThrough = require('readable-stream/passthrough.js');\n\n// Backwards-compat with node 0.4.x\nStream.Stream = Stream;\n\n\n\n// old-style streams.  Note that the pipe method (the only relevant\n// part of this class) is overridden in the Readable class.\n\nfunction Stream() {\n  EE.call(this);\n}\n\nStream.prototype.pipe = function(dest, options) {\n  var source = this;\n\n  function ondata(chunk) {\n    if (dest.writable) {\n      if (false === dest.write(chunk) && source.pause) {\n        source.pause();\n      }\n    }\n  }\n\n  source.on('data', ondata);\n\n  function ondrain() {\n    if (source.readable && source.resume) {\n      source.resume();\n    }\n  }\n\n  dest.on('drain', ondrain);\n\n  // If the 'end' option is not supplied, dest.end() will be called when\n  // source gets the 'end' or 'close' events.  Only dest.end() once.\n  if (!dest._isStdio && (!options || options.end !== false)) {\n    source.on('end', onend);\n    source.on('close', onclose);\n  }\n\n  var didOnEnd = false;\n  function onend() {\n    if (didOnEnd) return;\n    didOnEnd = true;\n\n    dest.end();\n  }\n\n\n  function onclose() {\n    if (didOnEnd) return;\n    didOnEnd = true;\n\n    if (typeof dest.destroy === 'function') dest.destroy();\n  }\n\n  // don't leave dangling pipes when there are errors.\n  function onerror(er) {\n    cleanup();\n    if (EE.listenerCount(this, 'error') === 0) {\n      throw er; // Unhandled stream error in pipe.\n    }\n  }\n\n  source.on('error', onerror);\n  dest.on('error', onerror);\n\n  // remove all the event listeners that were added.\n  function cleanup() {\n    source.removeListener('data', ondata);\n    dest.removeListener('drain', ondrain);\n\n    source.removeListener('end', onend);\n    source.removeListener('close', onclose);\n\n    source.removeListener('error', onerror);\n    dest.removeListener('error', onerror);\n\n    source.removeListener('end', cleanup);\n    source.removeListener('close', cleanup);\n\n    dest.removeListener('close', cleanup);\n  }\n\n  source.on('end', cleanup);\n  source.on('close', cleanup);\n\n  dest.on('close', cleanup);\n\n  dest.emit('pipe', source);\n\n  // Allow for unix-like usage: A.pipe(B).pipe(C)\n  return dest;\n};\n\n},{\"events\":62,\"inherits\":66,\"readable-stream/duplex.js\":83,\"readable-stream/passthrough.js\":91,\"readable-stream/readable.js\":92,\"readable-stream/transform.js\":93,\"readable-stream/writable.js\":94}],97:[function(require,module,exports){\n'use strict';\n\nvar Buffer = require('safe-buffer').Buffer;\n\nvar isEncoding = Buffer.isEncoding || function (encoding) {\n  encoding = '' + encoding;\n  switch (encoding && encoding.toLowerCase()) {\n    case 'hex':case 'utf8':case 'utf-8':case 'ascii':case 'binary':case 'base64':case 'ucs2':case 'ucs-2':case 'utf16le':case 'utf-16le':case 'raw':\n      return true;\n    default:\n      return false;\n  }\n};\n\nfunction _normalizeEncoding(enc) {\n  if (!enc) return 'utf8';\n  var retried;\n  while (true) {\n    switch (enc) {\n      case 'utf8':\n      case 'utf-8':\n        return 'utf8';\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return 'utf16le';\n      case 'latin1':\n      case 'binary':\n        return 'latin1';\n      case 'base64':\n      case 'ascii':\n      case 'hex':\n        return enc;\n      default:\n        if (retried) return; // undefined\n        enc = ('' + enc).toLowerCase();\n        retried = true;\n    }\n  }\n};\n\n// Do not cache `Buffer.isEncoding` when checking encoding names as some\n// modules monkey-patch it to support additional encodings\nfunction normalizeEncoding(enc) {\n  var nenc = _normalizeEncoding(enc);\n  if (typeof nenc !== 'string' && (Buffer.isEncoding === isEncoding || !isEncoding(enc))) throw new Error('Unknown encoding: ' + enc);\n  return nenc || enc;\n}\n\n// StringDecoder provides an interface for efficiently splitting a series of\n// buffers into a series of JS strings without breaking apart multi-byte\n// characters.\nexports.StringDecoder = StringDecoder;\nfunction StringDecoder(encoding) {\n  this.encoding = normalizeEncoding(encoding);\n  var nb;\n  switch (this.encoding) {\n    case 'utf16le':\n      this.text = utf16Text;\n      this.end = utf16End;\n      nb = 4;\n      break;\n    case 'utf8':\n      this.fillLast = utf8FillLast;\n      nb = 4;\n      break;\n    case 'base64':\n      this.text = base64Text;\n      this.end = base64End;\n      nb = 3;\n      break;\n    default:\n      this.write = simpleWrite;\n      this.end = simpleEnd;\n      return;\n  }\n  this.lastNeed = 0;\n  this.lastTotal = 0;\n  this.lastChar = Buffer.allocUnsafe(nb);\n}\n\nStringDecoder.prototype.write = function (buf) {\n  if (buf.length === 0) return '';\n  var r;\n  var i;\n  if (this.lastNeed) {\n    r = this.fillLast(buf);\n    if (r === undefined) return '';\n    i = this.lastNeed;\n    this.lastNeed = 0;\n  } else {\n    i = 0;\n  }\n  if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);\n  return r || '';\n};\n\nStringDecoder.prototype.end = utf8End;\n\n// Returns only complete characters in a Buffer\nStringDecoder.prototype.text = utf8Text;\n\n// Attempts to complete a partial non-UTF-8 character using bytes from a Buffer\nStringDecoder.prototype.fillLast = function (buf) {\n  if (this.lastNeed <= buf.length) {\n    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);\n    return this.lastChar.toString(this.encoding, 0, this.lastTotal);\n  }\n  buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);\n  this.lastNeed -= buf.length;\n};\n\n// Checks the type of a UTF-8 byte, whether it's ASCII, a leading byte, or a\n// continuation byte.\nfunction utf8CheckByte(byte) {\n  if (byte <= 0x7F) return 0;else if (byte >> 5 === 0x06) return 2;else if (byte >> 4 === 0x0E) return 3;else if (byte >> 3 === 0x1E) return 4;\n  return -1;\n}\n\n// Checks at most 3 bytes at the end of a Buffer in order to detect an\n// incomplete multi-byte UTF-8 character. The total number of bytes (2, 3, or 4)\n// needed to complete the UTF-8 character (if applicable) are returned.\nfunction utf8CheckIncomplete(self, buf, i) {\n  var j = buf.length - 1;\n  if (j < i) return 0;\n  var nb = utf8CheckByte(buf[j]);\n  if (nb >= 0) {\n    if (nb > 0) self.lastNeed = nb - 1;\n    return nb;\n  }\n  if (--j < i) return 0;\n  nb = utf8CheckByte(buf[j]);\n  if (nb >= 0) {\n    if (nb > 0) self.lastNeed = nb - 2;\n    return nb;\n  }\n  if (--j < i) return 0;\n  nb = utf8CheckByte(buf[j]);\n  if (nb >= 0) {\n    if (nb > 0) {\n      if (nb === 2) nb = 0;else self.lastNeed = nb - 3;\n    }\n    return nb;\n  }\n  return 0;\n}\n\n// Validates as many continuation bytes for a multi-byte UTF-8 character as\n// needed or are available. If we see a non-continuation byte where we expect\n// one, we \"replace\" the validated continuation bytes we've seen so far with\n// UTF-8 replacement characters ('\\ufffd'), to match v8's UTF-8 decoding\n// behavior. The continuation byte check is included three times in the case\n// where all of the continuation bytes for a character exist in the same buffer.\n// It is also done this way as a slight performance increase instead of using a\n// loop.\nfunction utf8CheckExtraBytes(self, buf, p) {\n  if ((buf[0] & 0xC0) !== 0x80) {\n    self.lastNeed = 0;\n    return '\\ufffd'.repeat(p);\n  }\n  if (self.lastNeed > 1 && buf.length > 1) {\n    if ((buf[1] & 0xC0) !== 0x80) {\n      self.lastNeed = 1;\n      return '\\ufffd'.repeat(p + 1);\n    }\n    if (self.lastNeed > 2 && buf.length > 2) {\n      if ((buf[2] & 0xC0) !== 0x80) {\n        self.lastNeed = 2;\n        return '\\ufffd'.repeat(p + 2);\n      }\n    }\n  }\n}\n\n// Attempts to complete a multi-byte UTF-8 character using bytes from a Buffer.\nfunction utf8FillLast(buf) {\n  var p = this.lastTotal - this.lastNeed;\n  var r = utf8CheckExtraBytes(this, buf, p);\n  if (r !== undefined) return r;\n  if (this.lastNeed <= buf.length) {\n    buf.copy(this.lastChar, p, 0, this.lastNeed);\n    return this.lastChar.toString(this.encoding, 0, this.lastTotal);\n  }\n  buf.copy(this.lastChar, p, 0, buf.length);\n  this.lastNeed -= buf.length;\n}\n\n// Returns all complete UTF-8 characters in a Buffer. If the Buffer ended on a\n// partial character, the character's bytes are buffered until the required\n// number of bytes are available.\nfunction utf8Text(buf, i) {\n  var total = utf8CheckIncomplete(this, buf, i);\n  if (!this.lastNeed) return buf.toString('utf8', i);\n  this.lastTotal = total;\n  var end = buf.length - (total - this.lastNeed);\n  buf.copy(this.lastChar, 0, end);\n  return buf.toString('utf8', i, end);\n}\n\n// For UTF-8, a replacement character for each buffered byte of a (partial)\n// character needs to be added to the output.\nfunction utf8End(buf) {\n  var r = buf && buf.length ? this.write(buf) : '';\n  if (this.lastNeed) return r + '\\ufffd'.repeat(this.lastTotal - this.lastNeed);\n  return r;\n}\n\n// UTF-16LE typically needs two bytes per character, but even if we have an even\n// number of bytes available, we need to check if we end on a leading/high\n// surrogate. In that case, we need to wait for the next two bytes in order to\n// decode the last character properly.\nfunction utf16Text(buf, i) {\n  if ((buf.length - i) % 2 === 0) {\n    var r = buf.toString('utf16le', i);\n    if (r) {\n      var c = r.charCodeAt(r.length - 1);\n      if (c >= 0xD800 && c <= 0xDBFF) {\n        this.lastNeed = 2;\n        this.lastTotal = 4;\n        this.lastChar[0] = buf[buf.length - 2];\n        this.lastChar[1] = buf[buf.length - 1];\n        return r.slice(0, -1);\n      }\n    }\n    return r;\n  }\n  this.lastNeed = 1;\n  this.lastTotal = 2;\n  this.lastChar[0] = buf[buf.length - 1];\n  return buf.toString('utf16le', i, buf.length - 1);\n}\n\n// For UTF-16LE we do not explicitly append special replacement characters if we\n// end on a partial character, we simply let v8 handle that.\nfunction utf16End(buf) {\n  var r = buf && buf.length ? this.write(buf) : '';\n  if (this.lastNeed) {\n    var end = this.lastTotal - this.lastNeed;\n    return r + this.lastChar.toString('utf16le', 0, end);\n  }\n  return r;\n}\n\nfunction base64Text(buf, i) {\n  var n = (buf.length - i) % 3;\n  if (n === 0) return buf.toString('base64', i);\n  this.lastNeed = 3 - n;\n  this.lastTotal = 3;\n  if (n === 1) {\n    this.lastChar[0] = buf[buf.length - 1];\n  } else {\n    this.lastChar[0] = buf[buf.length - 2];\n    this.lastChar[1] = buf[buf.length - 1];\n  }\n  return buf.toString('base64', i, buf.length - n);\n}\n\nfunction base64End(buf) {\n  var r = buf && buf.length ? this.write(buf) : '';\n  if (this.lastNeed) return r + this.lastChar.toString('base64', 0, 3 - this.lastNeed);\n  return r;\n}\n\n// Pass bytes on through for single-byte encodings (e.g. ascii, latin1, hex)\nfunction simpleWrite(buf) {\n  return buf.toString(this.encoding);\n}\n\nfunction simpleEnd(buf) {\n  return buf && buf.length ? this.write(buf) : '';\n}\n},{\"safe-buffer\":98}],98:[function(require,module,exports){\n/* eslint-disable node/no-deprecated-api */\nvar buffer = require('buffer')\nvar Buffer = buffer.Buffer\n\n// alternative to using Object.keys for old browsers\nfunction copyProps (src, dst) {\n  for (var key in src) {\n    dst[key] = src[key]\n  }\n}\nif (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {\n  module.exports = buffer\n} else {\n  // Copy properties from require('buffer')\n  copyProps(buffer, exports)\n  exports.Buffer = SafeBuffer\n}\n\nfunction SafeBuffer (arg, encodingOrOffset, length) {\n  return Buffer(arg, encodingOrOffset, length)\n}\n\n// Copy static methods from Buffer\ncopyProps(Buffer, SafeBuffer)\n\nSafeBuffer.from = function (arg, encodingOrOffset, length) {\n  if (typeof arg === 'number') {\n    throw new TypeError('Argument must not be a number')\n  }\n  return Buffer(arg, encodingOrOffset, length)\n}\n\nSafeBuffer.alloc = function (size, fill, encoding) {\n  if (typeof size !== 'number') {\n    throw new TypeError('Argument must be a number')\n  }\n  var buf = Buffer(size)\n  if (fill !== undefined) {\n    if (typeof encoding === 'string') {\n      buf.fill(fill, encoding)\n    } else {\n      buf.fill(fill)\n    }\n  } else {\n    buf.fill(0)\n  }\n  return buf\n}\n\nSafeBuffer.allocUnsafe = function (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('Argument must be a number')\n  }\n  return Buffer(size)\n}\n\nSafeBuffer.allocUnsafeSlow = function (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('Argument must be a number')\n  }\n  return buffer.SlowBuffer(size)\n}\n\n},{\"buffer\":43}],99:[function(require,module,exports){\n(function (global){\n\n/**\n * Module exports.\n */\n\nmodule.exports = deprecate;\n\n/**\n * Mark that a method should not be used.\n * Returns a modified function which warns once by default.\n *\n * If `localStorage.noDeprecation = true` is set, then it is a no-op.\n *\n * If `localStorage.throwDeprecation = true` is set, then deprecated functions\n * will throw an Error when invoked.\n *\n * If `localStorage.traceDeprecation = true` is set, then deprecated functions\n * will invoke `console.trace()` instead of `console.error()`.\n *\n * @param {Function} fn - the function to deprecate\n * @param {String} msg - the string to print to the console when `fn` is invoked\n * @returns {Function} a new \"deprecated\" version of `fn`\n * @api public\n */\n\nfunction deprecate (fn, msg) {\n  if (config('noDeprecation')) {\n    return fn;\n  }\n\n  var warned = false;\n  function deprecated() {\n    if (!warned) {\n      if (config('throwDeprecation')) {\n        throw new Error(msg);\n      } else if (config('traceDeprecation')) {\n        console.trace(msg);\n      } else {\n        console.warn(msg);\n      }\n      warned = true;\n    }\n    return fn.apply(this, arguments);\n  }\n\n  return deprecated;\n}\n\n/**\n * Checks `localStorage` for boolean values for the given `name`.\n *\n * @param {String} name\n * @returns {Boolean}\n * @api private\n */\n\nfunction config (name) {\n  // accessing global.localStorage can trigger a DOMException in sandboxed iframes\n  try {\n    if (!global.localStorage) return false;\n  } catch (_) {\n    return false;\n  }\n  var val = global.localStorage[name];\n  if (null == val) return false;\n  return String(val).toLowerCase() === 'true';\n}\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n},{}],100:[function(require,module,exports){\narguments[4][66][0].apply(exports,arguments)\n},{\"dup\":66}],101:[function(require,module,exports){\nmodule.exports = function isBuffer(arg) {\n  return arg && typeof arg === 'object'\n    && typeof arg.copy === 'function'\n    && typeof arg.fill === 'function'\n    && typeof arg.readUInt8 === 'function';\n}\n},{}],102:[function(require,module,exports){\n(function (process,global){\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nvar formatRegExp = /%[sdj%]/g;\nexports.format = function(f) {\n  if (!isString(f)) {\n    var objects = [];\n    for (var i = 0; i < arguments.length; i++) {\n      objects.push(inspect(arguments[i]));\n    }\n    return objects.join(' ');\n  }\n\n  var i = 1;\n  var args = arguments;\n  var len = args.length;\n  var str = String(f).replace(formatRegExp, function(x) {\n    if (x === '%%') return '%';\n    if (i >= len) return x;\n    switch (x) {\n      case '%s': return String(args[i++]);\n      case '%d': return Number(args[i++]);\n      case '%j':\n        try {\n          return JSON.stringify(args[i++]);\n        } catch (_) {\n          return '[Circular]';\n        }\n      default:\n        return x;\n    }\n  });\n  for (var x = args[i]; i < len; x = args[++i]) {\n    if (isNull(x) || !isObject(x)) {\n      str += ' ' + x;\n    } else {\n      str += ' ' + inspect(x);\n    }\n  }\n  return str;\n};\n\n\n// Mark that a method should not be used.\n// Returns a modified function which warns once by default.\n// If --no-deprecation is set, then it is a no-op.\nexports.deprecate = function(fn, msg) {\n  // Allow for deprecating things in the process of starting up.\n  if (isUndefined(global.process)) {\n    return function() {\n      return exports.deprecate(fn, msg).apply(this, arguments);\n    };\n  }\n\n  if (process.noDeprecation === true) {\n    return fn;\n  }\n\n  var warned = false;\n  function deprecated() {\n    if (!warned) {\n      if (process.throwDeprecation) {\n        throw new Error(msg);\n      } else if (process.traceDeprecation) {\n        console.trace(msg);\n      } else {\n        console.error(msg);\n      }\n      warned = true;\n    }\n    return fn.apply(this, arguments);\n  }\n\n  return deprecated;\n};\n\n\nvar debugs = {};\nvar debugEnviron;\nexports.debuglog = function(set) {\n  if (isUndefined(debugEnviron))\n    debugEnviron = process.env.NODE_DEBUG || '';\n  set = set.toUpperCase();\n  if (!debugs[set]) {\n    if (new RegExp('\\\\b' + set + '\\\\b', 'i').test(debugEnviron)) {\n      var pid = process.pid;\n      debugs[set] = function() {\n        var msg = exports.format.apply(exports, arguments);\n        console.error('%s %d: %s', set, pid, msg);\n      };\n    } else {\n      debugs[set] = function() {};\n    }\n  }\n  return debugs[set];\n};\n\n\n/**\n * Echos the value of a value. Trys to print the value out\n * in the best way possible given the different types.\n *\n * @param {Object} obj The object to print out.\n * @param {Object} opts Optional options object that alters the output.\n */\n/* legacy: obj, showHidden, depth, colors*/\nfunction inspect(obj, opts) {\n  // default options\n  var ctx = {\n    seen: [],\n    stylize: stylizeNoColor\n  };\n  // legacy...\n  if (arguments.length >= 3) ctx.depth = arguments[2];\n  if (arguments.length >= 4) ctx.colors = arguments[3];\n  if (isBoolean(opts)) {\n    // legacy...\n    ctx.showHidden = opts;\n  } else if (opts) {\n    // got an \"options\" object\n    exports._extend(ctx, opts);\n  }\n  // set default options\n  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;\n  if (isUndefined(ctx.depth)) ctx.depth = 2;\n  if (isUndefined(ctx.colors)) ctx.colors = false;\n  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;\n  if (ctx.colors) ctx.stylize = stylizeWithColor;\n  return formatValue(ctx, obj, ctx.depth);\n}\nexports.inspect = inspect;\n\n\n// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics\ninspect.colors = {\n  'bold' : [1, 22],\n  'italic' : [3, 23],\n  'underline' : [4, 24],\n  'inverse' : [7, 27],\n  'white' : [37, 39],\n  'grey' : [90, 39],\n  'black' : [30, 39],\n  'blue' : [34, 39],\n  'cyan' : [36, 39],\n  'green' : [32, 39],\n  'magenta' : [35, 39],\n  'red' : [31, 39],\n  'yellow' : [33, 39]\n};\n\n// Don't use 'blue' not visible on cmd.exe\ninspect.styles = {\n  'special': 'cyan',\n  'number': 'yellow',\n  'boolean': 'yellow',\n  'undefined': 'grey',\n  'null': 'bold',\n  'string': 'green',\n  'date': 'magenta',\n  // \"name\": intentionally not styling\n  'regexp': 'red'\n};\n\n\nfunction stylizeWithColor(str, styleType) {\n  var style = inspect.styles[styleType];\n\n  if (style) {\n    return '\\u001b[' + inspect.colors[style][0] + 'm' + str +\n           '\\u001b[' + inspect.colors[style][1] + 'm';\n  } else {\n    return str;\n  }\n}\n\n\nfunction stylizeNoColor(str, styleType) {\n  return str;\n}\n\n\nfunction arrayToHash(array) {\n  var hash = {};\n\n  array.forEach(function(val, idx) {\n    hash[val] = true;\n  });\n\n  return hash;\n}\n\n\nfunction formatValue(ctx, value, recurseTimes) {\n  // Provide a hook for user-specified inspect functions.\n  // Check that value is an object with an inspect function on it\n  if (ctx.customInspect &&\n      value &&\n      isFunction(value.inspect) &&\n      // Filter out the util module, it's inspect function is special\n      value.inspect !== exports.inspect &&\n      // Also filter out any prototype objects using the circular check.\n      !(value.constructor && value.constructor.prototype === value)) {\n    var ret = value.inspect(recurseTimes, ctx);\n    if (!isString(ret)) {\n      ret = formatValue(ctx, ret, recurseTimes);\n    }\n    return ret;\n  }\n\n  // Primitive types cannot have properties\n  var primitive = formatPrimitive(ctx, value);\n  if (primitive) {\n    return primitive;\n  }\n\n  // Look up the keys of the object.\n  var keys = Object.keys(value);\n  var visibleKeys = arrayToHash(keys);\n\n  if (ctx.showHidden) {\n    keys = Object.getOwnPropertyNames(value);\n  }\n\n  // IE doesn't make error fields non-enumerable\n  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx\n  if (isError(value)\n      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {\n    return formatError(value);\n  }\n\n  // Some type of object without properties can be shortcutted.\n  if (keys.length === 0) {\n    if (isFunction(value)) {\n      var name = value.name ? ': ' + value.name : '';\n      return ctx.stylize('[Function' + name + ']', 'special');\n    }\n    if (isRegExp(value)) {\n      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');\n    }\n    if (isDate(value)) {\n      return ctx.stylize(Date.prototype.toString.call(value), 'date');\n    }\n    if (isError(value)) {\n      return formatError(value);\n    }\n  }\n\n  var base = '', array = false, braces = ['{', '}'];\n\n  // Make Array say that they are Array\n  if (isArray(value)) {\n    array = true;\n    braces = ['[', ']'];\n  }\n\n  // Make functions say that they are functions\n  if (isFunction(value)) {\n    var n = value.name ? ': ' + value.name : '';\n    base = ' [Function' + n + ']';\n  }\n\n  // Make RegExps say that they are RegExps\n  if (isRegExp(value)) {\n    base = ' ' + RegExp.prototype.toString.call(value);\n  }\n\n  // Make dates with properties first say the date\n  if (isDate(value)) {\n    base = ' ' + Date.prototype.toUTCString.call(value);\n  }\n\n  // Make error with message first say the error\n  if (isError(value)) {\n    base = ' ' + formatError(value);\n  }\n\n  if (keys.length === 0 && (!array || value.length == 0)) {\n    return braces[0] + base + braces[1];\n  }\n\n  if (recurseTimes < 0) {\n    if (isRegExp(value)) {\n      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');\n    } else {\n      return ctx.stylize('[Object]', 'special');\n    }\n  }\n\n  ctx.seen.push(value);\n\n  var output;\n  if (array) {\n    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);\n  } else {\n    output = keys.map(function(key) {\n      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);\n    });\n  }\n\n  ctx.seen.pop();\n\n  return reduceToSingleString(output, base, braces);\n}\n\n\nfunction formatPrimitive(ctx, value) {\n  if (isUndefined(value))\n    return ctx.stylize('undefined', 'undefined');\n  if (isString(value)) {\n    var simple = '\\'' + JSON.stringify(value).replace(/^\"|\"$/g, '')\n                                             .replace(/'/g, \"\\\\'\")\n                                             .replace(/\\\\\"/g, '\"') + '\\'';\n    return ctx.stylize(simple, 'string');\n  }\n  if (isNumber(value))\n    return ctx.stylize('' + value, 'number');\n  if (isBoolean(value))\n    return ctx.stylize('' + value, 'boolean');\n  // For some reason typeof null is \"object\", so special case here.\n  if (isNull(value))\n    return ctx.stylize('null', 'null');\n}\n\n\nfunction formatError(value) {\n  return '[' + Error.prototype.toString.call(value) + ']';\n}\n\n\nfunction formatArray(ctx, value, recurseTimes, visibleKeys, keys) {\n  var output = [];\n  for (var i = 0, l = value.length; i < l; ++i) {\n    if (hasOwnProperty(value, String(i))) {\n      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,\n          String(i), true));\n    } else {\n      output.push('');\n    }\n  }\n  keys.forEach(function(key) {\n    if (!key.match(/^\\d+$/)) {\n      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,\n          key, true));\n    }\n  });\n  return output;\n}\n\n\nfunction formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {\n  var name, str, desc;\n  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };\n  if (desc.get) {\n    if (desc.set) {\n      str = ctx.stylize('[Getter/Setter]', 'special');\n    } else {\n      str = ctx.stylize('[Getter]', 'special');\n    }\n  } else {\n    if (desc.set) {\n      str = ctx.stylize('[Setter]', 'special');\n    }\n  }\n  if (!hasOwnProperty(visibleKeys, key)) {\n    name = '[' + key + ']';\n  }\n  if (!str) {\n    if (ctx.seen.indexOf(desc.value) < 0) {\n      if (isNull(recurseTimes)) {\n        str = formatValue(ctx, desc.value, null);\n      } else {\n        str = formatValue(ctx, desc.value, recurseTimes - 1);\n      }\n      if (str.indexOf('\\n') > -1) {\n        if (array) {\n          str = str.split('\\n').map(function(line) {\n            return '  ' + line;\n          }).join('\\n').substr(2);\n        } else {\n          str = '\\n' + str.split('\\n').map(function(line) {\n            return '   ' + line;\n          }).join('\\n');\n        }\n      }\n    } else {\n      str = ctx.stylize('[Circular]', 'special');\n    }\n  }\n  if (isUndefined(name)) {\n    if (array && key.match(/^\\d+$/)) {\n      return str;\n    }\n    name = JSON.stringify('' + key);\n    if (name.match(/^\"([a-zA-Z_][a-zA-Z_0-9]*)\"$/)) {\n      name = name.substr(1, name.length - 2);\n      name = ctx.stylize(name, 'name');\n    } else {\n      name = name.replace(/'/g, \"\\\\'\")\n                 .replace(/\\\\\"/g, '\"')\n                 .replace(/(^\"|\"$)/g, \"'\");\n      name = ctx.stylize(name, 'string');\n    }\n  }\n\n  return name + ': ' + str;\n}\n\n\nfunction reduceToSingleString(output, base, braces) {\n  var numLinesEst = 0;\n  var length = output.reduce(function(prev, cur) {\n    numLinesEst++;\n    if (cur.indexOf('\\n') >= 0) numLinesEst++;\n    return prev + cur.replace(/\\u001b\\[\\d\\d?m/g, '').length + 1;\n  }, 0);\n\n  if (length > 60) {\n    return braces[0] +\n           (base === '' ? '' : base + '\\n ') +\n           ' ' +\n           output.join(',\\n  ') +\n           ' ' +\n           braces[1];\n  }\n\n  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];\n}\n\n\n// NOTE: These type checking functions intentionally don't use `instanceof`\n// because it is fragile and can be easily faked with `Object.create()`.\nfunction isArray(ar) {\n  return Array.isArray(ar);\n}\nexports.isArray = isArray;\n\nfunction isBoolean(arg) {\n  return typeof arg === 'boolean';\n}\nexports.isBoolean = isBoolean;\n\nfunction isNull(arg) {\n  return arg === null;\n}\nexports.isNull = isNull;\n\nfunction isNullOrUndefined(arg) {\n  return arg == null;\n}\nexports.isNullOrUndefined = isNullOrUndefined;\n\nfunction isNumber(arg) {\n  return typeof arg === 'number';\n}\nexports.isNumber = isNumber;\n\nfunction isString(arg) {\n  return typeof arg === 'string';\n}\nexports.isString = isString;\n\nfunction isSymbol(arg) {\n  return typeof arg === 'symbol';\n}\nexports.isSymbol = isSymbol;\n\nfunction isUndefined(arg) {\n  return arg === void 0;\n}\nexports.isUndefined = isUndefined;\n\nfunction isRegExp(re) {\n  return isObject(re) && objectToString(re) === '[object RegExp]';\n}\nexports.isRegExp = isRegExp;\n\nfunction isObject(arg) {\n  return typeof arg === 'object' && arg !== null;\n}\nexports.isObject = isObject;\n\nfunction isDate(d) {\n  return isObject(d) && objectToString(d) === '[object Date]';\n}\nexports.isDate = isDate;\n\nfunction isError(e) {\n  return isObject(e) &&\n      (objectToString(e) === '[object Error]' || e instanceof Error);\n}\nexports.isError = isError;\n\nfunction isFunction(arg) {\n  return typeof arg === 'function';\n}\nexports.isFunction = isFunction;\n\nfunction isPrimitive(arg) {\n  return arg === null ||\n         typeof arg === 'boolean' ||\n         typeof arg === 'number' ||\n         typeof arg === 'string' ||\n         typeof arg === 'symbol' ||  // ES6 symbol\n         typeof arg === 'undefined';\n}\nexports.isPrimitive = isPrimitive;\n\nexports.isBuffer = require('./support/isBuffer');\n\nfunction objectToString(o) {\n  return Object.prototype.toString.call(o);\n}\n\n\nfunction pad(n) {\n  return n < 10 ? '0' + n.toString(10) : n.toString(10);\n}\n\n\nvar months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',\n              'Oct', 'Nov', 'Dec'];\n\n// 26 Feb 16:19:34\nfunction timestamp() {\n  var d = new Date();\n  var time = [pad(d.getHours()),\n              pad(d.getMinutes()),\n              pad(d.getSeconds())].join(':');\n  return [d.getDate(), months[d.getMonth()], time].join(' ');\n}\n\n\n// log is just a thin wrapper to console.log that prepends a timestamp\nexports.log = function() {\n  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));\n};\n\n\n/**\n * Inherit the prototype methods from one constructor into another.\n *\n * The Function.prototype.inherits from lang.js rewritten as a standalone\n * function (not on Function.prototype). NOTE: If this file is to be loaded\n * during bootstrapping this function needs to be rewritten using some native\n * functions as prototype setup using normal JavaScript does not work as\n * expected during bootstrapping (see mirror.js in r114903).\n *\n * @param {function} ctor Constructor function which needs to inherit the\n *     prototype.\n * @param {function} superCtor Constructor function to inherit prototype from.\n */\nexports.inherits = require('inherits');\n\nexports._extend = function(origin, add) {\n  // Don't do anything if add isn't an object\n  if (!add || !isObject(add)) return origin;\n\n  var keys = Object.keys(add);\n  var i = keys.length;\n  while (i--) {\n    origin[keys[i]] = add[keys[i]];\n  }\n  return origin;\n};\n\nfunction hasOwnProperty(obj, prop) {\n  return Object.prototype.hasOwnProperty.call(obj, prop);\n}\n\n}).call(this,require('_process'),typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n},{\"./support/isBuffer\":101,\"_process\":82,\"inherits\":100}]},{},[1]);\n"

/***/ }),
/* 15 */
/***/ (function(module, exports) {

	"use strict";

/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {process.nextTick(function() {
		delete __webpack_require__.c[module.id];
		if(typeof window !== "undefined" && window.mochaPhantomJS)
			mochaPhantomJS.run();
		else
			mocha.run();
	});
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(17)))

/***/ }),
/* 17 */
/***/ (function(module, exports) {

	// shim for using process in browser
	var process = module.exports = {};
	
	// cached from whatever global is present so that test runners that stub it
	// don't break things.  But we need to wrap it in a try catch in case it is
	// wrapped in strict mode code which doesn't define any globals.  It's inside a
	// function because try/catches deoptimize in certain engines.
	
	var cachedSetTimeout;
	var cachedClearTimeout;
	
	function defaultSetTimout() {
	    throw new Error('setTimeout has not been defined');
	}
	function defaultClearTimeout () {
	    throw new Error('clearTimeout has not been defined');
	}
	(function () {
	    try {
	        if (typeof setTimeout === 'function') {
	            cachedSetTimeout = setTimeout;
	        } else {
	            cachedSetTimeout = defaultSetTimout;
	        }
	    } catch (e) {
	        cachedSetTimeout = defaultSetTimout;
	    }
	    try {
	        if (typeof clearTimeout === 'function') {
	            cachedClearTimeout = clearTimeout;
	        } else {
	            cachedClearTimeout = defaultClearTimeout;
	        }
	    } catch (e) {
	        cachedClearTimeout = defaultClearTimeout;
	    }
	} ())
	function runTimeout(fun) {
	    if (cachedSetTimeout === setTimeout) {
	        //normal enviroments in sane situations
	        return setTimeout(fun, 0);
	    }
	    // if setTimeout wasn't available but was latter defined
	    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
	        cachedSetTimeout = setTimeout;
	        return setTimeout(fun, 0);
	    }
	    try {
	        // when when somebody has screwed with setTimeout but no I.E. maddness
	        return cachedSetTimeout(fun, 0);
	    } catch(e){
	        try {
	            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
	            return cachedSetTimeout.call(null, fun, 0);
	        } catch(e){
	            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
	            return cachedSetTimeout.call(this, fun, 0);
	        }
	    }
	
	
	}
	function runClearTimeout(marker) {
	    if (cachedClearTimeout === clearTimeout) {
	        //normal enviroments in sane situations
	        return clearTimeout(marker);
	    }
	    // if clearTimeout wasn't available but was latter defined
	    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
	        cachedClearTimeout = clearTimeout;
	        return clearTimeout(marker);
	    }
	    try {
	        // when when somebody has screwed with setTimeout but no I.E. maddness
	        return cachedClearTimeout(marker);
	    } catch (e){
	        try {
	            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
	            return cachedClearTimeout.call(null, marker);
	        } catch (e){
	            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
	            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
	            return cachedClearTimeout.call(this, marker);
	        }
	    }
	
	
	
	}
	var queue = [];
	var draining = false;
	var currentQueue;
	var queueIndex = -1;
	
	function cleanUpNextTick() {
	    if (!draining || !currentQueue) {
	        return;
	    }
	    draining = false;
	    if (currentQueue.length) {
	        queue = currentQueue.concat(queue);
	    } else {
	        queueIndex = -1;
	    }
	    if (queue.length) {
	        drainQueue();
	    }
	}
	
	function drainQueue() {
	    if (draining) {
	        return;
	    }
	    var timeout = runTimeout(cleanUpNextTick);
	    draining = true;
	
	    var len = queue.length;
	    while(len) {
	        currentQueue = queue;
	        queue = [];
	        while (++queueIndex < len) {
	            if (currentQueue) {
	                currentQueue[queueIndex].run();
	            }
	        }
	        queueIndex = -1;
	        len = queue.length;
	    }
	    currentQueue = null;
	    draining = false;
	    runClearTimeout(timeout);
	}
	
	process.nextTick = function (fun) {
	    var args = new Array(arguments.length - 1);
	    if (arguments.length > 1) {
	        for (var i = 1; i < arguments.length; i++) {
	            args[i - 1] = arguments[i];
	        }
	    }
	    queue.push(new Item(fun, args));
	    if (queue.length === 1 && !draining) {
	        runTimeout(drainQueue);
	    }
	};
	
	// v8 likes predictible objects
	function Item(fun, array) {
	    this.fun = fun;
	    this.array = array;
	}
	Item.prototype.run = function () {
	    this.fun.apply(null, this.array);
	};
	process.title = 'browser';
	process.browser = true;
	process.env = {};
	process.argv = [];
	process.version = ''; // empty string to avoid regexp issues
	process.versions = {};
	
	function noop() {}
	
	process.on = noop;
	process.addListener = noop;
	process.once = noop;
	process.off = noop;
	process.removeListener = noop;
	process.removeAllListeners = noop;
	process.emit = noop;
	process.prependListener = noop;
	process.prependOnceListener = noop;
	
	process.listeners = function (name) { return [] }
	
	process.binding = function (name) {
	    throw new Error('process.binding is not supported');
	};
	
	process.cwd = function () { return '/' };
	process.chdir = function (dir) {
	    throw new Error('process.chdir is not supported');
	};
	process.umask = function() { return 0; };


/***/ })
/******/ ]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAgMTcyN2NmZTJmZGQxODViMDU5YjA/MjE2OSIsIndlYnBhY2s6Ly8vLi90ZXN0L2luZGV4LmpzIiwid2VicGFjazovLy8uL34vbW9jaGEtbG9hZGVyL3dlYi5qcyIsIndlYnBhY2s6Ly8vLi9+L21vY2hhL21vY2hhLmNzcz83NWQwIiwid2VicGFjazovLy8uL34vbW9jaGEvbW9jaGEuY3NzIiwid2VicGFjazovLy8uL34vbW9jaGEtbG9hZGVyL34vY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanMiLCJ3ZWJwYWNrOi8vLy4vfi9tb2NoYS1sb2FkZXIvfi9zdHlsZS1sb2FkZXIvbGliL2FkZFN0eWxlcy5qcyIsIndlYnBhY2s6Ly8vLi9+L21vY2hhLWxvYWRlci9+L3N0eWxlLWxvYWRlci9saWIvdXJscy5qcyIsIndlYnBhY2s6Ly8vLi9+L21vY2hhL21vY2hhLmpzP2QxOGUiLCJ3ZWJwYWNrOi8vLy4vfi9zY3JpcHQtbG9hZGVyL2FkZFNjcmlwdC5qcyIsIndlYnBhY2s6Ly8vLi9+L21vY2hhL21vY2hhLmpzIiwid2VicGFjazovLy8uL34vbW9jaGEtbG9hZGVyL3N0YXJ0LmpzIiwid2VicGFjazovLy8uL34vcHJvY2Vzcy9icm93c2VyLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx1QkFBZTtBQUNmO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOzs7Ozs7O0FDdENBO0FBQ0EsaUVBQWdFLDZCQUE2QjtBQUM3RixjQUFhLFdBQVc7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFO0FBQ0YsRTs7Ozs7Ozs7Ozs7QUNkQSwwQ0FB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QUFDQSxPQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLEdBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUM7O0FBRUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRTtBQUNGO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx3REFBdUQ7QUFDdkQ7O0FBRUEsOEJBQTZCLG1CQUFtQjs7QUFFaEQ7O0FBRUE7O0FBRUE7QUFDQTs7Ozs7Ozs7QUM1V0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7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O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esd0JBQXVCLHNCQUFzQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFxQjtBQUNyQjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsc0NBQXFDOztBQUVyQztBQUNBO0FBQ0E7O0FBRUEsNEJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBLDZCQUE0QixVQUFVIiwiZmlsZSI6InRlc3QuYnVuZGxlLmpzIiwic291cmNlc0NvbnRlbnQiOlsiIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcblxuIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbiBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblxuIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbiBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pXG4gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG5cbiBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbiBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuIFx0XHRcdGV4cG9ydHM6IHt9LFxuIFx0XHRcdGlkOiBtb2R1bGVJZCxcbiBcdFx0XHRsb2FkZWQ6IGZhbHNlXG4gXHRcdH07XG5cbiBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG4gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcbiBcdFx0bW9kdWxlLmxvYWRlZCA9IHRydWU7XG5cbiBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbiBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuIFx0fVxuXG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcblxuIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cbiBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiXCI7XG5cbiBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gd2VicGFjay9ib290c3RyYXAgMTcyN2NmZTJmZGQxODViMDU5YjAiLCJyZXF1aXJlKFwiISEvVXNlcnMvc2FicmluYW1hZS9EZXNrdG9wL3R1cmluZy9tb2R1bGUtMi9nYW1lLXRpbWUvbm9kZV9tb2R1bGVzL21vY2hhLWxvYWRlci93ZWIuanNcIik7XG5pZih0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuaW5pdE1vY2hhUGhhbnRvbUpTKSB7IHdpbmRvdy5pbml0TW9jaGFQaGFudG9tSlMoKTsgfVxubW9jaGEuc2V0dXAoe1widWlcIjpcImJkZFwifSk7XG5yZXF1aXJlKFwiISEvVXNlcnMvc2FicmluYW1hZS9EZXNrdG9wL3R1cmluZy9tb2R1bGUtMi9nYW1lLXRpbWUvbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIvaW5kZXguanMhL1VzZXJzL3NhYnJpbmFtYWUvRGVza3RvcC90dXJpbmcvbW9kdWxlLTIvZ2FtZS10aW1lL3Rlc3QvaW5kZXguanNcIilcbnJlcXVpcmUoXCIhIS9Vc2Vycy9zYWJyaW5hbWFlL0Rlc2t0b3AvdHVyaW5nL21vZHVsZS0yL2dhbWUtdGltZS9ub2RlX21vZHVsZXMvbW9jaGEtbG9hZGVyL3N0YXJ0LmpzXCIpO1xuaWYobW9kdWxlLmhvdCkge1xuXHRtb2R1bGUuaG90LmFjY2VwdCgpO1xuXHRtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24oKSB7XG5cdFx0bW9jaGEuc3VpdGUuc3VpdGVzLmxlbmd0aCA9IDA7XG5cdFx0dmFyIHN0YXRzID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ21vY2hhLXN0YXRzJyk7XG5cdFx0dmFyIHJlcG9ydCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdtb2NoYS1yZXBvcnQnKTtcblx0XHRzdGF0cyAmJiBzdGF0cy5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHN0YXRzKTtcblx0XHRyZXBvcnQgJiYgcmVwb3J0LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQocmVwb3J0KTtcblx0fSk7XG59XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L21vY2hhLWxvYWRlciEuL3Rlc3QvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDBcbi8vIG1vZHVsZSBjaHVua3MgPSAxIiwiaWYgKCEgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJtb2NoYVwiKSkgeyBkb2N1bWVudC53cml0ZShcIjxkaXYgaWQ9XFxcIm1vY2hhXFxcIj48L2Rpdj5cIik7IH1cblxucmVxdWlyZShcIiFzdHlsZS1sb2FkZXIhY3NzLWxvYWRlciFtb2NoYS9tb2NoYS5jc3NcIik7XG5yZXF1aXJlKFwiIXNjcmlwdC1sb2FkZXIhbW9jaGEvbW9jaGEuanNcIik7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vbW9jaGEtbG9hZGVyL3dlYi5qc1xuLy8gbW9kdWxlIGlkID0gNlxuLy8gbW9kdWxlIGNodW5rcyA9IDEiLCIvLyBzdHlsZS1sb2FkZXI6IEFkZHMgc29tZSBjc3MgdG8gdGhlIERPTSBieSBhZGRpbmcgYSA8c3R5bGU+IHRhZ1xuXG4vLyBsb2FkIHRoZSBzdHlsZXNcbnZhciBjb250ZW50ID0gcmVxdWlyZShcIiEhLi4vbW9jaGEtbG9hZGVyL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzIS4vbW9jaGEuY3NzXCIpO1xuaWYodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG4vLyBQcmVwYXJlIGNzc1RyYW5zZm9ybWF0aW9uXG52YXIgdHJhbnNmb3JtO1xuXG52YXIgb3B0aW9ucyA9IHtcImhtclwiOnRydWV9XG5vcHRpb25zLnRyYW5zZm9ybSA9IHRyYW5zZm9ybVxuLy8gYWRkIHRoZSBzdHlsZXMgdG8gdGhlIERPTVxudmFyIHVwZGF0ZSA9IHJlcXVpcmUoXCIhLi4vbW9jaGEtbG9hZGVyL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvbGliL2FkZFN0eWxlcy5qc1wiKShjb250ZW50LCBvcHRpb25zKTtcbmlmKGNvbnRlbnQubG9jYWxzKSBtb2R1bGUuZXhwb3J0cyA9IGNvbnRlbnQubG9jYWxzO1xuLy8gSG90IE1vZHVsZSBSZXBsYWNlbWVudFxuaWYobW9kdWxlLmhvdCkge1xuXHQvLyBXaGVuIHRoZSBzdHlsZXMgY2hhbmdlLCB1cGRhdGUgdGhlIDxzdHlsZT4gdGFnc1xuXHRpZighY29udGVudC5sb2NhbHMpIHtcblx0XHRtb2R1bGUuaG90LmFjY2VwdChcIiEhLi4vbW9jaGEtbG9hZGVyL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzIS4vbW9jaGEuY3NzXCIsIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIG5ld0NvbnRlbnQgPSByZXF1aXJlKFwiISEuLi9tb2NoYS1sb2FkZXIvbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanMhLi9tb2NoYS5jc3NcIik7XG5cdFx0XHRpZih0eXBlb2YgbmV3Q29udGVudCA9PT0gJ3N0cmluZycpIG5ld0NvbnRlbnQgPSBbW21vZHVsZS5pZCwgbmV3Q29udGVudCwgJyddXTtcblx0XHRcdHVwZGF0ZShuZXdDb250ZW50KTtcblx0XHR9KTtcblx0fVxuXHQvLyBXaGVuIHRoZSBtb2R1bGUgaXMgZGlzcG9zZWQsIHJlbW92ZSB0aGUgPHN0eWxlPiB0YWdzXG5cdG1vZHVsZS5ob3QuZGlzcG9zZShmdW5jdGlvbigpIHsgdXBkYXRlKCk7IH0pO1xufVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9tb2NoYS1sb2FkZXIvfi9zdHlsZS1sb2FkZXIhLi9+L21vY2hhLWxvYWRlci9+L2Nzcy1sb2FkZXIhLi9+L21vY2hhL21vY2hhLmNzc1xuLy8gbW9kdWxlIGlkID0gN1xuLy8gbW9kdWxlIGNodW5rcyA9IDEiLCJleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi4vbW9jaGEtbG9hZGVyL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2xpYi9jc3MtYmFzZS5qc1wiKShmYWxzZSk7XG4vLyBpbXBvcnRzXG5cblxuLy8gbW9kdWxlXG5leHBvcnRzLnB1c2goW21vZHVsZS5pZCwgXCJAY2hhcnNldCBcXFwidXRmLThcXFwiO1xcblxcbmJvZHkge1xcbiAgbWFyZ2luOjA7XFxufVxcblxcbiNtb2NoYSB7XFxuICBmb250OiAyMHB4LzEuNSBcXFwiSGVsdmV0aWNhIE5ldWVcXFwiLCBIZWx2ZXRpY2EsIEFyaWFsLCBzYW5zLXNlcmlmO1xcbiAgbWFyZ2luOiA2MHB4IDUwcHg7XFxufVxcblxcbiNtb2NoYSB1bCxcXG4jbW9jaGEgbGkge1xcbiAgbWFyZ2luOiAwO1xcbiAgcGFkZGluZzogMDtcXG59XFxuXFxuI21vY2hhIHVsIHtcXG4gIGxpc3Qtc3R5bGU6IG5vbmU7XFxufVxcblxcbiNtb2NoYSBoMSxcXG4jbW9jaGEgaDIge1xcbiAgbWFyZ2luOiAwO1xcbn1cXG5cXG4jbW9jaGEgaDEge1xcbiAgbWFyZ2luLXRvcDogMTVweDtcXG4gIGZvbnQtc2l6ZTogMWVtO1xcbiAgZm9udC13ZWlnaHQ6IDIwMDtcXG59XFxuXFxuI21vY2hhIGgxIGEge1xcbiAgdGV4dC1kZWNvcmF0aW9uOiBub25lO1xcbiAgY29sb3I6IGluaGVyaXQ7XFxufVxcblxcbiNtb2NoYSBoMSBhOmhvdmVyIHtcXG4gIHRleHQtZGVjb3JhdGlvbjogdW5kZXJsaW5lO1xcbn1cXG5cXG4jbW9jaGEgLnN1aXRlIC5zdWl0ZSBoMSB7XFxuICBtYXJnaW4tdG9wOiAwO1xcbiAgZm9udC1zaXplOiAuOGVtO1xcbn1cXG5cXG4jbW9jaGEgLmhpZGRlbiB7XFxuICBkaXNwbGF5OiBub25lO1xcbn1cXG5cXG4jbW9jaGEgaDIge1xcbiAgZm9udC1zaXplOiAxMnB4O1xcbiAgZm9udC13ZWlnaHQ6IG5vcm1hbDtcXG4gIGN1cnNvcjogcG9pbnRlcjtcXG59XFxuXFxuI21vY2hhIC5zdWl0ZSB7XFxuICBtYXJnaW4tbGVmdDogMTVweDtcXG59XFxuXFxuI21vY2hhIC50ZXN0IHtcXG4gIG1hcmdpbi1sZWZ0OiAxNXB4O1xcbiAgb3ZlcmZsb3c6IGhpZGRlbjtcXG59XFxuXFxuI21vY2hhIC50ZXN0LnBlbmRpbmc6aG92ZXIgaDI6OmFmdGVyIHtcXG4gIGNvbnRlbnQ6ICcocGVuZGluZyknO1xcbiAgZm9udC1mYW1pbHk6IGFyaWFsLCBzYW5zLXNlcmlmO1xcbn1cXG5cXG4jbW9jaGEgLnRlc3QucGFzcy5tZWRpdW0gLmR1cmF0aW9uIHtcXG4gIGJhY2tncm91bmQ6ICNjMDk4NTM7XFxufVxcblxcbiNtb2NoYSAudGVzdC5wYXNzLnNsb3cgLmR1cmF0aW9uIHtcXG4gIGJhY2tncm91bmQ6ICNiOTRhNDg7XFxufVxcblxcbiNtb2NoYSAudGVzdC5wYXNzOjpiZWZvcmUge1xcbiAgY29udGVudDogJ1xcXFwyNzEzJztcXG4gIGZvbnQtc2l6ZTogMTJweDtcXG4gIGRpc3BsYXk6IGJsb2NrO1xcbiAgZmxvYXQ6IGxlZnQ7XFxuICBtYXJnaW4tcmlnaHQ6IDVweDtcXG4gIGNvbG9yOiAjMDBkNmIyO1xcbn1cXG5cXG4jbW9jaGEgLnRlc3QucGFzcyAuZHVyYXRpb24ge1xcbiAgZm9udC1zaXplOiA5cHg7XFxuICBtYXJnaW4tbGVmdDogNXB4O1xcbiAgcGFkZGluZzogMnB4IDVweDtcXG4gIGNvbG9yOiAjZmZmO1xcbiAgLXdlYmtpdC1ib3gtc2hhZG93OiBpbnNldCAwIDFweCAxcHggcmdiYSgwLDAsMCwuMik7XFxuICAtbW96LWJveC1zaGFkb3c6IGluc2V0IDAgMXB4IDFweCByZ2JhKDAsMCwwLC4yKTtcXG4gIGJveC1zaGFkb3c6IGluc2V0IDAgMXB4IDFweCByZ2JhKDAsMCwwLC4yKTtcXG4gIC13ZWJraXQtYm9yZGVyLXJhZGl1czogNXB4O1xcbiAgLW1vei1ib3JkZXItcmFkaXVzOiA1cHg7XFxuICAtbXMtYm9yZGVyLXJhZGl1czogNXB4O1xcbiAgLW8tYm9yZGVyLXJhZGl1czogNXB4O1xcbiAgYm9yZGVyLXJhZGl1czogNXB4O1xcbn1cXG5cXG4jbW9jaGEgLnRlc3QucGFzcy5mYXN0IC5kdXJhdGlvbiB7XFxuICBkaXNwbGF5OiBub25lO1xcbn1cXG5cXG4jbW9jaGEgLnRlc3QucGVuZGluZyB7XFxuICBjb2xvcjogIzBiOTdjNDtcXG59XFxuXFxuI21vY2hhIC50ZXN0LnBlbmRpbmc6OmJlZm9yZSB7XFxuICBjb250ZW50OiAnXFxcXDI1RTYnO1xcbiAgY29sb3I6ICMwYjk3YzQ7XFxufVxcblxcbiNtb2NoYSAudGVzdC5mYWlsIHtcXG4gIGNvbG9yOiAjYzAwO1xcbn1cXG5cXG4jbW9jaGEgLnRlc3QuZmFpbCBwcmUge1xcbiAgY29sb3I6IGJsYWNrO1xcbn1cXG5cXG4jbW9jaGEgLnRlc3QuZmFpbDo6YmVmb3JlIHtcXG4gIGNvbnRlbnQ6ICdcXFxcMjcxNic7XFxuICBmb250LXNpemU6IDEycHg7XFxuICBkaXNwbGF5OiBibG9jaztcXG4gIGZsb2F0OiBsZWZ0O1xcbiAgbWFyZ2luLXJpZ2h0OiA1cHg7XFxuICBjb2xvcjogI2MwMDtcXG59XFxuXFxuI21vY2hhIC50ZXN0IHByZS5lcnJvciB7XFxuICBjb2xvcjogI2MwMDtcXG4gIG1heC1oZWlnaHQ6IDMwMHB4O1xcbiAgb3ZlcmZsb3c6IGF1dG87XFxufVxcblxcbiNtb2NoYSAudGVzdCAuaHRtbC1lcnJvciB7XFxuICBvdmVyZmxvdzogYXV0bztcXG4gIGNvbG9yOiBibGFjaztcXG4gIGxpbmUtaGVpZ2h0OiAxLjU7XFxuICBkaXNwbGF5OiBibG9jaztcXG4gIGZsb2F0OiBsZWZ0O1xcbiAgY2xlYXI6IGxlZnQ7XFxuICBmb250OiAxMnB4LzEuNSBtb25hY28sIG1vbm9zcGFjZTtcXG4gIG1hcmdpbjogNXB4O1xcbiAgcGFkZGluZzogMTVweDtcXG4gIGJvcmRlcjogMXB4IHNvbGlkICNlZWU7XFxuICBtYXgtd2lkdGg6IDg1JTsgLyooMSkqL1xcbiAgbWF4LXdpZHRoOiAtd2Via2l0LWNhbGMoMTAwJSAtIDQycHgpO1xcbiAgbWF4LXdpZHRoOiAtbW96LWNhbGMoMTAwJSAtIDQycHgpO1xcbiAgbWF4LXdpZHRoOiBjYWxjKDEwMCUgLSA0MnB4KTsgLyooMikqL1xcbiAgbWF4LWhlaWdodDogMzAwcHg7XFxuICB3b3JkLXdyYXA6IGJyZWFrLXdvcmQ7XFxuICBib3JkZXItYm90dG9tLWNvbG9yOiAjZGRkO1xcbiAgLXdlYmtpdC1ib3gtc2hhZG93OiAwIDFweCAzcHggI2VlZTtcXG4gIC1tb3otYm94LXNoYWRvdzogMCAxcHggM3B4ICNlZWU7XFxuICBib3gtc2hhZG93OiAwIDFweCAzcHggI2VlZTtcXG4gIC13ZWJraXQtYm9yZGVyLXJhZGl1czogM3B4O1xcbiAgLW1vei1ib3JkZXItcmFkaXVzOiAzcHg7XFxuICBib3JkZXItcmFkaXVzOiAzcHg7XFxufVxcblxcbiNtb2NoYSAudGVzdCAuaHRtbC1lcnJvciBwcmUuZXJyb3Ige1xcbiAgYm9yZGVyOiBub25lO1xcbiAgLXdlYmtpdC1ib3JkZXItcmFkaXVzOiAwO1xcbiAgLW1vei1ib3JkZXItcmFkaXVzOiAwO1xcbiAgYm9yZGVyLXJhZGl1czogMDtcXG4gIC13ZWJraXQtYm94LXNoYWRvdzogMDtcXG4gIC1tb3otYm94LXNoYWRvdzogMDtcXG4gIGJveC1zaGFkb3c6IDA7XFxuICBwYWRkaW5nOiAwO1xcbiAgbWFyZ2luOiAwO1xcbiAgbWFyZ2luLXRvcDogMThweDtcXG4gIG1heC1oZWlnaHQ6IG5vbmU7XFxufVxcblxcbi8qKlxcbiAqICgxKTogYXBwcm94aW1hdGUgZm9yIGJyb3dzZXJzIG5vdCBzdXBwb3J0aW5nIGNhbGNcXG4gKiAoMik6IDQyID0gMioxNSArIDIqMTAgKyAyKjEgKHBhZGRpbmcgKyBtYXJnaW4gKyBib3JkZXIpXFxuICogICAgICBeXiBzZXJpb3VzbHlcXG4gKi9cXG4jbW9jaGEgLnRlc3QgcHJlIHtcXG4gIGRpc3BsYXk6IGJsb2NrO1xcbiAgZmxvYXQ6IGxlZnQ7XFxuICBjbGVhcjogbGVmdDtcXG4gIGZvbnQ6IDEycHgvMS41IG1vbmFjbywgbW9ub3NwYWNlO1xcbiAgbWFyZ2luOiA1cHg7XFxuICBwYWRkaW5nOiAxNXB4O1xcbiAgYm9yZGVyOiAxcHggc29saWQgI2VlZTtcXG4gIG1heC13aWR0aDogODUlOyAvKigxKSovXFxuICBtYXgtd2lkdGg6IC13ZWJraXQtY2FsYygxMDAlIC0gNDJweCk7XFxuICBtYXgtd2lkdGg6IC1tb3otY2FsYygxMDAlIC0gNDJweCk7XFxuICBtYXgtd2lkdGg6IGNhbGMoMTAwJSAtIDQycHgpOyAvKigyKSovXFxuICB3b3JkLXdyYXA6IGJyZWFrLXdvcmQ7XFxuICBib3JkZXItYm90dG9tLWNvbG9yOiAjZGRkO1xcbiAgLXdlYmtpdC1ib3gtc2hhZG93OiAwIDFweCAzcHggI2VlZTtcXG4gIC1tb3otYm94LXNoYWRvdzogMCAxcHggM3B4ICNlZWU7XFxuICBib3gtc2hhZG93OiAwIDFweCAzcHggI2VlZTtcXG4gIC13ZWJraXQtYm9yZGVyLXJhZGl1czogM3B4O1xcbiAgLW1vei1ib3JkZXItcmFkaXVzOiAzcHg7XFxuICBib3JkZXItcmFkaXVzOiAzcHg7XFxufVxcblxcbiNtb2NoYSAudGVzdCBoMiB7XFxuICBwb3NpdGlvbjogcmVsYXRpdmU7XFxufVxcblxcbiNtb2NoYSAudGVzdCBhLnJlcGxheSB7XFxuICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICB0b3A6IDNweDtcXG4gIHJpZ2h0OiAwO1xcbiAgdGV4dC1kZWNvcmF0aW9uOiBub25lO1xcbiAgdmVydGljYWwtYWxpZ246IG1pZGRsZTtcXG4gIGRpc3BsYXk6IGJsb2NrO1xcbiAgd2lkdGg6IDE1cHg7XFxuICBoZWlnaHQ6IDE1cHg7XFxuICBsaW5lLWhlaWdodDogMTVweDtcXG4gIHRleHQtYWxpZ246IGNlbnRlcjtcXG4gIGJhY2tncm91bmQ6ICNlZWU7XFxuICBmb250LXNpemU6IDE1cHg7XFxuICAtd2Via2l0LWJvcmRlci1yYWRpdXM6IDE1cHg7XFxuICAtbW96LWJvcmRlci1yYWRpdXM6IDE1cHg7XFxuICBib3JkZXItcmFkaXVzOiAxNXB4O1xcbiAgLXdlYmtpdC10cmFuc2l0aW9uOm9wYWNpdHkgMjAwbXM7XFxuICAtbW96LXRyYW5zaXRpb246b3BhY2l0eSAyMDBtcztcXG4gIC1vLXRyYW5zaXRpb246b3BhY2l0eSAyMDBtcztcXG4gIHRyYW5zaXRpb246IG9wYWNpdHkgMjAwbXM7XFxuICBvcGFjaXR5OiAwLjM7XFxuICBjb2xvcjogIzg4ODtcXG59XFxuXFxuI21vY2hhIC50ZXN0OmhvdmVyIGEucmVwbGF5IHtcXG4gIG9wYWNpdHk6IDE7XFxufVxcblxcbiNtb2NoYS1yZXBvcnQucGFzcyAudGVzdC5mYWlsIHtcXG4gIGRpc3BsYXk6IG5vbmU7XFxufVxcblxcbiNtb2NoYS1yZXBvcnQuZmFpbCAudGVzdC5wYXNzIHtcXG4gIGRpc3BsYXk6IG5vbmU7XFxufVxcblxcbiNtb2NoYS1yZXBvcnQucGVuZGluZyAudGVzdC5wYXNzLFxcbiNtb2NoYS1yZXBvcnQucGVuZGluZyAudGVzdC5mYWlsIHtcXG4gIGRpc3BsYXk6IG5vbmU7XFxufVxcbiNtb2NoYS1yZXBvcnQucGVuZGluZyAudGVzdC5wYXNzLnBlbmRpbmcge1xcbiAgZGlzcGxheTogYmxvY2s7XFxufVxcblxcbiNtb2NoYS1lcnJvciB7XFxuICBjb2xvcjogI2MwMDtcXG4gIGZvbnQtc2l6ZTogMS41ZW07XFxuICBmb250LXdlaWdodDogMTAwO1xcbiAgbGV0dGVyLXNwYWNpbmc6IDFweDtcXG59XFxuXFxuI21vY2hhLXN0YXRzIHtcXG4gIHBvc2l0aW9uOiBmaXhlZDtcXG4gIHRvcDogMTVweDtcXG4gIHJpZ2h0OiAxMHB4O1xcbiAgZm9udC1zaXplOiAxMnB4O1xcbiAgbWFyZ2luOiAwO1xcbiAgY29sb3I6ICM4ODg7XFxuICB6LWluZGV4OiAxO1xcbn1cXG5cXG4jbW9jaGEtc3RhdHMgLnByb2dyZXNzIHtcXG4gIGZsb2F0OiByaWdodDtcXG4gIHBhZGRpbmctdG9wOiAwO1xcblxcbiAgLyoqXFxuICAgKiBTZXQgc2FmZSBpbml0aWFsIHZhbHVlcywgc28gbW9jaGFzIC5wcm9ncmVzcyBkb2VzIG5vdCBpbmhlcml0IHRoZXNlXFxuICAgKiBwcm9wZXJ0aWVzIGZyb20gQm9vdHN0cmFwIC5wcm9ncmVzcyAod2hpY2ggY2F1c2VzIC5wcm9ncmVzcyBoZWlnaHQgdG9cXG4gICAqIGVxdWFsIGxpbmUgaGVpZ2h0IHNldCBpbiBCb290c3RyYXApLlxcbiAgICovXFxuICBoZWlnaHQ6IGF1dG87XFxuICAtd2Via2l0LWJveC1zaGFkb3c6IG5vbmU7XFxuICAtbW96LWJveC1zaGFkb3c6IG5vbmU7XFxuICBib3gtc2hhZG93OiBub25lO1xcbiAgYmFja2dyb3VuZC1jb2xvcjogaW5pdGlhbDtcXG59XFxuXFxuI21vY2hhLXN0YXRzIGVtIHtcXG4gIGNvbG9yOiBibGFjaztcXG59XFxuXFxuI21vY2hhLXN0YXRzIGEge1xcbiAgdGV4dC1kZWNvcmF0aW9uOiBub25lO1xcbiAgY29sb3I6IGluaGVyaXQ7XFxufVxcblxcbiNtb2NoYS1zdGF0cyBhOmhvdmVyIHtcXG4gIGJvcmRlci1ib3R0b206IDFweCBzb2xpZCAjZWVlO1xcbn1cXG5cXG4jbW9jaGEtc3RhdHMgbGkge1xcbiAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xcbiAgbWFyZ2luOiAwIDVweDtcXG4gIGxpc3Qtc3R5bGU6IG5vbmU7XFxuICBwYWRkaW5nLXRvcDogMTFweDtcXG59XFxuXFxuI21vY2hhLXN0YXRzIGNhbnZhcyB7XFxuICB3aWR0aDogNDBweDtcXG4gIGhlaWdodDogNDBweDtcXG59XFxuXFxuI21vY2hhIGNvZGUgLmNvbW1lbnQgeyBjb2xvcjogI2RkZDsgfVxcbiNtb2NoYSBjb2RlIC5pbml0IHsgY29sb3I6ICMyZjZmYWQ7IH1cXG4jbW9jaGEgY29kZSAuc3RyaW5nIHsgY29sb3I6ICM1ODkwYWQ7IH1cXG4jbW9jaGEgY29kZSAua2V5d29yZCB7IGNvbG9yOiAjOGE2MzQzOyB9XFxuI21vY2hhIGNvZGUgLm51bWJlciB7IGNvbG9yOiAjMmY2ZmFkOyB9XFxuXFxuQG1lZGlhIHNjcmVlbiBhbmQgKG1heC1kZXZpY2Utd2lkdGg6IDQ4MHB4KSB7XFxuICAjbW9jaGEge1xcbiAgICBtYXJnaW46IDYwcHggMHB4O1xcbiAgfVxcblxcbiAgI21vY2hhICNzdGF0cyB7XFxuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gIH1cXG59XFxuXCIsIFwiXCJdKTtcblxuLy8gZXhwb3J0c1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L21vY2hhLWxvYWRlci9+L2Nzcy1sb2FkZXIhLi9+L21vY2hhL21vY2hhLmNzc1xuLy8gbW9kdWxlIGlkID0gOFxuLy8gbW9kdWxlIGNodW5rcyA9IDEiLCIvKlxuXHRNSVQgTGljZW5zZSBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxuXHRBdXRob3IgVG9iaWFzIEtvcHBlcnMgQHNva3JhXG4qL1xuLy8gY3NzIGJhc2UgY29kZSwgaW5qZWN0ZWQgYnkgdGhlIGNzcy1sb2FkZXJcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24odXNlU291cmNlTWFwKSB7XG5cdHZhciBsaXN0ID0gW107XG5cblx0Ly8gcmV0dXJuIHRoZSBsaXN0IG9mIG1vZHVsZXMgYXMgY3NzIHN0cmluZ1xuXHRsaXN0LnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG5cdFx0cmV0dXJuIHRoaXMubWFwKGZ1bmN0aW9uIChpdGVtKSB7XG5cdFx0XHR2YXIgY29udGVudCA9IGNzc1dpdGhNYXBwaW5nVG9TdHJpbmcoaXRlbSwgdXNlU291cmNlTWFwKTtcblx0XHRcdGlmKGl0ZW1bMl0pIHtcblx0XHRcdFx0cmV0dXJuIFwiQG1lZGlhIFwiICsgaXRlbVsyXSArIFwie1wiICsgY29udGVudCArIFwifVwiO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cmV0dXJuIGNvbnRlbnQ7XG5cdFx0XHR9XG5cdFx0fSkuam9pbihcIlwiKTtcblx0fTtcblxuXHQvLyBpbXBvcnQgYSBsaXN0IG9mIG1vZHVsZXMgaW50byB0aGUgbGlzdFxuXHRsaXN0LmkgPSBmdW5jdGlvbihtb2R1bGVzLCBtZWRpYVF1ZXJ5KSB7XG5cdFx0aWYodHlwZW9mIG1vZHVsZXMgPT09IFwic3RyaW5nXCIpXG5cdFx0XHRtb2R1bGVzID0gW1tudWxsLCBtb2R1bGVzLCBcIlwiXV07XG5cdFx0dmFyIGFscmVhZHlJbXBvcnRlZE1vZHVsZXMgPSB7fTtcblx0XHRmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFyIGlkID0gdGhpc1tpXVswXTtcblx0XHRcdGlmKHR5cGVvZiBpZCA9PT0gXCJudW1iZXJcIilcblx0XHRcdFx0YWxyZWFkeUltcG9ydGVkTW9kdWxlc1tpZF0gPSB0cnVlO1xuXHRcdH1cblx0XHRmb3IoaSA9IDA7IGkgPCBtb2R1bGVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIgaXRlbSA9IG1vZHVsZXNbaV07XG5cdFx0XHQvLyBza2lwIGFscmVhZHkgaW1wb3J0ZWQgbW9kdWxlXG5cdFx0XHQvLyB0aGlzIGltcGxlbWVudGF0aW9uIGlzIG5vdCAxMDAlIHBlcmZlY3QgZm9yIHdlaXJkIG1lZGlhIHF1ZXJ5IGNvbWJpbmF0aW9uc1xuXHRcdFx0Ly8gIHdoZW4gYSBtb2R1bGUgaXMgaW1wb3J0ZWQgbXVsdGlwbGUgdGltZXMgd2l0aCBkaWZmZXJlbnQgbWVkaWEgcXVlcmllcy5cblx0XHRcdC8vICBJIGhvcGUgdGhpcyB3aWxsIG5ldmVyIG9jY3VyIChIZXkgdGhpcyB3YXkgd2UgaGF2ZSBzbWFsbGVyIGJ1bmRsZXMpXG5cdFx0XHRpZih0eXBlb2YgaXRlbVswXSAhPT0gXCJudW1iZXJcIiB8fCAhYWxyZWFkeUltcG9ydGVkTW9kdWxlc1tpdGVtWzBdXSkge1xuXHRcdFx0XHRpZihtZWRpYVF1ZXJ5ICYmICFpdGVtWzJdKSB7XG5cdFx0XHRcdFx0aXRlbVsyXSA9IG1lZGlhUXVlcnk7XG5cdFx0XHRcdH0gZWxzZSBpZihtZWRpYVF1ZXJ5KSB7XG5cdFx0XHRcdFx0aXRlbVsyXSA9IFwiKFwiICsgaXRlbVsyXSArIFwiKSBhbmQgKFwiICsgbWVkaWFRdWVyeSArIFwiKVwiO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGxpc3QucHVzaChpdGVtKTtcblx0XHRcdH1cblx0XHR9XG5cdH07XG5cdHJldHVybiBsaXN0O1xufTtcblxuZnVuY3Rpb24gY3NzV2l0aE1hcHBpbmdUb1N0cmluZyhpdGVtLCB1c2VTb3VyY2VNYXApIHtcblx0dmFyIGNvbnRlbnQgPSBpdGVtWzFdIHx8ICcnO1xuXHR2YXIgY3NzTWFwcGluZyA9IGl0ZW1bM107XG5cdGlmICghY3NzTWFwcGluZykge1xuXHRcdHJldHVybiBjb250ZW50O1xuXHR9XG5cblx0aWYgKHVzZVNvdXJjZU1hcCAmJiB0eXBlb2YgYnRvYSA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdHZhciBzb3VyY2VNYXBwaW5nID0gdG9Db21tZW50KGNzc01hcHBpbmcpO1xuXHRcdHZhciBzb3VyY2VVUkxzID0gY3NzTWFwcGluZy5zb3VyY2VzLm1hcChmdW5jdGlvbiAoc291cmNlKSB7XG5cdFx0XHRyZXR1cm4gJy8qIyBzb3VyY2VVUkw9JyArIGNzc01hcHBpbmcuc291cmNlUm9vdCArIHNvdXJjZSArICcgKi8nXG5cdFx0fSk7XG5cblx0XHRyZXR1cm4gW2NvbnRlbnRdLmNvbmNhdChzb3VyY2VVUkxzKS5jb25jYXQoW3NvdXJjZU1hcHBpbmddKS5qb2luKCdcXG4nKTtcblx0fVxuXG5cdHJldHVybiBbY29udGVudF0uam9pbignXFxuJyk7XG59XG5cbi8vIEFkYXB0ZWQgZnJvbSBjb252ZXJ0LXNvdXJjZS1tYXAgKE1JVClcbmZ1bmN0aW9uIHRvQ29tbWVudChzb3VyY2VNYXApIHtcblx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVuZGVmXG5cdHZhciBiYXNlNjQgPSBidG9hKHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChKU09OLnN0cmluZ2lmeShzb3VyY2VNYXApKSkpO1xuXHR2YXIgZGF0YSA9ICdzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtjaGFyc2V0PXV0Zi04O2Jhc2U2NCwnICsgYmFzZTY0O1xuXG5cdHJldHVybiAnLyojICcgKyBkYXRhICsgJyAqLyc7XG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vbW9jaGEtbG9hZGVyL34vY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanNcbi8vIG1vZHVsZSBpZCA9IDlcbi8vIG1vZHVsZSBjaHVua3MgPSAxIiwiLypcblx0TUlUIExpY2Vuc2UgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHBcblx0QXV0aG9yIFRvYmlhcyBLb3BwZXJzIEBzb2tyYVxuKi9cblxudmFyIHN0eWxlc0luRG9tID0ge307XG5cbnZhclx0bWVtb2l6ZSA9IGZ1bmN0aW9uIChmbikge1xuXHR2YXIgbWVtbztcblxuXHRyZXR1cm4gZnVuY3Rpb24gKCkge1xuXHRcdGlmICh0eXBlb2YgbWVtbyA9PT0gXCJ1bmRlZmluZWRcIikgbWVtbyA9IGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdFx0cmV0dXJuIG1lbW87XG5cdH07XG59O1xuXG52YXIgaXNPbGRJRSA9IG1lbW9pemUoZnVuY3Rpb24gKCkge1xuXHQvLyBUZXN0IGZvciBJRSA8PSA5IGFzIHByb3Bvc2VkIGJ5IEJyb3dzZXJoYWNrc1xuXHQvLyBAc2VlIGh0dHA6Ly9icm93c2VyaGFja3MuY29tLyNoYWNrLWU3MWQ4NjkyZjY1MzM0MTczZmVlNzE1YzIyMmNiODA1XG5cdC8vIFRlc3RzIGZvciBleGlzdGVuY2Ugb2Ygc3RhbmRhcmQgZ2xvYmFscyBpcyB0byBhbGxvdyBzdHlsZS1sb2FkZXJcblx0Ly8gdG8gb3BlcmF0ZSBjb3JyZWN0bHkgaW50byBub24tc3RhbmRhcmQgZW52aXJvbm1lbnRzXG5cdC8vIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL3dlYnBhY2stY29udHJpYi9zdHlsZS1sb2FkZXIvaXNzdWVzLzE3N1xuXHRyZXR1cm4gd2luZG93ICYmIGRvY3VtZW50ICYmIGRvY3VtZW50LmFsbCAmJiAhd2luZG93LmF0b2I7XG59KTtcblxudmFyIGdldEVsZW1lbnQgPSAoZnVuY3Rpb24gKGZuKSB7XG5cdHZhciBtZW1vID0ge307XG5cblx0cmV0dXJuIGZ1bmN0aW9uKHNlbGVjdG9yKSB7XG5cdFx0aWYgKHR5cGVvZiBtZW1vW3NlbGVjdG9yXSA9PT0gXCJ1bmRlZmluZWRcIikge1xuXHRcdFx0dmFyIHN0eWxlVGFyZ2V0ID0gZm4uY2FsbCh0aGlzLCBzZWxlY3Rvcik7XG5cdFx0XHQvLyBTcGVjaWFsIGNhc2UgdG8gcmV0dXJuIGhlYWQgb2YgaWZyYW1lIGluc3RlYWQgb2YgaWZyYW1lIGl0c2VsZlxuXHRcdFx0aWYgKHN0eWxlVGFyZ2V0IGluc3RhbmNlb2Ygd2luZG93LkhUTUxJRnJhbWVFbGVtZW50KSB7XG5cdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0Ly8gVGhpcyB3aWxsIHRocm93IGFuIGV4Y2VwdGlvbiBpZiBhY2Nlc3MgdG8gaWZyYW1lIGlzIGJsb2NrZWRcblx0XHRcdFx0XHQvLyBkdWUgdG8gY3Jvc3Mtb3JpZ2luIHJlc3RyaWN0aW9uc1xuXHRcdFx0XHRcdHN0eWxlVGFyZ2V0ID0gc3R5bGVUYXJnZXQuY29udGVudERvY3VtZW50LmhlYWQ7XG5cdFx0XHRcdH0gY2F0Y2goZSkge1xuXHRcdFx0XHRcdHN0eWxlVGFyZ2V0ID0gbnVsbDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0bWVtb1tzZWxlY3Rvcl0gPSBzdHlsZVRhcmdldDtcblx0XHR9XG5cdFx0cmV0dXJuIG1lbW9bc2VsZWN0b3JdXG5cdH07XG59KShmdW5jdGlvbiAodGFyZ2V0KSB7XG5cdHJldHVybiBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHRhcmdldClcbn0pO1xuXG52YXIgc2luZ2xldG9uID0gbnVsbDtcbnZhclx0c2luZ2xldG9uQ291bnRlciA9IDA7XG52YXJcdHN0eWxlc0luc2VydGVkQXRUb3AgPSBbXTtcblxudmFyXHRmaXhVcmxzID0gcmVxdWlyZShcIi4vdXJsc1wiKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihsaXN0LCBvcHRpb25zKSB7XG5cdGlmICh0eXBlb2YgREVCVUcgIT09IFwidW5kZWZpbmVkXCIgJiYgREVCVUcpIHtcblx0XHRpZiAodHlwZW9mIGRvY3VtZW50ICE9PSBcIm9iamVjdFwiKSB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgc3R5bGUtbG9hZGVyIGNhbm5vdCBiZSB1c2VkIGluIGEgbm9uLWJyb3dzZXIgZW52aXJvbm1lbnRcIik7XG5cdH1cblxuXHRvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuXHRvcHRpb25zLmF0dHJzID0gdHlwZW9mIG9wdGlvbnMuYXR0cnMgPT09IFwib2JqZWN0XCIgPyBvcHRpb25zLmF0dHJzIDoge307XG5cblx0Ly8gRm9yY2Ugc2luZ2xlLXRhZyBzb2x1dGlvbiBvbiBJRTYtOSwgd2hpY2ggaGFzIGEgaGFyZCBsaW1pdCBvbiB0aGUgIyBvZiA8c3R5bGU+XG5cdC8vIHRhZ3MgaXQgd2lsbCBhbGxvdyBvbiBhIHBhZ2Vcblx0aWYgKCFvcHRpb25zLnNpbmdsZXRvbiAmJiB0eXBlb2Ygb3B0aW9ucy5zaW5nbGV0b24gIT09IFwiYm9vbGVhblwiKSBvcHRpb25zLnNpbmdsZXRvbiA9IGlzT2xkSUUoKTtcblxuXHQvLyBCeSBkZWZhdWx0LCBhZGQgPHN0eWxlPiB0YWdzIHRvIHRoZSA8aGVhZD4gZWxlbWVudFxuXHRpZiAoIW9wdGlvbnMuaW5zZXJ0SW50bykgb3B0aW9ucy5pbnNlcnRJbnRvID0gXCJoZWFkXCI7XG5cblx0Ly8gQnkgZGVmYXVsdCwgYWRkIDxzdHlsZT4gdGFncyB0byB0aGUgYm90dG9tIG9mIHRoZSB0YXJnZXRcblx0aWYgKCFvcHRpb25zLmluc2VydEF0KSBvcHRpb25zLmluc2VydEF0ID0gXCJib3R0b21cIjtcblxuXHR2YXIgc3R5bGVzID0gbGlzdFRvU3R5bGVzKGxpc3QsIG9wdGlvbnMpO1xuXG5cdGFkZFN0eWxlc1RvRG9tKHN0eWxlcywgb3B0aW9ucyk7XG5cblx0cmV0dXJuIGZ1bmN0aW9uIHVwZGF0ZSAobmV3TGlzdCkge1xuXHRcdHZhciBtYXlSZW1vdmUgPSBbXTtcblxuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgc3R5bGVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIgaXRlbSA9IHN0eWxlc1tpXTtcblx0XHRcdHZhciBkb21TdHlsZSA9IHN0eWxlc0luRG9tW2l0ZW0uaWRdO1xuXG5cdFx0XHRkb21TdHlsZS5yZWZzLS07XG5cdFx0XHRtYXlSZW1vdmUucHVzaChkb21TdHlsZSk7XG5cdFx0fVxuXG5cdFx0aWYobmV3TGlzdCkge1xuXHRcdFx0dmFyIG5ld1N0eWxlcyA9IGxpc3RUb1N0eWxlcyhuZXdMaXN0LCBvcHRpb25zKTtcblx0XHRcdGFkZFN0eWxlc1RvRG9tKG5ld1N0eWxlcywgb3B0aW9ucyk7XG5cdFx0fVxuXG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBtYXlSZW1vdmUubGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhciBkb21TdHlsZSA9IG1heVJlbW92ZVtpXTtcblxuXHRcdFx0aWYoZG9tU3R5bGUucmVmcyA9PT0gMCkge1xuXHRcdFx0XHRmb3IgKHZhciBqID0gMDsgaiA8IGRvbVN0eWxlLnBhcnRzLmxlbmd0aDsgaisrKSBkb21TdHlsZS5wYXJ0c1tqXSgpO1xuXG5cdFx0XHRcdGRlbGV0ZSBzdHlsZXNJbkRvbVtkb21TdHlsZS5pZF07XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xufTtcblxuZnVuY3Rpb24gYWRkU3R5bGVzVG9Eb20gKHN0eWxlcywgb3B0aW9ucykge1xuXHRmb3IgKHZhciBpID0gMDsgaSA8IHN0eWxlcy5sZW5ndGg7IGkrKykge1xuXHRcdHZhciBpdGVtID0gc3R5bGVzW2ldO1xuXHRcdHZhciBkb21TdHlsZSA9IHN0eWxlc0luRG9tW2l0ZW0uaWRdO1xuXG5cdFx0aWYoZG9tU3R5bGUpIHtcblx0XHRcdGRvbVN0eWxlLnJlZnMrKztcblxuXHRcdFx0Zm9yKHZhciBqID0gMDsgaiA8IGRvbVN0eWxlLnBhcnRzLmxlbmd0aDsgaisrKSB7XG5cdFx0XHRcdGRvbVN0eWxlLnBhcnRzW2pdKGl0ZW0ucGFydHNbal0pO1xuXHRcdFx0fVxuXG5cdFx0XHRmb3IoOyBqIDwgaXRlbS5wYXJ0cy5sZW5ndGg7IGorKykge1xuXHRcdFx0XHRkb21TdHlsZS5wYXJ0cy5wdXNoKGFkZFN0eWxlKGl0ZW0ucGFydHNbal0sIG9wdGlvbnMpKTtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0dmFyIHBhcnRzID0gW107XG5cblx0XHRcdGZvcih2YXIgaiA9IDA7IGogPCBpdGVtLnBhcnRzLmxlbmd0aDsgaisrKSB7XG5cdFx0XHRcdHBhcnRzLnB1c2goYWRkU3R5bGUoaXRlbS5wYXJ0c1tqXSwgb3B0aW9ucykpO1xuXHRcdFx0fVxuXG5cdFx0XHRzdHlsZXNJbkRvbVtpdGVtLmlkXSA9IHtpZDogaXRlbS5pZCwgcmVmczogMSwgcGFydHM6IHBhcnRzfTtcblx0XHR9XG5cdH1cbn1cblxuZnVuY3Rpb24gbGlzdFRvU3R5bGVzIChsaXN0LCBvcHRpb25zKSB7XG5cdHZhciBzdHlsZXMgPSBbXTtcblx0dmFyIG5ld1N0eWxlcyA9IHt9O1xuXG5cdGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuXHRcdHZhciBpdGVtID0gbGlzdFtpXTtcblx0XHR2YXIgaWQgPSBvcHRpb25zLmJhc2UgPyBpdGVtWzBdICsgb3B0aW9ucy5iYXNlIDogaXRlbVswXTtcblx0XHR2YXIgY3NzID0gaXRlbVsxXTtcblx0XHR2YXIgbWVkaWEgPSBpdGVtWzJdO1xuXHRcdHZhciBzb3VyY2VNYXAgPSBpdGVtWzNdO1xuXHRcdHZhciBwYXJ0ID0ge2NzczogY3NzLCBtZWRpYTogbWVkaWEsIHNvdXJjZU1hcDogc291cmNlTWFwfTtcblxuXHRcdGlmKCFuZXdTdHlsZXNbaWRdKSBzdHlsZXMucHVzaChuZXdTdHlsZXNbaWRdID0ge2lkOiBpZCwgcGFydHM6IFtwYXJ0XX0pO1xuXHRcdGVsc2UgbmV3U3R5bGVzW2lkXS5wYXJ0cy5wdXNoKHBhcnQpO1xuXHR9XG5cblx0cmV0dXJuIHN0eWxlcztcbn1cblxuZnVuY3Rpb24gaW5zZXJ0U3R5bGVFbGVtZW50IChvcHRpb25zLCBzdHlsZSkge1xuXHR2YXIgdGFyZ2V0ID0gZ2V0RWxlbWVudChvcHRpb25zLmluc2VydEludG8pXG5cblx0aWYgKCF0YXJnZXQpIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoXCJDb3VsZG4ndCBmaW5kIGEgc3R5bGUgdGFyZ2V0LiBUaGlzIHByb2JhYmx5IG1lYW5zIHRoYXQgdGhlIHZhbHVlIGZvciB0aGUgJ2luc2VydEludG8nIHBhcmFtZXRlciBpcyBpbnZhbGlkLlwiKTtcblx0fVxuXG5cdHZhciBsYXN0U3R5bGVFbGVtZW50SW5zZXJ0ZWRBdFRvcCA9IHN0eWxlc0luc2VydGVkQXRUb3Bbc3R5bGVzSW5zZXJ0ZWRBdFRvcC5sZW5ndGggLSAxXTtcblxuXHRpZiAob3B0aW9ucy5pbnNlcnRBdCA9PT0gXCJ0b3BcIikge1xuXHRcdGlmICghbGFzdFN0eWxlRWxlbWVudEluc2VydGVkQXRUb3ApIHtcblx0XHRcdHRhcmdldC5pbnNlcnRCZWZvcmUoc3R5bGUsIHRhcmdldC5maXJzdENoaWxkKTtcblx0XHR9IGVsc2UgaWYgKGxhc3RTdHlsZUVsZW1lbnRJbnNlcnRlZEF0VG9wLm5leHRTaWJsaW5nKSB7XG5cdFx0XHR0YXJnZXQuaW5zZXJ0QmVmb3JlKHN0eWxlLCBsYXN0U3R5bGVFbGVtZW50SW5zZXJ0ZWRBdFRvcC5uZXh0U2libGluZyk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRhcmdldC5hcHBlbmRDaGlsZChzdHlsZSk7XG5cdFx0fVxuXHRcdHN0eWxlc0luc2VydGVkQXRUb3AucHVzaChzdHlsZSk7XG5cdH0gZWxzZSBpZiAob3B0aW9ucy5pbnNlcnRBdCA9PT0gXCJib3R0b21cIikge1xuXHRcdHRhcmdldC5hcHBlbmRDaGlsZChzdHlsZSk7XG5cdH0gZWxzZSBpZiAodHlwZW9mIG9wdGlvbnMuaW5zZXJ0QXQgPT09IFwib2JqZWN0XCIgJiYgb3B0aW9ucy5pbnNlcnRBdC5iZWZvcmUpIHtcblx0XHR2YXIgbmV4dFNpYmxpbmcgPSBnZXRFbGVtZW50KG9wdGlvbnMuaW5zZXJ0SW50byArIFwiIFwiICsgb3B0aW9ucy5pbnNlcnRBdC5iZWZvcmUpO1xuXHRcdHRhcmdldC5pbnNlcnRCZWZvcmUoc3R5bGUsIG5leHRTaWJsaW5nKTtcblx0fSBlbHNlIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoXCJbU3R5bGUgTG9hZGVyXVxcblxcbiBJbnZhbGlkIHZhbHVlIGZvciBwYXJhbWV0ZXIgJ2luc2VydEF0JyAoJ29wdGlvbnMuaW5zZXJ0QXQnKSBmb3VuZC5cXG4gTXVzdCBiZSAndG9wJywgJ2JvdHRvbScsIG9yIE9iamVjdC5cXG4gKGh0dHBzOi8vZ2l0aHViLmNvbS93ZWJwYWNrLWNvbnRyaWIvc3R5bGUtbG9hZGVyI2luc2VydGF0KVxcblwiKTtcblx0fVxufVxuXG5mdW5jdGlvbiByZW1vdmVTdHlsZUVsZW1lbnQgKHN0eWxlKSB7XG5cdGlmIChzdHlsZS5wYXJlbnROb2RlID09PSBudWxsKSByZXR1cm4gZmFsc2U7XG5cdHN0eWxlLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoc3R5bGUpO1xuXG5cdHZhciBpZHggPSBzdHlsZXNJbnNlcnRlZEF0VG9wLmluZGV4T2Yoc3R5bGUpO1xuXHRpZihpZHggPj0gMCkge1xuXHRcdHN0eWxlc0luc2VydGVkQXRUb3Auc3BsaWNlKGlkeCwgMSk7XG5cdH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlU3R5bGVFbGVtZW50IChvcHRpb25zKSB7XG5cdHZhciBzdHlsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzdHlsZVwiKTtcblxuXHRvcHRpb25zLmF0dHJzLnR5cGUgPSBcInRleHQvY3NzXCI7XG5cblx0YWRkQXR0cnMoc3R5bGUsIG9wdGlvbnMuYXR0cnMpO1xuXHRpbnNlcnRTdHlsZUVsZW1lbnQob3B0aW9ucywgc3R5bGUpO1xuXG5cdHJldHVybiBzdHlsZTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlTGlua0VsZW1lbnQgKG9wdGlvbnMpIHtcblx0dmFyIGxpbmsgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwibGlua1wiKTtcblxuXHRvcHRpb25zLmF0dHJzLnR5cGUgPSBcInRleHQvY3NzXCI7XG5cdG9wdGlvbnMuYXR0cnMucmVsID0gXCJzdHlsZXNoZWV0XCI7XG5cblx0YWRkQXR0cnMobGluaywgb3B0aW9ucy5hdHRycyk7XG5cdGluc2VydFN0eWxlRWxlbWVudChvcHRpb25zLCBsaW5rKTtcblxuXHRyZXR1cm4gbGluaztcbn1cblxuZnVuY3Rpb24gYWRkQXR0cnMgKGVsLCBhdHRycykge1xuXHRPYmplY3Qua2V5cyhhdHRycykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG5cdFx0ZWwuc2V0QXR0cmlidXRlKGtleSwgYXR0cnNba2V5XSk7XG5cdH0pO1xufVxuXG5mdW5jdGlvbiBhZGRTdHlsZSAob2JqLCBvcHRpb25zKSB7XG5cdHZhciBzdHlsZSwgdXBkYXRlLCByZW1vdmUsIHJlc3VsdDtcblxuXHQvLyBJZiBhIHRyYW5zZm9ybSBmdW5jdGlvbiB3YXMgZGVmaW5lZCwgcnVuIGl0IG9uIHRoZSBjc3Ncblx0aWYgKG9wdGlvbnMudHJhbnNmb3JtICYmIG9iai5jc3MpIHtcblx0ICAgIHJlc3VsdCA9IG9wdGlvbnMudHJhbnNmb3JtKG9iai5jc3MpO1xuXG5cdCAgICBpZiAocmVzdWx0KSB7XG5cdCAgICBcdC8vIElmIHRyYW5zZm9ybSByZXR1cm5zIGEgdmFsdWUsIHVzZSB0aGF0IGluc3RlYWQgb2YgdGhlIG9yaWdpbmFsIGNzcy5cblx0ICAgIFx0Ly8gVGhpcyBhbGxvd3MgcnVubmluZyBydW50aW1lIHRyYW5zZm9ybWF0aW9ucyBvbiB0aGUgY3NzLlxuXHQgICAgXHRvYmouY3NzID0gcmVzdWx0O1xuXHQgICAgfSBlbHNlIHtcblx0ICAgIFx0Ly8gSWYgdGhlIHRyYW5zZm9ybSBmdW5jdGlvbiByZXR1cm5zIGEgZmFsc3kgdmFsdWUsIGRvbid0IGFkZCB0aGlzIGNzcy5cblx0ICAgIFx0Ly8gVGhpcyBhbGxvd3MgY29uZGl0aW9uYWwgbG9hZGluZyBvZiBjc3Ncblx0ICAgIFx0cmV0dXJuIGZ1bmN0aW9uKCkge1xuXHQgICAgXHRcdC8vIG5vb3Bcblx0ICAgIFx0fTtcblx0ICAgIH1cblx0fVxuXG5cdGlmIChvcHRpb25zLnNpbmdsZXRvbikge1xuXHRcdHZhciBzdHlsZUluZGV4ID0gc2luZ2xldG9uQ291bnRlcisrO1xuXG5cdFx0c3R5bGUgPSBzaW5nbGV0b24gfHwgKHNpbmdsZXRvbiA9IGNyZWF0ZVN0eWxlRWxlbWVudChvcHRpb25zKSk7XG5cblx0XHR1cGRhdGUgPSBhcHBseVRvU2luZ2xldG9uVGFnLmJpbmQobnVsbCwgc3R5bGUsIHN0eWxlSW5kZXgsIGZhbHNlKTtcblx0XHRyZW1vdmUgPSBhcHBseVRvU2luZ2xldG9uVGFnLmJpbmQobnVsbCwgc3R5bGUsIHN0eWxlSW5kZXgsIHRydWUpO1xuXG5cdH0gZWxzZSBpZiAoXG5cdFx0b2JqLnNvdXJjZU1hcCAmJlxuXHRcdHR5cGVvZiBVUkwgPT09IFwiZnVuY3Rpb25cIiAmJlxuXHRcdHR5cGVvZiBVUkwuY3JlYXRlT2JqZWN0VVJMID09PSBcImZ1bmN0aW9uXCIgJiZcblx0XHR0eXBlb2YgVVJMLnJldm9rZU9iamVjdFVSTCA9PT0gXCJmdW5jdGlvblwiICYmXG5cdFx0dHlwZW9mIEJsb2IgPT09IFwiZnVuY3Rpb25cIiAmJlxuXHRcdHR5cGVvZiBidG9hID09PSBcImZ1bmN0aW9uXCJcblx0KSB7XG5cdFx0c3R5bGUgPSBjcmVhdGVMaW5rRWxlbWVudChvcHRpb25zKTtcblx0XHR1cGRhdGUgPSB1cGRhdGVMaW5rLmJpbmQobnVsbCwgc3R5bGUsIG9wdGlvbnMpO1xuXHRcdHJlbW92ZSA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdHJlbW92ZVN0eWxlRWxlbWVudChzdHlsZSk7XG5cblx0XHRcdGlmKHN0eWxlLmhyZWYpIFVSTC5yZXZva2VPYmplY3RVUkwoc3R5bGUuaHJlZik7XG5cdFx0fTtcblx0fSBlbHNlIHtcblx0XHRzdHlsZSA9IGNyZWF0ZVN0eWxlRWxlbWVudChvcHRpb25zKTtcblx0XHR1cGRhdGUgPSBhcHBseVRvVGFnLmJpbmQobnVsbCwgc3R5bGUpO1xuXHRcdHJlbW92ZSA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdHJlbW92ZVN0eWxlRWxlbWVudChzdHlsZSk7XG5cdFx0fTtcblx0fVxuXG5cdHVwZGF0ZShvYmopO1xuXG5cdHJldHVybiBmdW5jdGlvbiB1cGRhdGVTdHlsZSAobmV3T2JqKSB7XG5cdFx0aWYgKG5ld09iaikge1xuXHRcdFx0aWYgKFxuXHRcdFx0XHRuZXdPYmouY3NzID09PSBvYmouY3NzICYmXG5cdFx0XHRcdG5ld09iai5tZWRpYSA9PT0gb2JqLm1lZGlhICYmXG5cdFx0XHRcdG5ld09iai5zb3VyY2VNYXAgPT09IG9iai5zb3VyY2VNYXBcblx0XHRcdCkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdHVwZGF0ZShvYmogPSBuZXdPYmopO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZW1vdmUoKTtcblx0XHR9XG5cdH07XG59XG5cbnZhciByZXBsYWNlVGV4dCA9IChmdW5jdGlvbiAoKSB7XG5cdHZhciB0ZXh0U3RvcmUgPSBbXTtcblxuXHRyZXR1cm4gZnVuY3Rpb24gKGluZGV4LCByZXBsYWNlbWVudCkge1xuXHRcdHRleHRTdG9yZVtpbmRleF0gPSByZXBsYWNlbWVudDtcblxuXHRcdHJldHVybiB0ZXh0U3RvcmUuZmlsdGVyKEJvb2xlYW4pLmpvaW4oJ1xcbicpO1xuXHR9O1xufSkoKTtcblxuZnVuY3Rpb24gYXBwbHlUb1NpbmdsZXRvblRhZyAoc3R5bGUsIGluZGV4LCByZW1vdmUsIG9iaikge1xuXHR2YXIgY3NzID0gcmVtb3ZlID8gXCJcIiA6IG9iai5jc3M7XG5cblx0aWYgKHN0eWxlLnN0eWxlU2hlZXQpIHtcblx0XHRzdHlsZS5zdHlsZVNoZWV0LmNzc1RleHQgPSByZXBsYWNlVGV4dChpbmRleCwgY3NzKTtcblx0fSBlbHNlIHtcblx0XHR2YXIgY3NzTm9kZSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNzcyk7XG5cdFx0dmFyIGNoaWxkTm9kZXMgPSBzdHlsZS5jaGlsZE5vZGVzO1xuXG5cdFx0aWYgKGNoaWxkTm9kZXNbaW5kZXhdKSBzdHlsZS5yZW1vdmVDaGlsZChjaGlsZE5vZGVzW2luZGV4XSk7XG5cblx0XHRpZiAoY2hpbGROb2Rlcy5sZW5ndGgpIHtcblx0XHRcdHN0eWxlLmluc2VydEJlZm9yZShjc3NOb2RlLCBjaGlsZE5vZGVzW2luZGV4XSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHN0eWxlLmFwcGVuZENoaWxkKGNzc05vZGUpO1xuXHRcdH1cblx0fVxufVxuXG5mdW5jdGlvbiBhcHBseVRvVGFnIChzdHlsZSwgb2JqKSB7XG5cdHZhciBjc3MgPSBvYmouY3NzO1xuXHR2YXIgbWVkaWEgPSBvYmoubWVkaWE7XG5cblx0aWYobWVkaWEpIHtcblx0XHRzdHlsZS5zZXRBdHRyaWJ1dGUoXCJtZWRpYVwiLCBtZWRpYSlcblx0fVxuXG5cdGlmKHN0eWxlLnN0eWxlU2hlZXQpIHtcblx0XHRzdHlsZS5zdHlsZVNoZWV0LmNzc1RleHQgPSBjc3M7XG5cdH0gZWxzZSB7XG5cdFx0d2hpbGUoc3R5bGUuZmlyc3RDaGlsZCkge1xuXHRcdFx0c3R5bGUucmVtb3ZlQ2hpbGQoc3R5bGUuZmlyc3RDaGlsZCk7XG5cdFx0fVxuXG5cdFx0c3R5bGUuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY3NzKSk7XG5cdH1cbn1cblxuZnVuY3Rpb24gdXBkYXRlTGluayAobGluaywgb3B0aW9ucywgb2JqKSB7XG5cdHZhciBjc3MgPSBvYmouY3NzO1xuXHR2YXIgc291cmNlTWFwID0gb2JqLnNvdXJjZU1hcDtcblxuXHQvKlxuXHRcdElmIGNvbnZlcnRUb0Fic29sdXRlVXJscyBpc24ndCBkZWZpbmVkLCBidXQgc291cmNlbWFwcyBhcmUgZW5hYmxlZFxuXHRcdGFuZCB0aGVyZSBpcyBubyBwdWJsaWNQYXRoIGRlZmluZWQgdGhlbiBsZXRzIHR1cm4gY29udmVydFRvQWJzb2x1dGVVcmxzXG5cdFx0b24gYnkgZGVmYXVsdC4gIE90aGVyd2lzZSBkZWZhdWx0IHRvIHRoZSBjb252ZXJ0VG9BYnNvbHV0ZVVybHMgb3B0aW9uXG5cdFx0ZGlyZWN0bHlcblx0Ki9cblx0dmFyIGF1dG9GaXhVcmxzID0gb3B0aW9ucy5jb252ZXJ0VG9BYnNvbHV0ZVVybHMgPT09IHVuZGVmaW5lZCAmJiBzb3VyY2VNYXA7XG5cblx0aWYgKG9wdGlvbnMuY29udmVydFRvQWJzb2x1dGVVcmxzIHx8IGF1dG9GaXhVcmxzKSB7XG5cdFx0Y3NzID0gZml4VXJscyhjc3MpO1xuXHR9XG5cblx0aWYgKHNvdXJjZU1hcCkge1xuXHRcdC8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzI2NjAzODc1XG5cdFx0Y3NzICs9IFwiXFxuLyojIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCxcIiArIGJ0b2EodW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KEpTT04uc3RyaW5naWZ5KHNvdXJjZU1hcCkpKSkgKyBcIiAqL1wiO1xuXHR9XG5cblx0dmFyIGJsb2IgPSBuZXcgQmxvYihbY3NzXSwgeyB0eXBlOiBcInRleHQvY3NzXCIgfSk7XG5cblx0dmFyIG9sZFNyYyA9IGxpbmsuaHJlZjtcblxuXHRsaW5rLmhyZWYgPSBVUkwuY3JlYXRlT2JqZWN0VVJMKGJsb2IpO1xuXG5cdGlmKG9sZFNyYykgVVJMLnJldm9rZU9iamVjdFVSTChvbGRTcmMpO1xufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L21vY2hhLWxvYWRlci9+L3N0eWxlLWxvYWRlci9saWIvYWRkU3R5bGVzLmpzXG4vLyBtb2R1bGUgaWQgPSAxMFxuLy8gbW9kdWxlIGNodW5rcyA9IDEiLCJcbi8qKlxuICogV2hlbiBzb3VyY2UgbWFwcyBhcmUgZW5hYmxlZCwgYHN0eWxlLWxvYWRlcmAgdXNlcyBhIGxpbmsgZWxlbWVudCB3aXRoIGEgZGF0YS11cmkgdG9cbiAqIGVtYmVkIHRoZSBjc3Mgb24gdGhlIHBhZ2UuIFRoaXMgYnJlYWtzIGFsbCByZWxhdGl2ZSB1cmxzIGJlY2F1c2Ugbm93IHRoZXkgYXJlIHJlbGF0aXZlIHRvIGFcbiAqIGJ1bmRsZSBpbnN0ZWFkIG9mIHRoZSBjdXJyZW50IHBhZ2UuXG4gKlxuICogT25lIHNvbHV0aW9uIGlzIHRvIG9ubHkgdXNlIGZ1bGwgdXJscywgYnV0IHRoYXQgbWF5IGJlIGltcG9zc2libGUuXG4gKlxuICogSW5zdGVhZCwgdGhpcyBmdW5jdGlvbiBcImZpeGVzXCIgdGhlIHJlbGF0aXZlIHVybHMgdG8gYmUgYWJzb2x1dGUgYWNjb3JkaW5nIHRvIHRoZSBjdXJyZW50IHBhZ2UgbG9jYXRpb24uXG4gKlxuICogQSBydWRpbWVudGFyeSB0ZXN0IHN1aXRlIGlzIGxvY2F0ZWQgYXQgYHRlc3QvZml4VXJscy5qc2AgYW5kIGNhbiBiZSBydW4gdmlhIHRoZSBgbnBtIHRlc3RgIGNvbW1hbmQuXG4gKlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGNzcykge1xuICAvLyBnZXQgY3VycmVudCBsb2NhdGlvblxuICB2YXIgbG9jYXRpb24gPSB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIHdpbmRvdy5sb2NhdGlvbjtcblxuICBpZiAoIWxvY2F0aW9uKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiZml4VXJscyByZXF1aXJlcyB3aW5kb3cubG9jYXRpb25cIik7XG4gIH1cblxuXHQvLyBibGFuayBvciBudWxsP1xuXHRpZiAoIWNzcyB8fCB0eXBlb2YgY3NzICE9PSBcInN0cmluZ1wiKSB7XG5cdCAgcmV0dXJuIGNzcztcbiAgfVxuXG4gIHZhciBiYXNlVXJsID0gbG9jYXRpb24ucHJvdG9jb2wgKyBcIi8vXCIgKyBsb2NhdGlvbi5ob3N0O1xuICB2YXIgY3VycmVudERpciA9IGJhc2VVcmwgKyBsb2NhdGlvbi5wYXRobmFtZS5yZXBsYWNlKC9cXC9bXlxcL10qJC8sIFwiL1wiKTtcblxuXHQvLyBjb252ZXJ0IGVhY2ggdXJsKC4uLilcblx0Lypcblx0VGhpcyByZWd1bGFyIGV4cHJlc3Npb24gaXMganVzdCBhIHdheSB0byByZWN1cnNpdmVseSBtYXRjaCBicmFja2V0cyB3aXRoaW5cblx0YSBzdHJpbmcuXG5cblx0IC91cmxcXHMqXFwoICA9IE1hdGNoIG9uIHRoZSB3b3JkIFwidXJsXCIgd2l0aCBhbnkgd2hpdGVzcGFjZSBhZnRlciBpdCBhbmQgdGhlbiBhIHBhcmVuc1xuXHQgICAoICA9IFN0YXJ0IGEgY2FwdHVyaW5nIGdyb3VwXG5cdCAgICAgKD86ICA9IFN0YXJ0IGEgbm9uLWNhcHR1cmluZyBncm91cFxuXHQgICAgICAgICBbXikoXSAgPSBNYXRjaCBhbnl0aGluZyB0aGF0IGlzbid0IGEgcGFyZW50aGVzZXNcblx0ICAgICAgICAgfCAgPSBPUlxuXHQgICAgICAgICBcXCggID0gTWF0Y2ggYSBzdGFydCBwYXJlbnRoZXNlc1xuXHQgICAgICAgICAgICAgKD86ICA9IFN0YXJ0IGFub3RoZXIgbm9uLWNhcHR1cmluZyBncm91cHNcblx0ICAgICAgICAgICAgICAgICBbXikoXSsgID0gTWF0Y2ggYW55dGhpbmcgdGhhdCBpc24ndCBhIHBhcmVudGhlc2VzXG5cdCAgICAgICAgICAgICAgICAgfCAgPSBPUlxuXHQgICAgICAgICAgICAgICAgIFxcKCAgPSBNYXRjaCBhIHN0YXJ0IHBhcmVudGhlc2VzXG5cdCAgICAgICAgICAgICAgICAgICAgIFteKShdKiAgPSBNYXRjaCBhbnl0aGluZyB0aGF0IGlzbid0IGEgcGFyZW50aGVzZXNcblx0ICAgICAgICAgICAgICAgICBcXCkgID0gTWF0Y2ggYSBlbmQgcGFyZW50aGVzZXNcblx0ICAgICAgICAgICAgICkgID0gRW5kIEdyb3VwXG4gICAgICAgICAgICAgICpcXCkgPSBNYXRjaCBhbnl0aGluZyBhbmQgdGhlbiBhIGNsb3NlIHBhcmVuc1xuICAgICAgICAgICkgID0gQ2xvc2Ugbm9uLWNhcHR1cmluZyBncm91cFxuICAgICAgICAgICogID0gTWF0Y2ggYW55dGhpbmdcbiAgICAgICApICA9IENsb3NlIGNhcHR1cmluZyBncm91cFxuXHQgXFwpICA9IE1hdGNoIGEgY2xvc2UgcGFyZW5zXG5cblx0IC9naSAgPSBHZXQgYWxsIG1hdGNoZXMsIG5vdCB0aGUgZmlyc3QuICBCZSBjYXNlIGluc2Vuc2l0aXZlLlxuXHQgKi9cblx0dmFyIGZpeGVkQ3NzID0gY3NzLnJlcGxhY2UoL3VybFxccypcXCgoKD86W14pKF18XFwoKD86W14pKF0rfFxcKFteKShdKlxcKSkqXFwpKSopXFwpL2dpLCBmdW5jdGlvbihmdWxsTWF0Y2gsIG9yaWdVcmwpIHtcblx0XHQvLyBzdHJpcCBxdW90ZXMgKGlmIHRoZXkgZXhpc3QpXG5cdFx0dmFyIHVucXVvdGVkT3JpZ1VybCA9IG9yaWdVcmxcblx0XHRcdC50cmltKClcblx0XHRcdC5yZXBsYWNlKC9eXCIoLiopXCIkLywgZnVuY3Rpb24obywgJDEpeyByZXR1cm4gJDE7IH0pXG5cdFx0XHQucmVwbGFjZSgvXicoLiopJyQvLCBmdW5jdGlvbihvLCAkMSl7IHJldHVybiAkMTsgfSk7XG5cblx0XHQvLyBhbHJlYWR5IGEgZnVsbCB1cmw/IG5vIGNoYW5nZVxuXHRcdGlmICgvXigjfGRhdGE6fGh0dHA6XFwvXFwvfGh0dHBzOlxcL1xcL3xmaWxlOlxcL1xcL1xcLykvaS50ZXN0KHVucXVvdGVkT3JpZ1VybCkpIHtcblx0XHQgIHJldHVybiBmdWxsTWF0Y2g7XG5cdFx0fVxuXG5cdFx0Ly8gY29udmVydCB0aGUgdXJsIHRvIGEgZnVsbCB1cmxcblx0XHR2YXIgbmV3VXJsO1xuXG5cdFx0aWYgKHVucXVvdGVkT3JpZ1VybC5pbmRleE9mKFwiLy9cIikgPT09IDApIHtcblx0XHQgIFx0Ly9UT0RPOiBzaG91bGQgd2UgYWRkIHByb3RvY29sP1xuXHRcdFx0bmV3VXJsID0gdW5xdW90ZWRPcmlnVXJsO1xuXHRcdH0gZWxzZSBpZiAodW5xdW90ZWRPcmlnVXJsLmluZGV4T2YoXCIvXCIpID09PSAwKSB7XG5cdFx0XHQvLyBwYXRoIHNob3VsZCBiZSByZWxhdGl2ZSB0byB0aGUgYmFzZSB1cmxcblx0XHRcdG5ld1VybCA9IGJhc2VVcmwgKyB1bnF1b3RlZE9yaWdVcmw7IC8vIGFscmVhZHkgc3RhcnRzIHdpdGggJy8nXG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIHBhdGggc2hvdWxkIGJlIHJlbGF0aXZlIHRvIGN1cnJlbnQgZGlyZWN0b3J5XG5cdFx0XHRuZXdVcmwgPSBjdXJyZW50RGlyICsgdW5xdW90ZWRPcmlnVXJsLnJlcGxhY2UoL15cXC5cXC8vLCBcIlwiKTsgLy8gU3RyaXAgbGVhZGluZyAnLi8nXG5cdFx0fVxuXG5cdFx0Ly8gc2VuZCBiYWNrIHRoZSBmaXhlZCB1cmwoLi4uKVxuXHRcdHJldHVybiBcInVybChcIiArIEpTT04uc3RyaW5naWZ5KG5ld1VybCkgKyBcIilcIjtcblx0fSk7XG5cblx0Ly8gc2VuZCBiYWNrIHRoZSBmaXhlZCBjc3Ncblx0cmV0dXJuIGZpeGVkQ3NzO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9tb2NoYS1sb2FkZXIvfi9zdHlsZS1sb2FkZXIvbGliL3VybHMuanNcbi8vIG1vZHVsZSBpZCA9IDExXG4vLyBtb2R1bGUgY2h1bmtzID0gMSIsInJlcXVpcmUoXCIhIS9Vc2Vycy9zYWJyaW5hbWFlL0Rlc2t0b3AvdHVyaW5nL21vZHVsZS0yL2dhbWUtdGltZS9ub2RlX21vZHVsZXMvc2NyaXB0LWxvYWRlci9hZGRTY3JpcHQuanNcIikocmVxdWlyZShcIiEhL1VzZXJzL3NhYnJpbmFtYWUvRGVza3RvcC90dXJpbmcvbW9kdWxlLTIvZ2FtZS10aW1lL25vZGVfbW9kdWxlcy9yYXctbG9hZGVyL2luZGV4LmpzIS9Vc2Vycy9zYWJyaW5hbWFlL0Rlc2t0b3AvdHVyaW5nL21vZHVsZS0yL2dhbWUtdGltZS9ub2RlX21vZHVsZXMvbW9jaGEvbW9jaGEuanNcIikpXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3NjcmlwdC1sb2FkZXIhLi9+L21vY2hhL21vY2hhLmpzXG4vLyBtb2R1bGUgaWQgPSAxMlxuLy8gbW9kdWxlIGNodW5rcyA9IDEiLCIvKlxuXHRNSVQgTGljZW5zZSBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxuXHRBdXRob3IgVG9iaWFzIEtvcHBlcnMgQHNva3JhXG4qL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihzcmMpIHtcblx0ZnVuY3Rpb24gbG9nKGVycm9yKSB7XG5cdFx0KHR5cGVvZiBjb25zb2xlICE9PSBcInVuZGVmaW5lZFwiKVxuXHRcdCYmIChjb25zb2xlLmVycm9yIHx8IGNvbnNvbGUubG9nKShcIltTY3JpcHQgTG9hZGVyXVwiLCBlcnJvcik7XG5cdH1cblxuXHQvLyBDaGVjayBmb3IgSUUgPTwgOFxuXHRmdW5jdGlvbiBpc0lFKCkge1xuXHRcdHJldHVybiB0eXBlb2YgYXR0YWNoRXZlbnQgIT09IFwidW5kZWZpbmVkXCIgJiYgdHlwZW9mIGFkZEV2ZW50TGlzdGVuZXIgPT09IFwidW5kZWZpbmVkXCI7XG5cdH1cblxuXHR0cnkge1xuXHRcdGlmICh0eXBlb2YgZXhlY1NjcmlwdCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBpc0lFKCkpIHtcblx0XHRcdGV4ZWNTY3JpcHQoc3JjKTtcblx0XHR9IGVsc2UgaWYgKHR5cGVvZiBldmFsICE9PSBcInVuZGVmaW5lZFwiKSB7XG5cdFx0XHRldmFsLmNhbGwobnVsbCwgc3JjKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0bG9nKFwiRXZhbEVycm9yOiBObyBldmFsIGZ1bmN0aW9uIGF2YWlsYWJsZVwiKTtcblx0XHR9XG5cdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0bG9nKGVycm9yKTtcblx0fVxufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3NjcmlwdC1sb2FkZXIvYWRkU2NyaXB0LmpzXG4vLyBtb2R1bGUgaWQgPSAxM1xuLy8gbW9kdWxlIGNodW5rcyA9IDEiLCJtb2R1bGUuZXhwb3J0cyA9IFwiKGZ1bmN0aW9uIGUodCxuLHIpe2Z1bmN0aW9uIHMobyx1KXtpZighbltvXSl7aWYoIXRbb10pe3ZhciBhPXR5cGVvZiByZXF1aXJlPT1cXFwiZnVuY3Rpb25cXFwiJiZyZXF1aXJlO2lmKCF1JiZhKXJldHVybiBhKG8sITApO2lmKGkpcmV0dXJuIGkobywhMCk7dmFyIGY9bmV3IEVycm9yKFxcXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1xcXCIrbytcXFwiJ1xcXCIpO3Rocm93IGYuY29kZT1cXFwiTU9EVUxFX05PVF9GT1VORFxcXCIsZn12YXIgbD1uW29dPXtleHBvcnRzOnt9fTt0W29dWzBdLmNhbGwobC5leHBvcnRzLGZ1bmN0aW9uKGUpe3ZhciBuPXRbb11bMV1bZV07cmV0dXJuIHMobj9uOmUpfSxsLGwuZXhwb3J0cyxlLHQsbixyKX1yZXR1cm4gbltvXS5leHBvcnRzfXZhciBpPXR5cGVvZiByZXF1aXJlPT1cXFwiZnVuY3Rpb25cXFwiJiZyZXF1aXJlO2Zvcih2YXIgbz0wO288ci5sZW5ndGg7bysrKXMocltvXSk7cmV0dXJuIHN9KSh7MTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XFxuKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCl7XFxuJ3VzZSBzdHJpY3QnO1xcblxcbi8qIGVzbGludCBuby11bnVzZWQtdmFyczogb2ZmICovXFxuLyogZXNsaW50LWVudiBjb21tb25qcyAqL1xcblxcbi8qKlxcbiAqIFNoaW0gcHJvY2Vzcy5zdGRvdXQuXFxuICovXFxuXFxucHJvY2Vzcy5zdGRvdXQgPSByZXF1aXJlKCdicm93c2VyLXN0ZG91dCcpKCk7XFxuXFxudmFyIE1vY2hhID0gcmVxdWlyZSgnLi9saWIvbW9jaGEnKTtcXG5cXG4vKipcXG4gKiBDcmVhdGUgYSBNb2NoYSBpbnN0YW5jZS5cXG4gKlxcbiAqIEByZXR1cm4ge3VuZGVmaW5lZH1cXG4gKi9cXG5cXG52YXIgbW9jaGEgPSBuZXcgTW9jaGEoeyByZXBvcnRlcjogJ2h0bWwnIH0pO1xcblxcbi8qKlxcbiAqIFNhdmUgdGltZXIgcmVmZXJlbmNlcyB0byBhdm9pZCBTaW5vbiBpbnRlcmZlcmluZyAoc2VlIEdILTIzNykuXFxuICovXFxuXFxudmFyIERhdGUgPSBnbG9iYWwuRGF0ZTtcXG52YXIgc2V0VGltZW91dCA9IGdsb2JhbC5zZXRUaW1lb3V0O1xcbnZhciBzZXRJbnRlcnZhbCA9IGdsb2JhbC5zZXRJbnRlcnZhbDtcXG52YXIgY2xlYXJUaW1lb3V0ID0gZ2xvYmFsLmNsZWFyVGltZW91dDtcXG52YXIgY2xlYXJJbnRlcnZhbCA9IGdsb2JhbC5jbGVhckludGVydmFsO1xcblxcbnZhciB1bmNhdWdodEV4Y2VwdGlvbkhhbmRsZXJzID0gW107XFxuXFxudmFyIG9yaWdpbmFsT25lcnJvckhhbmRsZXIgPSBnbG9iYWwub25lcnJvcjtcXG5cXG4vKipcXG4gKiBSZW1vdmUgdW5jYXVnaHRFeGNlcHRpb24gbGlzdGVuZXIuXFxuICogUmV2ZXJ0IHRvIG9yaWdpbmFsIG9uZXJyb3IgaGFuZGxlciBpZiBwcmV2aW91c2x5IGRlZmluZWQuXFxuICovXFxuXFxucHJvY2Vzcy5yZW1vdmVMaXN0ZW5lciA9IGZ1bmN0aW9uIChlLCBmbikge1xcbiAgaWYgKGUgPT09ICd1bmNhdWdodEV4Y2VwdGlvbicpIHtcXG4gICAgaWYgKG9yaWdpbmFsT25lcnJvckhhbmRsZXIpIHtcXG4gICAgICBnbG9iYWwub25lcnJvciA9IG9yaWdpbmFsT25lcnJvckhhbmRsZXI7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgZ2xvYmFsLm9uZXJyb3IgPSBmdW5jdGlvbiAoKSB7fTtcXG4gICAgfVxcbiAgICB2YXIgaSA9IE1vY2hhLnV0aWxzLmluZGV4T2YodW5jYXVnaHRFeGNlcHRpb25IYW5kbGVycywgZm4pO1xcbiAgICBpZiAoaSAhPT0gLTEpIHtcXG4gICAgICB1bmNhdWdodEV4Y2VwdGlvbkhhbmRsZXJzLnNwbGljZShpLCAxKTtcXG4gICAgfVxcbiAgfVxcbn07XFxuXFxuLyoqXFxuICogSW1wbGVtZW50cyB1bmNhdWdodEV4Y2VwdGlvbiBsaXN0ZW5lci5cXG4gKi9cXG5cXG5wcm9jZXNzLm9uID0gZnVuY3Rpb24gKGUsIGZuKSB7XFxuICBpZiAoZSA9PT0gJ3VuY2F1Z2h0RXhjZXB0aW9uJykge1xcbiAgICBnbG9iYWwub25lcnJvciA9IGZ1bmN0aW9uIChlcnIsIHVybCwgbGluZSkge1xcbiAgICAgIGZuKG5ldyBFcnJvcihlcnIgKyAnICgnICsgdXJsICsgJzonICsgbGluZSArICcpJykpO1xcbiAgICAgIHJldHVybiAhbW9jaGEuYWxsb3dVbmNhdWdodDtcXG4gICAgfTtcXG4gICAgdW5jYXVnaHRFeGNlcHRpb25IYW5kbGVycy5wdXNoKGZuKTtcXG4gIH1cXG59O1xcblxcbi8vIFRoZSBCREQgVUkgaXMgcmVnaXN0ZXJlZCBieSBkZWZhdWx0LCBidXQgbm8gVUkgd2lsbCBiZSBmdW5jdGlvbmFsIGluIHRoZVxcbi8vIGJyb3dzZXIgd2l0aG91dCBhbiBleHBsaWNpdCBjYWxsIHRvIHRoZSBvdmVycmlkZGVuIGBtb2NoYS51aWAgKHNlZSBiZWxvdykuXFxuLy8gRW5zdXJlIHRoYXQgdGhpcyBkZWZhdWx0IFVJIGRvZXMgbm90IGV4cG9zZSBpdHMgbWV0aG9kcyB0byB0aGUgZ2xvYmFsIHNjb3BlLlxcbm1vY2hhLnN1aXRlLnJlbW92ZUFsbExpc3RlbmVycygncHJlLXJlcXVpcmUnKTtcXG5cXG52YXIgaW1tZWRpYXRlUXVldWUgPSBbXTtcXG52YXIgaW1tZWRpYXRlVGltZW91dDtcXG5cXG5mdW5jdGlvbiB0aW1lc2xpY2UgKCkge1xcbiAgdmFyIGltbWVkaWF0ZVN0YXJ0ID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XFxuICB3aGlsZSAoaW1tZWRpYXRlUXVldWUubGVuZ3RoICYmIChuZXcgRGF0ZSgpLmdldFRpbWUoKSAtIGltbWVkaWF0ZVN0YXJ0KSA8IDEwMCkge1xcbiAgICBpbW1lZGlhdGVRdWV1ZS5zaGlmdCgpKCk7XFxuICB9XFxuICBpZiAoaW1tZWRpYXRlUXVldWUubGVuZ3RoKSB7XFxuICAgIGltbWVkaWF0ZVRpbWVvdXQgPSBzZXRUaW1lb3V0KHRpbWVzbGljZSwgMCk7XFxuICB9IGVsc2Uge1xcbiAgICBpbW1lZGlhdGVUaW1lb3V0ID0gbnVsbDtcXG4gIH1cXG59XFxuXFxuLyoqXFxuICogSGlnaC1wZXJmb3JtYW5jZSBvdmVycmlkZSBvZiBSdW5uZXIuaW1tZWRpYXRlbHkuXFxuICovXFxuXFxuTW9jaGEuUnVubmVyLmltbWVkaWF0ZWx5ID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XFxuICBpbW1lZGlhdGVRdWV1ZS5wdXNoKGNhbGxiYWNrKTtcXG4gIGlmICghaW1tZWRpYXRlVGltZW91dCkge1xcbiAgICBpbW1lZGlhdGVUaW1lb3V0ID0gc2V0VGltZW91dCh0aW1lc2xpY2UsIDApO1xcbiAgfVxcbn07XFxuXFxuLyoqXFxuICogRnVuY3Rpb24gdG8gYWxsb3cgYXNzZXJ0aW9uIGxpYnJhcmllcyB0byB0aHJvdyBlcnJvcnMgZGlyZWN0bHkgaW50byBtb2NoYS5cXG4gKiBUaGlzIGlzIHVzZWZ1bCB3aGVuIHJ1bm5pbmcgdGVzdHMgaW4gYSBicm93c2VyIGJlY2F1c2Ugd2luZG93Lm9uZXJyb3Igd2lsbFxcbiAqIG9ubHkgcmVjZWl2ZSB0aGUgJ21lc3NhZ2UnIGF0dHJpYnV0ZSBvZiB0aGUgRXJyb3IuXFxuICovXFxubW9jaGEudGhyb3dFcnJvciA9IGZ1bmN0aW9uIChlcnIpIHtcXG4gIE1vY2hhLnV0aWxzLmZvckVhY2godW5jYXVnaHRFeGNlcHRpb25IYW5kbGVycywgZnVuY3Rpb24gKGZuKSB7XFxuICAgIGZuKGVycik7XFxuICB9KTtcXG4gIHRocm93IGVycjtcXG59O1xcblxcbi8qKlxcbiAqIE92ZXJyaWRlIHVpIHRvIGVuc3VyZSB0aGF0IHRoZSB1aSBmdW5jdGlvbnMgYXJlIGluaXRpYWxpemVkLlxcbiAqIE5vcm1hbGx5IHRoaXMgd291bGQgaGFwcGVuIGluIE1vY2hhLnByb3RvdHlwZS5sb2FkRmlsZXMuXFxuICovXFxuXFxubW9jaGEudWkgPSBmdW5jdGlvbiAodWkpIHtcXG4gIE1vY2hhLnByb3RvdHlwZS51aS5jYWxsKHRoaXMsIHVpKTtcXG4gIHRoaXMuc3VpdGUuZW1pdCgncHJlLXJlcXVpcmUnLCBnbG9iYWwsIG51bGwsIHRoaXMpO1xcbiAgcmV0dXJuIHRoaXM7XFxufTtcXG5cXG4vKipcXG4gKiBTZXR1cCBtb2NoYSB3aXRoIHRoZSBnaXZlbiBzZXR0aW5nIG9wdGlvbnMuXFxuICovXFxuXFxubW9jaGEuc2V0dXAgPSBmdW5jdGlvbiAob3B0cykge1xcbiAgaWYgKHR5cGVvZiBvcHRzID09PSAnc3RyaW5nJykge1xcbiAgICBvcHRzID0geyB1aTogb3B0cyB9O1xcbiAgfVxcbiAgZm9yICh2YXIgb3B0IGluIG9wdHMpIHtcXG4gICAgaWYgKG9wdHMuaGFzT3duUHJvcGVydHkob3B0KSkge1xcbiAgICAgIHRoaXNbb3B0XShvcHRzW29wdF0pO1xcbiAgICB9XFxuICB9XFxuICByZXR1cm4gdGhpcztcXG59O1xcblxcbi8qKlxcbiAqIFJ1biBtb2NoYSwgcmV0dXJuaW5nIHRoZSBSdW5uZXIuXFxuICovXFxuXFxubW9jaGEucnVuID0gZnVuY3Rpb24gKGZuKSB7XFxuICB2YXIgb3B0aW9ucyA9IG1vY2hhLm9wdGlvbnM7XFxuICBtb2NoYS5nbG9iYWxzKCdsb2NhdGlvbicpO1xcblxcbiAgdmFyIHF1ZXJ5ID0gTW9jaGEudXRpbHMucGFyc2VRdWVyeShnbG9iYWwubG9jYXRpb24uc2VhcmNoIHx8ICcnKTtcXG4gIGlmIChxdWVyeS5ncmVwKSB7XFxuICAgIG1vY2hhLmdyZXAocXVlcnkuZ3JlcCk7XFxuICB9XFxuICBpZiAocXVlcnkuZmdyZXApIHtcXG4gICAgbW9jaGEuZmdyZXAocXVlcnkuZmdyZXApO1xcbiAgfVxcbiAgaWYgKHF1ZXJ5LmludmVydCkge1xcbiAgICBtb2NoYS5pbnZlcnQoKTtcXG4gIH1cXG5cXG4gIHJldHVybiBNb2NoYS5wcm90b3R5cGUucnVuLmNhbGwobW9jaGEsIGZ1bmN0aW9uIChlcnIpIHtcXG4gICAgLy8gVGhlIERPTSBEb2N1bWVudCBpcyBub3QgYXZhaWxhYmxlIGluIFdlYiBXb3JrZXJzLlxcbiAgICB2YXIgZG9jdW1lbnQgPSBnbG9iYWwuZG9jdW1lbnQ7XFxuICAgIGlmIChkb2N1bWVudCAmJiBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnbW9jaGEnKSAmJiBvcHRpb25zLm5vSGlnaGxpZ2h0aW5nICE9PSB0cnVlKSB7XFxuICAgICAgTW9jaGEudXRpbHMuaGlnaGxpZ2h0VGFncygnY29kZScpO1xcbiAgICB9XFxuICAgIGlmIChmbikge1xcbiAgICAgIGZuKGVycik7XFxuICAgIH1cXG4gIH0pO1xcbn07XFxuXFxuLyoqXFxuICogRXhwb3NlIHRoZSBwcm9jZXNzIHNoaW0uXFxuICogaHR0cHM6Ly9naXRodWIuY29tL21vY2hhanMvbW9jaGEvcHVsbC85MTZcXG4gKi9cXG5cXG5Nb2NoYS5wcm9jZXNzID0gcHJvY2VzcztcXG5cXG4vKipcXG4gKiBFeHBvc2UgbW9jaGEuXFxuICovXFxuXFxuZ2xvYmFsLk1vY2hhID0gTW9jaGE7XFxuZ2xvYmFsLm1vY2hhID0gbW9jaGE7XFxuXFxuLy8gdGhpcyBhbGxvd3MgdGVzdC9hY2NlcHRhbmNlL3JlcXVpcmVkLXRva2Vucy5qcyB0byBwYXNzOyB0aHVzLFxcbi8vIHlvdSBjYW4gbm93IGRvIGBjb25zdCBkZXNjcmliZSA9IHJlcXVpcmUoJ21vY2hhJykuZGVzY3JpYmVgIGluIGFcXG4vLyBicm93c2VyIGNvbnRleHQgKGFzc3VtaW5nIGJyb3dzZXJpZmljYXRpb24pLiAgc2hvdWxkIGZpeCAjODgwXFxubW9kdWxlLmV4cG9ydHMgPSBnbG9iYWw7XFxuXFxufSkuY2FsbCh0aGlzLHJlcXVpcmUoJ19wcm9jZXNzJyksdHlwZW9mIGdsb2JhbCAhPT0gXFxcInVuZGVmaW5lZFxcXCIgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gXFxcInVuZGVmaW5lZFxcXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXFxcInVuZGVmaW5lZFxcXCIgPyB3aW5kb3cgOiB7fSlcXG59LHtcXFwiLi9saWIvbW9jaGFcXFwiOjE0LFxcXCJfcHJvY2Vzc1xcXCI6ODIsXFxcImJyb3dzZXItc3Rkb3V0XFxcIjo0MX1dLDI6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xcbid1c2Ugc3RyaWN0JztcXG5cXG5mdW5jdGlvbiBub29wICgpIHt9XFxuXFxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoKSB7XFxuICByZXR1cm4gbm9vcDtcXG59O1xcblxcbn0se31dLDM6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xcbid1c2Ugc3RyaWN0JztcXG5cXG4vKipcXG4gKiBNb2R1bGUgZXhwb3J0cy5cXG4gKi9cXG5cXG5leHBvcnRzLkV2ZW50RW1pdHRlciA9IEV2ZW50RW1pdHRlcjtcXG5cXG4vKipcXG4gKiBPYmplY3QjdG9TdHJpbmcgcmVmZXJlbmNlLlxcbiAqL1xcbnZhciBvYmpUb1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XFxuXFxuLyoqXFxuICogQ2hlY2sgaWYgYSB2YWx1ZSBpcyBhbiBhcnJheS5cXG4gKlxcbiAqIEBhcGkgcHJpdmF0ZVxcbiAqIEBwYXJhbSB7Kn0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0LlxcbiAqIEByZXR1cm4ge2Jvb2xlYW59IHRydWUgaWYgdGhlIHZhbHVlIGlzIGFuIGFycmF5LCBvdGhlcndpc2UgZmFsc2UuXFxuICovXFxuZnVuY3Rpb24gaXNBcnJheSAodmFsKSB7XFxuICByZXR1cm4gb2JqVG9TdHJpbmcuY2FsbCh2YWwpID09PSAnW29iamVjdCBBcnJheV0nO1xcbn1cXG5cXG4vKipcXG4gKiBFdmVudCBlbWl0dGVyIGNvbnN0cnVjdG9yLlxcbiAqXFxuICogQGFwaSBwdWJsaWNcXG4gKi9cXG5mdW5jdGlvbiBFdmVudEVtaXR0ZXIgKCkge31cXG5cXG4vKipcXG4gKiBBZGQgYSBsaXN0ZW5lci5cXG4gKlxcbiAqIEBhcGkgcHVibGljXFxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgRXZlbnQgbmFtZS5cXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBFdmVudCBoYW5kbGVyLlxcbiAqIEByZXR1cm4ge0V2ZW50RW1pdHRlcn0gRW1pdHRlciBpbnN0YW5jZS5cXG4gKi9cXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uID0gZnVuY3Rpb24gKG5hbWUsIGZuKSB7XFxuICBpZiAoIXRoaXMuJGV2ZW50cykge1xcbiAgICB0aGlzLiRldmVudHMgPSB7fTtcXG4gIH1cXG5cXG4gIGlmICghdGhpcy4kZXZlbnRzW25hbWVdKSB7XFxuICAgIHRoaXMuJGV2ZW50c1tuYW1lXSA9IGZuO1xcbiAgfSBlbHNlIGlmIChpc0FycmF5KHRoaXMuJGV2ZW50c1tuYW1lXSkpIHtcXG4gICAgdGhpcy4kZXZlbnRzW25hbWVdLnB1c2goZm4pO1xcbiAgfSBlbHNlIHtcXG4gICAgdGhpcy4kZXZlbnRzW25hbWVdID0gW3RoaXMuJGV2ZW50c1tuYW1lXSwgZm5dO1xcbiAgfVxcblxcbiAgcmV0dXJuIHRoaXM7XFxufTtcXG5cXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmFkZExpc3RlbmVyID0gRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbjtcXG5cXG4vKipcXG4gKiBBZGRzIGEgdm9sYXRpbGUgbGlzdGVuZXIuXFxuICpcXG4gKiBAYXBpIHB1YmxpY1xcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIEV2ZW50IG5hbWUuXFxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gRXZlbnQgaGFuZGxlci5cXG4gKiBAcmV0dXJuIHtFdmVudEVtaXR0ZXJ9IEVtaXR0ZXIgaW5zdGFuY2UuXFxuICovXFxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbmNlID0gZnVuY3Rpb24gKG5hbWUsIGZuKSB7XFxuICB2YXIgc2VsZiA9IHRoaXM7XFxuXFxuICBmdW5jdGlvbiBvbiAoKSB7XFxuICAgIHNlbGYucmVtb3ZlTGlzdGVuZXIobmFtZSwgb24pO1xcbiAgICBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xcbiAgfVxcblxcbiAgb24ubGlzdGVuZXIgPSBmbjtcXG4gIHRoaXMub24obmFtZSwgb24pO1xcblxcbiAgcmV0dXJuIHRoaXM7XFxufTtcXG5cXG4vKipcXG4gKiBSZW1vdmUgYSBsaXN0ZW5lci5cXG4gKlxcbiAqIEBhcGkgcHVibGljXFxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgRXZlbnQgbmFtZS5cXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBFdmVudCBoYW5kbGVyLlxcbiAqIEByZXR1cm4ge0V2ZW50RW1pdHRlcn0gRW1pdHRlciBpbnN0YW5jZS5cXG4gKi9cXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyID0gZnVuY3Rpb24gKG5hbWUsIGZuKSB7XFxuICBpZiAodGhpcy4kZXZlbnRzICYmIHRoaXMuJGV2ZW50c1tuYW1lXSkge1xcbiAgICB2YXIgbGlzdCA9IHRoaXMuJGV2ZW50c1tuYW1lXTtcXG5cXG4gICAgaWYgKGlzQXJyYXkobGlzdCkpIHtcXG4gICAgICB2YXIgcG9zID0gLTE7XFxuXFxuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBsaXN0Lmxlbmd0aDsgaSA8IGw7IGkrKykge1xcbiAgICAgICAgaWYgKGxpc3RbaV0gPT09IGZuIHx8IChsaXN0W2ldLmxpc3RlbmVyICYmIGxpc3RbaV0ubGlzdGVuZXIgPT09IGZuKSkge1xcbiAgICAgICAgICBwb3MgPSBpO1xcbiAgICAgICAgICBicmVhaztcXG4gICAgICAgIH1cXG4gICAgICB9XFxuXFxuICAgICAgaWYgKHBvcyA8IDApIHtcXG4gICAgICAgIHJldHVybiB0aGlzO1xcbiAgICAgIH1cXG5cXG4gICAgICBsaXN0LnNwbGljZShwb3MsIDEpO1xcblxcbiAgICAgIGlmICghbGlzdC5sZW5ndGgpIHtcXG4gICAgICAgIGRlbGV0ZSB0aGlzLiRldmVudHNbbmFtZV07XFxuICAgICAgfVxcbiAgICB9IGVsc2UgaWYgKGxpc3QgPT09IGZuIHx8IChsaXN0Lmxpc3RlbmVyICYmIGxpc3QubGlzdGVuZXIgPT09IGZuKSkge1xcbiAgICAgIGRlbGV0ZSB0aGlzLiRldmVudHNbbmFtZV07XFxuICAgIH1cXG4gIH1cXG5cXG4gIHJldHVybiB0aGlzO1xcbn07XFxuXFxuLyoqXFxuICogUmVtb3ZlIGFsbCBsaXN0ZW5lcnMgZm9yIGFuIGV2ZW50LlxcbiAqXFxuICogQGFwaSBwdWJsaWNcXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBFdmVudCBuYW1lLlxcbiAqIEByZXR1cm4ge0V2ZW50RW1pdHRlcn0gRW1pdHRlciBpbnN0YW5jZS5cXG4gKi9cXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUFsbExpc3RlbmVycyA9IGZ1bmN0aW9uIChuYW1lKSB7XFxuICBpZiAobmFtZSA9PT0gdW5kZWZpbmVkKSB7XFxuICAgIHRoaXMuJGV2ZW50cyA9IHt9O1xcbiAgICByZXR1cm4gdGhpcztcXG4gIH1cXG5cXG4gIGlmICh0aGlzLiRldmVudHMgJiYgdGhpcy4kZXZlbnRzW25hbWVdKSB7XFxuICAgIHRoaXMuJGV2ZW50c1tuYW1lXSA9IG51bGw7XFxuICB9XFxuXFxuICByZXR1cm4gdGhpcztcXG59O1xcblxcbi8qKlxcbiAqIEdldCBhbGwgbGlzdGVuZXJzIGZvciBhIGdpdmVuIGV2ZW50LlxcbiAqXFxuICogQGFwaSBwdWJsaWNcXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBFdmVudCBuYW1lLlxcbiAqIEByZXR1cm4ge0V2ZW50RW1pdHRlcn0gRW1pdHRlciBpbnN0YW5jZS5cXG4gKi9cXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVycyA9IGZ1bmN0aW9uIChuYW1lKSB7XFxuICBpZiAoIXRoaXMuJGV2ZW50cykge1xcbiAgICB0aGlzLiRldmVudHMgPSB7fTtcXG4gIH1cXG5cXG4gIGlmICghdGhpcy4kZXZlbnRzW25hbWVdKSB7XFxuICAgIHRoaXMuJGV2ZW50c1tuYW1lXSA9IFtdO1xcbiAgfVxcblxcbiAgaWYgKCFpc0FycmF5KHRoaXMuJGV2ZW50c1tuYW1lXSkpIHtcXG4gICAgdGhpcy4kZXZlbnRzW25hbWVdID0gW3RoaXMuJGV2ZW50c1tuYW1lXV07XFxuICB9XFxuXFxuICByZXR1cm4gdGhpcy4kZXZlbnRzW25hbWVdO1xcbn07XFxuXFxuLyoqXFxuICogRW1pdCBhbiBldmVudC5cXG4gKlxcbiAqIEBhcGkgcHVibGljXFxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgRXZlbnQgbmFtZS5cXG4gKiBAcmV0dXJuIHtib29sZWFufSB0cnVlIGlmIGF0IGxlYXN0IG9uZSBoYW5kbGVyIHdhcyBpbnZva2VkLCBlbHNlIGZhbHNlLlxcbiAqL1xcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uIChuYW1lKSB7XFxuICBpZiAoIXRoaXMuJGV2ZW50cykge1xcbiAgICByZXR1cm4gZmFsc2U7XFxuICB9XFxuXFxuICB2YXIgaGFuZGxlciA9IHRoaXMuJGV2ZW50c1tuYW1lXTtcXG5cXG4gIGlmICghaGFuZGxlcikge1xcbiAgICByZXR1cm4gZmFsc2U7XFxuICB9XFxuXFxuICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XFxuXFxuICBpZiAodHlwZW9mIGhhbmRsZXIgPT09ICdmdW5jdGlvbicpIHtcXG4gICAgaGFuZGxlci5hcHBseSh0aGlzLCBhcmdzKTtcXG4gIH0gZWxzZSBpZiAoaXNBcnJheShoYW5kbGVyKSkge1xcbiAgICB2YXIgbGlzdGVuZXJzID0gaGFuZGxlci5zbGljZSgpO1xcblxcbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IGxpc3RlbmVycy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcXG4gICAgICBsaXN0ZW5lcnNbaV0uYXBwbHkodGhpcywgYXJncyk7XFxuICAgIH1cXG4gIH0gZWxzZSB7XFxuICAgIHJldHVybiBmYWxzZTtcXG4gIH1cXG5cXG4gIHJldHVybiB0cnVlO1xcbn07XFxuXFxufSx7fV0sNDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XFxuJ3VzZSBzdHJpY3QnO1xcblxcbi8qKlxcbiAqIEV4cG9zZSBgUHJvZ3Jlc3NgLlxcbiAqL1xcblxcbm1vZHVsZS5leHBvcnRzID0gUHJvZ3Jlc3M7XFxuXFxuLyoqXFxuICogSW5pdGlhbGl6ZSBhIG5ldyBgUHJvZ3Jlc3NgIGluZGljYXRvci5cXG4gKi9cXG5mdW5jdGlvbiBQcm9ncmVzcyAoKSB7XFxuICB0aGlzLnBlcmNlbnQgPSAwO1xcbiAgdGhpcy5zaXplKDApO1xcbiAgdGhpcy5mb250U2l6ZSgxMSk7XFxuICB0aGlzLmZvbnQoJ2hlbHZldGljYSwgYXJpYWwsIHNhbnMtc2VyaWYnKTtcXG59XFxuXFxuLyoqXFxuICogU2V0IHByb2dyZXNzIHNpemUgdG8gYHNpemVgLlxcbiAqXFxuICogQGFwaSBwdWJsaWNcXG4gKiBAcGFyYW0ge251bWJlcn0gc2l6ZVxcbiAqIEByZXR1cm4ge1Byb2dyZXNzfSBQcm9ncmVzcyBpbnN0YW5jZS5cXG4gKi9cXG5Qcm9ncmVzcy5wcm90b3R5cGUuc2l6ZSA9IGZ1bmN0aW9uIChzaXplKSB7XFxuICB0aGlzLl9zaXplID0gc2l6ZTtcXG4gIHJldHVybiB0aGlzO1xcbn07XFxuXFxuLyoqXFxuICogU2V0IHRleHQgdG8gYHRleHRgLlxcbiAqXFxuICogQGFwaSBwdWJsaWNcXG4gKiBAcGFyYW0ge3N0cmluZ30gdGV4dFxcbiAqIEByZXR1cm4ge1Byb2dyZXNzfSBQcm9ncmVzcyBpbnN0YW5jZS5cXG4gKi9cXG5Qcm9ncmVzcy5wcm90b3R5cGUudGV4dCA9IGZ1bmN0aW9uICh0ZXh0KSB7XFxuICB0aGlzLl90ZXh0ID0gdGV4dDtcXG4gIHJldHVybiB0aGlzO1xcbn07XFxuXFxuLyoqXFxuICogU2V0IGZvbnQgc2l6ZSB0byBgc2l6ZWAuXFxuICpcXG4gKiBAYXBpIHB1YmxpY1xcbiAqIEBwYXJhbSB7bnVtYmVyfSBzaXplXFxuICogQHJldHVybiB7UHJvZ3Jlc3N9IFByb2dyZXNzIGluc3RhbmNlLlxcbiAqL1xcblByb2dyZXNzLnByb3RvdHlwZS5mb250U2l6ZSA9IGZ1bmN0aW9uIChzaXplKSB7XFxuICB0aGlzLl9mb250U2l6ZSA9IHNpemU7XFxuICByZXR1cm4gdGhpcztcXG59O1xcblxcbi8qKlxcbiAqIFNldCBmb250IHRvIGBmYW1pbHlgLlxcbiAqXFxuICogQHBhcmFtIHtzdHJpbmd9IGZhbWlseVxcbiAqIEByZXR1cm4ge1Byb2dyZXNzfSBQcm9ncmVzcyBpbnN0YW5jZS5cXG4gKi9cXG5Qcm9ncmVzcy5wcm90b3R5cGUuZm9udCA9IGZ1bmN0aW9uIChmYW1pbHkpIHtcXG4gIHRoaXMuX2ZvbnQgPSBmYW1pbHk7XFxuICByZXR1cm4gdGhpcztcXG59O1xcblxcbi8qKlxcbiAqIFVwZGF0ZSBwZXJjZW50YWdlIHRvIGBuYC5cXG4gKlxcbiAqIEBwYXJhbSB7bnVtYmVyfSBuXFxuICogQHJldHVybiB7UHJvZ3Jlc3N9IFByb2dyZXNzIGluc3RhbmNlLlxcbiAqL1xcblByb2dyZXNzLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAobikge1xcbiAgdGhpcy5wZXJjZW50ID0gbjtcXG4gIHJldHVybiB0aGlzO1xcbn07XFxuXFxuLyoqXFxuICogRHJhdyBvbiBgY3R4YC5cXG4gKlxcbiAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJkfSBjdHhcXG4gKiBAcmV0dXJuIHtQcm9ncmVzc30gUHJvZ3Jlc3MgaW5zdGFuY2UuXFxuICovXFxuUHJvZ3Jlc3MucHJvdG90eXBlLmRyYXcgPSBmdW5jdGlvbiAoY3R4KSB7XFxuICB0cnkge1xcbiAgICB2YXIgcGVyY2VudCA9IE1hdGgubWluKHRoaXMucGVyY2VudCwgMTAwKTtcXG4gICAgdmFyIHNpemUgPSB0aGlzLl9zaXplO1xcbiAgICB2YXIgaGFsZiA9IHNpemUgLyAyO1xcbiAgICB2YXIgeCA9IGhhbGY7XFxuICAgIHZhciB5ID0gaGFsZjtcXG4gICAgdmFyIHJhZCA9IGhhbGYgLSAxO1xcbiAgICB2YXIgZm9udFNpemUgPSB0aGlzLl9mb250U2l6ZTtcXG5cXG4gICAgY3R4LmZvbnQgPSBmb250U2l6ZSArICdweCAnICsgdGhpcy5fZm9udDtcXG5cXG4gICAgdmFyIGFuZ2xlID0gTWF0aC5QSSAqIDIgKiAocGVyY2VudCAvIDEwMCk7XFxuICAgIGN0eC5jbGVhclJlY3QoMCwgMCwgc2l6ZSwgc2l6ZSk7XFxuXFxuICAgIC8vIG91dGVyIGNpcmNsZVxcbiAgICBjdHguc3Ryb2tlU3R5bGUgPSAnIzlmOWY5Zic7XFxuICAgIGN0eC5iZWdpblBhdGgoKTtcXG4gICAgY3R4LmFyYyh4LCB5LCByYWQsIDAsIGFuZ2xlLCBmYWxzZSk7XFxuICAgIGN0eC5zdHJva2UoKTtcXG5cXG4gICAgLy8gaW5uZXIgY2lyY2xlXFxuICAgIGN0eC5zdHJva2VTdHlsZSA9ICcjZWVlJztcXG4gICAgY3R4LmJlZ2luUGF0aCgpO1xcbiAgICBjdHguYXJjKHgsIHksIHJhZCAtIDEsIDAsIGFuZ2xlLCB0cnVlKTtcXG4gICAgY3R4LnN0cm9rZSgpO1xcblxcbiAgICAvLyB0ZXh0XFxuICAgIHZhciB0ZXh0ID0gdGhpcy5fdGV4dCB8fCAocGVyY2VudCB8IDApICsgJyUnO1xcbiAgICB2YXIgdyA9IGN0eC5tZWFzdXJlVGV4dCh0ZXh0KS53aWR0aDtcXG5cXG4gICAgY3R4LmZpbGxUZXh0KHRleHQsIHggLSB3IC8gMiArIDEsIHkgKyBmb250U2l6ZSAvIDIgLSAxKTtcXG4gIH0gY2F0Y2ggKGVycikge1xcbiAgICAvLyBkb24ndCBmYWlsIGlmIHdlIGNhbid0IHJlbmRlciBwcm9ncmVzc1xcbiAgfVxcbiAgcmV0dXJuIHRoaXM7XFxufTtcXG5cXG59LHt9XSw1OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcXG4oZnVuY3Rpb24gKGdsb2JhbCl7XFxuJ3VzZSBzdHJpY3QnO1xcblxcbmV4cG9ydHMuaXNhdHR5ID0gZnVuY3Rpb24gaXNhdHR5ICgpIHtcXG4gIHJldHVybiB0cnVlO1xcbn07XFxuXFxuZXhwb3J0cy5nZXRXaW5kb3dTaXplID0gZnVuY3Rpb24gZ2V0V2luZG93U2l6ZSAoKSB7XFxuICBpZiAoJ2lubmVySGVpZ2h0JyBpbiBnbG9iYWwpIHtcXG4gICAgcmV0dXJuIFtnbG9iYWwuaW5uZXJIZWlnaHQsIGdsb2JhbC5pbm5lcldpZHRoXTtcXG4gIH1cXG4gIC8vIEluIGEgV2ViIFdvcmtlciwgdGhlIERPTSBXaW5kb3cgaXMgbm90IGF2YWlsYWJsZS5cXG4gIHJldHVybiBbNjQwLCA0ODBdO1xcbn07XFxuXFxufSkuY2FsbCh0aGlzLHR5cGVvZiBnbG9iYWwgIT09IFxcXCJ1bmRlZmluZWRcXFwiID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09IFxcXCJ1bmRlZmluZWRcXFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFxcXCJ1bmRlZmluZWRcXFwiID8gd2luZG93IDoge30pXFxufSx7fV0sNjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XFxuJ3VzZSBzdHJpY3QnO1xcblxcbi8qKlxcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXFxuICovXFxuXFxudmFyIEpTT04gPSByZXF1aXJlKCdqc29uMycpO1xcblxcbi8qKlxcbiAqIEV4cG9zZSBgQ29udGV4dGAuXFxuICovXFxuXFxubW9kdWxlLmV4cG9ydHMgPSBDb250ZXh0O1xcblxcbi8qKlxcbiAqIEluaXRpYWxpemUgYSBuZXcgYENvbnRleHRgLlxcbiAqXFxuICogQGFwaSBwcml2YXRlXFxuICovXFxuZnVuY3Rpb24gQ29udGV4dCAoKSB7fVxcblxcbi8qKlxcbiAqIFNldCBvciBnZXQgdGhlIGNvbnRleHQgYFJ1bm5hYmxlYCB0byBgcnVubmFibGVgLlxcbiAqXFxuICogQGFwaSBwcml2YXRlXFxuICogQHBhcmFtIHtSdW5uYWJsZX0gcnVubmFibGVcXG4gKiBAcmV0dXJuIHtDb250ZXh0fVxcbiAqL1xcbkNvbnRleHQucHJvdG90eXBlLnJ1bm5hYmxlID0gZnVuY3Rpb24gKHJ1bm5hYmxlKSB7XFxuICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcXG4gICAgcmV0dXJuIHRoaXMuX3J1bm5hYmxlO1xcbiAgfVxcbiAgdGhpcy50ZXN0ID0gdGhpcy5fcnVubmFibGUgPSBydW5uYWJsZTtcXG4gIHJldHVybiB0aGlzO1xcbn07XFxuXFxuLyoqXFxuICogU2V0IHRlc3QgdGltZW91dCBgbXNgLlxcbiAqXFxuICogQGFwaSBwcml2YXRlXFxuICogQHBhcmFtIHtudW1iZXJ9IG1zXFxuICogQHJldHVybiB7Q29udGV4dH0gc2VsZlxcbiAqL1xcbkNvbnRleHQucHJvdG90eXBlLnRpbWVvdXQgPSBmdW5jdGlvbiAobXMpIHtcXG4gIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xcbiAgICByZXR1cm4gdGhpcy5ydW5uYWJsZSgpLnRpbWVvdXQoKTtcXG4gIH1cXG4gIHRoaXMucnVubmFibGUoKS50aW1lb3V0KG1zKTtcXG4gIHJldHVybiB0aGlzO1xcbn07XFxuXFxuLyoqXFxuICogU2V0IHRlc3QgdGltZW91dCBgZW5hYmxlZGAuXFxuICpcXG4gKiBAYXBpIHByaXZhdGVcXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGVuYWJsZWRcXG4gKiBAcmV0dXJuIHtDb250ZXh0fSBzZWxmXFxuICovXFxuQ29udGV4dC5wcm90b3R5cGUuZW5hYmxlVGltZW91dHMgPSBmdW5jdGlvbiAoZW5hYmxlZCkge1xcbiAgdGhpcy5ydW5uYWJsZSgpLmVuYWJsZVRpbWVvdXRzKGVuYWJsZWQpO1xcbiAgcmV0dXJuIHRoaXM7XFxufTtcXG5cXG4vKipcXG4gKiBTZXQgdGVzdCBzbG93bmVzcyB0aHJlc2hvbGQgYG1zYC5cXG4gKlxcbiAqIEBhcGkgcHJpdmF0ZVxcbiAqIEBwYXJhbSB7bnVtYmVyfSBtc1xcbiAqIEByZXR1cm4ge0NvbnRleHR9IHNlbGZcXG4gKi9cXG5Db250ZXh0LnByb3RvdHlwZS5zbG93ID0gZnVuY3Rpb24gKG1zKSB7XFxuICB0aGlzLnJ1bm5hYmxlKCkuc2xvdyhtcyk7XFxuICByZXR1cm4gdGhpcztcXG59O1xcblxcbi8qKlxcbiAqIE1hcmsgYSB0ZXN0IGFzIHNraXBwZWQuXFxuICpcXG4gKiBAYXBpIHByaXZhdGVcXG4gKiBAcmV0dXJuIHtDb250ZXh0fSBzZWxmXFxuICovXFxuQ29udGV4dC5wcm90b3R5cGUuc2tpcCA9IGZ1bmN0aW9uICgpIHtcXG4gIHRoaXMucnVubmFibGUoKS5za2lwKCk7XFxuICByZXR1cm4gdGhpcztcXG59O1xcblxcbi8qKlxcbiAqIEFsbG93IGEgbnVtYmVyIG9mIHJldHJpZXMgb24gZmFpbGVkIHRlc3RzXFxuICpcXG4gKiBAYXBpIHByaXZhdGVcXG4gKiBAcGFyYW0ge251bWJlcn0gblxcbiAqIEByZXR1cm4ge0NvbnRleHR9IHNlbGZcXG4gKi9cXG5Db250ZXh0LnByb3RvdHlwZS5yZXRyaWVzID0gZnVuY3Rpb24gKG4pIHtcXG4gIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xcbiAgICByZXR1cm4gdGhpcy5ydW5uYWJsZSgpLnJldHJpZXMoKTtcXG4gIH1cXG4gIHRoaXMucnVubmFibGUoKS5yZXRyaWVzKG4pO1xcbiAgcmV0dXJuIHRoaXM7XFxufTtcXG5cXG4vKipcXG4gKiBJbnNwZWN0IHRoZSBjb250ZXh0IHZvaWQgb2YgYC5fcnVubmFibGVgLlxcbiAqXFxuICogQGFwaSBwcml2YXRlXFxuICogQHJldHVybiB7c3RyaW5nfVxcbiAqL1xcbkNvbnRleHQucHJvdG90eXBlLmluc3BlY3QgPSBmdW5jdGlvbiAoKSB7XFxuICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodGhpcywgZnVuY3Rpb24gKGtleSwgdmFsKSB7XFxuICAgIHJldHVybiBrZXkgPT09ICdydW5uYWJsZScgfHwga2V5ID09PSAndGVzdCcgPyB1bmRlZmluZWQgOiB2YWw7XFxuICB9LCAyKTtcXG59O1xcblxcbn0se1xcXCJqc29uM1xcXCI6Njl9XSw3OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcXG4ndXNlIHN0cmljdCc7XFxuXFxuLyoqXFxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cXG4gKi9cXG5cXG52YXIgUnVubmFibGUgPSByZXF1aXJlKCcuL3J1bm5hYmxlJyk7XFxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnLi91dGlscycpLmluaGVyaXRzO1xcblxcbi8qKlxcbiAqIEV4cG9zZSBgSG9va2AuXFxuICovXFxuXFxubW9kdWxlLmV4cG9ydHMgPSBIb29rO1xcblxcbi8qKlxcbiAqIEluaXRpYWxpemUgYSBuZXcgYEhvb2tgIHdpdGggdGhlIGdpdmVuIGB0aXRsZWAgYW5kIGNhbGxiYWNrIGBmbmAuXFxuICpcXG4gKiBAcGFyYW0ge1N0cmluZ30gdGl0bGVcXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxcbiAqIEBhcGkgcHJpdmF0ZVxcbiAqL1xcbmZ1bmN0aW9uIEhvb2sgKHRpdGxlLCBmbikge1xcbiAgUnVubmFibGUuY2FsbCh0aGlzLCB0aXRsZSwgZm4pO1xcbiAgdGhpcy50eXBlID0gJ2hvb2snO1xcbn1cXG5cXG4vKipcXG4gKiBJbmhlcml0IGZyb20gYFJ1bm5hYmxlLnByb3RvdHlwZWAuXFxuICovXFxuaW5oZXJpdHMoSG9vaywgUnVubmFibGUpO1xcblxcbi8qKlxcbiAqIEdldCBvciBzZXQgdGhlIHRlc3QgYGVycmAuXFxuICpcXG4gKiBAcGFyYW0ge0Vycm9yfSBlcnJcXG4gKiBAcmV0dXJuIHtFcnJvcn1cXG4gKiBAYXBpIHB1YmxpY1xcbiAqL1xcbkhvb2sucHJvdG90eXBlLmVycm9yID0gZnVuY3Rpb24gKGVycikge1xcbiAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XFxuICAgIGVyciA9IHRoaXMuX2Vycm9yO1xcbiAgICB0aGlzLl9lcnJvciA9IG51bGw7XFxuICAgIHJldHVybiBlcnI7XFxuICB9XFxuXFxuICB0aGlzLl9lcnJvciA9IGVycjtcXG59O1xcblxcbn0se1xcXCIuL3J1bm5hYmxlXFxcIjozMyxcXFwiLi91dGlsc1xcXCI6Mzh9XSw4OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcXG4ndXNlIHN0cmljdCc7XFxuXFxuLyoqXFxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cXG4gKi9cXG5cXG52YXIgVGVzdCA9IHJlcXVpcmUoJy4uL3Rlc3QnKTtcXG5cXG4vKipcXG4gKiBCREQtc3R5bGUgaW50ZXJmYWNlOlxcbiAqXFxuICogICAgICBkZXNjcmliZSgnQXJyYXknLCBmdW5jdGlvbigpIHtcXG4gKiAgICAgICAgZGVzY3JpYmUoJyNpbmRleE9mKCknLCBmdW5jdGlvbigpIHtcXG4gKiAgICAgICAgICBpdCgnc2hvdWxkIHJldHVybiAtMSB3aGVuIG5vdCBwcmVzZW50JywgZnVuY3Rpb24oKSB7XFxuICogICAgICAgICAgICAvLyAuLi5cXG4gKiAgICAgICAgICB9KTtcXG4gKlxcbiAqICAgICAgICAgIGl0KCdzaG91bGQgcmV0dXJuIHRoZSBpbmRleCB3aGVuIHByZXNlbnQnLCBmdW5jdGlvbigpIHtcXG4gKiAgICAgICAgICAgIC8vIC4uLlxcbiAqICAgICAgICAgIH0pO1xcbiAqICAgICAgICB9KTtcXG4gKiAgICAgIH0pO1xcbiAqXFxuICogQHBhcmFtIHtTdWl0ZX0gc3VpdGUgUm9vdCBzdWl0ZS5cXG4gKi9cXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChzdWl0ZSkge1xcbiAgdmFyIHN1aXRlcyA9IFtzdWl0ZV07XFxuXFxuICBzdWl0ZS5vbigncHJlLXJlcXVpcmUnLCBmdW5jdGlvbiAoY29udGV4dCwgZmlsZSwgbW9jaGEpIHtcXG4gICAgdmFyIGNvbW1vbiA9IHJlcXVpcmUoJy4vY29tbW9uJykoc3VpdGVzLCBjb250ZXh0LCBtb2NoYSk7XFxuXFxuICAgIGNvbnRleHQuYmVmb3JlID0gY29tbW9uLmJlZm9yZTtcXG4gICAgY29udGV4dC5hZnRlciA9IGNvbW1vbi5hZnRlcjtcXG4gICAgY29udGV4dC5iZWZvcmVFYWNoID0gY29tbW9uLmJlZm9yZUVhY2g7XFxuICAgIGNvbnRleHQuYWZ0ZXJFYWNoID0gY29tbW9uLmFmdGVyRWFjaDtcXG4gICAgY29udGV4dC5ydW4gPSBtb2NoYS5vcHRpb25zLmRlbGF5ICYmIGNvbW1vbi5ydW5XaXRoU3VpdGUoc3VpdGUpO1xcbiAgICAvKipcXG4gICAgICogRGVzY3JpYmUgYSBcXFwic3VpdGVcXFwiIHdpdGggdGhlIGdpdmVuIGB0aXRsZWBcXG4gICAgICogYW5kIGNhbGxiYWNrIGBmbmAgY29udGFpbmluZyBuZXN0ZWQgc3VpdGVzXFxuICAgICAqIGFuZC9vciB0ZXN0cy5cXG4gICAgICovXFxuXFxuICAgIGNvbnRleHQuZGVzY3JpYmUgPSBjb250ZXh0LmNvbnRleHQgPSBmdW5jdGlvbiAodGl0bGUsIGZuKSB7XFxuICAgICAgcmV0dXJuIGNvbW1vbi5zdWl0ZS5jcmVhdGUoe1xcbiAgICAgICAgdGl0bGU6IHRpdGxlLFxcbiAgICAgICAgZmlsZTogZmlsZSxcXG4gICAgICAgIGZuOiBmblxcbiAgICAgIH0pO1xcbiAgICB9O1xcblxcbiAgICAvKipcXG4gICAgICogUGVuZGluZyBkZXNjcmliZS5cXG4gICAgICovXFxuXFxuICAgIGNvbnRleHQueGRlc2NyaWJlID0gY29udGV4dC54Y29udGV4dCA9IGNvbnRleHQuZGVzY3JpYmUuc2tpcCA9IGZ1bmN0aW9uICh0aXRsZSwgZm4pIHtcXG4gICAgICByZXR1cm4gY29tbW9uLnN1aXRlLnNraXAoe1xcbiAgICAgICAgdGl0bGU6IHRpdGxlLFxcbiAgICAgICAgZmlsZTogZmlsZSxcXG4gICAgICAgIGZuOiBmblxcbiAgICAgIH0pO1xcbiAgICB9O1xcblxcbiAgICAvKipcXG4gICAgICogRXhjbHVzaXZlIHN1aXRlLlxcbiAgICAgKi9cXG5cXG4gICAgY29udGV4dC5kZXNjcmliZS5vbmx5ID0gZnVuY3Rpb24gKHRpdGxlLCBmbikge1xcbiAgICAgIHJldHVybiBjb21tb24uc3VpdGUub25seSh7XFxuICAgICAgICB0aXRsZTogdGl0bGUsXFxuICAgICAgICBmaWxlOiBmaWxlLFxcbiAgICAgICAgZm46IGZuXFxuICAgICAgfSk7XFxuICAgIH07XFxuXFxuICAgIC8qKlxcbiAgICAgKiBEZXNjcmliZSBhIHNwZWNpZmljYXRpb24gb3IgdGVzdC1jYXNlXFxuICAgICAqIHdpdGggdGhlIGdpdmVuIGB0aXRsZWAgYW5kIGNhbGxiYWNrIGBmbmBcXG4gICAgICogYWN0aW5nIGFzIGEgdGh1bmsuXFxuICAgICAqL1xcblxcbiAgICBjb250ZXh0Lml0ID0gY29udGV4dC5zcGVjaWZ5ID0gZnVuY3Rpb24gKHRpdGxlLCBmbikge1xcbiAgICAgIHZhciBzdWl0ZSA9IHN1aXRlc1swXTtcXG4gICAgICBpZiAoc3VpdGUuaXNQZW5kaW5nKCkpIHtcXG4gICAgICAgIGZuID0gbnVsbDtcXG4gICAgICB9XFxuICAgICAgdmFyIHRlc3QgPSBuZXcgVGVzdCh0aXRsZSwgZm4pO1xcbiAgICAgIHRlc3QuZmlsZSA9IGZpbGU7XFxuICAgICAgc3VpdGUuYWRkVGVzdCh0ZXN0KTtcXG4gICAgICByZXR1cm4gdGVzdDtcXG4gICAgfTtcXG5cXG4gICAgLyoqXFxuICAgICAqIEV4Y2x1c2l2ZSB0ZXN0LWNhc2UuXFxuICAgICAqL1xcblxcbiAgICBjb250ZXh0Lml0Lm9ubHkgPSBmdW5jdGlvbiAodGl0bGUsIGZuKSB7XFxuICAgICAgcmV0dXJuIGNvbW1vbi50ZXN0Lm9ubHkobW9jaGEsIGNvbnRleHQuaXQodGl0bGUsIGZuKSk7XFxuICAgIH07XFxuXFxuICAgIC8qKlxcbiAgICAgKiBQZW5kaW5nIHRlc3QgY2FzZS5cXG4gICAgICovXFxuXFxuICAgIGNvbnRleHQueGl0ID0gY29udGV4dC54c3BlY2lmeSA9IGNvbnRleHQuaXQuc2tpcCA9IGZ1bmN0aW9uICh0aXRsZSkge1xcbiAgICAgIGNvbnRleHQuaXQodGl0bGUpO1xcbiAgICB9O1xcblxcbiAgICAvKipcXG4gICAgICogTnVtYmVyIG9mIGF0dGVtcHRzIHRvIHJldHJ5LlxcbiAgICAgKi9cXG4gICAgY29udGV4dC5pdC5yZXRyaWVzID0gZnVuY3Rpb24gKG4pIHtcXG4gICAgICBjb250ZXh0LnJldHJpZXMobik7XFxuICAgIH07XFxuICB9KTtcXG59O1xcblxcbn0se1xcXCIuLi90ZXN0XFxcIjozNixcXFwiLi9jb21tb25cXFwiOjl9XSw5OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcXG4ndXNlIHN0cmljdCc7XFxuXFxudmFyIFN1aXRlID0gcmVxdWlyZSgnLi4vc3VpdGUnKTtcXG5cXG4vKipcXG4gKiBGdW5jdGlvbnMgY29tbW9uIHRvIG1vcmUgdGhhbiBvbmUgaW50ZXJmYWNlLlxcbiAqXFxuICogQHBhcmFtIHtTdWl0ZVtdfSBzdWl0ZXNcXG4gKiBAcGFyYW0ge0NvbnRleHR9IGNvbnRleHRcXG4gKiBAcGFyYW0ge01vY2hhfSBtb2NoYVxcbiAqIEByZXR1cm4ge09iamVjdH0gQW4gb2JqZWN0IGNvbnRhaW5pbmcgY29tbW9uIGZ1bmN0aW9ucy5cXG4gKi9cXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChzdWl0ZXMsIGNvbnRleHQsIG1vY2hhKSB7XFxuICByZXR1cm4ge1xcbiAgICAvKipcXG4gICAgICogVGhpcyBpcyBvbmx5IHByZXNlbnQgaWYgZmxhZyAtLWRlbGF5IGlzIHBhc3NlZCBpbnRvIE1vY2hhLiBJdCB0cmlnZ2Vyc1xcbiAgICAgKiByb290IHN1aXRlIGV4ZWN1dGlvbi5cXG4gICAgICpcXG4gICAgICogQHBhcmFtIHtTdWl0ZX0gc3VpdGUgVGhlIHJvb3Qgc3VpdGUuXFxuICAgICAqIEByZXR1cm4ge0Z1bmN0aW9ufSBBIGZ1bmN0aW9uIHdoaWNoIHJ1bnMgdGhlIHJvb3Qgc3VpdGVcXG4gICAgICovXFxuICAgIHJ1bldpdGhTdWl0ZTogZnVuY3Rpb24gcnVuV2l0aFN1aXRlIChzdWl0ZSkge1xcbiAgICAgIHJldHVybiBmdW5jdGlvbiBydW4gKCkge1xcbiAgICAgICAgc3VpdGUucnVuKCk7XFxuICAgICAgfTtcXG4gICAgfSxcXG5cXG4gICAgLyoqXFxuICAgICAqIEV4ZWN1dGUgYmVmb3JlIHJ1bm5pbmcgdGVzdHMuXFxuICAgICAqXFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXFxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXFxuICAgICAqL1xcbiAgICBiZWZvcmU6IGZ1bmN0aW9uIChuYW1lLCBmbikge1xcbiAgICAgIHN1aXRlc1swXS5iZWZvcmVBbGwobmFtZSwgZm4pO1xcbiAgICB9LFxcblxcbiAgICAvKipcXG4gICAgICogRXhlY3V0ZSBhZnRlciBydW5uaW5nIHRlc3RzLlxcbiAgICAgKlxcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxcbiAgICAgKi9cXG4gICAgYWZ0ZXI6IGZ1bmN0aW9uIChuYW1lLCBmbikge1xcbiAgICAgIHN1aXRlc1swXS5hZnRlckFsbChuYW1lLCBmbik7XFxuICAgIH0sXFxuXFxuICAgIC8qKlxcbiAgICAgKiBFeGVjdXRlIGJlZm9yZSBlYWNoIHRlc3QgY2FzZS5cXG4gICAgICpcXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cXG4gICAgICovXFxuICAgIGJlZm9yZUVhY2g6IGZ1bmN0aW9uIChuYW1lLCBmbikge1xcbiAgICAgIHN1aXRlc1swXS5iZWZvcmVFYWNoKG5hbWUsIGZuKTtcXG4gICAgfSxcXG5cXG4gICAgLyoqXFxuICAgICAqIEV4ZWN1dGUgYWZ0ZXIgZWFjaCB0ZXN0IGNhc2UuXFxuICAgICAqXFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXFxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXFxuICAgICAqL1xcbiAgICBhZnRlckVhY2g6IGZ1bmN0aW9uIChuYW1lLCBmbikge1xcbiAgICAgIHN1aXRlc1swXS5hZnRlckVhY2gobmFtZSwgZm4pO1xcbiAgICB9LFxcblxcbiAgICBzdWl0ZToge1xcbiAgICAgIC8qKlxcbiAgICAgICAqIENyZWF0ZSBhbiBleGNsdXNpdmUgU3VpdGU7IGNvbnZlbmllbmNlIGZ1bmN0aW9uXFxuICAgICAgICogU2VlIGRvY3N0cmluZyBmb3IgY3JlYXRlKCkgYmVsb3cuXFxuICAgICAgICpcXG4gICAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0c1xcbiAgICAgICAqIEByZXR1cm5zIHtTdWl0ZX1cXG4gICAgICAgKi9cXG4gICAgICBvbmx5OiBmdW5jdGlvbiBvbmx5IChvcHRzKSB7XFxuICAgICAgICBtb2NoYS5vcHRpb25zLmhhc09ubHkgPSB0cnVlO1xcbiAgICAgICAgb3B0cy5pc09ubHkgPSB0cnVlO1xcbiAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlKG9wdHMpO1xcbiAgICAgIH0sXFxuXFxuICAgICAgLyoqXFxuICAgICAgICogQ3JlYXRlIGEgU3VpdGUsIGJ1dCBza2lwIGl0OyBjb252ZW5pZW5jZSBmdW5jdGlvblxcbiAgICAgICAqIFNlZSBkb2NzdHJpbmcgZm9yIGNyZWF0ZSgpIGJlbG93LlxcbiAgICAgICAqXFxuICAgICAgICogQHBhcmFtIHtPYmplY3R9IG9wdHNcXG4gICAgICAgKiBAcmV0dXJucyB7U3VpdGV9XFxuICAgICAgICovXFxuICAgICAgc2tpcDogZnVuY3Rpb24gc2tpcCAob3B0cykge1xcbiAgICAgICAgb3B0cy5wZW5kaW5nID0gdHJ1ZTtcXG4gICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZShvcHRzKTtcXG4gICAgICB9LFxcblxcbiAgICAgIC8qKlxcbiAgICAgICAqIENyZWF0ZXMgYSBzdWl0ZS5cXG4gICAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyBPcHRpb25zXFxuICAgICAgICogQHBhcmFtIHtzdHJpbmd9IG9wdHMudGl0bGUgVGl0bGUgb2YgU3VpdGVcXG4gICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0cy5mbl0gU3VpdGUgRnVuY3Rpb24gKG5vdCBhbHdheXMgYXBwbGljYWJsZSlcXG4gICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRzLnBlbmRpbmddIElzIFN1aXRlIHBlbmRpbmc/XFxuICAgICAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLmZpbGVdIEZpbGVwYXRoIHdoZXJlIHRoaXMgU3VpdGUgcmVzaWRlc1xcbiAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdHMuaXNPbmx5XSBJcyBTdWl0ZSBleGNsdXNpdmU/XFxuICAgICAgICogQHJldHVybnMge1N1aXRlfVxcbiAgICAgICAqL1xcbiAgICAgIGNyZWF0ZTogZnVuY3Rpb24gY3JlYXRlIChvcHRzKSB7XFxuICAgICAgICB2YXIgc3VpdGUgPSBTdWl0ZS5jcmVhdGUoc3VpdGVzWzBdLCBvcHRzLnRpdGxlKTtcXG4gICAgICAgIHN1aXRlLnBlbmRpbmcgPSBCb29sZWFuKG9wdHMucGVuZGluZyk7XFxuICAgICAgICBzdWl0ZS5maWxlID0gb3B0cy5maWxlO1xcbiAgICAgICAgc3VpdGVzLnVuc2hpZnQoc3VpdGUpO1xcbiAgICAgICAgaWYgKG9wdHMuaXNPbmx5KSB7XFxuICAgICAgICAgIHN1aXRlLnBhcmVudC5fb25seVN1aXRlcyA9IHN1aXRlLnBhcmVudC5fb25seVN1aXRlcy5jb25jYXQoc3VpdGUpO1xcbiAgICAgICAgICBtb2NoYS5vcHRpb25zLmhhc09ubHkgPSB0cnVlO1xcbiAgICAgICAgfVxcbiAgICAgICAgaWYgKHR5cGVvZiBvcHRzLmZuID09PSAnZnVuY3Rpb24nKSB7XFxuICAgICAgICAgIG9wdHMuZm4uY2FsbChzdWl0ZSk7XFxuICAgICAgICAgIHN1aXRlcy5zaGlmdCgpO1xcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2Ygb3B0cy5mbiA9PT0gJ3VuZGVmaW5lZCcgJiYgIXN1aXRlLnBlbmRpbmcpIHtcXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdTdWl0ZSBcXFwiJyArIHN1aXRlLmZ1bGxUaXRsZSgpICsgJ1xcXCIgd2FzIGRlZmluZWQgYnV0IG5vIGNhbGxiYWNrIHdhcyBzdXBwbGllZC4gU3VwcGx5IGEgY2FsbGJhY2sgb3IgZXhwbGljaXRseSBza2lwIHRoZSBzdWl0ZS4nKTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIHJldHVybiBzdWl0ZTtcXG4gICAgICB9XFxuICAgIH0sXFxuXFxuICAgIHRlc3Q6IHtcXG5cXG4gICAgICAvKipcXG4gICAgICAgKiBFeGNsdXNpdmUgdGVzdC1jYXNlLlxcbiAgICAgICAqXFxuICAgICAgICogQHBhcmFtIHtPYmplY3R9IG1vY2hhXFxuICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gdGVzdFxcbiAgICAgICAqIEByZXR1cm5zIHsqfVxcbiAgICAgICAqL1xcbiAgICAgIG9ubHk6IGZ1bmN0aW9uIChtb2NoYSwgdGVzdCkge1xcbiAgICAgICAgdGVzdC5wYXJlbnQuX29ubHlUZXN0cyA9IHRlc3QucGFyZW50Ll9vbmx5VGVzdHMuY29uY2F0KHRlc3QpO1xcbiAgICAgICAgbW9jaGEub3B0aW9ucy5oYXNPbmx5ID0gdHJ1ZTtcXG4gICAgICAgIHJldHVybiB0ZXN0O1xcbiAgICAgIH0sXFxuXFxuICAgICAgLyoqXFxuICAgICAgICogUGVuZGluZyB0ZXN0IGNhc2UuXFxuICAgICAgICpcXG4gICAgICAgKiBAcGFyYW0ge3N0cmluZ30gdGl0bGVcXG4gICAgICAgKi9cXG4gICAgICBza2lwOiBmdW5jdGlvbiAodGl0bGUpIHtcXG4gICAgICAgIGNvbnRleHQudGVzdCh0aXRsZSk7XFxuICAgICAgfSxcXG5cXG4gICAgICAvKipcXG4gICAgICAgKiBOdW1iZXIgb2YgcmV0cnkgYXR0ZW1wdHNcXG4gICAgICAgKlxcbiAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBuXFxuICAgICAgICovXFxuICAgICAgcmV0cmllczogZnVuY3Rpb24gKG4pIHtcXG4gICAgICAgIGNvbnRleHQucmV0cmllcyhuKTtcXG4gICAgICB9XFxuICAgIH1cXG4gIH07XFxufTtcXG5cXG59LHtcXFwiLi4vc3VpdGVcXFwiOjM1fV0sMTA6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xcbid1c2Ugc3RyaWN0JztcXG5cXG4vKipcXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxcbiAqL1xcblxcbnZhciBTdWl0ZSA9IHJlcXVpcmUoJy4uL3N1aXRlJyk7XFxudmFyIFRlc3QgPSByZXF1aXJlKCcuLi90ZXN0Jyk7XFxuXFxuLyoqXFxuICogRXhwb3J0cy1zdHlsZSAoYXMgTm9kZS5qcyBtb2R1bGUpIGludGVyZmFjZTpcXG4gKlxcbiAqICAgICBleHBvcnRzLkFycmF5ID0ge1xcbiAqICAgICAgICcjaW5kZXhPZigpJzoge1xcbiAqICAgICAgICAgJ3Nob3VsZCByZXR1cm4gLTEgd2hlbiB0aGUgdmFsdWUgaXMgbm90IHByZXNlbnQnOiBmdW5jdGlvbigpIHtcXG4gKlxcbiAqICAgICAgICAgfSxcXG4gKlxcbiAqICAgICAgICAgJ3Nob3VsZCByZXR1cm4gdGhlIGNvcnJlY3QgaW5kZXggd2hlbiB0aGUgdmFsdWUgaXMgcHJlc2VudCc6IGZ1bmN0aW9uKCkge1xcbiAqXFxuICogICAgICAgICB9XFxuICogICAgICAgfVxcbiAqICAgICB9O1xcbiAqXFxuICogQHBhcmFtIHtTdWl0ZX0gc3VpdGUgUm9vdCBzdWl0ZS5cXG4gKi9cXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChzdWl0ZSkge1xcbiAgdmFyIHN1aXRlcyA9IFtzdWl0ZV07XFxuXFxuICBzdWl0ZS5vbigncmVxdWlyZScsIHZpc2l0KTtcXG5cXG4gIGZ1bmN0aW9uIHZpc2l0IChvYmosIGZpbGUpIHtcXG4gICAgdmFyIHN1aXRlO1xcbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XFxuICAgICAgaWYgKHR5cGVvZiBvYmpba2V5XSA9PT0gJ2Z1bmN0aW9uJykge1xcbiAgICAgICAgdmFyIGZuID0gb2JqW2tleV07XFxuICAgICAgICBzd2l0Y2ggKGtleSkge1xcbiAgICAgICAgICBjYXNlICdiZWZvcmUnOlxcbiAgICAgICAgICAgIHN1aXRlc1swXS5iZWZvcmVBbGwoZm4pO1xcbiAgICAgICAgICAgIGJyZWFrO1xcbiAgICAgICAgICBjYXNlICdhZnRlcic6XFxuICAgICAgICAgICAgc3VpdGVzWzBdLmFmdGVyQWxsKGZuKTtcXG4gICAgICAgICAgICBicmVhaztcXG4gICAgICAgICAgY2FzZSAnYmVmb3JlRWFjaCc6XFxuICAgICAgICAgICAgc3VpdGVzWzBdLmJlZm9yZUVhY2goZm4pO1xcbiAgICAgICAgICAgIGJyZWFrO1xcbiAgICAgICAgICBjYXNlICdhZnRlckVhY2gnOlxcbiAgICAgICAgICAgIHN1aXRlc1swXS5hZnRlckVhY2goZm4pO1xcbiAgICAgICAgICAgIGJyZWFrO1xcbiAgICAgICAgICBkZWZhdWx0OlxcbiAgICAgICAgICAgIHZhciB0ZXN0ID0gbmV3IFRlc3Qoa2V5LCBmbik7XFxuICAgICAgICAgICAgdGVzdC5maWxlID0gZmlsZTtcXG4gICAgICAgICAgICBzdWl0ZXNbMF0uYWRkVGVzdCh0ZXN0KTtcXG4gICAgICAgIH1cXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgc3VpdGUgPSBTdWl0ZS5jcmVhdGUoc3VpdGVzWzBdLCBrZXkpO1xcbiAgICAgICAgc3VpdGVzLnVuc2hpZnQoc3VpdGUpO1xcbiAgICAgICAgdmlzaXQob2JqW2tleV0sIGZpbGUpO1xcbiAgICAgICAgc3VpdGVzLnNoaWZ0KCk7XFxuICAgICAgfVxcbiAgICB9XFxuICB9XFxufTtcXG5cXG59LHtcXFwiLi4vc3VpdGVcXFwiOjM1LFxcXCIuLi90ZXN0XFxcIjozNn1dLDExOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcXG4ndXNlIHN0cmljdCc7XFxuXFxuZXhwb3J0cy5iZGQgPSByZXF1aXJlKCcuL2JkZCcpO1xcbmV4cG9ydHMudGRkID0gcmVxdWlyZSgnLi90ZGQnKTtcXG5leHBvcnRzLnF1bml0ID0gcmVxdWlyZSgnLi9xdW5pdCcpO1xcbmV4cG9ydHMuZXhwb3J0cyA9IHJlcXVpcmUoJy4vZXhwb3J0cycpO1xcblxcbn0se1xcXCIuL2JkZFxcXCI6OCxcXFwiLi9leHBvcnRzXFxcIjoxMCxcXFwiLi9xdW5pdFxcXCI6MTIsXFxcIi4vdGRkXFxcIjoxM31dLDEyOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcXG4ndXNlIHN0cmljdCc7XFxuXFxuLyoqXFxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cXG4gKi9cXG5cXG52YXIgVGVzdCA9IHJlcXVpcmUoJy4uL3Rlc3QnKTtcXG5cXG4vKipcXG4gKiBRVW5pdC1zdHlsZSBpbnRlcmZhY2U6XFxuICpcXG4gKiAgICAgc3VpdGUoJ0FycmF5Jyk7XFxuICpcXG4gKiAgICAgdGVzdCgnI2xlbmd0aCcsIGZ1bmN0aW9uKCkge1xcbiAqICAgICAgIHZhciBhcnIgPSBbMSwyLDNdO1xcbiAqICAgICAgIG9rKGFyci5sZW5ndGggPT0gMyk7XFxuICogICAgIH0pO1xcbiAqXFxuICogICAgIHRlc3QoJyNpbmRleE9mKCknLCBmdW5jdGlvbigpIHtcXG4gKiAgICAgICB2YXIgYXJyID0gWzEsMiwzXTtcXG4gKiAgICAgICBvayhhcnIuaW5kZXhPZigxKSA9PSAwKTtcXG4gKiAgICAgICBvayhhcnIuaW5kZXhPZigyKSA9PSAxKTtcXG4gKiAgICAgICBvayhhcnIuaW5kZXhPZigzKSA9PSAyKTtcXG4gKiAgICAgfSk7XFxuICpcXG4gKiAgICAgc3VpdGUoJ1N0cmluZycpO1xcbiAqXFxuICogICAgIHRlc3QoJyNsZW5ndGgnLCBmdW5jdGlvbigpIHtcXG4gKiAgICAgICBvaygnZm9vJy5sZW5ndGggPT0gMyk7XFxuICogICAgIH0pO1xcbiAqXFxuICogQHBhcmFtIHtTdWl0ZX0gc3VpdGUgUm9vdCBzdWl0ZS5cXG4gKi9cXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChzdWl0ZSkge1xcbiAgdmFyIHN1aXRlcyA9IFtzdWl0ZV07XFxuXFxuICBzdWl0ZS5vbigncHJlLXJlcXVpcmUnLCBmdW5jdGlvbiAoY29udGV4dCwgZmlsZSwgbW9jaGEpIHtcXG4gICAgdmFyIGNvbW1vbiA9IHJlcXVpcmUoJy4vY29tbW9uJykoc3VpdGVzLCBjb250ZXh0LCBtb2NoYSk7XFxuXFxuICAgIGNvbnRleHQuYmVmb3JlID0gY29tbW9uLmJlZm9yZTtcXG4gICAgY29udGV4dC5hZnRlciA9IGNvbW1vbi5hZnRlcjtcXG4gICAgY29udGV4dC5iZWZvcmVFYWNoID0gY29tbW9uLmJlZm9yZUVhY2g7XFxuICAgIGNvbnRleHQuYWZ0ZXJFYWNoID0gY29tbW9uLmFmdGVyRWFjaDtcXG4gICAgY29udGV4dC5ydW4gPSBtb2NoYS5vcHRpb25zLmRlbGF5ICYmIGNvbW1vbi5ydW5XaXRoU3VpdGUoc3VpdGUpO1xcbiAgICAvKipcXG4gICAgICogRGVzY3JpYmUgYSBcXFwic3VpdGVcXFwiIHdpdGggdGhlIGdpdmVuIGB0aXRsZWAuXFxuICAgICAqL1xcblxcbiAgICBjb250ZXh0LnN1aXRlID0gZnVuY3Rpb24gKHRpdGxlKSB7XFxuICAgICAgaWYgKHN1aXRlcy5sZW5ndGggPiAxKSB7XFxuICAgICAgICBzdWl0ZXMuc2hpZnQoKTtcXG4gICAgICB9XFxuICAgICAgcmV0dXJuIGNvbW1vbi5zdWl0ZS5jcmVhdGUoe1xcbiAgICAgICAgdGl0bGU6IHRpdGxlLFxcbiAgICAgICAgZmlsZTogZmlsZSxcXG4gICAgICAgIGZuOiBmYWxzZVxcbiAgICAgIH0pO1xcbiAgICB9O1xcblxcbiAgICAvKipcXG4gICAgICogRXhjbHVzaXZlIFN1aXRlLlxcbiAgICAgKi9cXG5cXG4gICAgY29udGV4dC5zdWl0ZS5vbmx5ID0gZnVuY3Rpb24gKHRpdGxlKSB7XFxuICAgICAgaWYgKHN1aXRlcy5sZW5ndGggPiAxKSB7XFxuICAgICAgICBzdWl0ZXMuc2hpZnQoKTtcXG4gICAgICB9XFxuICAgICAgcmV0dXJuIGNvbW1vbi5zdWl0ZS5vbmx5KHtcXG4gICAgICAgIHRpdGxlOiB0aXRsZSxcXG4gICAgICAgIGZpbGU6IGZpbGUsXFxuICAgICAgICBmbjogZmFsc2VcXG4gICAgICB9KTtcXG4gICAgfTtcXG5cXG4gICAgLyoqXFxuICAgICAqIERlc2NyaWJlIGEgc3BlY2lmaWNhdGlvbiBvciB0ZXN0LWNhc2VcXG4gICAgICogd2l0aCB0aGUgZ2l2ZW4gYHRpdGxlYCBhbmQgY2FsbGJhY2sgYGZuYFxcbiAgICAgKiBhY3RpbmcgYXMgYSB0aHVuay5cXG4gICAgICovXFxuXFxuICAgIGNvbnRleHQudGVzdCA9IGZ1bmN0aW9uICh0aXRsZSwgZm4pIHtcXG4gICAgICB2YXIgdGVzdCA9IG5ldyBUZXN0KHRpdGxlLCBmbik7XFxuICAgICAgdGVzdC5maWxlID0gZmlsZTtcXG4gICAgICBzdWl0ZXNbMF0uYWRkVGVzdCh0ZXN0KTtcXG4gICAgICByZXR1cm4gdGVzdDtcXG4gICAgfTtcXG5cXG4gICAgLyoqXFxuICAgICAqIEV4Y2x1c2l2ZSB0ZXN0LWNhc2UuXFxuICAgICAqL1xcblxcbiAgICBjb250ZXh0LnRlc3Qub25seSA9IGZ1bmN0aW9uICh0aXRsZSwgZm4pIHtcXG4gICAgICByZXR1cm4gY29tbW9uLnRlc3Qub25seShtb2NoYSwgY29udGV4dC50ZXN0KHRpdGxlLCBmbikpO1xcbiAgICB9O1xcblxcbiAgICBjb250ZXh0LnRlc3Quc2tpcCA9IGNvbW1vbi50ZXN0LnNraXA7XFxuICAgIGNvbnRleHQudGVzdC5yZXRyaWVzID0gY29tbW9uLnRlc3QucmV0cmllcztcXG4gIH0pO1xcbn07XFxuXFxufSx7XFxcIi4uL3Rlc3RcXFwiOjM2LFxcXCIuL2NvbW1vblxcXCI6OX1dLDEzOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcXG4ndXNlIHN0cmljdCc7XFxuXFxuLyoqXFxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cXG4gKi9cXG5cXG52YXIgVGVzdCA9IHJlcXVpcmUoJy4uL3Rlc3QnKTtcXG5cXG4vKipcXG4gKiBUREQtc3R5bGUgaW50ZXJmYWNlOlxcbiAqXFxuICogICAgICBzdWl0ZSgnQXJyYXknLCBmdW5jdGlvbigpIHtcXG4gKiAgICAgICAgc3VpdGUoJyNpbmRleE9mKCknLCBmdW5jdGlvbigpIHtcXG4gKiAgICAgICAgICBzdWl0ZVNldHVwKGZ1bmN0aW9uKCkge1xcbiAqXFxuICogICAgICAgICAgfSk7XFxuICpcXG4gKiAgICAgICAgICB0ZXN0KCdzaG91bGQgcmV0dXJuIC0xIHdoZW4gbm90IHByZXNlbnQnLCBmdW5jdGlvbigpIHtcXG4gKlxcbiAqICAgICAgICAgIH0pO1xcbiAqXFxuICogICAgICAgICAgdGVzdCgnc2hvdWxkIHJldHVybiB0aGUgaW5kZXggd2hlbiBwcmVzZW50JywgZnVuY3Rpb24oKSB7XFxuICpcXG4gKiAgICAgICAgICB9KTtcXG4gKlxcbiAqICAgICAgICAgIHN1aXRlVGVhcmRvd24oZnVuY3Rpb24oKSB7XFxuICpcXG4gKiAgICAgICAgICB9KTtcXG4gKiAgICAgICAgfSk7XFxuICogICAgICB9KTtcXG4gKlxcbiAqIEBwYXJhbSB7U3VpdGV9IHN1aXRlIFJvb3Qgc3VpdGUuXFxuICovXFxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoc3VpdGUpIHtcXG4gIHZhciBzdWl0ZXMgPSBbc3VpdGVdO1xcblxcbiAgc3VpdGUub24oJ3ByZS1yZXF1aXJlJywgZnVuY3Rpb24gKGNvbnRleHQsIGZpbGUsIG1vY2hhKSB7XFxuICAgIHZhciBjb21tb24gPSByZXF1aXJlKCcuL2NvbW1vbicpKHN1aXRlcywgY29udGV4dCwgbW9jaGEpO1xcblxcbiAgICBjb250ZXh0LnNldHVwID0gY29tbW9uLmJlZm9yZUVhY2g7XFxuICAgIGNvbnRleHQudGVhcmRvd24gPSBjb21tb24uYWZ0ZXJFYWNoO1xcbiAgICBjb250ZXh0LnN1aXRlU2V0dXAgPSBjb21tb24uYmVmb3JlO1xcbiAgICBjb250ZXh0LnN1aXRlVGVhcmRvd24gPSBjb21tb24uYWZ0ZXI7XFxuICAgIGNvbnRleHQucnVuID0gbW9jaGEub3B0aW9ucy5kZWxheSAmJiBjb21tb24ucnVuV2l0aFN1aXRlKHN1aXRlKTtcXG5cXG4gICAgLyoqXFxuICAgICAqIERlc2NyaWJlIGEgXFxcInN1aXRlXFxcIiB3aXRoIHRoZSBnaXZlbiBgdGl0bGVgIGFuZCBjYWxsYmFjayBgZm5gIGNvbnRhaW5pbmdcXG4gICAgICogbmVzdGVkIHN1aXRlcyBhbmQvb3IgdGVzdHMuXFxuICAgICAqL1xcbiAgICBjb250ZXh0LnN1aXRlID0gZnVuY3Rpb24gKHRpdGxlLCBmbikge1xcbiAgICAgIHJldHVybiBjb21tb24uc3VpdGUuY3JlYXRlKHtcXG4gICAgICAgIHRpdGxlOiB0aXRsZSxcXG4gICAgICAgIGZpbGU6IGZpbGUsXFxuICAgICAgICBmbjogZm5cXG4gICAgICB9KTtcXG4gICAgfTtcXG5cXG4gICAgLyoqXFxuICAgICAqIFBlbmRpbmcgc3VpdGUuXFxuICAgICAqL1xcbiAgICBjb250ZXh0LnN1aXRlLnNraXAgPSBmdW5jdGlvbiAodGl0bGUsIGZuKSB7XFxuICAgICAgcmV0dXJuIGNvbW1vbi5zdWl0ZS5za2lwKHtcXG4gICAgICAgIHRpdGxlOiB0aXRsZSxcXG4gICAgICAgIGZpbGU6IGZpbGUsXFxuICAgICAgICBmbjogZm5cXG4gICAgICB9KTtcXG4gICAgfTtcXG5cXG4gICAgLyoqXFxuICAgICAqIEV4Y2x1c2l2ZSB0ZXN0LWNhc2UuXFxuICAgICAqL1xcbiAgICBjb250ZXh0LnN1aXRlLm9ubHkgPSBmdW5jdGlvbiAodGl0bGUsIGZuKSB7XFxuICAgICAgcmV0dXJuIGNvbW1vbi5zdWl0ZS5vbmx5KHtcXG4gICAgICAgIHRpdGxlOiB0aXRsZSxcXG4gICAgICAgIGZpbGU6IGZpbGUsXFxuICAgICAgICBmbjogZm5cXG4gICAgICB9KTtcXG4gICAgfTtcXG5cXG4gICAgLyoqXFxuICAgICAqIERlc2NyaWJlIGEgc3BlY2lmaWNhdGlvbiBvciB0ZXN0LWNhc2Ugd2l0aCB0aGUgZ2l2ZW4gYHRpdGxlYCBhbmRcXG4gICAgICogY2FsbGJhY2sgYGZuYCBhY3RpbmcgYXMgYSB0aHVuay5cXG4gICAgICovXFxuICAgIGNvbnRleHQudGVzdCA9IGZ1bmN0aW9uICh0aXRsZSwgZm4pIHtcXG4gICAgICB2YXIgc3VpdGUgPSBzdWl0ZXNbMF07XFxuICAgICAgaWYgKHN1aXRlLmlzUGVuZGluZygpKSB7XFxuICAgICAgICBmbiA9IG51bGw7XFxuICAgICAgfVxcbiAgICAgIHZhciB0ZXN0ID0gbmV3IFRlc3QodGl0bGUsIGZuKTtcXG4gICAgICB0ZXN0LmZpbGUgPSBmaWxlO1xcbiAgICAgIHN1aXRlLmFkZFRlc3QodGVzdCk7XFxuICAgICAgcmV0dXJuIHRlc3Q7XFxuICAgIH07XFxuXFxuICAgIC8qKlxcbiAgICAgKiBFeGNsdXNpdmUgdGVzdC1jYXNlLlxcbiAgICAgKi9cXG5cXG4gICAgY29udGV4dC50ZXN0Lm9ubHkgPSBmdW5jdGlvbiAodGl0bGUsIGZuKSB7XFxuICAgICAgcmV0dXJuIGNvbW1vbi50ZXN0Lm9ubHkobW9jaGEsIGNvbnRleHQudGVzdCh0aXRsZSwgZm4pKTtcXG4gICAgfTtcXG5cXG4gICAgY29udGV4dC50ZXN0LnNraXAgPSBjb21tb24udGVzdC5za2lwO1xcbiAgICBjb250ZXh0LnRlc3QucmV0cmllcyA9IGNvbW1vbi50ZXN0LnJldHJpZXM7XFxuICB9KTtcXG59O1xcblxcbn0se1xcXCIuLi90ZXN0XFxcIjozNixcXFwiLi9jb21tb25cXFwiOjl9XSwxNDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XFxuKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCxfX2Rpcm5hbWUpe1xcbid1c2Ugc3RyaWN0JztcXG5cXG4vKiFcXG4gKiBtb2NoYVxcbiAqIENvcHlyaWdodChjKSAyMDExIFRKIEhvbG93YXljaHVrIDx0akB2aXNpb24tbWVkaWEuY2E+XFxuICogTUlUIExpY2Vuc2VkXFxuICovXFxuXFxuLyoqXFxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cXG4gKi9cXG5cXG52YXIgZXNjYXBlUmUgPSByZXF1aXJlKCdlc2NhcGUtc3RyaW5nLXJlZ2V4cCcpO1xcbnZhciBwYXRoID0gcmVxdWlyZSgncGF0aCcpO1xcbnZhciByZXBvcnRlcnMgPSByZXF1aXJlKCcuL3JlcG9ydGVycycpO1xcbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcXG5cXG4vKipcXG4gKiBFeHBvc2UgYE1vY2hhYC5cXG4gKi9cXG5cXG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBNb2NoYTtcXG5cXG4vKipcXG4gKiBUbyByZXF1aXJlIGxvY2FsIFVJcyBhbmQgcmVwb3J0ZXJzIHdoZW4gcnVubmluZyBpbiBub2RlLlxcbiAqL1xcblxcbmlmICghcHJvY2Vzcy5icm93c2VyKSB7XFxuICB2YXIgY3dkID0gcHJvY2Vzcy5jd2QoKTtcXG4gIG1vZHVsZS5wYXRocy5wdXNoKGN3ZCwgcGF0aC5qb2luKGN3ZCwgJ25vZGVfbW9kdWxlcycpKTtcXG59XFxuXFxuLyoqXFxuICogRXhwb3NlIGludGVybmFscy5cXG4gKi9cXG5cXG5leHBvcnRzLnV0aWxzID0gdXRpbHM7XFxuZXhwb3J0cy5pbnRlcmZhY2VzID0gcmVxdWlyZSgnLi9pbnRlcmZhY2VzJyk7XFxuZXhwb3J0cy5yZXBvcnRlcnMgPSByZXBvcnRlcnM7XFxuZXhwb3J0cy5SdW5uYWJsZSA9IHJlcXVpcmUoJy4vcnVubmFibGUnKTtcXG5leHBvcnRzLkNvbnRleHQgPSByZXF1aXJlKCcuL2NvbnRleHQnKTtcXG5leHBvcnRzLlJ1bm5lciA9IHJlcXVpcmUoJy4vcnVubmVyJyk7XFxuZXhwb3J0cy5TdWl0ZSA9IHJlcXVpcmUoJy4vc3VpdGUnKTtcXG5leHBvcnRzLkhvb2sgPSByZXF1aXJlKCcuL2hvb2snKTtcXG5leHBvcnRzLlRlc3QgPSByZXF1aXJlKCcuL3Rlc3QnKTtcXG5cXG4vKipcXG4gKiBSZXR1cm4gaW1hZ2UgYG5hbWVgIHBhdGguXFxuICpcXG4gKiBAYXBpIHByaXZhdGVcXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxcbiAqIEByZXR1cm4ge3N0cmluZ31cXG4gKi9cXG5mdW5jdGlvbiBpbWFnZSAobmFtZSkge1xcbiAgcmV0dXJuIHBhdGguam9pbihfX2Rpcm5hbWUsICcuLi9pbWFnZXMnLCBuYW1lICsgJy5wbmcnKTtcXG59XFxuXFxuLyoqXFxuICogU2V0IHVwIG1vY2hhIHdpdGggYG9wdGlvbnNgLlxcbiAqXFxuICogT3B0aW9uczpcXG4gKlxcbiAqICAgLSBgdWlgIG5hbWUgXFxcImJkZFxcXCIsIFxcXCJ0ZGRcXFwiLCBcXFwiZXhwb3J0c1xcXCIgZXRjXFxuICogICAtIGByZXBvcnRlcmAgcmVwb3J0ZXIgaW5zdGFuY2UsIGRlZmF1bHRzIHRvIGBtb2NoYS5yZXBvcnRlcnMuc3BlY2BcXG4gKiAgIC0gYGdsb2JhbHNgIGFycmF5IG9mIGFjY2VwdGVkIGdsb2JhbHNcXG4gKiAgIC0gYHRpbWVvdXRgIHRpbWVvdXQgaW4gbWlsbGlzZWNvbmRzXFxuICogICAtIGByZXRyaWVzYCBudW1iZXIgb2YgdGltZXMgdG8gcmV0cnkgZmFpbGVkIHRlc3RzXFxuICogICAtIGBiYWlsYCBiYWlsIG9uIHRoZSBmaXJzdCB0ZXN0IGZhaWx1cmVcXG4gKiAgIC0gYHNsb3dgIG1pbGxpc2Vjb25kcyB0byB3YWl0IGJlZm9yZSBjb25zaWRlcmluZyBhIHRlc3Qgc2xvd1xcbiAqICAgLSBgaWdub3JlTGVha3NgIGlnbm9yZSBnbG9iYWwgbGVha3NcXG4gKiAgIC0gYGZ1bGxUcmFjZWAgZGlzcGxheSB0aGUgZnVsbCBzdGFjay10cmFjZSBvbiBmYWlsaW5nXFxuICogICAtIGBncmVwYCBzdHJpbmcgb3IgcmVnZXhwIHRvIGZpbHRlciB0ZXN0cyB3aXRoXFxuICpcXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xcbiAqIEBhcGkgcHVibGljXFxuICovXFxuZnVuY3Rpb24gTW9jaGEgKG9wdGlvbnMpIHtcXG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xcbiAgdGhpcy5maWxlcyA9IFtdO1xcbiAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcXG4gIGlmIChvcHRpb25zLmdyZXApIHtcXG4gICAgdGhpcy5ncmVwKG5ldyBSZWdFeHAob3B0aW9ucy5ncmVwKSk7XFxuICB9XFxuICBpZiAob3B0aW9ucy5mZ3JlcCkge1xcbiAgICB0aGlzLmZncmVwKG9wdGlvbnMuZmdyZXApO1xcbiAgfVxcbiAgdGhpcy5zdWl0ZSA9IG5ldyBleHBvcnRzLlN1aXRlKCcnLCBuZXcgZXhwb3J0cy5Db250ZXh0KCkpO1xcbiAgdGhpcy51aShvcHRpb25zLnVpKTtcXG4gIHRoaXMuYmFpbChvcHRpb25zLmJhaWwpO1xcbiAgdGhpcy5yZXBvcnRlcihvcHRpb25zLnJlcG9ydGVyLCBvcHRpb25zLnJlcG9ydGVyT3B0aW9ucyk7XFxuICBpZiAodHlwZW9mIG9wdGlvbnMudGltZW91dCAhPT0gJ3VuZGVmaW5lZCcgJiYgb3B0aW9ucy50aW1lb3V0ICE9PSBudWxsKSB7XFxuICAgIHRoaXMudGltZW91dChvcHRpb25zLnRpbWVvdXQpO1xcbiAgfVxcbiAgaWYgKHR5cGVvZiBvcHRpb25zLnJldHJpZXMgIT09ICd1bmRlZmluZWQnICYmIG9wdGlvbnMucmV0cmllcyAhPT0gbnVsbCkge1xcbiAgICB0aGlzLnJldHJpZXMob3B0aW9ucy5yZXRyaWVzKTtcXG4gIH1cXG4gIHRoaXMudXNlQ29sb3JzKG9wdGlvbnMudXNlQ29sb3JzKTtcXG4gIGlmIChvcHRpb25zLmVuYWJsZVRpbWVvdXRzICE9PSBudWxsKSB7XFxuICAgIHRoaXMuZW5hYmxlVGltZW91dHMob3B0aW9ucy5lbmFibGVUaW1lb3V0cyk7XFxuICB9XFxuICBpZiAob3B0aW9ucy5zbG93KSB7XFxuICAgIHRoaXMuc2xvdyhvcHRpb25zLnNsb3cpO1xcbiAgfVxcbn1cXG5cXG4vKipcXG4gKiBFbmFibGUgb3IgZGlzYWJsZSBiYWlsaW5nIG9uIHRoZSBmaXJzdCBmYWlsdXJlLlxcbiAqXFxuICogQGFwaSBwdWJsaWNcXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtiYWlsXVxcbiAqL1xcbk1vY2hhLnByb3RvdHlwZS5iYWlsID0gZnVuY3Rpb24gKGJhaWwpIHtcXG4gIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xcbiAgICBiYWlsID0gdHJ1ZTtcXG4gIH1cXG4gIHRoaXMuc3VpdGUuYmFpbChiYWlsKTtcXG4gIHJldHVybiB0aGlzO1xcbn07XFxuXFxuLyoqXFxuICogQWRkIHRlc3QgYGZpbGVgLlxcbiAqXFxuICogQGFwaSBwdWJsaWNcXG4gKiBAcGFyYW0ge3N0cmluZ30gZmlsZVxcbiAqL1xcbk1vY2hhLnByb3RvdHlwZS5hZGRGaWxlID0gZnVuY3Rpb24gKGZpbGUpIHtcXG4gIHRoaXMuZmlsZXMucHVzaChmaWxlKTtcXG4gIHJldHVybiB0aGlzO1xcbn07XFxuXFxuLyoqXFxuICogU2V0IHJlcG9ydGVyIHRvIGByZXBvcnRlcmAsIGRlZmF1bHRzIHRvIFxcXCJzcGVjXFxcIi5cXG4gKlxcbiAqIEBwYXJhbSB7U3RyaW5nfEZ1bmN0aW9ufSByZXBvcnRlciBuYW1lIG9yIGNvbnN0cnVjdG9yXFxuICogQHBhcmFtIHtPYmplY3R9IHJlcG9ydGVyT3B0aW9ucyBvcHRpb25hbCBvcHRpb25zXFxuICogQGFwaSBwdWJsaWNcXG4gKiBAcGFyYW0ge3N0cmluZ3xGdW5jdGlvbn0gcmVwb3J0ZXIgbmFtZSBvciBjb25zdHJ1Y3RvclxcbiAqIEBwYXJhbSB7T2JqZWN0fSByZXBvcnRlck9wdGlvbnMgb3B0aW9uYWwgb3B0aW9uc1xcbiAqL1xcbk1vY2hhLnByb3RvdHlwZS5yZXBvcnRlciA9IGZ1bmN0aW9uIChyZXBvcnRlciwgcmVwb3J0ZXJPcHRpb25zKSB7XFxuICBpZiAodHlwZW9mIHJlcG9ydGVyID09PSAnZnVuY3Rpb24nKSB7XFxuICAgIHRoaXMuX3JlcG9ydGVyID0gcmVwb3J0ZXI7XFxuICB9IGVsc2Uge1xcbiAgICByZXBvcnRlciA9IHJlcG9ydGVyIHx8ICdzcGVjJztcXG4gICAgdmFyIF9yZXBvcnRlcjtcXG4gICAgLy8gVHJ5IHRvIGxvYWQgYSBidWlsdC1pbiByZXBvcnRlci5cXG4gICAgaWYgKHJlcG9ydGVyc1tyZXBvcnRlcl0pIHtcXG4gICAgICBfcmVwb3J0ZXIgPSByZXBvcnRlcnNbcmVwb3J0ZXJdO1xcbiAgICB9XFxuICAgIC8vIFRyeSB0byBsb2FkIHJlcG9ydGVycyBmcm9tIHByb2Nlc3MuY3dkKCkgYW5kIG5vZGVfbW9kdWxlc1xcbiAgICBpZiAoIV9yZXBvcnRlcikge1xcbiAgICAgIHRyeSB7XFxuICAgICAgICBfcmVwb3J0ZXIgPSByZXF1aXJlKHJlcG9ydGVyKTtcXG4gICAgICB9IGNhdGNoIChlcnIpIHtcXG4gICAgICAgIGlmIChlcnIubWVzc2FnZS5pbmRleE9mKCdDYW5ub3QgZmluZCBtb2R1bGUnKSAhPT0gLTEpIHtcXG4gICAgICAgICAgLy8gVHJ5IHRvIGxvYWQgcmVwb3J0ZXJzIGZyb20gYSBwYXRoIChhYnNvbHV0ZSBvciByZWxhdGl2ZSlcXG4gICAgICAgICAgdHJ5IHtcXG4gICAgICAgICAgICBfcmVwb3J0ZXIgPSByZXF1aXJlKHBhdGgucmVzb2x2ZShwcm9jZXNzLmN3ZCgpLCByZXBvcnRlcikpO1xcbiAgICAgICAgICB9IGNhdGNoIChfZXJyKSB7XFxuICAgICAgICAgICAgZXJyLm1lc3NhZ2UuaW5kZXhPZignQ2Fubm90IGZpbmQgbW9kdWxlJykgIT09IC0xID8gY29uc29sZS53YXJuKCdcXFwiJyArIHJlcG9ydGVyICsgJ1xcXCIgcmVwb3J0ZXIgbm90IGZvdW5kJylcXG4gICAgICAgICAgICAgIDogY29uc29sZS53YXJuKCdcXFwiJyArIHJlcG9ydGVyICsgJ1xcXCIgcmVwb3J0ZXIgYmxldyB1cCB3aXRoIGVycm9yOlxcXFxuJyArIGVyci5zdGFjayk7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgIGNvbnNvbGUud2FybignXFxcIicgKyByZXBvcnRlciArICdcXFwiIHJlcG9ydGVyIGJsZXcgdXAgd2l0aCBlcnJvcjpcXFxcbicgKyBlcnIuc3RhY2spO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG4gICAgfVxcbiAgICBpZiAoIV9yZXBvcnRlciAmJiByZXBvcnRlciA9PT0gJ3RlYW1jaXR5Jykge1xcbiAgICAgIGNvbnNvbGUud2FybignVGhlIFRlYW1jaXR5IHJlcG9ydGVyIHdhcyBtb3ZlZCB0byBhIHBhY2thZ2UgbmFtZWQgJyArXFxuICAgICAgICAnbW9jaGEtdGVhbWNpdHktcmVwb3J0ZXIgJyArXFxuICAgICAgICAnKGh0dHBzOi8vbnBtanMub3JnL3BhY2thZ2UvbW9jaGEtdGVhbWNpdHktcmVwb3J0ZXIpLicpO1xcbiAgICB9XFxuICAgIGlmICghX3JlcG9ydGVyKSB7XFxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIHJlcG9ydGVyIFxcXCInICsgcmVwb3J0ZXIgKyAnXFxcIicpO1xcbiAgICB9XFxuICAgIHRoaXMuX3JlcG9ydGVyID0gX3JlcG9ydGVyO1xcbiAgfVxcbiAgdGhpcy5vcHRpb25zLnJlcG9ydGVyT3B0aW9ucyA9IHJlcG9ydGVyT3B0aW9ucztcXG4gIHJldHVybiB0aGlzO1xcbn07XFxuXFxuLyoqXFxuICogU2V0IHRlc3QgVUkgYG5hbWVgLCBkZWZhdWx0cyB0byBcXFwiYmRkXFxcIi5cXG4gKlxcbiAqIEBhcGkgcHVibGljXFxuICogQHBhcmFtIHtzdHJpbmd9IGJkZFxcbiAqL1xcbk1vY2hhLnByb3RvdHlwZS51aSA9IGZ1bmN0aW9uIChuYW1lKSB7XFxuICBuYW1lID0gbmFtZSB8fCAnYmRkJztcXG4gIHRoaXMuX3VpID0gZXhwb3J0cy5pbnRlcmZhY2VzW25hbWVdO1xcbiAgaWYgKCF0aGlzLl91aSkge1xcbiAgICB0cnkge1xcbiAgICAgIHRoaXMuX3VpID0gcmVxdWlyZShuYW1lKTtcXG4gICAgfSBjYXRjaCAoZXJyKSB7XFxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGludGVyZmFjZSBcXFwiJyArIG5hbWUgKyAnXFxcIicpO1xcbiAgICB9XFxuICB9XFxuICB0aGlzLl91aSA9IHRoaXMuX3VpKHRoaXMuc3VpdGUpO1xcblxcbiAgdGhpcy5zdWl0ZS5vbigncHJlLXJlcXVpcmUnLCBmdW5jdGlvbiAoY29udGV4dCkge1xcbiAgICBleHBvcnRzLmFmdGVyRWFjaCA9IGNvbnRleHQuYWZ0ZXJFYWNoIHx8IGNvbnRleHQudGVhcmRvd247XFxuICAgIGV4cG9ydHMuYWZ0ZXIgPSBjb250ZXh0LmFmdGVyIHx8IGNvbnRleHQuc3VpdGVUZWFyZG93bjtcXG4gICAgZXhwb3J0cy5iZWZvcmVFYWNoID0gY29udGV4dC5iZWZvcmVFYWNoIHx8IGNvbnRleHQuc2V0dXA7XFxuICAgIGV4cG9ydHMuYmVmb3JlID0gY29udGV4dC5iZWZvcmUgfHwgY29udGV4dC5zdWl0ZVNldHVwO1xcbiAgICBleHBvcnRzLmRlc2NyaWJlID0gY29udGV4dC5kZXNjcmliZSB8fCBjb250ZXh0LnN1aXRlO1xcbiAgICBleHBvcnRzLml0ID0gY29udGV4dC5pdCB8fCBjb250ZXh0LnRlc3Q7XFxuICAgIGV4cG9ydHMueGl0ID0gY29udGV4dC54aXQgfHwgY29udGV4dC50ZXN0LnNraXA7XFxuICAgIGV4cG9ydHMuc2V0dXAgPSBjb250ZXh0LnNldHVwIHx8IGNvbnRleHQuYmVmb3JlRWFjaDtcXG4gICAgZXhwb3J0cy5zdWl0ZVNldHVwID0gY29udGV4dC5zdWl0ZVNldHVwIHx8IGNvbnRleHQuYmVmb3JlO1xcbiAgICBleHBvcnRzLnN1aXRlVGVhcmRvd24gPSBjb250ZXh0LnN1aXRlVGVhcmRvd24gfHwgY29udGV4dC5hZnRlcjtcXG4gICAgZXhwb3J0cy5zdWl0ZSA9IGNvbnRleHQuc3VpdGUgfHwgY29udGV4dC5kZXNjcmliZTtcXG4gICAgZXhwb3J0cy50ZWFyZG93biA9IGNvbnRleHQudGVhcmRvd24gfHwgY29udGV4dC5hZnRlckVhY2g7XFxuICAgIGV4cG9ydHMudGVzdCA9IGNvbnRleHQudGVzdCB8fCBjb250ZXh0Lml0O1xcbiAgICBleHBvcnRzLnJ1biA9IGNvbnRleHQucnVuO1xcbiAgfSk7XFxuXFxuICByZXR1cm4gdGhpcztcXG59O1xcblxcbi8qKlxcbiAqIExvYWQgcmVnaXN0ZXJlZCBmaWxlcy5cXG4gKlxcbiAqIEBhcGkgcHJpdmF0ZVxcbiAqL1xcbk1vY2hhLnByb3RvdHlwZS5sb2FkRmlsZXMgPSBmdW5jdGlvbiAoZm4pIHtcXG4gIHZhciBzZWxmID0gdGhpcztcXG4gIHZhciBzdWl0ZSA9IHRoaXMuc3VpdGU7XFxuICB0aGlzLmZpbGVzLmZvckVhY2goZnVuY3Rpb24gKGZpbGUpIHtcXG4gICAgZmlsZSA9IHBhdGgucmVzb2x2ZShmaWxlKTtcXG4gICAgc3VpdGUuZW1pdCgncHJlLXJlcXVpcmUnLCBnbG9iYWwsIGZpbGUsIHNlbGYpO1xcbiAgICBzdWl0ZS5lbWl0KCdyZXF1aXJlJywgcmVxdWlyZShmaWxlKSwgZmlsZSwgc2VsZik7XFxuICAgIHN1aXRlLmVtaXQoJ3Bvc3QtcmVxdWlyZScsIGdsb2JhbCwgZmlsZSwgc2VsZik7XFxuICB9KTtcXG4gIGZuICYmIGZuKCk7XFxufTtcXG5cXG4vKipcXG4gKiBFbmFibGUgZ3Jvd2wgc3VwcG9ydC5cXG4gKlxcbiAqIEBhcGkgcHJpdmF0ZVxcbiAqL1xcbk1vY2hhLnByb3RvdHlwZS5fZ3Jvd2wgPSBmdW5jdGlvbiAocnVubmVyLCByZXBvcnRlcikge1xcbiAgdmFyIG5vdGlmeSA9IHJlcXVpcmUoJ2dyb3dsJyk7XFxuXFxuICBydW5uZXIub24oJ2VuZCcsIGZ1bmN0aW9uICgpIHtcXG4gICAgdmFyIHN0YXRzID0gcmVwb3J0ZXIuc3RhdHM7XFxuICAgIGlmIChzdGF0cy5mYWlsdXJlcykge1xcbiAgICAgIHZhciBtc2cgPSBzdGF0cy5mYWlsdXJlcyArICcgb2YgJyArIHJ1bm5lci50b3RhbCArICcgdGVzdHMgZmFpbGVkJztcXG4gICAgICBub3RpZnkobXNnLCB7IG5hbWU6ICdtb2NoYScsIHRpdGxlOiAnRmFpbGVkJywgaW1hZ2U6IGltYWdlKCdlcnJvcicpIH0pO1xcbiAgICB9IGVsc2Uge1xcbiAgICAgIG5vdGlmeShzdGF0cy5wYXNzZXMgKyAnIHRlc3RzIHBhc3NlZCBpbiAnICsgc3RhdHMuZHVyYXRpb24gKyAnbXMnLCB7XFxuICAgICAgICBuYW1lOiAnbW9jaGEnLFxcbiAgICAgICAgdGl0bGU6ICdQYXNzZWQnLFxcbiAgICAgICAgaW1hZ2U6IGltYWdlKCdvaycpXFxuICAgICAgfSk7XFxuICAgIH1cXG4gIH0pO1xcbn07XFxuXFxuLyoqXFxuICogRXNjYXBlIHN0cmluZyBhbmQgYWRkIGl0IHRvIGdyZXAgYXMgYSByZWdleHAuXFxuICpcXG4gKiBAYXBpIHB1YmxpY1xcbiAqIEBwYXJhbSBzdHJcXG4gKiBAcmV0dXJucyB7TW9jaGF9XFxuICovXFxuTW9jaGEucHJvdG90eXBlLmZncmVwID0gZnVuY3Rpb24gKHN0cikge1xcbiAgcmV0dXJuIHRoaXMuZ3JlcChuZXcgUmVnRXhwKGVzY2FwZVJlKHN0cikpKTtcXG59O1xcblxcbi8qKlxcbiAqIEFkZCByZWdleHAgdG8gZ3JlcCwgaWYgYHJlYCBpcyBhIHN0cmluZyBpdCBpcyBlc2NhcGVkLlxcbiAqXFxuICogQHBhcmFtIHtSZWdFeHB8U3RyaW5nfSByZVxcbiAqIEByZXR1cm4ge01vY2hhfVxcbiAqIEBhcGkgcHVibGljXFxuICogQHBhcmFtIHtSZWdFeHB8c3RyaW5nfSByZVxcbiAqIEByZXR1cm4ge01vY2hhfVxcbiAqL1xcbk1vY2hhLnByb3RvdHlwZS5ncmVwID0gZnVuY3Rpb24gKHJlKSB7XFxuICBpZiAodXRpbHMuaXNTdHJpbmcocmUpKSB7XFxuICAgIC8vIGV4dHJhY3QgYXJncyBpZiBpdCdzIHJlZ2V4LWxpa2UsIGkuZTogW3N0cmluZywgcGF0dGVybiwgZmxhZ11cXG4gICAgdmFyIGFyZyA9IHJlLm1hdGNoKC9eXFxcXC8oLiopXFxcXC8oZ3xpfCkkfC4qLyk7XFxuICAgIHRoaXMub3B0aW9ucy5ncmVwID0gbmV3IFJlZ0V4cChhcmdbMV0gfHwgYXJnWzBdLCBhcmdbMl0pO1xcbiAgfSBlbHNlIHtcXG4gICAgdGhpcy5vcHRpb25zLmdyZXAgPSByZTtcXG4gIH1cXG4gIHJldHVybiB0aGlzO1xcbn07XFxuLyoqXFxuICogSW52ZXJ0IGAuZ3JlcCgpYCBtYXRjaGVzLlxcbiAqXFxuICogQHJldHVybiB7TW9jaGF9XFxuICogQGFwaSBwdWJsaWNcXG4gKi9cXG5Nb2NoYS5wcm90b3R5cGUuaW52ZXJ0ID0gZnVuY3Rpb24gKCkge1xcbiAgdGhpcy5vcHRpb25zLmludmVydCA9IHRydWU7XFxuICByZXR1cm4gdGhpcztcXG59O1xcblxcbi8qKlxcbiAqIElnbm9yZSBnbG9iYWwgbGVha3MuXFxuICpcXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGlnbm9yZVxcbiAqIEByZXR1cm4ge01vY2hhfVxcbiAqIEBhcGkgcHVibGljXFxuICogQHBhcmFtIHtib29sZWFufSBpZ25vcmVcXG4gKiBAcmV0dXJuIHtNb2NoYX1cXG4gKi9cXG5Nb2NoYS5wcm90b3R5cGUuaWdub3JlTGVha3MgPSBmdW5jdGlvbiAoaWdub3JlKSB7XFxuICB0aGlzLm9wdGlvbnMuaWdub3JlTGVha3MgPSBCb29sZWFuKGlnbm9yZSk7XFxuICByZXR1cm4gdGhpcztcXG59O1xcblxcbi8qKlxcbiAqIEVuYWJsZSBnbG9iYWwgbGVhayBjaGVja2luZy5cXG4gKlxcbiAqIEByZXR1cm4ge01vY2hhfVxcbiAqIEBhcGkgcHVibGljXFxuICovXFxuTW9jaGEucHJvdG90eXBlLmNoZWNrTGVha3MgPSBmdW5jdGlvbiAoKSB7XFxuICB0aGlzLm9wdGlvbnMuaWdub3JlTGVha3MgPSBmYWxzZTtcXG4gIHJldHVybiB0aGlzO1xcbn07XFxuXFxuLyoqXFxuICogRGlzcGxheSBsb25nIHN0YWNrLXRyYWNlIG9uIGZhaWxpbmdcXG4gKlxcbiAqIEByZXR1cm4ge01vY2hhfVxcbiAqIEBhcGkgcHVibGljXFxuICovXFxuTW9jaGEucHJvdG90eXBlLmZ1bGxUcmFjZSA9IGZ1bmN0aW9uICgpIHtcXG4gIHRoaXMub3B0aW9ucy5mdWxsU3RhY2tUcmFjZSA9IHRydWU7XFxuICByZXR1cm4gdGhpcztcXG59O1xcblxcbi8qKlxcbiAqIEVuYWJsZSBncm93bCBzdXBwb3J0LlxcbiAqXFxuICogQHJldHVybiB7TW9jaGF9XFxuICogQGFwaSBwdWJsaWNcXG4gKi9cXG5Nb2NoYS5wcm90b3R5cGUuZ3Jvd2wgPSBmdW5jdGlvbiAoKSB7XFxuICB0aGlzLm9wdGlvbnMuZ3Jvd2wgPSB0cnVlO1xcbiAgcmV0dXJuIHRoaXM7XFxufTtcXG5cXG4vKipcXG4gKiBJZ25vcmUgYGdsb2JhbHNgIGFycmF5IG9yIHN0cmluZy5cXG4gKlxcbiAqIEBwYXJhbSB7QXJyYXl8U3RyaW5nfSBnbG9iYWxzXFxuICogQHJldHVybiB7TW9jaGF9XFxuICogQGFwaSBwdWJsaWNcXG4gKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gZ2xvYmFsc1xcbiAqIEByZXR1cm4ge01vY2hhfVxcbiAqL1xcbk1vY2hhLnByb3RvdHlwZS5nbG9iYWxzID0gZnVuY3Rpb24gKGdsb2JhbHMpIHtcXG4gIHRoaXMub3B0aW9ucy5nbG9iYWxzID0gKHRoaXMub3B0aW9ucy5nbG9iYWxzIHx8IFtdKS5jb25jYXQoZ2xvYmFscyk7XFxuICByZXR1cm4gdGhpcztcXG59O1xcblxcbi8qKlxcbiAqIEVtaXQgY29sb3Igb3V0cHV0LlxcbiAqXFxuICogQHBhcmFtIHtCb29sZWFufSBjb2xvcnNcXG4gKiBAcmV0dXJuIHtNb2NoYX1cXG4gKiBAYXBpIHB1YmxpY1xcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gY29sb3JzXFxuICogQHJldHVybiB7TW9jaGF9XFxuICovXFxuTW9jaGEucHJvdG90eXBlLnVzZUNvbG9ycyA9IGZ1bmN0aW9uIChjb2xvcnMpIHtcXG4gIGlmIChjb2xvcnMgIT09IHVuZGVmaW5lZCkge1xcbiAgICB0aGlzLm9wdGlvbnMudXNlQ29sb3JzID0gY29sb3JzO1xcbiAgfVxcbiAgcmV0dXJuIHRoaXM7XFxufTtcXG5cXG4vKipcXG4gKiBVc2UgaW5saW5lIGRpZmZzIHJhdGhlciB0aGFuICsvLS5cXG4gKlxcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gaW5saW5lRGlmZnNcXG4gKiBAcmV0dXJuIHtNb2NoYX1cXG4gKiBAYXBpIHB1YmxpY1xcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gaW5saW5lRGlmZnNcXG4gKiBAcmV0dXJuIHtNb2NoYX1cXG4gKi9cXG5Nb2NoYS5wcm90b3R5cGUudXNlSW5saW5lRGlmZnMgPSBmdW5jdGlvbiAoaW5saW5lRGlmZnMpIHtcXG4gIHRoaXMub3B0aW9ucy51c2VJbmxpbmVEaWZmcyA9IGlubGluZURpZmZzICE9PSB1bmRlZmluZWQgJiYgaW5saW5lRGlmZnM7XFxuICByZXR1cm4gdGhpcztcXG59O1xcblxcbi8qKlxcbiAqIFNldCB0aGUgdGltZW91dCBpbiBtaWxsaXNlY29uZHMuXFxuICpcXG4gKiBAcGFyYW0ge051bWJlcn0gdGltZW91dFxcbiAqIEByZXR1cm4ge01vY2hhfVxcbiAqIEBhcGkgcHVibGljXFxuICogQHBhcmFtIHtudW1iZXJ9IHRpbWVvdXRcXG4gKiBAcmV0dXJuIHtNb2NoYX1cXG4gKi9cXG5Nb2NoYS5wcm90b3R5cGUudGltZW91dCA9IGZ1bmN0aW9uICh0aW1lb3V0KSB7XFxuICB0aGlzLnN1aXRlLnRpbWVvdXQodGltZW91dCk7XFxuICByZXR1cm4gdGhpcztcXG59O1xcblxcbi8qKlxcbiAqIFNldCB0aGUgbnVtYmVyIG9mIHRpbWVzIHRvIHJldHJ5IGZhaWxlZCB0ZXN0cy5cXG4gKlxcbiAqIEBwYXJhbSB7TnVtYmVyfSByZXRyeSB0aW1lc1xcbiAqIEByZXR1cm4ge01vY2hhfVxcbiAqIEBhcGkgcHVibGljXFxuICovXFxuTW9jaGEucHJvdG90eXBlLnJldHJpZXMgPSBmdW5jdGlvbiAobikge1xcbiAgdGhpcy5zdWl0ZS5yZXRyaWVzKG4pO1xcbiAgcmV0dXJuIHRoaXM7XFxufTtcXG5cXG4vKipcXG4gKiBTZXQgc2xvd25lc3MgdGhyZXNob2xkIGluIG1pbGxpc2Vjb25kcy5cXG4gKlxcbiAqIEBwYXJhbSB7TnVtYmVyfSBzbG93XFxuICogQHJldHVybiB7TW9jaGF9XFxuICogQGFwaSBwdWJsaWNcXG4gKiBAcGFyYW0ge251bWJlcn0gc2xvd1xcbiAqIEByZXR1cm4ge01vY2hhfVxcbiAqL1xcbk1vY2hhLnByb3RvdHlwZS5zbG93ID0gZnVuY3Rpb24gKHNsb3cpIHtcXG4gIHRoaXMuc3VpdGUuc2xvdyhzbG93KTtcXG4gIHJldHVybiB0aGlzO1xcbn07XFxuXFxuLyoqXFxuICogRW5hYmxlIHRpbWVvdXRzLlxcbiAqXFxuICogQHBhcmFtIHtCb29sZWFufSBlbmFibGVkXFxuICogQHJldHVybiB7TW9jaGF9XFxuICogQGFwaSBwdWJsaWNcXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGVuYWJsZWRcXG4gKiBAcmV0dXJuIHtNb2NoYX1cXG4gKi9cXG5Nb2NoYS5wcm90b3R5cGUuZW5hYmxlVGltZW91dHMgPSBmdW5jdGlvbiAoZW5hYmxlZCkge1xcbiAgdGhpcy5zdWl0ZS5lbmFibGVUaW1lb3V0cyhhcmd1bWVudHMubGVuZ3RoICYmIGVuYWJsZWQgIT09IHVuZGVmaW5lZCA/IGVuYWJsZWQgOiB0cnVlKTtcXG4gIHJldHVybiB0aGlzO1xcbn07XFxuXFxuLyoqXFxuICogTWFrZXMgYWxsIHRlc3RzIGFzeW5jIChhY2NlcHRpbmcgYSBjYWxsYmFjaylcXG4gKlxcbiAqIEByZXR1cm4ge01vY2hhfVxcbiAqIEBhcGkgcHVibGljXFxuICovXFxuTW9jaGEucHJvdG90eXBlLmFzeW5jT25seSA9IGZ1bmN0aW9uICgpIHtcXG4gIHRoaXMub3B0aW9ucy5hc3luY09ubHkgPSB0cnVlO1xcbiAgcmV0dXJuIHRoaXM7XFxufTtcXG5cXG4vKipcXG4gKiBEaXNhYmxlIHN5bnRheCBoaWdobGlnaHRpbmcgKGluIGJyb3dzZXIpLlxcbiAqXFxuICogQGFwaSBwdWJsaWNcXG4gKi9cXG5Nb2NoYS5wcm90b3R5cGUubm9IaWdobGlnaHRpbmcgPSBmdW5jdGlvbiAoKSB7XFxuICB0aGlzLm9wdGlvbnMubm9IaWdobGlnaHRpbmcgPSB0cnVlO1xcbiAgcmV0dXJuIHRoaXM7XFxufTtcXG5cXG4vKipcXG4gKiBFbmFibGUgdW5jYXVnaHQgZXJyb3JzIHRvIHByb3BhZ2F0ZSAoaW4gYnJvd3NlcikuXFxuICpcXG4gKiBAcmV0dXJuIHtNb2NoYX1cXG4gKiBAYXBpIHB1YmxpY1xcbiAqL1xcbk1vY2hhLnByb3RvdHlwZS5hbGxvd1VuY2F1Z2h0ID0gZnVuY3Rpb24gKCkge1xcbiAgdGhpcy5vcHRpb25zLmFsbG93VW5jYXVnaHQgPSB0cnVlO1xcbiAgcmV0dXJuIHRoaXM7XFxufTtcXG5cXG4vKipcXG4gKiBEZWxheSByb290IHN1aXRlIGV4ZWN1dGlvbi5cXG4gKiBAcmV0dXJucyB7TW9jaGF9XFxuICovXFxuTW9jaGEucHJvdG90eXBlLmRlbGF5ID0gZnVuY3Rpb24gZGVsYXkgKCkge1xcbiAgdGhpcy5vcHRpb25zLmRlbGF5ID0gdHJ1ZTtcXG4gIHJldHVybiB0aGlzO1xcbn07XFxuXFxuLyoqXFxuICogVGVzdHMgbWFya2VkIG9ubHkgZmFpbCB0aGUgc3VpdGVcXG4gKiBAcmV0dXJucyB7TW9jaGF9XFxuICovXFxuTW9jaGEucHJvdG90eXBlLmZvcmJpZE9ubHkgPSBmdW5jdGlvbiAoKSB7XFxuICB0aGlzLm9wdGlvbnMuZm9yYmlkT25seSA9IHRydWU7XFxuICByZXR1cm4gdGhpcztcXG59O1xcblxcbi8qKlxcbiAqIFBlbmRpbmcgdGVzdHMgYW5kIHRlc3RzIG1hcmtlZCBza2lwIGZhaWwgdGhlIHN1aXRlXFxuICogQHJldHVybnMge01vY2hhfVxcbiAqL1xcbk1vY2hhLnByb3RvdHlwZS5mb3JiaWRQZW5kaW5nID0gZnVuY3Rpb24gKCkge1xcbiAgdGhpcy5vcHRpb25zLmZvcmJpZFBlbmRpbmcgPSB0cnVlO1xcbiAgcmV0dXJuIHRoaXM7XFxufTtcXG5cXG4vKipcXG4gKiBSdW4gdGVzdHMgYW5kIGludm9rZSBgZm4oKWAgd2hlbiBjb21wbGV0ZS5cXG4gKlxcbiAqIEBhcGkgcHVibGljXFxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cXG4gKiBAcmV0dXJuIHtSdW5uZXJ9XFxuICovXFxuTW9jaGEucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uIChmbikge1xcbiAgaWYgKHRoaXMuZmlsZXMubGVuZ3RoKSB7XFxuICAgIHRoaXMubG9hZEZpbGVzKCk7XFxuICB9XFxuICB2YXIgc3VpdGUgPSB0aGlzLnN1aXRlO1xcbiAgdmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XFxuICBvcHRpb25zLmZpbGVzID0gdGhpcy5maWxlcztcXG4gIHZhciBydW5uZXIgPSBuZXcgZXhwb3J0cy5SdW5uZXIoc3VpdGUsIG9wdGlvbnMuZGVsYXkpO1xcbiAgdmFyIHJlcG9ydGVyID0gbmV3IHRoaXMuX3JlcG9ydGVyKHJ1bm5lciwgb3B0aW9ucyk7XFxuICBydW5uZXIuaWdub3JlTGVha3MgPSBvcHRpb25zLmlnbm9yZUxlYWtzICE9PSBmYWxzZTtcXG4gIHJ1bm5lci5mdWxsU3RhY2tUcmFjZSA9IG9wdGlvbnMuZnVsbFN0YWNrVHJhY2U7XFxuICBydW5uZXIuaGFzT25seSA9IG9wdGlvbnMuaGFzT25seTtcXG4gIHJ1bm5lci5hc3luY09ubHkgPSBvcHRpb25zLmFzeW5jT25seTtcXG4gIHJ1bm5lci5hbGxvd1VuY2F1Z2h0ID0gb3B0aW9ucy5hbGxvd1VuY2F1Z2h0O1xcbiAgcnVubmVyLmZvcmJpZE9ubHkgPSBvcHRpb25zLmZvcmJpZE9ubHk7XFxuICBydW5uZXIuZm9yYmlkUGVuZGluZyA9IG9wdGlvbnMuZm9yYmlkUGVuZGluZztcXG4gIGlmIChvcHRpb25zLmdyZXApIHtcXG4gICAgcnVubmVyLmdyZXAob3B0aW9ucy5ncmVwLCBvcHRpb25zLmludmVydCk7XFxuICB9XFxuICBpZiAob3B0aW9ucy5nbG9iYWxzKSB7XFxuICAgIHJ1bm5lci5nbG9iYWxzKG9wdGlvbnMuZ2xvYmFscyk7XFxuICB9XFxuICBpZiAob3B0aW9ucy5ncm93bCkge1xcbiAgICB0aGlzLl9ncm93bChydW5uZXIsIHJlcG9ydGVyKTtcXG4gIH1cXG4gIGlmIChvcHRpb25zLnVzZUNvbG9ycyAhPT0gdW5kZWZpbmVkKSB7XFxuICAgIGV4cG9ydHMucmVwb3J0ZXJzLkJhc2UudXNlQ29sb3JzID0gb3B0aW9ucy51c2VDb2xvcnM7XFxuICB9XFxuICBleHBvcnRzLnJlcG9ydGVycy5CYXNlLmlubGluZURpZmZzID0gb3B0aW9ucy51c2VJbmxpbmVEaWZmcztcXG5cXG4gIGZ1bmN0aW9uIGRvbmUgKGZhaWx1cmVzKSB7XFxuICAgIGlmIChyZXBvcnRlci5kb25lKSB7XFxuICAgICAgcmVwb3J0ZXIuZG9uZShmYWlsdXJlcywgZm4pO1xcbiAgICB9IGVsc2Uge1xcbiAgICAgIGZuICYmIGZuKGZhaWx1cmVzKTtcXG4gICAgfVxcbiAgfVxcblxcbiAgcmV0dXJuIHJ1bm5lci5ydW4oZG9uZSk7XFxufTtcXG5cXG59KS5jYWxsKHRoaXMscmVxdWlyZSgnX3Byb2Nlc3MnKSx0eXBlb2YgZ2xvYmFsICE9PSBcXFwidW5kZWZpbmVkXFxcIiA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSBcXFwidW5kZWZpbmVkXFxcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcXFwidW5kZWZpbmVkXFxcIiA/IHdpbmRvdyA6IHt9LFxcXCIvbGliXFxcIilcXG59LHtcXFwiLi9jb250ZXh0XFxcIjo2LFxcXCIuL2hvb2tcXFwiOjcsXFxcIi4vaW50ZXJmYWNlc1xcXCI6MTEsXFxcIi4vcmVwb3J0ZXJzXFxcIjoyMSxcXFwiLi9ydW5uYWJsZVxcXCI6MzMsXFxcIi4vcnVubmVyXFxcIjozNCxcXFwiLi9zdWl0ZVxcXCI6MzUsXFxcIi4vdGVzdFxcXCI6MzYsXFxcIi4vdXRpbHNcXFwiOjM4LFxcXCJfcHJvY2Vzc1xcXCI6ODIsXFxcImVzY2FwZS1zdHJpbmctcmVnZXhwXFxcIjo2MSxcXFwiZ3Jvd2xcXFwiOjYzLFxcXCJwYXRoXFxcIjo0Mn1dLDE1OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcXG4ndXNlIHN0cmljdCc7XFxuXFxuLyoqXFxuICogSGVscGVycy5cXG4gKi9cXG5cXG52YXIgcyA9IDEwMDA7XFxudmFyIG0gPSBzICogNjA7XFxudmFyIGggPSBtICogNjA7XFxudmFyIGQgPSBoICogMjQ7XFxudmFyIHkgPSBkICogMzY1LjI1O1xcblxcbi8qKlxcbiAqIFBhcnNlIG9yIGZvcm1hdCB0aGUgZ2l2ZW4gYHZhbGAuXFxuICpcXG4gKiBPcHRpb25zOlxcbiAqXFxuICogIC0gYGxvbmdgIHZlcmJvc2UgZm9ybWF0dGluZyBbZmFsc2VdXFxuICpcXG4gKiBAYXBpIHB1YmxpY1xcbiAqIEBwYXJhbSB7c3RyaW5nfG51bWJlcn0gdmFsXFxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcXG4gKiBAcmV0dXJuIHtzdHJpbmd8bnVtYmVyfVxcbiAqL1xcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHZhbCwgb3B0aW9ucykge1xcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XFxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHtcXG4gICAgcmV0dXJuIHBhcnNlKHZhbCk7XFxuICB9XFxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vbW9jaGFqcy9tb2NoYS9wdWxsLzEwMzVcXG4gIHJldHVybiBvcHRpb25zWydsb25nJ10gPyBsb25nRm9ybWF0KHZhbCkgOiBzaG9ydEZvcm1hdCh2YWwpO1xcbn07XFxuXFxuLyoqXFxuICogUGFyc2UgdGhlIGdpdmVuIGBzdHJgIGFuZCByZXR1cm4gbWlsbGlzZWNvbmRzLlxcbiAqXFxuICogQGFwaSBwcml2YXRlXFxuICogQHBhcmFtIHtzdHJpbmd9IHN0clxcbiAqIEByZXR1cm4ge251bWJlcn1cXG4gKi9cXG5mdW5jdGlvbiBwYXJzZSAoc3RyKSB7XFxuICB2YXIgbWF0Y2ggPSAoL14oKD86XFxcXGQrKT9cXFxcLj9cXFxcZCspICoobXN8c2Vjb25kcz98c3xtaW51dGVzP3xtfGhvdXJzP3xofGRheXM/fGR8eWVhcnM/fHkpPyQvaSkuZXhlYyhzdHIpO1xcbiAgaWYgKCFtYXRjaCkge1xcbiAgICByZXR1cm47XFxuICB9XFxuICB2YXIgbiA9IHBhcnNlRmxvYXQobWF0Y2hbMV0pO1xcbiAgdmFyIHR5cGUgPSAobWF0Y2hbMl0gfHwgJ21zJykudG9Mb3dlckNhc2UoKTtcXG4gIHN3aXRjaCAodHlwZSkge1xcbiAgICBjYXNlICd5ZWFycyc6XFxuICAgIGNhc2UgJ3llYXInOlxcbiAgICBjYXNlICd5JzpcXG4gICAgICByZXR1cm4gbiAqIHk7XFxuICAgIGNhc2UgJ2RheXMnOlxcbiAgICBjYXNlICdkYXknOlxcbiAgICBjYXNlICdkJzpcXG4gICAgICByZXR1cm4gbiAqIGQ7XFxuICAgIGNhc2UgJ2hvdXJzJzpcXG4gICAgY2FzZSAnaG91cic6XFxuICAgIGNhc2UgJ2gnOlxcbiAgICAgIHJldHVybiBuICogaDtcXG4gICAgY2FzZSAnbWludXRlcyc6XFxuICAgIGNhc2UgJ21pbnV0ZSc6XFxuICAgIGNhc2UgJ20nOlxcbiAgICAgIHJldHVybiBuICogbTtcXG4gICAgY2FzZSAnc2Vjb25kcyc6XFxuICAgIGNhc2UgJ3NlY29uZCc6XFxuICAgIGNhc2UgJ3MnOlxcbiAgICAgIHJldHVybiBuICogcztcXG4gICAgY2FzZSAnbXMnOlxcbiAgICAgIHJldHVybiBuO1xcbiAgICBkZWZhdWx0OlxcbiAgICAgIC8vIE5vIGRlZmF1bHQgY2FzZVxcbiAgfVxcbn1cXG5cXG4vKipcXG4gKiBTaG9ydCBmb3JtYXQgZm9yIGBtc2AuXFxuICpcXG4gKiBAYXBpIHByaXZhdGVcXG4gKiBAcGFyYW0ge251bWJlcn0gbXNcXG4gKiBAcmV0dXJuIHtzdHJpbmd9XFxuICovXFxuZnVuY3Rpb24gc2hvcnRGb3JtYXQgKG1zKSB7XFxuICBpZiAobXMgPj0gZCkge1xcbiAgICByZXR1cm4gTWF0aC5yb3VuZChtcyAvIGQpICsgJ2QnO1xcbiAgfVxcbiAgaWYgKG1zID49IGgpIHtcXG4gICAgcmV0dXJuIE1hdGgucm91bmQobXMgLyBoKSArICdoJztcXG4gIH1cXG4gIGlmIChtcyA+PSBtKSB7XFxuICAgIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gbSkgKyAnbSc7XFxuICB9XFxuICBpZiAobXMgPj0gcykge1xcbiAgICByZXR1cm4gTWF0aC5yb3VuZChtcyAvIHMpICsgJ3MnO1xcbiAgfVxcbiAgcmV0dXJuIG1zICsgJ21zJztcXG59XFxuXFxuLyoqXFxuICogTG9uZyBmb3JtYXQgZm9yIGBtc2AuXFxuICpcXG4gKiBAYXBpIHByaXZhdGVcXG4gKiBAcGFyYW0ge251bWJlcn0gbXNcXG4gKiBAcmV0dXJuIHtzdHJpbmd9XFxuICovXFxuZnVuY3Rpb24gbG9uZ0Zvcm1hdCAobXMpIHtcXG4gIHJldHVybiBwbHVyYWwobXMsIGQsICdkYXknKSB8fFxcbiAgICBwbHVyYWwobXMsIGgsICdob3VyJykgfHxcXG4gICAgcGx1cmFsKG1zLCBtLCAnbWludXRlJykgfHxcXG4gICAgcGx1cmFsKG1zLCBzLCAnc2Vjb25kJykgfHxcXG4gICAgbXMgKyAnIG1zJztcXG59XFxuXFxuLyoqXFxuICogUGx1cmFsaXphdGlvbiBoZWxwZXIuXFxuICpcXG4gKiBAYXBpIHByaXZhdGVcXG4gKiBAcGFyYW0ge251bWJlcn0gbXNcXG4gKiBAcGFyYW0ge251bWJlcn0gblxcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXFxuICovXFxuZnVuY3Rpb24gcGx1cmFsIChtcywgbiwgbmFtZSkge1xcbiAgaWYgKG1zIDwgbikge1xcbiAgICByZXR1cm47XFxuICB9XFxuICBpZiAobXMgPCBuICogMS41KSB7XFxuICAgIHJldHVybiBNYXRoLmZsb29yKG1zIC8gbikgKyAnICcgKyBuYW1lO1xcbiAgfVxcbiAgcmV0dXJuIE1hdGguY2VpbChtcyAvIG4pICsgJyAnICsgbmFtZSArICdzJztcXG59XFxuXFxufSx7fV0sMTY6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xcbid1c2Ugc3RyaWN0JztcXG5cXG4vKipcXG4gKiBFeHBvc2UgYFBlbmRpbmdgLlxcbiAqL1xcblxcbm1vZHVsZS5leHBvcnRzID0gUGVuZGluZztcXG5cXG4vKipcXG4gKiBJbml0aWFsaXplIGEgbmV3IGBQZW5kaW5nYCBlcnJvciB3aXRoIHRoZSBnaXZlbiBtZXNzYWdlLlxcbiAqXFxuICogQHBhcmFtIHtzdHJpbmd9IG1lc3NhZ2VcXG4gKi9cXG5mdW5jdGlvbiBQZW5kaW5nIChtZXNzYWdlKSB7XFxuICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xcbn1cXG5cXG59LHt9XSwxNzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XFxuKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCl7XFxuJ3VzZSBzdHJpY3QnO1xcblxcbi8qKlxcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXFxuICovXFxuXFxudmFyIHR0eSA9IHJlcXVpcmUoJ3R0eScpO1xcbnZhciBkaWZmID0gcmVxdWlyZSgnZGlmZicpO1xcbnZhciBtcyA9IHJlcXVpcmUoJy4uL21zJyk7XFxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMnKTtcXG52YXIgc3VwcG9ydHNDb2xvciA9IHByb2Nlc3MuYnJvd3NlciA/IG51bGwgOiByZXF1aXJlKCdzdXBwb3J0cy1jb2xvcicpO1xcblxcbi8qKlxcbiAqIEV4cG9zZSBgQmFzZWAuXFxuICovXFxuXFxuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gQmFzZTtcXG5cXG4vKipcXG4gKiBTYXZlIHRpbWVyIHJlZmVyZW5jZXMgdG8gYXZvaWQgU2lub24gaW50ZXJmZXJpbmcuXFxuICogU2VlOiBodHRwczovL2dpdGh1Yi5jb20vbW9jaGFqcy9tb2NoYS9pc3N1ZXMvMjM3XFxuICovXFxuXFxuLyogZXNsaW50LWRpc2FibGUgbm8tdW51c2VkLXZhcnMsIG5vLW5hdGl2ZS1yZWFzc2lnbiAqL1xcbnZhciBEYXRlID0gZ2xvYmFsLkRhdGU7XFxudmFyIHNldFRpbWVvdXQgPSBnbG9iYWwuc2V0VGltZW91dDtcXG52YXIgc2V0SW50ZXJ2YWwgPSBnbG9iYWwuc2V0SW50ZXJ2YWw7XFxudmFyIGNsZWFyVGltZW91dCA9IGdsb2JhbC5jbGVhclRpbWVvdXQ7XFxudmFyIGNsZWFySW50ZXJ2YWwgPSBnbG9iYWwuY2xlYXJJbnRlcnZhbDtcXG4vKiBlc2xpbnQtZW5hYmxlIG5vLXVudXNlZC12YXJzLCBuby1uYXRpdmUtcmVhc3NpZ24gKi9cXG5cXG4vKipcXG4gKiBDaGVjayBpZiBib3RoIHN0ZGlvIHN0cmVhbXMgYXJlIGFzc29jaWF0ZWQgd2l0aCBhIHR0eS5cXG4gKi9cXG5cXG52YXIgaXNhdHR5ID0gdHR5LmlzYXR0eSgxKSAmJiB0dHkuaXNhdHR5KDIpO1xcblxcbi8qKlxcbiAqIEVuYWJsZSBjb2xvcmluZyBieSBkZWZhdWx0LCBleGNlcHQgaW4gdGhlIGJyb3dzZXIgaW50ZXJmYWNlLlxcbiAqL1xcblxcbmV4cG9ydHMudXNlQ29sb3JzID0gIXByb2Nlc3MuYnJvd3NlciAmJiAoc3VwcG9ydHNDb2xvciB8fCAocHJvY2Vzcy5lbnYuTU9DSEFfQ09MT1JTICE9PSB1bmRlZmluZWQpKTtcXG5cXG4vKipcXG4gKiBJbmxpbmUgZGlmZnMgaW5zdGVhZCBvZiArLy1cXG4gKi9cXG5cXG5leHBvcnRzLmlubGluZURpZmZzID0gZmFsc2U7XFxuXFxuLyoqXFxuICogRGVmYXVsdCBjb2xvciBtYXAuXFxuICovXFxuXFxuZXhwb3J0cy5jb2xvcnMgPSB7XFxuICBwYXNzOiA5MCxcXG4gIGZhaWw6IDMxLFxcbiAgJ2JyaWdodCBwYXNzJzogOTIsXFxuICAnYnJpZ2h0IGZhaWwnOiA5MSxcXG4gICdicmlnaHQgeWVsbG93JzogOTMsXFxuICBwZW5kaW5nOiAzNixcXG4gIHN1aXRlOiAwLFxcbiAgJ2Vycm9yIHRpdGxlJzogMCxcXG4gICdlcnJvciBtZXNzYWdlJzogMzEsXFxuICAnZXJyb3Igc3RhY2snOiA5MCxcXG4gIGNoZWNrbWFyazogMzIsXFxuICBmYXN0OiA5MCxcXG4gIG1lZGl1bTogMzMsXFxuICBzbG93OiAzMSxcXG4gIGdyZWVuOiAzMixcXG4gIGxpZ2h0OiA5MCxcXG4gICdkaWZmIGd1dHRlcic6IDkwLFxcbiAgJ2RpZmYgYWRkZWQnOiAzMixcXG4gICdkaWZmIHJlbW92ZWQnOiAzMVxcbn07XFxuXFxuLyoqXFxuICogRGVmYXVsdCBzeW1ib2wgbWFwLlxcbiAqL1xcblxcbmV4cG9ydHMuc3ltYm9scyA9IHtcXG4gIG9rOiAn4pyTJyxcXG4gIGVycjogJ+KclicsXFxuICBkb3Q6ICfigKQnLFxcbiAgY29tbWE6ICcsJyxcXG4gIGJhbmc6ICchJ1xcbn07XFxuXFxuLy8gV2l0aCBub2RlLmpzIG9uIFdpbmRvd3M6IHVzZSBzeW1ib2xzIGF2YWlsYWJsZSBpbiB0ZXJtaW5hbCBkZWZhdWx0IGZvbnRzXFxuaWYgKHByb2Nlc3MucGxhdGZvcm0gPT09ICd3aW4zMicpIHtcXG4gIGV4cG9ydHMuc3ltYm9scy5vayA9ICdcXFxcdTIyMUEnO1xcbiAgZXhwb3J0cy5zeW1ib2xzLmVyciA9ICdcXFxcdTAwRDcnO1xcbiAgZXhwb3J0cy5zeW1ib2xzLmRvdCA9ICcuJztcXG59XFxuXFxuLyoqXFxuICogQ29sb3IgYHN0cmAgd2l0aCB0aGUgZ2l2ZW4gYHR5cGVgLFxcbiAqIGFsbG93aW5nIGNvbG9ycyB0byBiZSBkaXNhYmxlZCxcXG4gKiBhcyB3ZWxsIGFzIHVzZXItZGVmaW5lZCBjb2xvclxcbiAqIHNjaGVtZXMuXFxuICpcXG4gKiBAcGFyYW0ge3N0cmluZ30gdHlwZVxcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJcXG4gKiBAcmV0dXJuIHtzdHJpbmd9XFxuICogQGFwaSBwcml2YXRlXFxuICovXFxudmFyIGNvbG9yID0gZXhwb3J0cy5jb2xvciA9IGZ1bmN0aW9uICh0eXBlLCBzdHIpIHtcXG4gIGlmICghZXhwb3J0cy51c2VDb2xvcnMpIHtcXG4gICAgcmV0dXJuIFN0cmluZyhzdHIpO1xcbiAgfVxcbiAgcmV0dXJuICdcXFxcdTAwMWJbJyArIGV4cG9ydHMuY29sb3JzW3R5cGVdICsgJ20nICsgc3RyICsgJ1xcXFx1MDAxYlswbSc7XFxufTtcXG5cXG4vKipcXG4gKiBFeHBvc2UgdGVybSB3aW5kb3cgc2l6ZSwgd2l0aCBzb21lIGRlZmF1bHRzIGZvciB3aGVuIHN0ZGVyciBpcyBub3QgYSB0dHkuXFxuICovXFxuXFxuZXhwb3J0cy53aW5kb3cgPSB7XFxuICB3aWR0aDogNzVcXG59O1xcblxcbmlmIChpc2F0dHkpIHtcXG4gIGV4cG9ydHMud2luZG93LndpZHRoID0gcHJvY2Vzcy5zdGRvdXQuZ2V0V2luZG93U2l6ZVxcbiAgICAgID8gcHJvY2Vzcy5zdGRvdXQuZ2V0V2luZG93U2l6ZSgxKVswXVxcbiAgICAgIDogdHR5LmdldFdpbmRvd1NpemUoKVsxXTtcXG59XFxuXFxuLyoqXFxuICogRXhwb3NlIHNvbWUgYmFzaWMgY3Vyc29yIGludGVyYWN0aW9ucyB0aGF0IGFyZSBjb21tb24gYW1vbmcgcmVwb3J0ZXJzLlxcbiAqL1xcblxcbmV4cG9ydHMuY3Vyc29yID0ge1xcbiAgaGlkZTogZnVuY3Rpb24gKCkge1xcbiAgICBpc2F0dHkgJiYgcHJvY2Vzcy5zdGRvdXQud3JpdGUoJ1xcXFx1MDAxYls/MjVsJyk7XFxuICB9LFxcblxcbiAgc2hvdzogZnVuY3Rpb24gKCkge1xcbiAgICBpc2F0dHkgJiYgcHJvY2Vzcy5zdGRvdXQud3JpdGUoJ1xcXFx1MDAxYls/MjVoJyk7XFxuICB9LFxcblxcbiAgZGVsZXRlTGluZTogZnVuY3Rpb24gKCkge1xcbiAgICBpc2F0dHkgJiYgcHJvY2Vzcy5zdGRvdXQud3JpdGUoJ1xcXFx1MDAxYlsySycpO1xcbiAgfSxcXG5cXG4gIGJlZ2lubmluZ09mTGluZTogZnVuY3Rpb24gKCkge1xcbiAgICBpc2F0dHkgJiYgcHJvY2Vzcy5zdGRvdXQud3JpdGUoJ1xcXFx1MDAxYlswRycpO1xcbiAgfSxcXG5cXG4gIENSOiBmdW5jdGlvbiAoKSB7XFxuICAgIGlmIChpc2F0dHkpIHtcXG4gICAgICBleHBvcnRzLmN1cnNvci5kZWxldGVMaW5lKCk7XFxuICAgICAgZXhwb3J0cy5jdXJzb3IuYmVnaW5uaW5nT2ZMaW5lKCk7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgcHJvY2Vzcy5zdGRvdXQud3JpdGUoJ1xcXFxyJyk7XFxuICAgIH1cXG4gIH1cXG59O1xcblxcbi8qKlxcbiAqIE91dHB1dCB0aGUgZ2l2ZW4gYGZhaWx1cmVzYCBhcyBhIGxpc3QuXFxuICpcXG4gKiBAcGFyYW0ge0FycmF5fSBmYWlsdXJlc1xcbiAqIEBhcGkgcHVibGljXFxuICovXFxuXFxuZXhwb3J0cy5saXN0ID0gZnVuY3Rpb24gKGZhaWx1cmVzKSB7XFxuICBjb25zb2xlLmxvZygpO1xcbiAgZmFpbHVyZXMuZm9yRWFjaChmdW5jdGlvbiAodGVzdCwgaSkge1xcbiAgICAvLyBmb3JtYXRcXG4gICAgdmFyIGZtdCA9IGNvbG9yKCdlcnJvciB0aXRsZScsICcgICVzKSAlczpcXFxcbicpICtcXG4gICAgICBjb2xvcignZXJyb3IgbWVzc2FnZScsICcgICAgICVzJykgK1xcbiAgICAgIGNvbG9yKCdlcnJvciBzdGFjaycsICdcXFxcbiVzXFxcXG4nKTtcXG5cXG4gICAgLy8gbXNnXFxuICAgIHZhciBtc2c7XFxuICAgIHZhciBlcnIgPSB0ZXN0LmVycjtcXG4gICAgdmFyIG1lc3NhZ2U7XFxuICAgIGlmIChlcnIubWVzc2FnZSAmJiB0eXBlb2YgZXJyLm1lc3NhZ2UudG9TdHJpbmcgPT09ICdmdW5jdGlvbicpIHtcXG4gICAgICBtZXNzYWdlID0gZXJyLm1lc3NhZ2UgKyAnJztcXG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZXJyLmluc3BlY3QgPT09ICdmdW5jdGlvbicpIHtcXG4gICAgICBtZXNzYWdlID0gZXJyLmluc3BlY3QoKSArICcnO1xcbiAgICB9IGVsc2Uge1xcbiAgICAgIG1lc3NhZ2UgPSAnJztcXG4gICAgfVxcbiAgICB2YXIgc3RhY2sgPSBlcnIuc3RhY2sgfHwgbWVzc2FnZTtcXG4gICAgdmFyIGluZGV4ID0gbWVzc2FnZSA/IHN0YWNrLmluZGV4T2YobWVzc2FnZSkgOiAtMTtcXG4gICAgdmFyIGFjdHVhbCA9IGVyci5hY3R1YWw7XFxuICAgIHZhciBleHBlY3RlZCA9IGVyci5leHBlY3RlZDtcXG4gICAgdmFyIGVzY2FwZSA9IHRydWU7XFxuXFxuICAgIGlmIChpbmRleCA9PT0gLTEpIHtcXG4gICAgICBtc2cgPSBtZXNzYWdlO1xcbiAgICB9IGVsc2Uge1xcbiAgICAgIGluZGV4ICs9IG1lc3NhZ2UubGVuZ3RoO1xcbiAgICAgIG1zZyA9IHN0YWNrLnNsaWNlKDAsIGluZGV4KTtcXG4gICAgICAvLyByZW1vdmUgbXNnIGZyb20gc3RhY2tcXG4gICAgICBzdGFjayA9IHN0YWNrLnNsaWNlKGluZGV4ICsgMSk7XFxuICAgIH1cXG5cXG4gICAgLy8gdW5jYXVnaHRcXG4gICAgaWYgKGVyci51bmNhdWdodCkge1xcbiAgICAgIG1zZyA9ICdVbmNhdWdodCAnICsgbXNnO1xcbiAgICB9XFxuICAgIC8vIGV4cGxpY2l0bHkgc2hvdyBkaWZmXFxuICAgIGlmIChlcnIuc2hvd0RpZmYgIT09IGZhbHNlICYmIHNhbWVUeXBlKGFjdHVhbCwgZXhwZWN0ZWQpICYmIGV4cGVjdGVkICE9PSB1bmRlZmluZWQpIHtcXG4gICAgICBlc2NhcGUgPSBmYWxzZTtcXG4gICAgICBpZiAoISh1dGlscy5pc1N0cmluZyhhY3R1YWwpICYmIHV0aWxzLmlzU3RyaW5nKGV4cGVjdGVkKSkpIHtcXG4gICAgICAgIGVyci5hY3R1YWwgPSBhY3R1YWwgPSB1dGlscy5zdHJpbmdpZnkoYWN0dWFsKTtcXG4gICAgICAgIGVyci5leHBlY3RlZCA9IGV4cGVjdGVkID0gdXRpbHMuc3RyaW5naWZ5KGV4cGVjdGVkKTtcXG4gICAgICB9XFxuXFxuICAgICAgZm10ID0gY29sb3IoJ2Vycm9yIHRpdGxlJywgJyAgJXMpICVzOlxcXFxuJXMnKSArIGNvbG9yKCdlcnJvciBzdGFjaycsICdcXFxcbiVzXFxcXG4nKTtcXG4gICAgICB2YXIgbWF0Y2ggPSBtZXNzYWdlLm1hdGNoKC9eKFteOl0rKTogZXhwZWN0ZWQvKTtcXG4gICAgICBtc2cgPSAnXFxcXG4gICAgICAnICsgY29sb3IoJ2Vycm9yIG1lc3NhZ2UnLCBtYXRjaCA/IG1hdGNoWzFdIDogbXNnKTtcXG5cXG4gICAgICBpZiAoZXhwb3J0cy5pbmxpbmVEaWZmcykge1xcbiAgICAgICAgbXNnICs9IGlubGluZURpZmYoZXJyLCBlc2NhcGUpO1xcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICBtc2cgKz0gdW5pZmllZERpZmYoZXJyLCBlc2NhcGUpO1xcbiAgICAgIH1cXG4gICAgfVxcblxcbiAgICAvLyBpbmRlbnQgc3RhY2sgdHJhY2VcXG4gICAgc3RhY2sgPSBzdGFjay5yZXBsYWNlKC9eL2dtLCAnICAnKTtcXG5cXG4gICAgY29uc29sZS5sb2coZm10LCAoaSArIDEpLCB0ZXN0LmZ1bGxUaXRsZSgpLCBtc2csIHN0YWNrKTtcXG4gIH0pO1xcbn07XFxuXFxuLyoqXFxuICogSW5pdGlhbGl6ZSBhIG5ldyBgQmFzZWAgcmVwb3J0ZXIuXFxuICpcXG4gKiBBbGwgb3RoZXIgcmVwb3J0ZXJzIGdlbmVyYWxseVxcbiAqIGluaGVyaXQgZnJvbSB0aGlzIHJlcG9ydGVyLCBwcm92aWRpbmdcXG4gKiBzdGF0cyBzdWNoIGFzIHRlc3QgZHVyYXRpb24sIG51bWJlclxcbiAqIG9mIHRlc3RzIHBhc3NlZCAvIGZhaWxlZCBldGMuXFxuICpcXG4gKiBAcGFyYW0ge1J1bm5lcn0gcnVubmVyXFxuICogQGFwaSBwdWJsaWNcXG4gKi9cXG5cXG5mdW5jdGlvbiBCYXNlIChydW5uZXIpIHtcXG4gIHZhciBzdGF0cyA9IHRoaXMuc3RhdHMgPSB7IHN1aXRlczogMCwgdGVzdHM6IDAsIHBhc3NlczogMCwgcGVuZGluZzogMCwgZmFpbHVyZXM6IDAgfTtcXG4gIHZhciBmYWlsdXJlcyA9IHRoaXMuZmFpbHVyZXMgPSBbXTtcXG5cXG4gIGlmICghcnVubmVyKSB7XFxuICAgIHJldHVybjtcXG4gIH1cXG4gIHRoaXMucnVubmVyID0gcnVubmVyO1xcblxcbiAgcnVubmVyLnN0YXRzID0gc3RhdHM7XFxuXFxuICBydW5uZXIub24oJ3N0YXJ0JywgZnVuY3Rpb24gKCkge1xcbiAgICBzdGF0cy5zdGFydCA9IG5ldyBEYXRlKCk7XFxuICB9KTtcXG5cXG4gIHJ1bm5lci5vbignc3VpdGUnLCBmdW5jdGlvbiAoc3VpdGUpIHtcXG4gICAgc3RhdHMuc3VpdGVzID0gc3RhdHMuc3VpdGVzIHx8IDA7XFxuICAgIHN1aXRlLnJvb3QgfHwgc3RhdHMuc3VpdGVzKys7XFxuICB9KTtcXG5cXG4gIHJ1bm5lci5vbigndGVzdCBlbmQnLCBmdW5jdGlvbiAoKSB7XFxuICAgIHN0YXRzLnRlc3RzID0gc3RhdHMudGVzdHMgfHwgMDtcXG4gICAgc3RhdHMudGVzdHMrKztcXG4gIH0pO1xcblxcbiAgcnVubmVyLm9uKCdwYXNzJywgZnVuY3Rpb24gKHRlc3QpIHtcXG4gICAgc3RhdHMucGFzc2VzID0gc3RhdHMucGFzc2VzIHx8IDA7XFxuXFxuICAgIGlmICh0ZXN0LmR1cmF0aW9uID4gdGVzdC5zbG93KCkpIHtcXG4gICAgICB0ZXN0LnNwZWVkID0gJ3Nsb3cnO1xcbiAgICB9IGVsc2UgaWYgKHRlc3QuZHVyYXRpb24gPiB0ZXN0LnNsb3coKSAvIDIpIHtcXG4gICAgICB0ZXN0LnNwZWVkID0gJ21lZGl1bSc7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgdGVzdC5zcGVlZCA9ICdmYXN0JztcXG4gICAgfVxcblxcbiAgICBzdGF0cy5wYXNzZXMrKztcXG4gIH0pO1xcblxcbiAgcnVubmVyLm9uKCdmYWlsJywgZnVuY3Rpb24gKHRlc3QsIGVycikge1xcbiAgICBzdGF0cy5mYWlsdXJlcyA9IHN0YXRzLmZhaWx1cmVzIHx8IDA7XFxuICAgIHN0YXRzLmZhaWx1cmVzKys7XFxuICAgIHRlc3QuZXJyID0gZXJyO1xcbiAgICBmYWlsdXJlcy5wdXNoKHRlc3QpO1xcbiAgfSk7XFxuXFxuICBydW5uZXIub24oJ2VuZCcsIGZ1bmN0aW9uICgpIHtcXG4gICAgc3RhdHMuZW5kID0gbmV3IERhdGUoKTtcXG4gICAgc3RhdHMuZHVyYXRpb24gPSBuZXcgRGF0ZSgpIC0gc3RhdHMuc3RhcnQ7XFxuICB9KTtcXG5cXG4gIHJ1bm5lci5vbigncGVuZGluZycsIGZ1bmN0aW9uICgpIHtcXG4gICAgc3RhdHMucGVuZGluZysrO1xcbiAgfSk7XFxufVxcblxcbi8qKlxcbiAqIE91dHB1dCBjb21tb24gZXBpbG9ndWUgdXNlZCBieSBtYW55IG9mXFxuICogdGhlIGJ1bmRsZWQgcmVwb3J0ZXJzLlxcbiAqXFxuICogQGFwaSBwdWJsaWNcXG4gKi9cXG5CYXNlLnByb3RvdHlwZS5lcGlsb2d1ZSA9IGZ1bmN0aW9uICgpIHtcXG4gIHZhciBzdGF0cyA9IHRoaXMuc3RhdHM7XFxuICB2YXIgZm10O1xcblxcbiAgY29uc29sZS5sb2coKTtcXG5cXG4gIC8vIHBhc3Nlc1xcbiAgZm10ID0gY29sb3IoJ2JyaWdodCBwYXNzJywgJyAnKSArXFxuICAgIGNvbG9yKCdncmVlbicsICcgJWQgcGFzc2luZycpICtcXG4gICAgY29sb3IoJ2xpZ2h0JywgJyAoJXMpJyk7XFxuXFxuICBjb25zb2xlLmxvZyhmbXQsXFxuICAgIHN0YXRzLnBhc3NlcyB8fCAwLFxcbiAgICBtcyhzdGF0cy5kdXJhdGlvbikpO1xcblxcbiAgLy8gcGVuZGluZ1xcbiAgaWYgKHN0YXRzLnBlbmRpbmcpIHtcXG4gICAgZm10ID0gY29sb3IoJ3BlbmRpbmcnLCAnICcpICtcXG4gICAgICBjb2xvcigncGVuZGluZycsICcgJWQgcGVuZGluZycpO1xcblxcbiAgICBjb25zb2xlLmxvZyhmbXQsIHN0YXRzLnBlbmRpbmcpO1xcbiAgfVxcblxcbiAgLy8gZmFpbHVyZXNcXG4gIGlmIChzdGF0cy5mYWlsdXJlcykge1xcbiAgICBmbXQgPSBjb2xvcignZmFpbCcsICcgICVkIGZhaWxpbmcnKTtcXG5cXG4gICAgY29uc29sZS5sb2coZm10LCBzdGF0cy5mYWlsdXJlcyk7XFxuXFxuICAgIEJhc2UubGlzdCh0aGlzLmZhaWx1cmVzKTtcXG4gICAgY29uc29sZS5sb2coKTtcXG4gIH1cXG5cXG4gIGNvbnNvbGUubG9nKCk7XFxufTtcXG5cXG4vKipcXG4gKiBQYWQgdGhlIGdpdmVuIGBzdHJgIHRvIGBsZW5gLlxcbiAqXFxuICogQGFwaSBwcml2YXRlXFxuICogQHBhcmFtIHtzdHJpbmd9IHN0clxcbiAqIEBwYXJhbSB7c3RyaW5nfSBsZW5cXG4gKiBAcmV0dXJuIHtzdHJpbmd9XFxuICovXFxuZnVuY3Rpb24gcGFkIChzdHIsIGxlbikge1xcbiAgc3RyID0gU3RyaW5nKHN0cik7XFxuICByZXR1cm4gQXJyYXkobGVuIC0gc3RyLmxlbmd0aCArIDEpLmpvaW4oJyAnKSArIHN0cjtcXG59XFxuXFxuLyoqXFxuICogUmV0dXJucyBhbiBpbmxpbmUgZGlmZiBiZXR3ZWVuIDIgc3RyaW5ncyB3aXRoIGNvbG91cmVkIEFOU0kgb3V0cHV0XFxuICpcXG4gKiBAYXBpIHByaXZhdGVcXG4gKiBAcGFyYW0ge0Vycm9yfSBlcnIgd2l0aCBhY3R1YWwvZXhwZWN0ZWRcXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGVzY2FwZVxcbiAqIEByZXR1cm4ge3N0cmluZ30gRGlmZlxcbiAqL1xcbmZ1bmN0aW9uIGlubGluZURpZmYgKGVyciwgZXNjYXBlKSB7XFxuICB2YXIgbXNnID0gZXJyb3JEaWZmKGVyciwgJ1dvcmRzV2l0aFNwYWNlJywgZXNjYXBlKTtcXG5cXG4gIC8vIGxpbmVub3NcXG4gIHZhciBsaW5lcyA9IG1zZy5zcGxpdCgnXFxcXG4nKTtcXG4gIGlmIChsaW5lcy5sZW5ndGggPiA0KSB7XFxuICAgIHZhciB3aWR0aCA9IFN0cmluZyhsaW5lcy5sZW5ndGgpLmxlbmd0aDtcXG4gICAgbXNnID0gbGluZXMubWFwKGZ1bmN0aW9uIChzdHIsIGkpIHtcXG4gICAgICByZXR1cm4gcGFkKCsraSwgd2lkdGgpICsgJyB8JyArICcgJyArIHN0cjtcXG4gICAgfSkuam9pbignXFxcXG4nKTtcXG4gIH1cXG5cXG4gIC8vIGxlZ2VuZFxcbiAgbXNnID0gJ1xcXFxuJyArXFxuICAgIGNvbG9yKCdkaWZmIHJlbW92ZWQnLCAnYWN0dWFsJykgK1xcbiAgICAnICcgK1xcbiAgICBjb2xvcignZGlmZiBhZGRlZCcsICdleHBlY3RlZCcpICtcXG4gICAgJ1xcXFxuXFxcXG4nICtcXG4gICAgbXNnICtcXG4gICAgJ1xcXFxuJztcXG5cXG4gIC8vIGluZGVudFxcbiAgbXNnID0gbXNnLnJlcGxhY2UoL14vZ20sICcgICAgICAnKTtcXG4gIHJldHVybiBtc2c7XFxufVxcblxcbi8qKlxcbiAqIFJldHVybnMgYSB1bmlmaWVkIGRpZmYgYmV0d2VlbiB0d28gc3RyaW5ncy5cXG4gKlxcbiAqIEBhcGkgcHJpdmF0ZVxcbiAqIEBwYXJhbSB7RXJyb3J9IGVyciB3aXRoIGFjdHVhbC9leHBlY3RlZFxcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gZXNjYXBlXFxuICogQHJldHVybiB7c3RyaW5nfSBUaGUgZGlmZi5cXG4gKi9cXG5mdW5jdGlvbiB1bmlmaWVkRGlmZiAoZXJyLCBlc2NhcGUpIHtcXG4gIHZhciBpbmRlbnQgPSAnICAgICAgJztcXG4gIGZ1bmN0aW9uIGNsZWFuVXAgKGxpbmUpIHtcXG4gICAgaWYgKGVzY2FwZSkge1xcbiAgICAgIGxpbmUgPSBlc2NhcGVJbnZpc2libGVzKGxpbmUpO1xcbiAgICB9XFxuICAgIGlmIChsaW5lWzBdID09PSAnKycpIHtcXG4gICAgICByZXR1cm4gaW5kZW50ICsgY29sb3JMaW5lcygnZGlmZiBhZGRlZCcsIGxpbmUpO1xcbiAgICB9XFxuICAgIGlmIChsaW5lWzBdID09PSAnLScpIHtcXG4gICAgICByZXR1cm4gaW5kZW50ICsgY29sb3JMaW5lcygnZGlmZiByZW1vdmVkJywgbGluZSk7XFxuICAgIH1cXG4gICAgaWYgKGxpbmUubWF0Y2goL0BALykpIHtcXG4gICAgICByZXR1cm4gbnVsbDtcXG4gICAgfVxcbiAgICBpZiAobGluZS5tYXRjaCgvXFxcXFxcXFwgTm8gbmV3bGluZS8pKSB7XFxuICAgICAgcmV0dXJuIG51bGw7XFxuICAgIH1cXG4gICAgcmV0dXJuIGluZGVudCArIGxpbmU7XFxuICB9XFxuICBmdW5jdGlvbiBub3RCbGFuayAobGluZSkge1xcbiAgICByZXR1cm4gdHlwZW9mIGxpbmUgIT09ICd1bmRlZmluZWQnICYmIGxpbmUgIT09IG51bGw7XFxuICB9XFxuICB2YXIgbXNnID0gZGlmZi5jcmVhdGVQYXRjaCgnc3RyaW5nJywgZXJyLmFjdHVhbCwgZXJyLmV4cGVjdGVkKTtcXG4gIHZhciBsaW5lcyA9IG1zZy5zcGxpdCgnXFxcXG4nKS5zcGxpY2UoNCk7XFxuICByZXR1cm4gJ1xcXFxuICAgICAgJyArXFxuICAgIGNvbG9yTGluZXMoJ2RpZmYgYWRkZWQnLCAnKyBleHBlY3RlZCcpICsgJyAnICtcXG4gICAgY29sb3JMaW5lcygnZGlmZiByZW1vdmVkJywgJy0gYWN0dWFsJykgK1xcbiAgICAnXFxcXG5cXFxcbicgK1xcbiAgICBsaW5lcy5tYXAoY2xlYW5VcCkuZmlsdGVyKG5vdEJsYW5rKS5qb2luKCdcXFxcbicpO1xcbn1cXG5cXG4vKipcXG4gKiBSZXR1cm4gYSBjaGFyYWN0ZXIgZGlmZiBmb3IgYGVycmAuXFxuICpcXG4gKiBAYXBpIHByaXZhdGVcXG4gKiBAcGFyYW0ge0Vycm9yfSBlcnJcXG4gKiBAcGFyYW0ge3N0cmluZ30gdHlwZVxcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gZXNjYXBlXFxuICogQHJldHVybiB7c3RyaW5nfVxcbiAqL1xcbmZ1bmN0aW9uIGVycm9yRGlmZiAoZXJyLCB0eXBlLCBlc2NhcGUpIHtcXG4gIHZhciBhY3R1YWwgPSBlc2NhcGUgPyBlc2NhcGVJbnZpc2libGVzKGVyci5hY3R1YWwpIDogZXJyLmFjdHVhbDtcXG4gIHZhciBleHBlY3RlZCA9IGVzY2FwZSA/IGVzY2FwZUludmlzaWJsZXMoZXJyLmV4cGVjdGVkKSA6IGVyci5leHBlY3RlZDtcXG4gIHJldHVybiBkaWZmWydkaWZmJyArIHR5cGVdKGFjdHVhbCwgZXhwZWN0ZWQpLm1hcChmdW5jdGlvbiAoc3RyKSB7XFxuICAgIGlmIChzdHIuYWRkZWQpIHtcXG4gICAgICByZXR1cm4gY29sb3JMaW5lcygnZGlmZiBhZGRlZCcsIHN0ci52YWx1ZSk7XFxuICAgIH1cXG4gICAgaWYgKHN0ci5yZW1vdmVkKSB7XFxuICAgICAgcmV0dXJuIGNvbG9yTGluZXMoJ2RpZmYgcmVtb3ZlZCcsIHN0ci52YWx1ZSk7XFxuICAgIH1cXG4gICAgcmV0dXJuIHN0ci52YWx1ZTtcXG4gIH0pLmpvaW4oJycpO1xcbn1cXG5cXG4vKipcXG4gKiBSZXR1cm5zIGEgc3RyaW5nIHdpdGggYWxsIGludmlzaWJsZSBjaGFyYWN0ZXJzIGluIHBsYWluIHRleHRcXG4gKlxcbiAqIEBhcGkgcHJpdmF0ZVxcbiAqIEBwYXJhbSB7c3RyaW5nfSBsaW5lXFxuICogQHJldHVybiB7c3RyaW5nfVxcbiAqL1xcbmZ1bmN0aW9uIGVzY2FwZUludmlzaWJsZXMgKGxpbmUpIHtcXG4gIHJldHVybiBsaW5lLnJlcGxhY2UoL1xcXFx0L2csICc8dGFiPicpXFxuICAgIC5yZXBsYWNlKC9cXFxcci9nLCAnPENSPicpXFxuICAgIC5yZXBsYWNlKC9cXFxcbi9nLCAnPExGPlxcXFxuJyk7XFxufVxcblxcbi8qKlxcbiAqIENvbG9yIGxpbmVzIGZvciBgc3RyYCwgdXNpbmcgdGhlIGNvbG9yIGBuYW1lYC5cXG4gKlxcbiAqIEBhcGkgcHJpdmF0ZVxcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXFxuICogQHBhcmFtIHtzdHJpbmd9IHN0clxcbiAqIEByZXR1cm4ge3N0cmluZ31cXG4gKi9cXG5mdW5jdGlvbiBjb2xvckxpbmVzIChuYW1lLCBzdHIpIHtcXG4gIHJldHVybiBzdHIuc3BsaXQoJ1xcXFxuJykubWFwKGZ1bmN0aW9uIChzdHIpIHtcXG4gICAgcmV0dXJuIGNvbG9yKG5hbWUsIHN0cik7XFxuICB9KS5qb2luKCdcXFxcbicpO1xcbn1cXG5cXG4vKipcXG4gKiBPYmplY3QjdG9TdHJpbmcgcmVmZXJlbmNlLlxcbiAqL1xcbnZhciBvYmpUb1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XFxuXFxuLyoqXFxuICogQ2hlY2sgdGhhdCBhIC8gYiBoYXZlIHRoZSBzYW1lIHR5cGUuXFxuICpcXG4gKiBAYXBpIHByaXZhdGVcXG4gKiBAcGFyYW0ge09iamVjdH0gYVxcbiAqIEBwYXJhbSB7T2JqZWN0fSBiXFxuICogQHJldHVybiB7Ym9vbGVhbn1cXG4gKi9cXG5mdW5jdGlvbiBzYW1lVHlwZSAoYSwgYikge1xcbiAgcmV0dXJuIG9ialRvU3RyaW5nLmNhbGwoYSkgPT09IG9ialRvU3RyaW5nLmNhbGwoYik7XFxufVxcblxcbn0pLmNhbGwodGhpcyxyZXF1aXJlKCdfcHJvY2VzcycpLHR5cGVvZiBnbG9iYWwgIT09IFxcXCJ1bmRlZmluZWRcXFwiID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09IFxcXCJ1bmRlZmluZWRcXFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFxcXCJ1bmRlZmluZWRcXFwiID8gd2luZG93IDoge30pXFxufSx7XFxcIi4uL21zXFxcIjoxNSxcXFwiLi4vdXRpbHNcXFwiOjM4LFxcXCJfcHJvY2Vzc1xcXCI6ODIsXFxcImRpZmZcXFwiOjU1LFxcXCJzdXBwb3J0cy1jb2xvclxcXCI6NDIsXFxcInR0eVxcXCI6NX1dLDE4OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcXG4ndXNlIHN0cmljdCc7XFxuXFxuLyoqXFxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cXG4gKi9cXG5cXG52YXIgQmFzZSA9IHJlcXVpcmUoJy4vYmFzZScpO1xcbnZhciB1dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzJyk7XFxuXFxuLyoqXFxuICogRXhwb3NlIGBEb2NgLlxcbiAqL1xcblxcbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IERvYztcXG5cXG4vKipcXG4gKiBJbml0aWFsaXplIGEgbmV3IGBEb2NgIHJlcG9ydGVyLlxcbiAqXFxuICogQHBhcmFtIHtSdW5uZXJ9IHJ1bm5lclxcbiAqIEBhcGkgcHVibGljXFxuICovXFxuZnVuY3Rpb24gRG9jIChydW5uZXIpIHtcXG4gIEJhc2UuY2FsbCh0aGlzLCBydW5uZXIpO1xcblxcbiAgdmFyIGluZGVudHMgPSAyO1xcblxcbiAgZnVuY3Rpb24gaW5kZW50ICgpIHtcXG4gICAgcmV0dXJuIEFycmF5KGluZGVudHMpLmpvaW4oJyAgJyk7XFxuICB9XFxuXFxuICBydW5uZXIub24oJ3N1aXRlJywgZnVuY3Rpb24gKHN1aXRlKSB7XFxuICAgIGlmIChzdWl0ZS5yb290KSB7XFxuICAgICAgcmV0dXJuO1xcbiAgICB9XFxuICAgICsraW5kZW50cztcXG4gICAgY29uc29sZS5sb2coJyVzPHNlY3Rpb24gY2xhc3M9XFxcInN1aXRlXFxcIj4nLCBpbmRlbnQoKSk7XFxuICAgICsraW5kZW50cztcXG4gICAgY29uc29sZS5sb2coJyVzPGgxPiVzPC9oMT4nLCBpbmRlbnQoKSwgdXRpbHMuZXNjYXBlKHN1aXRlLnRpdGxlKSk7XFxuICAgIGNvbnNvbGUubG9nKCclczxkbD4nLCBpbmRlbnQoKSk7XFxuICB9KTtcXG5cXG4gIHJ1bm5lci5vbignc3VpdGUgZW5kJywgZnVuY3Rpb24gKHN1aXRlKSB7XFxuICAgIGlmIChzdWl0ZS5yb290KSB7XFxuICAgICAgcmV0dXJuO1xcbiAgICB9XFxuICAgIGNvbnNvbGUubG9nKCclczwvZGw+JywgaW5kZW50KCkpO1xcbiAgICAtLWluZGVudHM7XFxuICAgIGNvbnNvbGUubG9nKCclczwvc2VjdGlvbj4nLCBpbmRlbnQoKSk7XFxuICAgIC0taW5kZW50cztcXG4gIH0pO1xcblxcbiAgcnVubmVyLm9uKCdwYXNzJywgZnVuY3Rpb24gKHRlc3QpIHtcXG4gICAgY29uc29sZS5sb2coJyVzICA8ZHQ+JXM8L2R0PicsIGluZGVudCgpLCB1dGlscy5lc2NhcGUodGVzdC50aXRsZSkpO1xcbiAgICB2YXIgY29kZSA9IHV0aWxzLmVzY2FwZSh1dGlscy5jbGVhbih0ZXN0LmJvZHkpKTtcXG4gICAgY29uc29sZS5sb2coJyVzICA8ZGQ+PHByZT48Y29kZT4lczwvY29kZT48L3ByZT48L2RkPicsIGluZGVudCgpLCBjb2RlKTtcXG4gIH0pO1xcblxcbiAgcnVubmVyLm9uKCdmYWlsJywgZnVuY3Rpb24gKHRlc3QsIGVycikge1xcbiAgICBjb25zb2xlLmxvZygnJXMgIDxkdCBjbGFzcz1cXFwiZXJyb3JcXFwiPiVzPC9kdD4nLCBpbmRlbnQoKSwgdXRpbHMuZXNjYXBlKHRlc3QudGl0bGUpKTtcXG4gICAgdmFyIGNvZGUgPSB1dGlscy5lc2NhcGUodXRpbHMuY2xlYW4odGVzdC5ib2R5KSk7XFxuICAgIGNvbnNvbGUubG9nKCclcyAgPGRkIGNsYXNzPVxcXCJlcnJvclxcXCI+PHByZT48Y29kZT4lczwvY29kZT48L3ByZT48L2RkPicsIGluZGVudCgpLCBjb2RlKTtcXG4gICAgY29uc29sZS5sb2coJyVzICA8ZGQgY2xhc3M9XFxcImVycm9yXFxcIj4lczwvZGQ+JywgaW5kZW50KCksIHV0aWxzLmVzY2FwZShlcnIpKTtcXG4gIH0pO1xcbn1cXG5cXG59LHtcXFwiLi4vdXRpbHNcXFwiOjM4LFxcXCIuL2Jhc2VcXFwiOjE3fV0sMTk6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xcbihmdW5jdGlvbiAocHJvY2Vzcyl7XFxuJ3VzZSBzdHJpY3QnO1xcblxcbi8qKlxcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXFxuICovXFxuXFxudmFyIEJhc2UgPSByZXF1aXJlKCcuL2Jhc2UnKTtcXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCcuLi91dGlscycpLmluaGVyaXRzO1xcbnZhciBjb2xvciA9IEJhc2UuY29sb3I7XFxuXFxuLyoqXFxuICogRXhwb3NlIGBEb3RgLlxcbiAqL1xcblxcbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IERvdDtcXG5cXG4vKipcXG4gKiBJbml0aWFsaXplIGEgbmV3IGBEb3RgIG1hdHJpeCB0ZXN0IHJlcG9ydGVyLlxcbiAqXFxuICogQGFwaSBwdWJsaWNcXG4gKiBAcGFyYW0ge1J1bm5lcn0gcnVubmVyXFxuICovXFxuZnVuY3Rpb24gRG90IChydW5uZXIpIHtcXG4gIEJhc2UuY2FsbCh0aGlzLCBydW5uZXIpO1xcblxcbiAgdmFyIHNlbGYgPSB0aGlzO1xcbiAgdmFyIHdpZHRoID0gQmFzZS53aW5kb3cud2lkdGggKiAwLjc1IHwgMDtcXG4gIHZhciBuID0gLTE7XFxuXFxuICBydW5uZXIub24oJ3N0YXJ0JywgZnVuY3Rpb24gKCkge1xcbiAgICBwcm9jZXNzLnN0ZG91dC53cml0ZSgnXFxcXG4nKTtcXG4gIH0pO1xcblxcbiAgcnVubmVyLm9uKCdwZW5kaW5nJywgZnVuY3Rpb24gKCkge1xcbiAgICBpZiAoKytuICUgd2lkdGggPT09IDApIHtcXG4gICAgICBwcm9jZXNzLnN0ZG91dC53cml0ZSgnXFxcXG4gICcpO1xcbiAgICB9XFxuICAgIHByb2Nlc3Muc3Rkb3V0LndyaXRlKGNvbG9yKCdwZW5kaW5nJywgQmFzZS5zeW1ib2xzLmNvbW1hKSk7XFxuICB9KTtcXG5cXG4gIHJ1bm5lci5vbigncGFzcycsIGZ1bmN0aW9uICh0ZXN0KSB7XFxuICAgIGlmICgrK24gJSB3aWR0aCA9PT0gMCkge1xcbiAgICAgIHByb2Nlc3Muc3Rkb3V0LndyaXRlKCdcXFxcbiAgJyk7XFxuICAgIH1cXG4gICAgaWYgKHRlc3Quc3BlZWQgPT09ICdzbG93Jykge1xcbiAgICAgIHByb2Nlc3Muc3Rkb3V0LndyaXRlKGNvbG9yKCdicmlnaHQgeWVsbG93JywgQmFzZS5zeW1ib2xzLmRvdCkpO1xcbiAgICB9IGVsc2Uge1xcbiAgICAgIHByb2Nlc3Muc3Rkb3V0LndyaXRlKGNvbG9yKHRlc3Quc3BlZWQsIEJhc2Uuc3ltYm9scy5kb3QpKTtcXG4gICAgfVxcbiAgfSk7XFxuXFxuICBydW5uZXIub24oJ2ZhaWwnLCBmdW5jdGlvbiAoKSB7XFxuICAgIGlmICgrK24gJSB3aWR0aCA9PT0gMCkge1xcbiAgICAgIHByb2Nlc3Muc3Rkb3V0LndyaXRlKCdcXFxcbiAgJyk7XFxuICAgIH1cXG4gICAgcHJvY2Vzcy5zdGRvdXQud3JpdGUoY29sb3IoJ2ZhaWwnLCBCYXNlLnN5bWJvbHMuYmFuZykpO1xcbiAgfSk7XFxuXFxuICBydW5uZXIub24oJ2VuZCcsIGZ1bmN0aW9uICgpIHtcXG4gICAgY29uc29sZS5sb2coKTtcXG4gICAgc2VsZi5lcGlsb2d1ZSgpO1xcbiAgfSk7XFxufVxcblxcbi8qKlxcbiAqIEluaGVyaXQgZnJvbSBgQmFzZS5wcm90b3R5cGVgLlxcbiAqL1xcbmluaGVyaXRzKERvdCwgQmFzZSk7XFxuXFxufSkuY2FsbCh0aGlzLHJlcXVpcmUoJ19wcm9jZXNzJykpXFxufSx7XFxcIi4uL3V0aWxzXFxcIjozOCxcXFwiLi9iYXNlXFxcIjoxNyxcXFwiX3Byb2Nlc3NcXFwiOjgyfV0sMjA6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xcbihmdW5jdGlvbiAoZ2xvYmFsKXtcXG4ndXNlIHN0cmljdCc7XFxuXFxuLyogZXNsaW50LWVudiBicm93c2VyICovXFxuXFxuLyoqXFxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cXG4gKi9cXG5cXG52YXIgQmFzZSA9IHJlcXVpcmUoJy4vYmFzZScpO1xcbnZhciB1dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzJyk7XFxudmFyIFByb2dyZXNzID0gcmVxdWlyZSgnLi4vYnJvd3Nlci9wcm9ncmVzcycpO1xcbnZhciBlc2NhcGVSZSA9IHJlcXVpcmUoJ2VzY2FwZS1zdHJpbmctcmVnZXhwJyk7XFxudmFyIGVzY2FwZSA9IHV0aWxzLmVzY2FwZTtcXG5cXG4vKipcXG4gKiBTYXZlIHRpbWVyIHJlZmVyZW5jZXMgdG8gYXZvaWQgU2lub24gaW50ZXJmZXJpbmcgKHNlZSBHSC0yMzcpLlxcbiAqL1xcblxcbi8qIGVzbGludC1kaXNhYmxlIG5vLXVudXNlZC12YXJzLCBuby1uYXRpdmUtcmVhc3NpZ24gKi9cXG52YXIgRGF0ZSA9IGdsb2JhbC5EYXRlO1xcbnZhciBzZXRUaW1lb3V0ID0gZ2xvYmFsLnNldFRpbWVvdXQ7XFxudmFyIHNldEludGVydmFsID0gZ2xvYmFsLnNldEludGVydmFsO1xcbnZhciBjbGVhclRpbWVvdXQgPSBnbG9iYWwuY2xlYXJUaW1lb3V0O1xcbnZhciBjbGVhckludGVydmFsID0gZ2xvYmFsLmNsZWFySW50ZXJ2YWw7XFxuLyogZXNsaW50LWVuYWJsZSBuby11bnVzZWQtdmFycywgbm8tbmF0aXZlLXJlYXNzaWduICovXFxuXFxuLyoqXFxuICogRXhwb3NlIGBIVE1MYC5cXG4gKi9cXG5cXG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBIVE1MO1xcblxcbi8qKlxcbiAqIFN0YXRzIHRlbXBsYXRlLlxcbiAqL1xcblxcbnZhciBzdGF0c1RlbXBsYXRlID0gJzx1bCBpZD1cXFwibW9jaGEtc3RhdHNcXFwiPicgK1xcbiAgJzxsaSBjbGFzcz1cXFwicHJvZ3Jlc3NcXFwiPjxjYW52YXMgd2lkdGg9XFxcIjQwXFxcIiBoZWlnaHQ9XFxcIjQwXFxcIj48L2NhbnZhcz48L2xpPicgK1xcbiAgJzxsaSBjbGFzcz1cXFwicGFzc2VzXFxcIj48YSBocmVmPVxcXCJqYXZhc2NyaXB0OnZvaWQoMCk7XFxcIj5wYXNzZXM6PC9hPiA8ZW0+MDwvZW0+PC9saT4nICtcXG4gICc8bGkgY2xhc3M9XFxcImZhaWx1cmVzXFxcIj48YSBocmVmPVxcXCJqYXZhc2NyaXB0OnZvaWQoMCk7XFxcIj5mYWlsdXJlczo8L2E+IDxlbT4wPC9lbT48L2xpPicgK1xcbiAgJzxsaSBjbGFzcz1cXFwiZHVyYXRpb25cXFwiPmR1cmF0aW9uOiA8ZW0+MDwvZW0+czwvbGk+JyArXFxuICAnPC91bD4nO1xcblxcbnZhciBwbGF5SWNvbiA9ICcmI3gyMDIzOyc7XFxuXFxuLyoqXFxuICogSW5pdGlhbGl6ZSBhIG5ldyBgSFRNTGAgcmVwb3J0ZXIuXFxuICpcXG4gKiBAYXBpIHB1YmxpY1xcbiAqIEBwYXJhbSB7UnVubmVyfSBydW5uZXJcXG4gKi9cXG5mdW5jdGlvbiBIVE1MIChydW5uZXIpIHtcXG4gIEJhc2UuY2FsbCh0aGlzLCBydW5uZXIpO1xcblxcbiAgdmFyIHNlbGYgPSB0aGlzO1xcbiAgdmFyIHN0YXRzID0gdGhpcy5zdGF0cztcXG4gIHZhciBzdGF0ID0gZnJhZ21lbnQoc3RhdHNUZW1wbGF0ZSk7XFxuICB2YXIgaXRlbXMgPSBzdGF0LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdsaScpO1xcbiAgdmFyIHBhc3NlcyA9IGl0ZW1zWzFdLmdldEVsZW1lbnRzQnlUYWdOYW1lKCdlbScpWzBdO1xcbiAgdmFyIHBhc3Nlc0xpbmsgPSBpdGVtc1sxXS5nZXRFbGVtZW50c0J5VGFnTmFtZSgnYScpWzBdO1xcbiAgdmFyIGZhaWx1cmVzID0gaXRlbXNbMl0uZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2VtJylbMF07XFxuICB2YXIgZmFpbHVyZXNMaW5rID0gaXRlbXNbMl0uZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2EnKVswXTtcXG4gIHZhciBkdXJhdGlvbiA9IGl0ZW1zWzNdLmdldEVsZW1lbnRzQnlUYWdOYW1lKCdlbScpWzBdO1xcbiAgdmFyIGNhbnZhcyA9IHN0YXQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2NhbnZhcycpWzBdO1xcbiAgdmFyIHJlcG9ydCA9IGZyYWdtZW50KCc8dWwgaWQ9XFxcIm1vY2hhLXJlcG9ydFxcXCI+PC91bD4nKTtcXG4gIHZhciBzdGFjayA9IFtyZXBvcnRdO1xcbiAgdmFyIHByb2dyZXNzO1xcbiAgdmFyIGN0eDtcXG4gIHZhciByb290ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ21vY2hhJyk7XFxuXFxuICBpZiAoY2FudmFzLmdldENvbnRleHQpIHtcXG4gICAgdmFyIHJhdGlvID0gd2luZG93LmRldmljZVBpeGVsUmF0aW8gfHwgMTtcXG4gICAgY2FudmFzLnN0eWxlLndpZHRoID0gY2FudmFzLndpZHRoO1xcbiAgICBjYW52YXMuc3R5bGUuaGVpZ2h0ID0gY2FudmFzLmhlaWdodDtcXG4gICAgY2FudmFzLndpZHRoICo9IHJhdGlvO1xcbiAgICBjYW52YXMuaGVpZ2h0ICo9IHJhdGlvO1xcbiAgICBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcXG4gICAgY3R4LnNjYWxlKHJhdGlvLCByYXRpbyk7XFxuICAgIHByb2dyZXNzID0gbmV3IFByb2dyZXNzKCk7XFxuICB9XFxuXFxuICBpZiAoIXJvb3QpIHtcXG4gICAgcmV0dXJuIGVycm9yKCcjbW9jaGEgZGl2IG1pc3NpbmcsIGFkZCBpdCB0byB5b3VyIGRvY3VtZW50Jyk7XFxuICB9XFxuXFxuICAvLyBwYXNzIHRvZ2dsZVxcbiAgb24ocGFzc2VzTGluaywgJ2NsaWNrJywgZnVuY3Rpb24gKGV2dCkge1xcbiAgICBldnQucHJldmVudERlZmF1bHQoKTtcXG4gICAgdW5oaWRlKCk7XFxuICAgIHZhciBuYW1lID0gKC9wYXNzLykudGVzdChyZXBvcnQuY2xhc3NOYW1lKSA/ICcnIDogJyBwYXNzJztcXG4gICAgcmVwb3J0LmNsYXNzTmFtZSA9IHJlcG9ydC5jbGFzc05hbWUucmVwbGFjZSgvZmFpbHxwYXNzL2csICcnKSArIG5hbWU7XFxuICAgIGlmIChyZXBvcnQuY2xhc3NOYW1lLnRyaW0oKSkge1xcbiAgICAgIGhpZGVTdWl0ZXNXaXRob3V0KCd0ZXN0IHBhc3MnKTtcXG4gICAgfVxcbiAgfSk7XFxuXFxuICAvLyBmYWlsdXJlIHRvZ2dsZVxcbiAgb24oZmFpbHVyZXNMaW5rLCAnY2xpY2snLCBmdW5jdGlvbiAoZXZ0KSB7XFxuICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xcbiAgICB1bmhpZGUoKTtcXG4gICAgdmFyIG5hbWUgPSAoL2ZhaWwvKS50ZXN0KHJlcG9ydC5jbGFzc05hbWUpID8gJycgOiAnIGZhaWwnO1xcbiAgICByZXBvcnQuY2xhc3NOYW1lID0gcmVwb3J0LmNsYXNzTmFtZS5yZXBsYWNlKC9mYWlsfHBhc3MvZywgJycpICsgbmFtZTtcXG4gICAgaWYgKHJlcG9ydC5jbGFzc05hbWUudHJpbSgpKSB7XFxuICAgICAgaGlkZVN1aXRlc1dpdGhvdXQoJ3Rlc3QgZmFpbCcpO1xcbiAgICB9XFxuICB9KTtcXG5cXG4gIHJvb3QuYXBwZW5kQ2hpbGQoc3RhdCk7XFxuICByb290LmFwcGVuZENoaWxkKHJlcG9ydCk7XFxuXFxuICBpZiAocHJvZ3Jlc3MpIHtcXG4gICAgcHJvZ3Jlc3Muc2l6ZSg0MCk7XFxuICB9XFxuXFxuICBydW5uZXIub24oJ3N1aXRlJywgZnVuY3Rpb24gKHN1aXRlKSB7XFxuICAgIGlmIChzdWl0ZS5yb290KSB7XFxuICAgICAgcmV0dXJuO1xcbiAgICB9XFxuXFxuICAgIC8vIHN1aXRlXFxuICAgIHZhciB1cmwgPSBzZWxmLnN1aXRlVVJMKHN1aXRlKTtcXG4gICAgdmFyIGVsID0gZnJhZ21lbnQoJzxsaSBjbGFzcz1cXFwic3VpdGVcXFwiPjxoMT48YSBocmVmPVxcXCIlc1xcXCI+JXM8L2E+PC9oMT48L2xpPicsIHVybCwgZXNjYXBlKHN1aXRlLnRpdGxlKSk7XFxuXFxuICAgIC8vIGNvbnRhaW5lclxcbiAgICBzdGFja1swXS5hcHBlbmRDaGlsZChlbCk7XFxuICAgIHN0YWNrLnVuc2hpZnQoZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndWwnKSk7XFxuICAgIGVsLmFwcGVuZENoaWxkKHN0YWNrWzBdKTtcXG4gIH0pO1xcblxcbiAgcnVubmVyLm9uKCdzdWl0ZSBlbmQnLCBmdW5jdGlvbiAoc3VpdGUpIHtcXG4gICAgaWYgKHN1aXRlLnJvb3QpIHtcXG4gICAgICB1cGRhdGVTdGF0cygpO1xcbiAgICAgIHJldHVybjtcXG4gICAgfVxcbiAgICBzdGFjay5zaGlmdCgpO1xcbiAgfSk7XFxuXFxuICBydW5uZXIub24oJ3Bhc3MnLCBmdW5jdGlvbiAodGVzdCkge1xcbiAgICB2YXIgdXJsID0gc2VsZi50ZXN0VVJMKHRlc3QpO1xcbiAgICB2YXIgbWFya3VwID0gJzxsaSBjbGFzcz1cXFwidGVzdCBwYXNzICVlXFxcIj48aDI+JWU8c3BhbiBjbGFzcz1cXFwiZHVyYXRpb25cXFwiPiVlbXM8L3NwYW4+ICcgK1xcbiAgICAgICc8YSBocmVmPVxcXCIlc1xcXCIgY2xhc3M9XFxcInJlcGxheVxcXCI+JyArIHBsYXlJY29uICsgJzwvYT48L2gyPjwvbGk+JztcXG4gICAgdmFyIGVsID0gZnJhZ21lbnQobWFya3VwLCB0ZXN0LnNwZWVkLCB0ZXN0LnRpdGxlLCB0ZXN0LmR1cmF0aW9uLCB1cmwpO1xcbiAgICBzZWxmLmFkZENvZGVUb2dnbGUoZWwsIHRlc3QuYm9keSk7XFxuICAgIGFwcGVuZFRvU3RhY2soZWwpO1xcbiAgICB1cGRhdGVTdGF0cygpO1xcbiAgfSk7XFxuXFxuICBydW5uZXIub24oJ2ZhaWwnLCBmdW5jdGlvbiAodGVzdCkge1xcbiAgICB2YXIgZWwgPSBmcmFnbWVudCgnPGxpIGNsYXNzPVxcXCJ0ZXN0IGZhaWxcXFwiPjxoMj4lZSA8YSBocmVmPVxcXCIlZVxcXCIgY2xhc3M9XFxcInJlcGxheVxcXCI+JyArIHBsYXlJY29uICsgJzwvYT48L2gyPjwvbGk+JyxcXG4gICAgICB0ZXN0LnRpdGxlLCBzZWxmLnRlc3RVUkwodGVzdCkpO1xcbiAgICB2YXIgc3RhY2tTdHJpbmc7IC8vIE5vdGU6IEluY2x1ZGVzIGxlYWRpbmcgbmV3bGluZVxcbiAgICB2YXIgbWVzc2FnZSA9IHRlc3QuZXJyLnRvU3RyaW5nKCk7XFxuXFxuICAgIC8vIDw9SUU3IHN0cmluZ2lmaWVzIHRvIFtPYmplY3QgRXJyb3JdLiBTaW5jZSBpdCBjYW4gYmUgb3ZlcmxvYWRlZCwgd2VcXG4gICAgLy8gY2hlY2sgZm9yIHRoZSByZXN1bHQgb2YgdGhlIHN0cmluZ2lmeWluZy5cXG4gICAgaWYgKG1lc3NhZ2UgPT09ICdbb2JqZWN0IEVycm9yXScpIHtcXG4gICAgICBtZXNzYWdlID0gdGVzdC5lcnIubWVzc2FnZTtcXG4gICAgfVxcblxcbiAgICBpZiAodGVzdC5lcnIuc3RhY2spIHtcXG4gICAgICB2YXIgaW5kZXhPZk1lc3NhZ2UgPSB0ZXN0LmVyci5zdGFjay5pbmRleE9mKHRlc3QuZXJyLm1lc3NhZ2UpO1xcbiAgICAgIGlmIChpbmRleE9mTWVzc2FnZSA9PT0gLTEpIHtcXG4gICAgICAgIHN0YWNrU3RyaW5nID0gdGVzdC5lcnIuc3RhY2s7XFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIHN0YWNrU3RyaW5nID0gdGVzdC5lcnIuc3RhY2suc3Vic3RyKHRlc3QuZXJyLm1lc3NhZ2UubGVuZ3RoICsgaW5kZXhPZk1lc3NhZ2UpO1xcbiAgICAgIH1cXG4gICAgfSBlbHNlIGlmICh0ZXN0LmVyci5zb3VyY2VVUkwgJiYgdGVzdC5lcnIubGluZSAhPT0gdW5kZWZpbmVkKSB7XFxuICAgICAgLy8gU2FmYXJpIGRvZXNuJ3QgZ2l2ZSB5b3UgYSBzdGFjay4gTGV0J3MgYXQgbGVhc3QgcHJvdmlkZSBhIHNvdXJjZSBsaW5lLlxcbiAgICAgIHN0YWNrU3RyaW5nID0gJ1xcXFxuKCcgKyB0ZXN0LmVyci5zb3VyY2VVUkwgKyAnOicgKyB0ZXN0LmVyci5saW5lICsgJyknO1xcbiAgICB9XFxuXFxuICAgIHN0YWNrU3RyaW5nID0gc3RhY2tTdHJpbmcgfHwgJyc7XFxuXFxuICAgIGlmICh0ZXN0LmVyci5odG1sTWVzc2FnZSAmJiBzdGFja1N0cmluZykge1xcbiAgICAgIGVsLmFwcGVuZENoaWxkKGZyYWdtZW50KCc8ZGl2IGNsYXNzPVxcXCJodG1sLWVycm9yXFxcIj4lc1xcXFxuPHByZSBjbGFzcz1cXFwiZXJyb3JcXFwiPiVlPC9wcmU+PC9kaXY+JyxcXG4gICAgICAgIHRlc3QuZXJyLmh0bWxNZXNzYWdlLCBzdGFja1N0cmluZykpO1xcbiAgICB9IGVsc2UgaWYgKHRlc3QuZXJyLmh0bWxNZXNzYWdlKSB7XFxuICAgICAgZWwuYXBwZW5kQ2hpbGQoZnJhZ21lbnQoJzxkaXYgY2xhc3M9XFxcImh0bWwtZXJyb3JcXFwiPiVzPC9kaXY+JywgdGVzdC5lcnIuaHRtbE1lc3NhZ2UpKTtcXG4gICAgfSBlbHNlIHtcXG4gICAgICBlbC5hcHBlbmRDaGlsZChmcmFnbWVudCgnPHByZSBjbGFzcz1cXFwiZXJyb3JcXFwiPiVlJWU8L3ByZT4nLCBtZXNzYWdlLCBzdGFja1N0cmluZykpO1xcbiAgICB9XFxuXFxuICAgIHNlbGYuYWRkQ29kZVRvZ2dsZShlbCwgdGVzdC5ib2R5KTtcXG4gICAgYXBwZW5kVG9TdGFjayhlbCk7XFxuICAgIHVwZGF0ZVN0YXRzKCk7XFxuICB9KTtcXG5cXG4gIHJ1bm5lci5vbigncGVuZGluZycsIGZ1bmN0aW9uICh0ZXN0KSB7XFxuICAgIHZhciBlbCA9IGZyYWdtZW50KCc8bGkgY2xhc3M9XFxcInRlc3QgcGFzcyBwZW5kaW5nXFxcIj48aDI+JWU8L2gyPjwvbGk+JywgdGVzdC50aXRsZSk7XFxuICAgIGFwcGVuZFRvU3RhY2soZWwpO1xcbiAgICB1cGRhdGVTdGF0cygpO1xcbiAgfSk7XFxuXFxuICBmdW5jdGlvbiBhcHBlbmRUb1N0YWNrIChlbCkge1xcbiAgICAvLyBEb24ndCBjYWxsIC5hcHBlbmRDaGlsZCBpZiAjbW9jaGEtcmVwb3J0IHdhcyBhbHJlYWR5IC5zaGlmdCgpJ2VkIG9mZiB0aGUgc3RhY2suXFxuICAgIGlmIChzdGFja1swXSkge1xcbiAgICAgIHN0YWNrWzBdLmFwcGVuZENoaWxkKGVsKTtcXG4gICAgfVxcbiAgfVxcblxcbiAgZnVuY3Rpb24gdXBkYXRlU3RhdHMgKCkge1xcbiAgICAvLyBUT0RPOiBhZGQgdG8gc3RhdHNcXG4gICAgdmFyIHBlcmNlbnQgPSBzdGF0cy50ZXN0cyAvIHJ1bm5lci50b3RhbCAqIDEwMCB8IDA7XFxuICAgIGlmIChwcm9ncmVzcykge1xcbiAgICAgIHByb2dyZXNzLnVwZGF0ZShwZXJjZW50KS5kcmF3KGN0eCk7XFxuICAgIH1cXG5cXG4gICAgLy8gdXBkYXRlIHN0YXRzXFxuICAgIHZhciBtcyA9IG5ldyBEYXRlKCkgLSBzdGF0cy5zdGFydDtcXG4gICAgdGV4dChwYXNzZXMsIHN0YXRzLnBhc3Nlcyk7XFxuICAgIHRleHQoZmFpbHVyZXMsIHN0YXRzLmZhaWx1cmVzKTtcXG4gICAgdGV4dChkdXJhdGlvbiwgKG1zIC8gMTAwMCkudG9GaXhlZCgyKSk7XFxuICB9XFxufVxcblxcbi8qKlxcbiAqIE1ha2VzIGEgVVJMLCBwcmVzZXJ2aW5nIHF1ZXJ5c3RyaW5nIChcXFwic2VhcmNoXFxcIikgcGFyYW1ldGVycy5cXG4gKlxcbiAqIEBwYXJhbSB7c3RyaW5nfSBzXFxuICogQHJldHVybiB7c3RyaW5nfSBBIG5ldyBVUkwuXFxuICovXFxuZnVuY3Rpb24gbWFrZVVybCAocykge1xcbiAgdmFyIHNlYXJjaCA9IHdpbmRvdy5sb2NhdGlvbi5zZWFyY2g7XFxuXFxuICAvLyBSZW1vdmUgcHJldmlvdXMgZ3JlcCBxdWVyeSBwYXJhbWV0ZXIgaWYgcHJlc2VudFxcbiAgaWYgKHNlYXJjaCkge1xcbiAgICBzZWFyY2ggPSBzZWFyY2gucmVwbGFjZSgvWz8mXWdyZXA9W14mXFxcXHNdKi9nLCAnJykucmVwbGFjZSgvXiYvLCAnPycpO1xcbiAgfVxcblxcbiAgcmV0dXJuIHdpbmRvdy5sb2NhdGlvbi5wYXRobmFtZSArIChzZWFyY2ggPyBzZWFyY2ggKyAnJicgOiAnPycpICsgJ2dyZXA9JyArIGVuY29kZVVSSUNvbXBvbmVudChlc2NhcGVSZShzKSk7XFxufVxcblxcbi8qKlxcbiAqIFByb3ZpZGUgc3VpdGUgVVJMLlxcbiAqXFxuICogQHBhcmFtIHtPYmplY3R9IFtzdWl0ZV1cXG4gKi9cXG5IVE1MLnByb3RvdHlwZS5zdWl0ZVVSTCA9IGZ1bmN0aW9uIChzdWl0ZSkge1xcbiAgcmV0dXJuIG1ha2VVcmwoc3VpdGUuZnVsbFRpdGxlKCkpO1xcbn07XFxuXFxuLyoqXFxuICogUHJvdmlkZSB0ZXN0IFVSTC5cXG4gKlxcbiAqIEBwYXJhbSB7T2JqZWN0fSBbdGVzdF1cXG4gKi9cXG5IVE1MLnByb3RvdHlwZS50ZXN0VVJMID0gZnVuY3Rpb24gKHRlc3QpIHtcXG4gIHJldHVybiBtYWtlVXJsKHRlc3QuZnVsbFRpdGxlKCkpO1xcbn07XFxuXFxuLyoqXFxuICogQWRkcyBjb2RlIHRvZ2dsZSBmdW5jdGlvbmFsaXR5IGZvciB0aGUgcHJvdmlkZWQgdGVzdCdzIGxpc3QgZWxlbWVudC5cXG4gKlxcbiAqIEBwYXJhbSB7SFRNTExJRWxlbWVudH0gZWxcXG4gKiBAcGFyYW0ge3N0cmluZ30gY29udGVudHNcXG4gKi9cXG5IVE1MLnByb3RvdHlwZS5hZGRDb2RlVG9nZ2xlID0gZnVuY3Rpb24gKGVsLCBjb250ZW50cykge1xcbiAgdmFyIGgyID0gZWwuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2gyJylbMF07XFxuXFxuICBvbihoMiwgJ2NsaWNrJywgZnVuY3Rpb24gKCkge1xcbiAgICBwcmUuc3R5bGUuZGlzcGxheSA9IHByZS5zdHlsZS5kaXNwbGF5ID09PSAnbm9uZScgPyAnYmxvY2snIDogJ25vbmUnO1xcbiAgfSk7XFxuXFxuICB2YXIgcHJlID0gZnJhZ21lbnQoJzxwcmU+PGNvZGU+JWU8L2NvZGU+PC9wcmU+JywgdXRpbHMuY2xlYW4oY29udGVudHMpKTtcXG4gIGVsLmFwcGVuZENoaWxkKHByZSk7XFxuICBwcmUuc3R5bGUuZGlzcGxheSA9ICdub25lJztcXG59O1xcblxcbi8qKlxcbiAqIERpc3BsYXkgZXJyb3IgYG1zZ2AuXFxuICpcXG4gKiBAcGFyYW0ge3N0cmluZ30gbXNnXFxuICovXFxuZnVuY3Rpb24gZXJyb3IgKG1zZykge1xcbiAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChmcmFnbWVudCgnPGRpdiBpZD1cXFwibW9jaGEtZXJyb3JcXFwiPiVzPC9kaXY+JywgbXNnKSk7XFxufVxcblxcbi8qKlxcbiAqIFJldHVybiBhIERPTSBmcmFnbWVudCBmcm9tIGBodG1sYC5cXG4gKlxcbiAqIEBwYXJhbSB7c3RyaW5nfSBodG1sXFxuICovXFxuZnVuY3Rpb24gZnJhZ21lbnQgKGh0bWwpIHtcXG4gIHZhciBhcmdzID0gYXJndW1lbnRzO1xcbiAgdmFyIGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xcbiAgdmFyIGkgPSAxO1xcblxcbiAgZGl2LmlubmVySFRNTCA9IGh0bWwucmVwbGFjZSgvJShbc2VdKS9nLCBmdW5jdGlvbiAoXywgdHlwZSkge1xcbiAgICBzd2l0Y2ggKHR5cGUpIHtcXG4gICAgICBjYXNlICdzJzogcmV0dXJuIFN0cmluZyhhcmdzW2krK10pO1xcbiAgICAgIGNhc2UgJ2UnOiByZXR1cm4gZXNjYXBlKGFyZ3NbaSsrXSk7XFxuICAgICAgLy8gbm8gZGVmYXVsdFxcbiAgICB9XFxuICB9KTtcXG5cXG4gIHJldHVybiBkaXYuZmlyc3RDaGlsZDtcXG59XFxuXFxuLyoqXFxuICogQ2hlY2sgZm9yIHN1aXRlcyB0aGF0IGRvIG5vdCBoYXZlIGVsZW1lbnRzXFxuICogd2l0aCBgY2xhc3NuYW1lYCwgYW5kIGhpZGUgdGhlbS5cXG4gKlxcbiAqIEBwYXJhbSB7dGV4dH0gY2xhc3NuYW1lXFxuICovXFxuZnVuY3Rpb24gaGlkZVN1aXRlc1dpdGhvdXQgKGNsYXNzbmFtZSkge1xcbiAgdmFyIHN1aXRlcyA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoJ3N1aXRlJyk7XFxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN1aXRlcy5sZW5ndGg7IGkrKykge1xcbiAgICB2YXIgZWxzID0gc3VpdGVzW2ldLmdldEVsZW1lbnRzQnlDbGFzc05hbWUoY2xhc3NuYW1lKTtcXG4gICAgaWYgKCFlbHMubGVuZ3RoKSB7XFxuICAgICAgc3VpdGVzW2ldLmNsYXNzTmFtZSArPSAnIGhpZGRlbic7XFxuICAgIH1cXG4gIH1cXG59XFxuXFxuLyoqXFxuICogVW5oaWRlIC5oaWRkZW4gc3VpdGVzLlxcbiAqL1xcbmZ1bmN0aW9uIHVuaGlkZSAoKSB7XFxuICB2YXIgZWxzID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSgnc3VpdGUgaGlkZGVuJyk7XFxuICBmb3IgKHZhciBpID0gMDsgaSA8IGVscy5sZW5ndGg7ICsraSkge1xcbiAgICBlbHNbaV0uY2xhc3NOYW1lID0gZWxzW2ldLmNsYXNzTmFtZS5yZXBsYWNlKCdzdWl0ZSBoaWRkZW4nLCAnc3VpdGUnKTtcXG4gIH1cXG59XFxuXFxuLyoqXFxuICogU2V0IGFuIGVsZW1lbnQncyB0ZXh0IGNvbnRlbnRzLlxcbiAqXFxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxcXG4gKiBAcGFyYW0ge3N0cmluZ30gY29udGVudHNcXG4gKi9cXG5mdW5jdGlvbiB0ZXh0IChlbCwgY29udGVudHMpIHtcXG4gIGlmIChlbC50ZXh0Q29udGVudCkge1xcbiAgICBlbC50ZXh0Q29udGVudCA9IGNvbnRlbnRzO1xcbiAgfSBlbHNlIHtcXG4gICAgZWwuaW5uZXJUZXh0ID0gY29udGVudHM7XFxuICB9XFxufVxcblxcbi8qKlxcbiAqIExpc3RlbiBvbiBgZXZlbnRgIHdpdGggY2FsbGJhY2sgYGZuYC5cXG4gKi9cXG5mdW5jdGlvbiBvbiAoZWwsIGV2ZW50LCBmbikge1xcbiAgaWYgKGVsLmFkZEV2ZW50TGlzdGVuZXIpIHtcXG4gICAgZWwuYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgZm4sIGZhbHNlKTtcXG4gIH0gZWxzZSB7XFxuICAgIGVsLmF0dGFjaEV2ZW50KCdvbicgKyBldmVudCwgZm4pO1xcbiAgfVxcbn1cXG5cXG59KS5jYWxsKHRoaXMsdHlwZW9mIGdsb2JhbCAhPT0gXFxcInVuZGVmaW5lZFxcXCIgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gXFxcInVuZGVmaW5lZFxcXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXFxcInVuZGVmaW5lZFxcXCIgPyB3aW5kb3cgOiB7fSlcXG59LHtcXFwiLi4vYnJvd3Nlci9wcm9ncmVzc1xcXCI6NCxcXFwiLi4vdXRpbHNcXFwiOjM4LFxcXCIuL2Jhc2VcXFwiOjE3LFxcXCJlc2NhcGUtc3RyaW5nLXJlZ2V4cFxcXCI6NjF9XSwyMTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XFxuJ3VzZSBzdHJpY3QnO1xcblxcbi8vIEFsaWFzIGV4cG9ydHMgdG8gYSB0aGVpciBub3JtYWxpemVkIGZvcm1hdCBNb2NoYSNyZXBvcnRlciB0byBwcmV2ZW50IGEgbmVlZFxcbi8vIGZvciBkeW5hbWljICh0cnkvY2F0Y2gpIHJlcXVpcmVzLCB3aGljaCBCcm93c2VyaWZ5IGRvZXNuJ3QgaGFuZGxlLlxcbmV4cG9ydHMuQmFzZSA9IGV4cG9ydHMuYmFzZSA9IHJlcXVpcmUoJy4vYmFzZScpO1xcbmV4cG9ydHMuRG90ID0gZXhwb3J0cy5kb3QgPSByZXF1aXJlKCcuL2RvdCcpO1xcbmV4cG9ydHMuRG9jID0gZXhwb3J0cy5kb2MgPSByZXF1aXJlKCcuL2RvYycpO1xcbmV4cG9ydHMuVEFQID0gZXhwb3J0cy50YXAgPSByZXF1aXJlKCcuL3RhcCcpO1xcbmV4cG9ydHMuSlNPTiA9IGV4cG9ydHMuanNvbiA9IHJlcXVpcmUoJy4vanNvbicpO1xcbmV4cG9ydHMuSFRNTCA9IGV4cG9ydHMuaHRtbCA9IHJlcXVpcmUoJy4vaHRtbCcpO1xcbmV4cG9ydHMuTGlzdCA9IGV4cG9ydHMubGlzdCA9IHJlcXVpcmUoJy4vbGlzdCcpO1xcbmV4cG9ydHMuTWluID0gZXhwb3J0cy5taW4gPSByZXF1aXJlKCcuL21pbicpO1xcbmV4cG9ydHMuU3BlYyA9IGV4cG9ydHMuc3BlYyA9IHJlcXVpcmUoJy4vc3BlYycpO1xcbmV4cG9ydHMuTnlhbiA9IGV4cG9ydHMubnlhbiA9IHJlcXVpcmUoJy4vbnlhbicpO1xcbmV4cG9ydHMuWFVuaXQgPSBleHBvcnRzLnh1bml0ID0gcmVxdWlyZSgnLi94dW5pdCcpO1xcbmV4cG9ydHMuTWFya2Rvd24gPSBleHBvcnRzLm1hcmtkb3duID0gcmVxdWlyZSgnLi9tYXJrZG93bicpO1xcbmV4cG9ydHMuUHJvZ3Jlc3MgPSBleHBvcnRzLnByb2dyZXNzID0gcmVxdWlyZSgnLi9wcm9ncmVzcycpO1xcbmV4cG9ydHMuTGFuZGluZyA9IGV4cG9ydHMubGFuZGluZyA9IHJlcXVpcmUoJy4vbGFuZGluZycpO1xcbmV4cG9ydHMuSlNPTlN0cmVhbSA9IGV4cG9ydHNbJ2pzb24tc3RyZWFtJ10gPSByZXF1aXJlKCcuL2pzb24tc3RyZWFtJyk7XFxuXFxufSx7XFxcIi4vYmFzZVxcXCI6MTcsXFxcIi4vZG9jXFxcIjoxOCxcXFwiLi9kb3RcXFwiOjE5LFxcXCIuL2h0bWxcXFwiOjIwLFxcXCIuL2pzb25cXFwiOjIzLFxcXCIuL2pzb24tc3RyZWFtXFxcIjoyMixcXFwiLi9sYW5kaW5nXFxcIjoyNCxcXFwiLi9saXN0XFxcIjoyNSxcXFwiLi9tYXJrZG93blxcXCI6MjYsXFxcIi4vbWluXFxcIjoyNyxcXFwiLi9ueWFuXFxcIjoyOCxcXFwiLi9wcm9ncmVzc1xcXCI6MjksXFxcIi4vc3BlY1xcXCI6MzAsXFxcIi4vdGFwXFxcIjozMSxcXFwiLi94dW5pdFxcXCI6MzJ9XSwyMjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XFxuKGZ1bmN0aW9uIChwcm9jZXNzKXtcXG4ndXNlIHN0cmljdCc7XFxuXFxuLyoqXFxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cXG4gKi9cXG5cXG52YXIgQmFzZSA9IHJlcXVpcmUoJy4vYmFzZScpO1xcbnZhciBKU09OID0gcmVxdWlyZSgnanNvbjMnKTtcXG5cXG4vKipcXG4gKiBFeHBvc2UgYExpc3RgLlxcbiAqL1xcblxcbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IExpc3Q7XFxuXFxuLyoqXFxuICogSW5pdGlhbGl6ZSBhIG5ldyBgTGlzdGAgdGVzdCByZXBvcnRlci5cXG4gKlxcbiAqIEBhcGkgcHVibGljXFxuICogQHBhcmFtIHtSdW5uZXJ9IHJ1bm5lclxcbiAqL1xcbmZ1bmN0aW9uIExpc3QgKHJ1bm5lcikge1xcbiAgQmFzZS5jYWxsKHRoaXMsIHJ1bm5lcik7XFxuXFxuICB2YXIgc2VsZiA9IHRoaXM7XFxuICB2YXIgdG90YWwgPSBydW5uZXIudG90YWw7XFxuXFxuICBydW5uZXIub24oJ3N0YXJ0JywgZnVuY3Rpb24gKCkge1xcbiAgICBjb25zb2xlLmxvZyhKU09OLnN0cmluZ2lmeShbJ3N0YXJ0JywgeyB0b3RhbDogdG90YWwgfV0pKTtcXG4gIH0pO1xcblxcbiAgcnVubmVyLm9uKCdwYXNzJywgZnVuY3Rpb24gKHRlc3QpIHtcXG4gICAgY29uc29sZS5sb2coSlNPTi5zdHJpbmdpZnkoWydwYXNzJywgY2xlYW4odGVzdCldKSk7XFxuICB9KTtcXG5cXG4gIHJ1bm5lci5vbignZmFpbCcsIGZ1bmN0aW9uICh0ZXN0LCBlcnIpIHtcXG4gICAgdGVzdCA9IGNsZWFuKHRlc3QpO1xcbiAgICB0ZXN0LmVyciA9IGVyci5tZXNzYWdlO1xcbiAgICB0ZXN0LnN0YWNrID0gZXJyLnN0YWNrIHx8IG51bGw7XFxuICAgIGNvbnNvbGUubG9nKEpTT04uc3RyaW5naWZ5KFsnZmFpbCcsIHRlc3RdKSk7XFxuICB9KTtcXG5cXG4gIHJ1bm5lci5vbignZW5kJywgZnVuY3Rpb24gKCkge1xcbiAgICBwcm9jZXNzLnN0ZG91dC53cml0ZShKU09OLnN0cmluZ2lmeShbJ2VuZCcsIHNlbGYuc3RhdHNdKSk7XFxuICB9KTtcXG59XFxuXFxuLyoqXFxuICogUmV0dXJuIGEgcGxhaW4tb2JqZWN0IHJlcHJlc2VudGF0aW9uIG9mIGB0ZXN0YFxcbiAqIGZyZWUgb2YgY3ljbGljIHByb3BlcnRpZXMgZXRjLlxcbiAqXFxuICogQGFwaSBwcml2YXRlXFxuICogQHBhcmFtIHtPYmplY3R9IHRlc3RcXG4gKiBAcmV0dXJuIHtPYmplY3R9XFxuICovXFxuZnVuY3Rpb24gY2xlYW4gKHRlc3QpIHtcXG4gIHJldHVybiB7XFxuICAgIHRpdGxlOiB0ZXN0LnRpdGxlLFxcbiAgICBmdWxsVGl0bGU6IHRlc3QuZnVsbFRpdGxlKCksXFxuICAgIGR1cmF0aW9uOiB0ZXN0LmR1cmF0aW9uLFxcbiAgICBjdXJyZW50UmV0cnk6IHRlc3QuY3VycmVudFJldHJ5KClcXG4gIH07XFxufVxcblxcbn0pLmNhbGwodGhpcyxyZXF1aXJlKCdfcHJvY2VzcycpKVxcbn0se1xcXCIuL2Jhc2VcXFwiOjE3LFxcXCJfcHJvY2Vzc1xcXCI6ODIsXFxcImpzb24zXFxcIjo2OX1dLDIzOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcXG4oZnVuY3Rpb24gKHByb2Nlc3Mpe1xcbid1c2Ugc3RyaWN0JztcXG5cXG4vKipcXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxcbiAqL1xcblxcbnZhciBCYXNlID0gcmVxdWlyZSgnLi9iYXNlJyk7XFxuXFxuLyoqXFxuICogRXhwb3NlIGBKU09OYC5cXG4gKi9cXG5cXG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBKU09OUmVwb3J0ZXI7XFxuXFxuLyoqXFxuICogSW5pdGlhbGl6ZSBhIG5ldyBgSlNPTmAgcmVwb3J0ZXIuXFxuICpcXG4gKiBAYXBpIHB1YmxpY1xcbiAqIEBwYXJhbSB7UnVubmVyfSBydW5uZXJcXG4gKi9cXG5mdW5jdGlvbiBKU09OUmVwb3J0ZXIgKHJ1bm5lcikge1xcbiAgQmFzZS5jYWxsKHRoaXMsIHJ1bm5lcik7XFxuXFxuICB2YXIgc2VsZiA9IHRoaXM7XFxuICB2YXIgdGVzdHMgPSBbXTtcXG4gIHZhciBwZW5kaW5nID0gW107XFxuICB2YXIgZmFpbHVyZXMgPSBbXTtcXG4gIHZhciBwYXNzZXMgPSBbXTtcXG5cXG4gIHJ1bm5lci5vbigndGVzdCBlbmQnLCBmdW5jdGlvbiAodGVzdCkge1xcbiAgICB0ZXN0cy5wdXNoKHRlc3QpO1xcbiAgfSk7XFxuXFxuICBydW5uZXIub24oJ3Bhc3MnLCBmdW5jdGlvbiAodGVzdCkge1xcbiAgICBwYXNzZXMucHVzaCh0ZXN0KTtcXG4gIH0pO1xcblxcbiAgcnVubmVyLm9uKCdmYWlsJywgZnVuY3Rpb24gKHRlc3QpIHtcXG4gICAgZmFpbHVyZXMucHVzaCh0ZXN0KTtcXG4gIH0pO1xcblxcbiAgcnVubmVyLm9uKCdwZW5kaW5nJywgZnVuY3Rpb24gKHRlc3QpIHtcXG4gICAgcGVuZGluZy5wdXNoKHRlc3QpO1xcbiAgfSk7XFxuXFxuICBydW5uZXIub24oJ2VuZCcsIGZ1bmN0aW9uICgpIHtcXG4gICAgdmFyIG9iaiA9IHtcXG4gICAgICBzdGF0czogc2VsZi5zdGF0cyxcXG4gICAgICB0ZXN0czogdGVzdHMubWFwKGNsZWFuKSxcXG4gICAgICBwZW5kaW5nOiBwZW5kaW5nLm1hcChjbGVhbiksXFxuICAgICAgZmFpbHVyZXM6IGZhaWx1cmVzLm1hcChjbGVhbiksXFxuICAgICAgcGFzc2VzOiBwYXNzZXMubWFwKGNsZWFuKVxcbiAgICB9O1xcblxcbiAgICBydW5uZXIudGVzdFJlc3VsdHMgPSBvYmo7XFxuXFxuICAgIHByb2Nlc3Muc3Rkb3V0LndyaXRlKEpTT04uc3RyaW5naWZ5KG9iaiwgbnVsbCwgMikpO1xcbiAgfSk7XFxufVxcblxcbi8qKlxcbiAqIFJldHVybiBhIHBsYWluLW9iamVjdCByZXByZXNlbnRhdGlvbiBvZiBgdGVzdGBcXG4gKiBmcmVlIG9mIGN5Y2xpYyBwcm9wZXJ0aWVzIGV0Yy5cXG4gKlxcbiAqIEBhcGkgcHJpdmF0ZVxcbiAqIEBwYXJhbSB7T2JqZWN0fSB0ZXN0XFxuICogQHJldHVybiB7T2JqZWN0fVxcbiAqL1xcbmZ1bmN0aW9uIGNsZWFuICh0ZXN0KSB7XFxuICByZXR1cm4ge1xcbiAgICB0aXRsZTogdGVzdC50aXRsZSxcXG4gICAgZnVsbFRpdGxlOiB0ZXN0LmZ1bGxUaXRsZSgpLFxcbiAgICBkdXJhdGlvbjogdGVzdC5kdXJhdGlvbixcXG4gICAgY3VycmVudFJldHJ5OiB0ZXN0LmN1cnJlbnRSZXRyeSgpLFxcbiAgICBlcnI6IGVycm9ySlNPTih0ZXN0LmVyciB8fCB7fSlcXG4gIH07XFxufVxcblxcbi8qKlxcbiAqIFRyYW5zZm9ybSBgZXJyb3JgIGludG8gYSBKU09OIG9iamVjdC5cXG4gKlxcbiAqIEBhcGkgcHJpdmF0ZVxcbiAqIEBwYXJhbSB7RXJyb3J9IGVyclxcbiAqIEByZXR1cm4ge09iamVjdH1cXG4gKi9cXG5mdW5jdGlvbiBlcnJvckpTT04gKGVycikge1xcbiAgdmFyIHJlcyA9IHt9O1xcbiAgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoZXJyKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcXG4gICAgcmVzW2tleV0gPSBlcnJba2V5XTtcXG4gIH0sIGVycik7XFxuICByZXR1cm4gcmVzO1xcbn1cXG5cXG59KS5jYWxsKHRoaXMscmVxdWlyZSgnX3Byb2Nlc3MnKSlcXG59LHtcXFwiLi9iYXNlXFxcIjoxNyxcXFwiX3Byb2Nlc3NcXFwiOjgyfV0sMjQ6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xcbihmdW5jdGlvbiAocHJvY2Vzcyl7XFxuJ3VzZSBzdHJpY3QnO1xcblxcbi8qKlxcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXFxuICovXFxuXFxudmFyIEJhc2UgPSByZXF1aXJlKCcuL2Jhc2UnKTtcXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCcuLi91dGlscycpLmluaGVyaXRzO1xcbnZhciBjdXJzb3IgPSBCYXNlLmN1cnNvcjtcXG52YXIgY29sb3IgPSBCYXNlLmNvbG9yO1xcblxcbi8qKlxcbiAqIEV4cG9zZSBgTGFuZGluZ2AuXFxuICovXFxuXFxuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gTGFuZGluZztcXG5cXG4vKipcXG4gKiBBaXJwbGFuZSBjb2xvci5cXG4gKi9cXG5cXG5CYXNlLmNvbG9ycy5wbGFuZSA9IDA7XFxuXFxuLyoqXFxuICogQWlycGxhbmUgY3Jhc2ggY29sb3IuXFxuICovXFxuXFxuQmFzZS5jb2xvcnNbJ3BsYW5lIGNyYXNoJ10gPSAzMTtcXG5cXG4vKipcXG4gKiBSdW53YXkgY29sb3IuXFxuICovXFxuXFxuQmFzZS5jb2xvcnMucnVud2F5ID0gOTA7XFxuXFxuLyoqXFxuICogSW5pdGlhbGl6ZSBhIG5ldyBgTGFuZGluZ2AgcmVwb3J0ZXIuXFxuICpcXG4gKiBAYXBpIHB1YmxpY1xcbiAqIEBwYXJhbSB7UnVubmVyfSBydW5uZXJcXG4gKi9cXG5mdW5jdGlvbiBMYW5kaW5nIChydW5uZXIpIHtcXG4gIEJhc2UuY2FsbCh0aGlzLCBydW5uZXIpO1xcblxcbiAgdmFyIHNlbGYgPSB0aGlzO1xcbiAgdmFyIHdpZHRoID0gQmFzZS53aW5kb3cud2lkdGggKiAwLjc1IHwgMDtcXG4gIHZhciB0b3RhbCA9IHJ1bm5lci50b3RhbDtcXG4gIHZhciBzdHJlYW0gPSBwcm9jZXNzLnN0ZG91dDtcXG4gIHZhciBwbGFuZSA9IGNvbG9yKCdwbGFuZScsICfinIgnKTtcXG4gIHZhciBjcmFzaGVkID0gLTE7XFxuICB2YXIgbiA9IDA7XFxuXFxuICBmdW5jdGlvbiBydW53YXkgKCkge1xcbiAgICB2YXIgYnVmID0gQXJyYXkod2lkdGgpLmpvaW4oJy0nKTtcXG4gICAgcmV0dXJuICcgICcgKyBjb2xvcigncnVud2F5JywgYnVmKTtcXG4gIH1cXG5cXG4gIHJ1bm5lci5vbignc3RhcnQnLCBmdW5jdGlvbiAoKSB7XFxuICAgIHN0cmVhbS53cml0ZSgnXFxcXG5cXFxcblxcXFxuICAnKTtcXG4gICAgY3Vyc29yLmhpZGUoKTtcXG4gIH0pO1xcblxcbiAgcnVubmVyLm9uKCd0ZXN0IGVuZCcsIGZ1bmN0aW9uICh0ZXN0KSB7XFxuICAgIC8vIGNoZWNrIGlmIHRoZSBwbGFuZSBjcmFzaGVkXFxuICAgIHZhciBjb2wgPSBjcmFzaGVkID09PSAtMSA/IHdpZHRoICogKytuIC8gdG90YWwgfCAwIDogY3Jhc2hlZDtcXG5cXG4gICAgLy8gc2hvdyB0aGUgY3Jhc2hcXG4gICAgaWYgKHRlc3Quc3RhdGUgPT09ICdmYWlsZWQnKSB7XFxuICAgICAgcGxhbmUgPSBjb2xvcigncGxhbmUgY3Jhc2gnLCAn4pyIJyk7XFxuICAgICAgY3Jhc2hlZCA9IGNvbDtcXG4gICAgfVxcblxcbiAgICAvLyByZW5kZXIgbGFuZGluZyBzdHJpcFxcbiAgICBzdHJlYW0ud3JpdGUoJ1xcXFx1MDAxYlsnICsgKHdpZHRoICsgMSkgKyAnRFxcXFx1MDAxYlsyQScpO1xcbiAgICBzdHJlYW0ud3JpdGUocnVud2F5KCkpO1xcbiAgICBzdHJlYW0ud3JpdGUoJ1xcXFxuICAnKTtcXG4gICAgc3RyZWFtLndyaXRlKGNvbG9yKCdydW53YXknLCBBcnJheShjb2wpLmpvaW4oJ+KLhScpKSk7XFxuICAgIHN0cmVhbS53cml0ZShwbGFuZSk7XFxuICAgIHN0cmVhbS53cml0ZShjb2xvcigncnVud2F5JywgQXJyYXkod2lkdGggLSBjb2wpLmpvaW4oJ+KLhScpICsgJ1xcXFxuJykpO1xcbiAgICBzdHJlYW0ud3JpdGUocnVud2F5KCkpO1xcbiAgICBzdHJlYW0ud3JpdGUoJ1xcXFx1MDAxYlswbScpO1xcbiAgfSk7XFxuXFxuICBydW5uZXIub24oJ2VuZCcsIGZ1bmN0aW9uICgpIHtcXG4gICAgY3Vyc29yLnNob3coKTtcXG4gICAgY29uc29sZS5sb2coKTtcXG4gICAgc2VsZi5lcGlsb2d1ZSgpO1xcbiAgfSk7XFxufVxcblxcbi8qKlxcbiAqIEluaGVyaXQgZnJvbSBgQmFzZS5wcm90b3R5cGVgLlxcbiAqL1xcbmluaGVyaXRzKExhbmRpbmcsIEJhc2UpO1xcblxcbn0pLmNhbGwodGhpcyxyZXF1aXJlKCdfcHJvY2VzcycpKVxcbn0se1xcXCIuLi91dGlsc1xcXCI6MzgsXFxcIi4vYmFzZVxcXCI6MTcsXFxcIl9wcm9jZXNzXFxcIjo4Mn1dLDI1OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcXG4oZnVuY3Rpb24gKHByb2Nlc3Mpe1xcbid1c2Ugc3RyaWN0JztcXG5cXG4vKipcXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxcbiAqL1xcblxcbnZhciBCYXNlID0gcmVxdWlyZSgnLi9iYXNlJyk7XFxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnLi4vdXRpbHMnKS5pbmhlcml0cztcXG52YXIgY29sb3IgPSBCYXNlLmNvbG9yO1xcbnZhciBjdXJzb3IgPSBCYXNlLmN1cnNvcjtcXG5cXG4vKipcXG4gKiBFeHBvc2UgYExpc3RgLlxcbiAqL1xcblxcbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IExpc3Q7XFxuXFxuLyoqXFxuICogSW5pdGlhbGl6ZSBhIG5ldyBgTGlzdGAgdGVzdCByZXBvcnRlci5cXG4gKlxcbiAqIEBhcGkgcHVibGljXFxuICogQHBhcmFtIHtSdW5uZXJ9IHJ1bm5lclxcbiAqL1xcbmZ1bmN0aW9uIExpc3QgKHJ1bm5lcikge1xcbiAgQmFzZS5jYWxsKHRoaXMsIHJ1bm5lcik7XFxuXFxuICB2YXIgc2VsZiA9IHRoaXM7XFxuICB2YXIgbiA9IDA7XFxuXFxuICBydW5uZXIub24oJ3N0YXJ0JywgZnVuY3Rpb24gKCkge1xcbiAgICBjb25zb2xlLmxvZygpO1xcbiAgfSk7XFxuXFxuICBydW5uZXIub24oJ3Rlc3QnLCBmdW5jdGlvbiAodGVzdCkge1xcbiAgICBwcm9jZXNzLnN0ZG91dC53cml0ZShjb2xvcigncGFzcycsICcgICAgJyArIHRlc3QuZnVsbFRpdGxlKCkgKyAnOiAnKSk7XFxuICB9KTtcXG5cXG4gIHJ1bm5lci5vbigncGVuZGluZycsIGZ1bmN0aW9uICh0ZXN0KSB7XFxuICAgIHZhciBmbXQgPSBjb2xvcignY2hlY2ttYXJrJywgJyAgLScpICtcXG4gICAgICBjb2xvcigncGVuZGluZycsICcgJXMnKTtcXG4gICAgY29uc29sZS5sb2coZm10LCB0ZXN0LmZ1bGxUaXRsZSgpKTtcXG4gIH0pO1xcblxcbiAgcnVubmVyLm9uKCdwYXNzJywgZnVuY3Rpb24gKHRlc3QpIHtcXG4gICAgdmFyIGZtdCA9IGNvbG9yKCdjaGVja21hcmsnLCAnICAnICsgQmFzZS5zeW1ib2xzLm9rKSArXFxuICAgICAgY29sb3IoJ3Bhc3MnLCAnICVzOiAnKSArXFxuICAgICAgY29sb3IodGVzdC5zcGVlZCwgJyVkbXMnKTtcXG4gICAgY3Vyc29yLkNSKCk7XFxuICAgIGNvbnNvbGUubG9nKGZtdCwgdGVzdC5mdWxsVGl0bGUoKSwgdGVzdC5kdXJhdGlvbik7XFxuICB9KTtcXG5cXG4gIHJ1bm5lci5vbignZmFpbCcsIGZ1bmN0aW9uICh0ZXN0KSB7XFxuICAgIGN1cnNvci5DUigpO1xcbiAgICBjb25zb2xlLmxvZyhjb2xvcignZmFpbCcsICcgICVkKSAlcycpLCArK24sIHRlc3QuZnVsbFRpdGxlKCkpO1xcbiAgfSk7XFxuXFxuICBydW5uZXIub24oJ2VuZCcsIHNlbGYuZXBpbG9ndWUuYmluZChzZWxmKSk7XFxufVxcblxcbi8qKlxcbiAqIEluaGVyaXQgZnJvbSBgQmFzZS5wcm90b3R5cGVgLlxcbiAqL1xcbmluaGVyaXRzKExpc3QsIEJhc2UpO1xcblxcbn0pLmNhbGwodGhpcyxyZXF1aXJlKCdfcHJvY2VzcycpKVxcbn0se1xcXCIuLi91dGlsc1xcXCI6MzgsXFxcIi4vYmFzZVxcXCI6MTcsXFxcIl9wcm9jZXNzXFxcIjo4Mn1dLDI2OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcXG4oZnVuY3Rpb24gKHByb2Nlc3Mpe1xcbid1c2Ugc3RyaWN0JztcXG5cXG4vKipcXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxcbiAqL1xcblxcbnZhciBCYXNlID0gcmVxdWlyZSgnLi9iYXNlJyk7XFxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMnKTtcXG5cXG4vKipcXG4gKiBDb25zdGFudHNcXG4gKi9cXG5cXG52YXIgU1VJVEVfUFJFRklYID0gJyQnO1xcblxcbi8qKlxcbiAqIEV4cG9zZSBgTWFya2Rvd25gLlxcbiAqL1xcblxcbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IE1hcmtkb3duO1xcblxcbi8qKlxcbiAqIEluaXRpYWxpemUgYSBuZXcgYE1hcmtkb3duYCByZXBvcnRlci5cXG4gKlxcbiAqIEBhcGkgcHVibGljXFxuICogQHBhcmFtIHtSdW5uZXJ9IHJ1bm5lclxcbiAqL1xcbmZ1bmN0aW9uIE1hcmtkb3duIChydW5uZXIpIHtcXG4gIEJhc2UuY2FsbCh0aGlzLCBydW5uZXIpO1xcblxcbiAgdmFyIGxldmVsID0gMDtcXG4gIHZhciBidWYgPSAnJztcXG5cXG4gIGZ1bmN0aW9uIHRpdGxlIChzdHIpIHtcXG4gICAgcmV0dXJuIEFycmF5KGxldmVsKS5qb2luKCcjJykgKyAnICcgKyBzdHI7XFxuICB9XFxuXFxuICBmdW5jdGlvbiBtYXBUT0MgKHN1aXRlLCBvYmopIHtcXG4gICAgdmFyIHJldCA9IG9iajtcXG4gICAgdmFyIGtleSA9IFNVSVRFX1BSRUZJWCArIHN1aXRlLnRpdGxlO1xcblxcbiAgICBvYmogPSBvYmpba2V5XSA9IG9ialtrZXldIHx8IHsgc3VpdGU6IHN1aXRlIH07XFxuICAgIHN1aXRlLnN1aXRlcy5mb3JFYWNoKGZ1bmN0aW9uIChzdWl0ZSkge1xcbiAgICAgIG1hcFRPQyhzdWl0ZSwgb2JqKTtcXG4gICAgfSk7XFxuXFxuICAgIHJldHVybiByZXQ7XFxuICB9XFxuXFxuICBmdW5jdGlvbiBzdHJpbmdpZnlUT0MgKG9iaiwgbGV2ZWwpIHtcXG4gICAgKytsZXZlbDtcXG4gICAgdmFyIGJ1ZiA9ICcnO1xcbiAgICB2YXIgbGluaztcXG4gICAgZm9yICh2YXIga2V5IGluIG9iaikge1xcbiAgICAgIGlmIChrZXkgPT09ICdzdWl0ZScpIHtcXG4gICAgICAgIGNvbnRpbnVlO1xcbiAgICAgIH1cXG4gICAgICBpZiAoa2V5ICE9PSBTVUlURV9QUkVGSVgpIHtcXG4gICAgICAgIGxpbmsgPSAnIC0gWycgKyBrZXkuc3Vic3RyaW5nKDEpICsgJ10nO1xcbiAgICAgICAgbGluayArPSAnKCMnICsgdXRpbHMuc2x1ZyhvYmpba2V5XS5zdWl0ZS5mdWxsVGl0bGUoKSkgKyAnKVxcXFxuJztcXG4gICAgICAgIGJ1ZiArPSBBcnJheShsZXZlbCkuam9pbignICAnKSArIGxpbms7XFxuICAgICAgfVxcbiAgICAgIGJ1ZiArPSBzdHJpbmdpZnlUT0Mob2JqW2tleV0sIGxldmVsKTtcXG4gICAgfVxcbiAgICByZXR1cm4gYnVmO1xcbiAgfVxcblxcbiAgZnVuY3Rpb24gZ2VuZXJhdGVUT0MgKHN1aXRlKSB7XFxuICAgIHZhciBvYmogPSBtYXBUT0Moc3VpdGUsIHt9KTtcXG4gICAgcmV0dXJuIHN0cmluZ2lmeVRPQyhvYmosIDApO1xcbiAgfVxcblxcbiAgZ2VuZXJhdGVUT0MocnVubmVyLnN1aXRlKTtcXG5cXG4gIHJ1bm5lci5vbignc3VpdGUnLCBmdW5jdGlvbiAoc3VpdGUpIHtcXG4gICAgKytsZXZlbDtcXG4gICAgdmFyIHNsdWcgPSB1dGlscy5zbHVnKHN1aXRlLmZ1bGxUaXRsZSgpKTtcXG4gICAgYnVmICs9ICc8YSBuYW1lPVxcXCInICsgc2x1ZyArICdcXFwiPjwvYT4nICsgJ1xcXFxuJztcXG4gICAgYnVmICs9IHRpdGxlKHN1aXRlLnRpdGxlKSArICdcXFxcbic7XFxuICB9KTtcXG5cXG4gIHJ1bm5lci5vbignc3VpdGUgZW5kJywgZnVuY3Rpb24gKCkge1xcbiAgICAtLWxldmVsO1xcbiAgfSk7XFxuXFxuICBydW5uZXIub24oJ3Bhc3MnLCBmdW5jdGlvbiAodGVzdCkge1xcbiAgICB2YXIgY29kZSA9IHV0aWxzLmNsZWFuKHRlc3QuYm9keSk7XFxuICAgIGJ1ZiArPSB0ZXN0LnRpdGxlICsgJy5cXFxcbic7XFxuICAgIGJ1ZiArPSAnXFxcXG5gYGBqc1xcXFxuJztcXG4gICAgYnVmICs9IGNvZGUgKyAnXFxcXG4nO1xcbiAgICBidWYgKz0gJ2BgYFxcXFxuXFxcXG4nO1xcbiAgfSk7XFxuXFxuICBydW5uZXIub24oJ2VuZCcsIGZ1bmN0aW9uICgpIHtcXG4gICAgcHJvY2Vzcy5zdGRvdXQud3JpdGUoJyMgVE9DXFxcXG4nKTtcXG4gICAgcHJvY2Vzcy5zdGRvdXQud3JpdGUoZ2VuZXJhdGVUT0MocnVubmVyLnN1aXRlKSk7XFxuICAgIHByb2Nlc3Muc3Rkb3V0LndyaXRlKGJ1Zik7XFxuICB9KTtcXG59XFxuXFxufSkuY2FsbCh0aGlzLHJlcXVpcmUoJ19wcm9jZXNzJykpXFxufSx7XFxcIi4uL3V0aWxzXFxcIjozOCxcXFwiLi9iYXNlXFxcIjoxNyxcXFwiX3Byb2Nlc3NcXFwiOjgyfV0sMjc6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xcbihmdW5jdGlvbiAocHJvY2Vzcyl7XFxuJ3VzZSBzdHJpY3QnO1xcblxcbi8qKlxcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXFxuICovXFxuXFxudmFyIEJhc2UgPSByZXF1aXJlKCcuL2Jhc2UnKTtcXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCcuLi91dGlscycpLmluaGVyaXRzO1xcblxcbi8qKlxcbiAqIEV4cG9zZSBgTWluYC5cXG4gKi9cXG5cXG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBNaW47XFxuXFxuLyoqXFxuICogSW5pdGlhbGl6ZSBhIG5ldyBgTWluYCBtaW5pbWFsIHRlc3QgcmVwb3J0ZXIgKGJlc3QgdXNlZCB3aXRoIC0td2F0Y2gpLlxcbiAqXFxuICogQGFwaSBwdWJsaWNcXG4gKiBAcGFyYW0ge1J1bm5lcn0gcnVubmVyXFxuICovXFxuZnVuY3Rpb24gTWluIChydW5uZXIpIHtcXG4gIEJhc2UuY2FsbCh0aGlzLCBydW5uZXIpO1xcblxcbiAgcnVubmVyLm9uKCdzdGFydCcsIGZ1bmN0aW9uICgpIHtcXG4gICAgLy8gY2xlYXIgc2NyZWVuXFxuICAgIHByb2Nlc3Muc3Rkb3V0LndyaXRlKCdcXFxcdTAwMWJbMkonKTtcXG4gICAgLy8gc2V0IGN1cnNvciBwb3NpdGlvblxcbiAgICBwcm9jZXNzLnN0ZG91dC53cml0ZSgnXFxcXHUwMDFiWzE7M0gnKTtcXG4gIH0pO1xcblxcbiAgcnVubmVyLm9uKCdlbmQnLCB0aGlzLmVwaWxvZ3VlLmJpbmQodGhpcykpO1xcbn1cXG5cXG4vKipcXG4gKiBJbmhlcml0IGZyb20gYEJhc2UucHJvdG90eXBlYC5cXG4gKi9cXG5pbmhlcml0cyhNaW4sIEJhc2UpO1xcblxcbn0pLmNhbGwodGhpcyxyZXF1aXJlKCdfcHJvY2VzcycpKVxcbn0se1xcXCIuLi91dGlsc1xcXCI6MzgsXFxcIi4vYmFzZVxcXCI6MTcsXFxcIl9wcm9jZXNzXFxcIjo4Mn1dLDI4OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcXG4oZnVuY3Rpb24gKHByb2Nlc3Mpe1xcbid1c2Ugc3RyaWN0JztcXG5cXG4vKipcXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxcbiAqL1xcblxcbnZhciBCYXNlID0gcmVxdWlyZSgnLi9iYXNlJyk7XFxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnLi4vdXRpbHMnKS5pbmhlcml0cztcXG5cXG4vKipcXG4gKiBFeHBvc2UgYERvdGAuXFxuICovXFxuXFxuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gTnlhbkNhdDtcXG5cXG4vKipcXG4gKiBJbml0aWFsaXplIGEgbmV3IGBEb3RgIG1hdHJpeCB0ZXN0IHJlcG9ydGVyLlxcbiAqXFxuICogQHBhcmFtIHtSdW5uZXJ9IHJ1bm5lclxcbiAqIEBhcGkgcHVibGljXFxuICovXFxuXFxuZnVuY3Rpb24gTnlhbkNhdCAocnVubmVyKSB7XFxuICBCYXNlLmNhbGwodGhpcywgcnVubmVyKTtcXG5cXG4gIHZhciBzZWxmID0gdGhpcztcXG4gIHZhciB3aWR0aCA9IEJhc2Uud2luZG93LndpZHRoICogMC43NSB8IDA7XFxuICB2YXIgbnlhbkNhdFdpZHRoID0gdGhpcy5ueWFuQ2F0V2lkdGggPSAxMTtcXG5cXG4gIHRoaXMuY29sb3JJbmRleCA9IDA7XFxuICB0aGlzLm51bWJlck9mTGluZXMgPSA0O1xcbiAgdGhpcy5yYWluYm93Q29sb3JzID0gc2VsZi5nZW5lcmF0ZUNvbG9ycygpO1xcbiAgdGhpcy5zY29yZWJvYXJkV2lkdGggPSA1O1xcbiAgdGhpcy50aWNrID0gMDtcXG4gIHRoaXMudHJhamVjdG9yaWVzID0gW1tdLCBbXSwgW10sIFtdXTtcXG4gIHRoaXMudHJhamVjdG9yeVdpZHRoTWF4ID0gKHdpZHRoIC0gbnlhbkNhdFdpZHRoKTtcXG5cXG4gIHJ1bm5lci5vbignc3RhcnQnLCBmdW5jdGlvbiAoKSB7XFxuICAgIEJhc2UuY3Vyc29yLmhpZGUoKTtcXG4gICAgc2VsZi5kcmF3KCk7XFxuICB9KTtcXG5cXG4gIHJ1bm5lci5vbigncGVuZGluZycsIGZ1bmN0aW9uICgpIHtcXG4gICAgc2VsZi5kcmF3KCk7XFxuICB9KTtcXG5cXG4gIHJ1bm5lci5vbigncGFzcycsIGZ1bmN0aW9uICgpIHtcXG4gICAgc2VsZi5kcmF3KCk7XFxuICB9KTtcXG5cXG4gIHJ1bm5lci5vbignZmFpbCcsIGZ1bmN0aW9uICgpIHtcXG4gICAgc2VsZi5kcmF3KCk7XFxuICB9KTtcXG5cXG4gIHJ1bm5lci5vbignZW5kJywgZnVuY3Rpb24gKCkge1xcbiAgICBCYXNlLmN1cnNvci5zaG93KCk7XFxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2VsZi5udW1iZXJPZkxpbmVzOyBpKyspIHtcXG4gICAgICB3cml0ZSgnXFxcXG4nKTtcXG4gICAgfVxcbiAgICBzZWxmLmVwaWxvZ3VlKCk7XFxuICB9KTtcXG59XFxuXFxuLyoqXFxuICogSW5oZXJpdCBmcm9tIGBCYXNlLnByb3RvdHlwZWAuXFxuICovXFxuaW5oZXJpdHMoTnlhbkNhdCwgQmFzZSk7XFxuXFxuLyoqXFxuICogRHJhdyB0aGUgbnlhbiBjYXRcXG4gKlxcbiAqIEBhcGkgcHJpdmF0ZVxcbiAqL1xcblxcbk55YW5DYXQucHJvdG90eXBlLmRyYXcgPSBmdW5jdGlvbiAoKSB7XFxuICB0aGlzLmFwcGVuZFJhaW5ib3coKTtcXG4gIHRoaXMuZHJhd1Njb3JlYm9hcmQoKTtcXG4gIHRoaXMuZHJhd1JhaW5ib3coKTtcXG4gIHRoaXMuZHJhd055YW5DYXQoKTtcXG4gIHRoaXMudGljayA9ICF0aGlzLnRpY2s7XFxufTtcXG5cXG4vKipcXG4gKiBEcmF3IHRoZSBcXFwic2NvcmVib2FyZFxcXCIgc2hvd2luZyB0aGUgbnVtYmVyXFxuICogb2YgcGFzc2VzLCBmYWlsdXJlcyBhbmQgcGVuZGluZyB0ZXN0cy5cXG4gKlxcbiAqIEBhcGkgcHJpdmF0ZVxcbiAqL1xcblxcbk55YW5DYXQucHJvdG90eXBlLmRyYXdTY29yZWJvYXJkID0gZnVuY3Rpb24gKCkge1xcbiAgdmFyIHN0YXRzID0gdGhpcy5zdGF0cztcXG5cXG4gIGZ1bmN0aW9uIGRyYXcgKHR5cGUsIG4pIHtcXG4gICAgd3JpdGUoJyAnKTtcXG4gICAgd3JpdGUoQmFzZS5jb2xvcih0eXBlLCBuKSk7XFxuICAgIHdyaXRlKCdcXFxcbicpO1xcbiAgfVxcblxcbiAgZHJhdygnZ3JlZW4nLCBzdGF0cy5wYXNzZXMpO1xcbiAgZHJhdygnZmFpbCcsIHN0YXRzLmZhaWx1cmVzKTtcXG4gIGRyYXcoJ3BlbmRpbmcnLCBzdGF0cy5wZW5kaW5nKTtcXG4gIHdyaXRlKCdcXFxcbicpO1xcblxcbiAgdGhpcy5jdXJzb3JVcCh0aGlzLm51bWJlck9mTGluZXMpO1xcbn07XFxuXFxuLyoqXFxuICogQXBwZW5kIHRoZSByYWluYm93LlxcbiAqXFxuICogQGFwaSBwcml2YXRlXFxuICovXFxuXFxuTnlhbkNhdC5wcm90b3R5cGUuYXBwZW5kUmFpbmJvdyA9IGZ1bmN0aW9uICgpIHtcXG4gIHZhciBzZWdtZW50ID0gdGhpcy50aWNrID8gJ18nIDogJy0nO1xcbiAgdmFyIHJhaW5ib3dpZmllZCA9IHRoaXMucmFpbmJvd2lmeShzZWdtZW50KTtcXG5cXG4gIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCB0aGlzLm51bWJlck9mTGluZXM7IGluZGV4KyspIHtcXG4gICAgdmFyIHRyYWplY3RvcnkgPSB0aGlzLnRyYWplY3Rvcmllc1tpbmRleF07XFxuICAgIGlmICh0cmFqZWN0b3J5Lmxlbmd0aCA+PSB0aGlzLnRyYWplY3RvcnlXaWR0aE1heCkge1xcbiAgICAgIHRyYWplY3Rvcnkuc2hpZnQoKTtcXG4gICAgfVxcbiAgICB0cmFqZWN0b3J5LnB1c2gocmFpbmJvd2lmaWVkKTtcXG4gIH1cXG59O1xcblxcbi8qKlxcbiAqIERyYXcgdGhlIHJhaW5ib3cuXFxuICpcXG4gKiBAYXBpIHByaXZhdGVcXG4gKi9cXG5cXG5OeWFuQ2F0LnByb3RvdHlwZS5kcmF3UmFpbmJvdyA9IGZ1bmN0aW9uICgpIHtcXG4gIHZhciBzZWxmID0gdGhpcztcXG5cXG4gIHRoaXMudHJhamVjdG9yaWVzLmZvckVhY2goZnVuY3Rpb24gKGxpbmUpIHtcXG4gICAgd3JpdGUoJ1xcXFx1MDAxYlsnICsgc2VsZi5zY29yZWJvYXJkV2lkdGggKyAnQycpO1xcbiAgICB3cml0ZShsaW5lLmpvaW4oJycpKTtcXG4gICAgd3JpdGUoJ1xcXFxuJyk7XFxuICB9KTtcXG5cXG4gIHRoaXMuY3Vyc29yVXAodGhpcy5udW1iZXJPZkxpbmVzKTtcXG59O1xcblxcbi8qKlxcbiAqIERyYXcgdGhlIG55YW4gY2F0XFxuICpcXG4gKiBAYXBpIHByaXZhdGVcXG4gKi9cXG5OeWFuQ2F0LnByb3RvdHlwZS5kcmF3TnlhbkNhdCA9IGZ1bmN0aW9uICgpIHtcXG4gIHZhciBzZWxmID0gdGhpcztcXG4gIHZhciBzdGFydFdpZHRoID0gdGhpcy5zY29yZWJvYXJkV2lkdGggKyB0aGlzLnRyYWplY3Rvcmllc1swXS5sZW5ndGg7XFxuICB2YXIgZGlzdCA9ICdcXFxcdTAwMWJbJyArIHN0YXJ0V2lkdGggKyAnQyc7XFxuICB2YXIgcGFkZGluZyA9ICcnO1xcblxcbiAgd3JpdGUoZGlzdCk7XFxuICB3cml0ZSgnXywtLS0tLS0sJyk7XFxuICB3cml0ZSgnXFxcXG4nKTtcXG5cXG4gIHdyaXRlKGRpc3QpO1xcbiAgcGFkZGluZyA9IHNlbGYudGljayA/ICcgICcgOiAnICAgJztcXG4gIHdyaXRlKCdffCcgKyBwYWRkaW5nICsgJy9cXFxcXFxcXF8vXFxcXFxcXFwgJyk7XFxuICB3cml0ZSgnXFxcXG4nKTtcXG5cXG4gIHdyaXRlKGRpc3QpO1xcbiAgcGFkZGluZyA9IHNlbGYudGljayA/ICdfJyA6ICdfXyc7XFxuICB2YXIgdGFpbCA9IHNlbGYudGljayA/ICd+JyA6ICdeJztcXG4gIHdyaXRlKHRhaWwgKyAnfCcgKyBwYWRkaW5nICsgdGhpcy5mYWNlKCkgKyAnICcpO1xcbiAgd3JpdGUoJ1xcXFxuJyk7XFxuXFxuICB3cml0ZShkaXN0KTtcXG4gIHBhZGRpbmcgPSBzZWxmLnRpY2sgPyAnICcgOiAnICAnO1xcbiAgd3JpdGUocGFkZGluZyArICdcXFwiXFxcIiAgXFxcIlxcXCIgJyk7XFxuICB3cml0ZSgnXFxcXG4nKTtcXG5cXG4gIHRoaXMuY3Vyc29yVXAodGhpcy5udW1iZXJPZkxpbmVzKTtcXG59O1xcblxcbi8qKlxcbiAqIERyYXcgbnlhbiBjYXQgZmFjZS5cXG4gKlxcbiAqIEBhcGkgcHJpdmF0ZVxcbiAqIEByZXR1cm4ge3N0cmluZ31cXG4gKi9cXG5cXG5OeWFuQ2F0LnByb3RvdHlwZS5mYWNlID0gZnVuY3Rpb24gKCkge1xcbiAgdmFyIHN0YXRzID0gdGhpcy5zdGF0cztcXG4gIGlmIChzdGF0cy5mYWlsdXJlcykge1xcbiAgICByZXR1cm4gJyggeCAueCknO1xcbiAgfSBlbHNlIGlmIChzdGF0cy5wZW5kaW5nKSB7XFxuICAgIHJldHVybiAnKCBvIC5vKSc7XFxuICB9IGVsc2UgaWYgKHN0YXRzLnBhc3Nlcykge1xcbiAgICByZXR1cm4gJyggXiAuXiknO1xcbiAgfVxcbiAgcmV0dXJuICcoIC0gLi0pJztcXG59O1xcblxcbi8qKlxcbiAqIE1vdmUgY3Vyc29yIHVwIGBuYC5cXG4gKlxcbiAqIEBhcGkgcHJpdmF0ZVxcbiAqIEBwYXJhbSB7bnVtYmVyfSBuXFxuICovXFxuXFxuTnlhbkNhdC5wcm90b3R5cGUuY3Vyc29yVXAgPSBmdW5jdGlvbiAobikge1xcbiAgd3JpdGUoJ1xcXFx1MDAxYlsnICsgbiArICdBJyk7XFxufTtcXG5cXG4vKipcXG4gKiBNb3ZlIGN1cnNvciBkb3duIGBuYC5cXG4gKlxcbiAqIEBhcGkgcHJpdmF0ZVxcbiAqIEBwYXJhbSB7bnVtYmVyfSBuXFxuICovXFxuXFxuTnlhbkNhdC5wcm90b3R5cGUuY3Vyc29yRG93biA9IGZ1bmN0aW9uIChuKSB7XFxuICB3cml0ZSgnXFxcXHUwMDFiWycgKyBuICsgJ0InKTtcXG59O1xcblxcbi8qKlxcbiAqIEdlbmVyYXRlIHJhaW5ib3cgY29sb3JzLlxcbiAqXFxuICogQGFwaSBwcml2YXRlXFxuICogQHJldHVybiB7QXJyYXl9XFxuICovXFxuTnlhbkNhdC5wcm90b3R5cGUuZ2VuZXJhdGVDb2xvcnMgPSBmdW5jdGlvbiAoKSB7XFxuICB2YXIgY29sb3JzID0gW107XFxuXFxuICBmb3IgKHZhciBpID0gMDsgaSA8ICg2ICogNyk7IGkrKykge1xcbiAgICB2YXIgcGkzID0gTWF0aC5mbG9vcihNYXRoLlBJIC8gMyk7XFxuICAgIHZhciBuID0gKGkgKiAoMS4wIC8gNikpO1xcbiAgICB2YXIgciA9IE1hdGguZmxvb3IoMyAqIE1hdGguc2luKG4pICsgMyk7XFxuICAgIHZhciBnID0gTWF0aC5mbG9vcigzICogTWF0aC5zaW4obiArIDIgKiBwaTMpICsgMyk7XFxuICAgIHZhciBiID0gTWF0aC5mbG9vcigzICogTWF0aC5zaW4obiArIDQgKiBwaTMpICsgMyk7XFxuICAgIGNvbG9ycy5wdXNoKDM2ICogciArIDYgKiBnICsgYiArIDE2KTtcXG4gIH1cXG5cXG4gIHJldHVybiBjb2xvcnM7XFxufTtcXG5cXG4vKipcXG4gKiBBcHBseSByYWluYm93IHRvIHRoZSBnaXZlbiBgc3RyYC5cXG4gKlxcbiAqIEBhcGkgcHJpdmF0ZVxcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJcXG4gKiBAcmV0dXJuIHtzdHJpbmd9XFxuICovXFxuTnlhbkNhdC5wcm90b3R5cGUucmFpbmJvd2lmeSA9IGZ1bmN0aW9uIChzdHIpIHtcXG4gIGlmICghQmFzZS51c2VDb2xvcnMpIHtcXG4gICAgcmV0dXJuIHN0cjtcXG4gIH1cXG4gIHZhciBjb2xvciA9IHRoaXMucmFpbmJvd0NvbG9yc1t0aGlzLmNvbG9ySW5kZXggJSB0aGlzLnJhaW5ib3dDb2xvcnMubGVuZ3RoXTtcXG4gIHRoaXMuY29sb3JJbmRleCArPSAxO1xcbiAgcmV0dXJuICdcXFxcdTAwMWJbMzg7NTsnICsgY29sb3IgKyAnbScgKyBzdHIgKyAnXFxcXHUwMDFiWzBtJztcXG59O1xcblxcbi8qKlxcbiAqIFN0ZG91dCBoZWxwZXIuXFxuICpcXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIEEgbWVzc2FnZSB0byB3cml0ZSB0byBzdGRvdXQuXFxuICovXFxuZnVuY3Rpb24gd3JpdGUgKHN0cmluZykge1xcbiAgcHJvY2Vzcy5zdGRvdXQud3JpdGUoc3RyaW5nKTtcXG59XFxuXFxufSkuY2FsbCh0aGlzLHJlcXVpcmUoJ19wcm9jZXNzJykpXFxufSx7XFxcIi4uL3V0aWxzXFxcIjozOCxcXFwiLi9iYXNlXFxcIjoxNyxcXFwiX3Byb2Nlc3NcXFwiOjgyfV0sMjk6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xcbihmdW5jdGlvbiAocHJvY2Vzcyl7XFxuJ3VzZSBzdHJpY3QnO1xcblxcbi8qKlxcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXFxuICovXFxuXFxudmFyIEJhc2UgPSByZXF1aXJlKCcuL2Jhc2UnKTtcXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCcuLi91dGlscycpLmluaGVyaXRzO1xcbnZhciBjb2xvciA9IEJhc2UuY29sb3I7XFxudmFyIGN1cnNvciA9IEJhc2UuY3Vyc29yO1xcblxcbi8qKlxcbiAqIEV4cG9zZSBgUHJvZ3Jlc3NgLlxcbiAqL1xcblxcbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IFByb2dyZXNzO1xcblxcbi8qKlxcbiAqIEdlbmVyYWwgcHJvZ3Jlc3MgYmFyIGNvbG9yLlxcbiAqL1xcblxcbkJhc2UuY29sb3JzLnByb2dyZXNzID0gOTA7XFxuXFxuLyoqXFxuICogSW5pdGlhbGl6ZSBhIG5ldyBgUHJvZ3Jlc3NgIGJhciB0ZXN0IHJlcG9ydGVyLlxcbiAqXFxuICogQGFwaSBwdWJsaWNcXG4gKiBAcGFyYW0ge1J1bm5lcn0gcnVubmVyXFxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcXG4gKi9cXG5mdW5jdGlvbiBQcm9ncmVzcyAocnVubmVyLCBvcHRpb25zKSB7XFxuICBCYXNlLmNhbGwodGhpcywgcnVubmVyKTtcXG5cXG4gIHZhciBzZWxmID0gdGhpcztcXG4gIHZhciB3aWR0aCA9IEJhc2Uud2luZG93LndpZHRoICogMC41MCB8IDA7XFxuICB2YXIgdG90YWwgPSBydW5uZXIudG90YWw7XFxuICB2YXIgY29tcGxldGUgPSAwO1xcbiAgdmFyIGxhc3ROID0gLTE7XFxuXFxuICAvLyBkZWZhdWx0IGNoYXJzXFxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcXG4gIG9wdGlvbnMub3BlbiA9IG9wdGlvbnMub3BlbiB8fCAnWyc7XFxuICBvcHRpb25zLmNvbXBsZXRlID0gb3B0aW9ucy5jb21wbGV0ZSB8fCAn4pasJztcXG4gIG9wdGlvbnMuaW5jb21wbGV0ZSA9IG9wdGlvbnMuaW5jb21wbGV0ZSB8fCBCYXNlLnN5bWJvbHMuZG90O1xcbiAgb3B0aW9ucy5jbG9zZSA9IG9wdGlvbnMuY2xvc2UgfHwgJ10nO1xcbiAgb3B0aW9ucy52ZXJib3NlID0gZmFsc2U7XFxuXFxuICAvLyB0ZXN0cyBzdGFydGVkXFxuICBydW5uZXIub24oJ3N0YXJ0JywgZnVuY3Rpb24gKCkge1xcbiAgICBjb25zb2xlLmxvZygpO1xcbiAgICBjdXJzb3IuaGlkZSgpO1xcbiAgfSk7XFxuXFxuICAvLyB0ZXN0cyBjb21wbGV0ZVxcbiAgcnVubmVyLm9uKCd0ZXN0IGVuZCcsIGZ1bmN0aW9uICgpIHtcXG4gICAgY29tcGxldGUrKztcXG5cXG4gICAgdmFyIHBlcmNlbnQgPSBjb21wbGV0ZSAvIHRvdGFsO1xcbiAgICB2YXIgbiA9IHdpZHRoICogcGVyY2VudCB8IDA7XFxuICAgIHZhciBpID0gd2lkdGggLSBuO1xcblxcbiAgICBpZiAobiA9PT0gbGFzdE4gJiYgIW9wdGlvbnMudmVyYm9zZSkge1xcbiAgICAgIC8vIERvbid0IHJlLXJlbmRlciB0aGUgbGluZSBpZiBpdCBoYXNuJ3QgY2hhbmdlZFxcbiAgICAgIHJldHVybjtcXG4gICAgfVxcbiAgICBsYXN0TiA9IG47XFxuXFxuICAgIGN1cnNvci5DUigpO1xcbiAgICBwcm9jZXNzLnN0ZG91dC53cml0ZSgnXFxcXHUwMDFiW0onKTtcXG4gICAgcHJvY2Vzcy5zdGRvdXQud3JpdGUoY29sb3IoJ3Byb2dyZXNzJywgJyAgJyArIG9wdGlvbnMub3BlbikpO1xcbiAgICBwcm9jZXNzLnN0ZG91dC53cml0ZShBcnJheShuKS5qb2luKG9wdGlvbnMuY29tcGxldGUpKTtcXG4gICAgcHJvY2Vzcy5zdGRvdXQud3JpdGUoQXJyYXkoaSkuam9pbihvcHRpb25zLmluY29tcGxldGUpKTtcXG4gICAgcHJvY2Vzcy5zdGRvdXQud3JpdGUoY29sb3IoJ3Byb2dyZXNzJywgb3B0aW9ucy5jbG9zZSkpO1xcbiAgICBpZiAob3B0aW9ucy52ZXJib3NlKSB7XFxuICAgICAgcHJvY2Vzcy5zdGRvdXQud3JpdGUoY29sb3IoJ3Byb2dyZXNzJywgJyAnICsgY29tcGxldGUgKyAnIG9mICcgKyB0b3RhbCkpO1xcbiAgICB9XFxuICB9KTtcXG5cXG4gIC8vIHRlc3RzIGFyZSBjb21wbGV0ZSwgb3V0cHV0IHNvbWUgc3RhdHNcXG4gIC8vIGFuZCB0aGUgZmFpbHVyZXMgaWYgYW55XFxuICBydW5uZXIub24oJ2VuZCcsIGZ1bmN0aW9uICgpIHtcXG4gICAgY3Vyc29yLnNob3coKTtcXG4gICAgY29uc29sZS5sb2coKTtcXG4gICAgc2VsZi5lcGlsb2d1ZSgpO1xcbiAgfSk7XFxufVxcblxcbi8qKlxcbiAqIEluaGVyaXQgZnJvbSBgQmFzZS5wcm90b3R5cGVgLlxcbiAqL1xcbmluaGVyaXRzKFByb2dyZXNzLCBCYXNlKTtcXG5cXG59KS5jYWxsKHRoaXMscmVxdWlyZSgnX3Byb2Nlc3MnKSlcXG59LHtcXFwiLi4vdXRpbHNcXFwiOjM4LFxcXCIuL2Jhc2VcXFwiOjE3LFxcXCJfcHJvY2Vzc1xcXCI6ODJ9XSwzMDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XFxuJ3VzZSBzdHJpY3QnO1xcblxcbi8qKlxcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXFxuICovXFxuXFxudmFyIEJhc2UgPSByZXF1aXJlKCcuL2Jhc2UnKTtcXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCcuLi91dGlscycpLmluaGVyaXRzO1xcbnZhciBjb2xvciA9IEJhc2UuY29sb3I7XFxuXFxuLyoqXFxuICogRXhwb3NlIGBTcGVjYC5cXG4gKi9cXG5cXG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBTcGVjO1xcblxcbi8qKlxcbiAqIEluaXRpYWxpemUgYSBuZXcgYFNwZWNgIHRlc3QgcmVwb3J0ZXIuXFxuICpcXG4gKiBAYXBpIHB1YmxpY1xcbiAqIEBwYXJhbSB7UnVubmVyfSBydW5uZXJcXG4gKi9cXG5mdW5jdGlvbiBTcGVjIChydW5uZXIpIHtcXG4gIEJhc2UuY2FsbCh0aGlzLCBydW5uZXIpO1xcblxcbiAgdmFyIHNlbGYgPSB0aGlzO1xcbiAgdmFyIGluZGVudHMgPSAwO1xcbiAgdmFyIG4gPSAwO1xcblxcbiAgZnVuY3Rpb24gaW5kZW50ICgpIHtcXG4gICAgcmV0dXJuIEFycmF5KGluZGVudHMpLmpvaW4oJyAgJyk7XFxuICB9XFxuXFxuICBydW5uZXIub24oJ3N0YXJ0JywgZnVuY3Rpb24gKCkge1xcbiAgICBjb25zb2xlLmxvZygpO1xcbiAgfSk7XFxuXFxuICBydW5uZXIub24oJ3N1aXRlJywgZnVuY3Rpb24gKHN1aXRlKSB7XFxuICAgICsraW5kZW50cztcXG4gICAgY29uc29sZS5sb2coY29sb3IoJ3N1aXRlJywgJyVzJXMnKSwgaW5kZW50KCksIHN1aXRlLnRpdGxlKTtcXG4gIH0pO1xcblxcbiAgcnVubmVyLm9uKCdzdWl0ZSBlbmQnLCBmdW5jdGlvbiAoKSB7XFxuICAgIC0taW5kZW50cztcXG4gICAgaWYgKGluZGVudHMgPT09IDEpIHtcXG4gICAgICBjb25zb2xlLmxvZygpO1xcbiAgICB9XFxuICB9KTtcXG5cXG4gIHJ1bm5lci5vbigncGVuZGluZycsIGZ1bmN0aW9uICh0ZXN0KSB7XFxuICAgIHZhciBmbXQgPSBpbmRlbnQoKSArIGNvbG9yKCdwZW5kaW5nJywgJyAgLSAlcycpO1xcbiAgICBjb25zb2xlLmxvZyhmbXQsIHRlc3QudGl0bGUpO1xcbiAgfSk7XFxuXFxuICBydW5uZXIub24oJ3Bhc3MnLCBmdW5jdGlvbiAodGVzdCkge1xcbiAgICB2YXIgZm10O1xcbiAgICBpZiAodGVzdC5zcGVlZCA9PT0gJ2Zhc3QnKSB7XFxuICAgICAgZm10ID0gaW5kZW50KCkgK1xcbiAgICAgICAgY29sb3IoJ2NoZWNrbWFyaycsICcgICcgKyBCYXNlLnN5bWJvbHMub2spICtcXG4gICAgICAgIGNvbG9yKCdwYXNzJywgJyAlcycpO1xcbiAgICAgIGNvbnNvbGUubG9nKGZtdCwgdGVzdC50aXRsZSk7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgZm10ID0gaW5kZW50KCkgK1xcbiAgICAgICAgY29sb3IoJ2NoZWNrbWFyaycsICcgICcgKyBCYXNlLnN5bWJvbHMub2spICtcXG4gICAgICAgIGNvbG9yKCdwYXNzJywgJyAlcycpICtcXG4gICAgICAgIGNvbG9yKHRlc3Quc3BlZWQsICcgKCVkbXMpJyk7XFxuICAgICAgY29uc29sZS5sb2coZm10LCB0ZXN0LnRpdGxlLCB0ZXN0LmR1cmF0aW9uKTtcXG4gICAgfVxcbiAgfSk7XFxuXFxuICBydW5uZXIub24oJ2ZhaWwnLCBmdW5jdGlvbiAodGVzdCkge1xcbiAgICBjb25zb2xlLmxvZyhpbmRlbnQoKSArIGNvbG9yKCdmYWlsJywgJyAgJWQpICVzJyksICsrbiwgdGVzdC50aXRsZSk7XFxuICB9KTtcXG5cXG4gIHJ1bm5lci5vbignZW5kJywgc2VsZi5lcGlsb2d1ZS5iaW5kKHNlbGYpKTtcXG59XFxuXFxuLyoqXFxuICogSW5oZXJpdCBmcm9tIGBCYXNlLnByb3RvdHlwZWAuXFxuICovXFxuaW5oZXJpdHMoU3BlYywgQmFzZSk7XFxuXFxufSx7XFxcIi4uL3V0aWxzXFxcIjozOCxcXFwiLi9iYXNlXFxcIjoxN31dLDMxOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcXG4ndXNlIHN0cmljdCc7XFxuXFxuLyoqXFxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cXG4gKi9cXG5cXG52YXIgQmFzZSA9IHJlcXVpcmUoJy4vYmFzZScpO1xcblxcbi8qKlxcbiAqIEV4cG9zZSBgVEFQYC5cXG4gKi9cXG5cXG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBUQVA7XFxuXFxuLyoqXFxuICogSW5pdGlhbGl6ZSBhIG5ldyBgVEFQYCByZXBvcnRlci5cXG4gKlxcbiAqIEBhcGkgcHVibGljXFxuICogQHBhcmFtIHtSdW5uZXJ9IHJ1bm5lclxcbiAqL1xcbmZ1bmN0aW9uIFRBUCAocnVubmVyKSB7XFxuICBCYXNlLmNhbGwodGhpcywgcnVubmVyKTtcXG5cXG4gIHZhciBuID0gMTtcXG4gIHZhciBwYXNzZXMgPSAwO1xcbiAgdmFyIGZhaWx1cmVzID0gMDtcXG5cXG4gIHJ1bm5lci5vbignc3RhcnQnLCBmdW5jdGlvbiAoKSB7XFxuICAgIHZhciB0b3RhbCA9IHJ1bm5lci5ncmVwVG90YWwocnVubmVyLnN1aXRlKTtcXG4gICAgY29uc29sZS5sb2coJyVkLi4lZCcsIDEsIHRvdGFsKTtcXG4gIH0pO1xcblxcbiAgcnVubmVyLm9uKCd0ZXN0IGVuZCcsIGZ1bmN0aW9uICgpIHtcXG4gICAgKytuO1xcbiAgfSk7XFxuXFxuICBydW5uZXIub24oJ3BlbmRpbmcnLCBmdW5jdGlvbiAodGVzdCkge1xcbiAgICBjb25zb2xlLmxvZygnb2sgJWQgJXMgIyBTS0lQIC0nLCBuLCB0aXRsZSh0ZXN0KSk7XFxuICB9KTtcXG5cXG4gIHJ1bm5lci5vbigncGFzcycsIGZ1bmN0aW9uICh0ZXN0KSB7XFxuICAgIHBhc3NlcysrO1xcbiAgICBjb25zb2xlLmxvZygnb2sgJWQgJXMnLCBuLCB0aXRsZSh0ZXN0KSk7XFxuICB9KTtcXG5cXG4gIHJ1bm5lci5vbignZmFpbCcsIGZ1bmN0aW9uICh0ZXN0LCBlcnIpIHtcXG4gICAgZmFpbHVyZXMrKztcXG4gICAgY29uc29sZS5sb2coJ25vdCBvayAlZCAlcycsIG4sIHRpdGxlKHRlc3QpKTtcXG4gICAgaWYgKGVyci5zdGFjaykge1xcbiAgICAgIGNvbnNvbGUubG9nKGVyci5zdGFjay5yZXBsYWNlKC9eL2dtLCAnICAnKSk7XFxuICAgIH1cXG4gIH0pO1xcblxcbiAgcnVubmVyLm9uKCdlbmQnLCBmdW5jdGlvbiAoKSB7XFxuICAgIGNvbnNvbGUubG9nKCcjIHRlc3RzICcgKyAocGFzc2VzICsgZmFpbHVyZXMpKTtcXG4gICAgY29uc29sZS5sb2coJyMgcGFzcyAnICsgcGFzc2VzKTtcXG4gICAgY29uc29sZS5sb2coJyMgZmFpbCAnICsgZmFpbHVyZXMpO1xcbiAgfSk7XFxufVxcblxcbi8qKlxcbiAqIFJldHVybiBhIFRBUC1zYWZlIHRpdGxlIG9mIGB0ZXN0YFxcbiAqXFxuICogQGFwaSBwcml2YXRlXFxuICogQHBhcmFtIHtPYmplY3R9IHRlc3RcXG4gKiBAcmV0dXJuIHtTdHJpbmd9XFxuICovXFxuZnVuY3Rpb24gdGl0bGUgKHRlc3QpIHtcXG4gIHJldHVybiB0ZXN0LmZ1bGxUaXRsZSgpLnJlcGxhY2UoLyMvZywgJycpO1xcbn1cXG5cXG59LHtcXFwiLi9iYXNlXFxcIjoxN31dLDMyOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcXG4oZnVuY3Rpb24gKHByb2Nlc3MsZ2xvYmFsKXtcXG4ndXNlIHN0cmljdCc7XFxuXFxuLyoqXFxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cXG4gKi9cXG5cXG52YXIgQmFzZSA9IHJlcXVpcmUoJy4vYmFzZScpO1xcbnZhciB1dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzJyk7XFxudmFyIGluaGVyaXRzID0gdXRpbHMuaW5oZXJpdHM7XFxudmFyIGZzID0gcmVxdWlyZSgnZnMnKTtcXG52YXIgZXNjYXBlID0gdXRpbHMuZXNjYXBlO1xcbnZhciBta2RpcnAgPSByZXF1aXJlKCdta2RpcnAnKTtcXG52YXIgcGF0aCA9IHJlcXVpcmUoJ3BhdGgnKTtcXG5cXG4vKipcXG4gKiBTYXZlIHRpbWVyIHJlZmVyZW5jZXMgdG8gYXZvaWQgU2lub24gaW50ZXJmZXJpbmcgKHNlZSBHSC0yMzcpLlxcbiAqL1xcblxcbi8qIGVzbGludC1kaXNhYmxlIG5vLXVudXNlZC12YXJzLCBuby1uYXRpdmUtcmVhc3NpZ24gKi9cXG52YXIgRGF0ZSA9IGdsb2JhbC5EYXRlO1xcbnZhciBzZXRUaW1lb3V0ID0gZ2xvYmFsLnNldFRpbWVvdXQ7XFxudmFyIHNldEludGVydmFsID0gZ2xvYmFsLnNldEludGVydmFsO1xcbnZhciBjbGVhclRpbWVvdXQgPSBnbG9iYWwuY2xlYXJUaW1lb3V0O1xcbnZhciBjbGVhckludGVydmFsID0gZ2xvYmFsLmNsZWFySW50ZXJ2YWw7XFxuLyogZXNsaW50LWVuYWJsZSBuby11bnVzZWQtdmFycywgbm8tbmF0aXZlLXJlYXNzaWduICovXFxuXFxuLyoqXFxuICogRXhwb3NlIGBYVW5pdGAuXFxuICovXFxuXFxuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gWFVuaXQ7XFxuXFxuLyoqXFxuICogSW5pdGlhbGl6ZSBhIG5ldyBgWFVuaXRgIHJlcG9ydGVyLlxcbiAqXFxuICogQGFwaSBwdWJsaWNcXG4gKiBAcGFyYW0ge1J1bm5lcn0gcnVubmVyXFxuICovXFxuZnVuY3Rpb24gWFVuaXQgKHJ1bm5lciwgb3B0aW9ucykge1xcbiAgQmFzZS5jYWxsKHRoaXMsIHJ1bm5lcik7XFxuXFxuICB2YXIgc3RhdHMgPSB0aGlzLnN0YXRzO1xcbiAgdmFyIHRlc3RzID0gW107XFxuICB2YXIgc2VsZiA9IHRoaXM7XFxuXFxuICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLnJlcG9ydGVyT3B0aW9ucyAmJiBvcHRpb25zLnJlcG9ydGVyT3B0aW9ucy5vdXRwdXQpIHtcXG4gICAgaWYgKCFmcy5jcmVhdGVXcml0ZVN0cmVhbSkge1xcbiAgICAgIHRocm93IG5ldyBFcnJvcignZmlsZSBvdXRwdXQgbm90IHN1cHBvcnRlZCBpbiBicm93c2VyJyk7XFxuICAgIH1cXG4gICAgbWtkaXJwLnN5bmMocGF0aC5kaXJuYW1lKG9wdGlvbnMucmVwb3J0ZXJPcHRpb25zLm91dHB1dCkpO1xcbiAgICBzZWxmLmZpbGVTdHJlYW0gPSBmcy5jcmVhdGVXcml0ZVN0cmVhbShvcHRpb25zLnJlcG9ydGVyT3B0aW9ucy5vdXRwdXQpO1xcbiAgfVxcblxcbiAgcnVubmVyLm9uKCdwZW5kaW5nJywgZnVuY3Rpb24gKHRlc3QpIHtcXG4gICAgdGVzdHMucHVzaCh0ZXN0KTtcXG4gIH0pO1xcblxcbiAgcnVubmVyLm9uKCdwYXNzJywgZnVuY3Rpb24gKHRlc3QpIHtcXG4gICAgdGVzdHMucHVzaCh0ZXN0KTtcXG4gIH0pO1xcblxcbiAgcnVubmVyLm9uKCdmYWlsJywgZnVuY3Rpb24gKHRlc3QpIHtcXG4gICAgdGVzdHMucHVzaCh0ZXN0KTtcXG4gIH0pO1xcblxcbiAgcnVubmVyLm9uKCdlbmQnLCBmdW5jdGlvbiAoKSB7XFxuICAgIHNlbGYud3JpdGUodGFnKCd0ZXN0c3VpdGUnLCB7XFxuICAgICAgbmFtZTogJ01vY2hhIFRlc3RzJyxcXG4gICAgICB0ZXN0czogc3RhdHMudGVzdHMsXFxuICAgICAgZmFpbHVyZXM6IHN0YXRzLmZhaWx1cmVzLFxcbiAgICAgIGVycm9yczogc3RhdHMuZmFpbHVyZXMsXFxuICAgICAgc2tpcHBlZDogc3RhdHMudGVzdHMgLSBzdGF0cy5mYWlsdXJlcyAtIHN0YXRzLnBhc3NlcyxcXG4gICAgICB0aW1lc3RhbXA6IChuZXcgRGF0ZSgpKS50b1VUQ1N0cmluZygpLFxcbiAgICAgIHRpbWU6IChzdGF0cy5kdXJhdGlvbiAvIDEwMDApIHx8IDBcXG4gICAgfSwgZmFsc2UpKTtcXG5cXG4gICAgdGVzdHMuZm9yRWFjaChmdW5jdGlvbiAodCkge1xcbiAgICAgIHNlbGYudGVzdCh0KTtcXG4gICAgfSk7XFxuXFxuICAgIHNlbGYud3JpdGUoJzwvdGVzdHN1aXRlPicpO1xcbiAgfSk7XFxufVxcblxcbi8qKlxcbiAqIEluaGVyaXQgZnJvbSBgQmFzZS5wcm90b3R5cGVgLlxcbiAqL1xcbmluaGVyaXRzKFhVbml0LCBCYXNlKTtcXG5cXG4vKipcXG4gKiBPdmVycmlkZSBkb25lIHRvIGNsb3NlIHRoZSBzdHJlYW0gKGlmIGl0J3MgYSBmaWxlKS5cXG4gKlxcbiAqIEBwYXJhbSBmYWlsdXJlc1xcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXFxuICovXFxuWFVuaXQucHJvdG90eXBlLmRvbmUgPSBmdW5jdGlvbiAoZmFpbHVyZXMsIGZuKSB7XFxuICBpZiAodGhpcy5maWxlU3RyZWFtKSB7XFxuICAgIHRoaXMuZmlsZVN0cmVhbS5lbmQoZnVuY3Rpb24gKCkge1xcbiAgICAgIGZuKGZhaWx1cmVzKTtcXG4gICAgfSk7XFxuICB9IGVsc2Uge1xcbiAgICBmbihmYWlsdXJlcyk7XFxuICB9XFxufTtcXG5cXG4vKipcXG4gKiBXcml0ZSBvdXQgdGhlIGdpdmVuIGxpbmUuXFxuICpcXG4gKiBAcGFyYW0ge3N0cmluZ30gbGluZVxcbiAqL1xcblhVbml0LnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uIChsaW5lKSB7XFxuICBpZiAodGhpcy5maWxlU3RyZWFtKSB7XFxuICAgIHRoaXMuZmlsZVN0cmVhbS53cml0ZShsaW5lICsgJ1xcXFxuJyk7XFxuICB9IGVsc2UgaWYgKHR5cGVvZiBwcm9jZXNzID09PSAnb2JqZWN0JyAmJiBwcm9jZXNzLnN0ZG91dCkge1xcbiAgICBwcm9jZXNzLnN0ZG91dC53cml0ZShsaW5lICsgJ1xcXFxuJyk7XFxuICB9IGVsc2Uge1xcbiAgICBjb25zb2xlLmxvZyhsaW5lKTtcXG4gIH1cXG59O1xcblxcbi8qKlxcbiAqIE91dHB1dCB0YWcgZm9yIHRoZSBnaXZlbiBgdGVzdC5gXFxuICpcXG4gKiBAcGFyYW0ge1Rlc3R9IHRlc3RcXG4gKi9cXG5YVW5pdC5wcm90b3R5cGUudGVzdCA9IGZ1bmN0aW9uICh0ZXN0KSB7XFxuICB2YXIgYXR0cnMgPSB7XFxuICAgIGNsYXNzbmFtZTogdGVzdC5wYXJlbnQuZnVsbFRpdGxlKCksXFxuICAgIG5hbWU6IHRlc3QudGl0bGUsXFxuICAgIHRpbWU6ICh0ZXN0LmR1cmF0aW9uIC8gMTAwMCkgfHwgMFxcbiAgfTtcXG5cXG4gIGlmICh0ZXN0LnN0YXRlID09PSAnZmFpbGVkJykge1xcbiAgICB2YXIgZXJyID0gdGVzdC5lcnI7XFxuICAgIHRoaXMud3JpdGUodGFnKCd0ZXN0Y2FzZScsIGF0dHJzLCBmYWxzZSwgdGFnKCdmYWlsdXJlJywge30sIGZhbHNlLCBlc2NhcGUoZXJyLm1lc3NhZ2UpICsgJ1xcXFxuJyArIGVzY2FwZShlcnIuc3RhY2spKSkpO1xcbiAgfSBlbHNlIGlmICh0ZXN0LmlzUGVuZGluZygpKSB7XFxuICAgIHRoaXMud3JpdGUodGFnKCd0ZXN0Y2FzZScsIGF0dHJzLCBmYWxzZSwgdGFnKCdza2lwcGVkJywge30sIHRydWUpKSk7XFxuICB9IGVsc2Uge1xcbiAgICB0aGlzLndyaXRlKHRhZygndGVzdGNhc2UnLCBhdHRycywgdHJ1ZSkpO1xcbiAgfVxcbn07XFxuXFxuLyoqXFxuICogSFRNTCB0YWcgaGVscGVyLlxcbiAqXFxuICogQHBhcmFtIG5hbWVcXG4gKiBAcGFyYW0gYXR0cnNcXG4gKiBAcGFyYW0gY2xvc2VcXG4gKiBAcGFyYW0gY29udGVudFxcbiAqIEByZXR1cm4ge3N0cmluZ31cXG4gKi9cXG5mdW5jdGlvbiB0YWcgKG5hbWUsIGF0dHJzLCBjbG9zZSwgY29udGVudCkge1xcbiAgdmFyIGVuZCA9IGNsb3NlID8gJy8+JyA6ICc+JztcXG4gIHZhciBwYWlycyA9IFtdO1xcbiAgdmFyIHRhZztcXG5cXG4gIGZvciAodmFyIGtleSBpbiBhdHRycykge1xcbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGF0dHJzLCBrZXkpKSB7XFxuICAgICAgcGFpcnMucHVzaChrZXkgKyAnPVxcXCInICsgZXNjYXBlKGF0dHJzW2tleV0pICsgJ1xcXCInKTtcXG4gICAgfVxcbiAgfVxcblxcbiAgdGFnID0gJzwnICsgbmFtZSArIChwYWlycy5sZW5ndGggPyAnICcgKyBwYWlycy5qb2luKCcgJykgOiAnJykgKyBlbmQ7XFxuICBpZiAoY29udGVudCkge1xcbiAgICB0YWcgKz0gY29udGVudCArICc8LycgKyBuYW1lICsgZW5kO1xcbiAgfVxcbiAgcmV0dXJuIHRhZztcXG59XFxuXFxufSkuY2FsbCh0aGlzLHJlcXVpcmUoJ19wcm9jZXNzJyksdHlwZW9mIGdsb2JhbCAhPT0gXFxcInVuZGVmaW5lZFxcXCIgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gXFxcInVuZGVmaW5lZFxcXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXFxcInVuZGVmaW5lZFxcXCIgPyB3aW5kb3cgOiB7fSlcXG59LHtcXFwiLi4vdXRpbHNcXFwiOjM4LFxcXCIuL2Jhc2VcXFwiOjE3LFxcXCJfcHJvY2Vzc1xcXCI6ODIsXFxcImZzXFxcIjo0MixcXFwibWtkaXJwXFxcIjo3OSxcXFwicGF0aFxcXCI6NDJ9XSwzMzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XFxuKGZ1bmN0aW9uIChnbG9iYWwpe1xcbid1c2Ugc3RyaWN0JztcXG5cXG4vKipcXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxcbiAqL1xcblxcbnZhciBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXI7XFxudmFyIEpTT04gPSByZXF1aXJlKCdqc29uMycpO1xcbnZhciBQZW5kaW5nID0gcmVxdWlyZSgnLi9wZW5kaW5nJyk7XFxudmFyIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnbW9jaGE6cnVubmFibGUnKTtcXG52YXIgbWlsbGlzZWNvbmRzID0gcmVxdWlyZSgnLi9tcycpO1xcbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcXG52YXIgY3JlYXRlID0gcmVxdWlyZSgnbG9kYXNoLmNyZWF0ZScpO1xcblxcbi8qKlxcbiAqIFNhdmUgdGltZXIgcmVmZXJlbmNlcyB0byBhdm9pZCBTaW5vbiBpbnRlcmZlcmluZyAoc2VlIEdILTIzNykuXFxuICovXFxuXFxuLyogZXNsaW50LWRpc2FibGUgbm8tdW51c2VkLXZhcnMsIG5vLW5hdGl2ZS1yZWFzc2lnbiAqL1xcbnZhciBEYXRlID0gZ2xvYmFsLkRhdGU7XFxudmFyIHNldFRpbWVvdXQgPSBnbG9iYWwuc2V0VGltZW91dDtcXG52YXIgc2V0SW50ZXJ2YWwgPSBnbG9iYWwuc2V0SW50ZXJ2YWw7XFxudmFyIGNsZWFyVGltZW91dCA9IGdsb2JhbC5jbGVhclRpbWVvdXQ7XFxudmFyIGNsZWFySW50ZXJ2YWwgPSBnbG9iYWwuY2xlYXJJbnRlcnZhbDtcXG4vKiBlc2xpbnQtZW5hYmxlIG5vLXVudXNlZC12YXJzLCBuby1uYXRpdmUtcmVhc3NpZ24gKi9cXG5cXG4vKipcXG4gKiBPYmplY3QjdG9TdHJpbmcoKS5cXG4gKi9cXG5cXG52YXIgdG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xcblxcbi8qKlxcbiAqIEV4cG9zZSBgUnVubmFibGVgLlxcbiAqL1xcblxcbm1vZHVsZS5leHBvcnRzID0gUnVubmFibGU7XFxuXFxuLyoqXFxuICogSW5pdGlhbGl6ZSBhIG5ldyBgUnVubmFibGVgIHdpdGggdGhlIGdpdmVuIGB0aXRsZWAgYW5kIGNhbGxiYWNrIGBmbmAuXFxuICpcXG4gKiBAcGFyYW0ge1N0cmluZ30gdGl0bGVcXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxcbiAqIEBhcGkgcHJpdmF0ZVxcbiAqIEBwYXJhbSB7c3RyaW5nfSB0aXRsZVxcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXFxuICovXFxuZnVuY3Rpb24gUnVubmFibGUgKHRpdGxlLCBmbikge1xcbiAgdGhpcy50aXRsZSA9IHRpdGxlO1xcbiAgdGhpcy5mbiA9IGZuO1xcbiAgdGhpcy5ib2R5ID0gKGZuIHx8ICcnKS50b1N0cmluZygpO1xcbiAgdGhpcy5hc3luYyA9IGZuICYmIGZuLmxlbmd0aDtcXG4gIHRoaXMuc3luYyA9ICF0aGlzLmFzeW5jO1xcbiAgdGhpcy5fdGltZW91dCA9IDIwMDA7XFxuICB0aGlzLl9zbG93ID0gNzU7XFxuICB0aGlzLl9lbmFibGVUaW1lb3V0cyA9IHRydWU7XFxuICB0aGlzLnRpbWVkT3V0ID0gZmFsc2U7XFxuICB0aGlzLl90cmFjZSA9IG5ldyBFcnJvcignZG9uZSgpIGNhbGxlZCBtdWx0aXBsZSB0aW1lcycpO1xcbiAgdGhpcy5fcmV0cmllcyA9IC0xO1xcbiAgdGhpcy5fY3VycmVudFJldHJ5ID0gMDtcXG4gIHRoaXMucGVuZGluZyA9IGZhbHNlO1xcbn1cXG5cXG4vKipcXG4gKiBJbmhlcml0IGZyb20gYEV2ZW50RW1pdHRlci5wcm90b3R5cGVgLlxcbiAqL1xcblJ1bm5hYmxlLnByb3RvdHlwZSA9IGNyZWF0ZShFdmVudEVtaXR0ZXIucHJvdG90eXBlLCB7XFxuICBjb25zdHJ1Y3RvcjogUnVubmFibGVcXG59KTtcXG5cXG4vKipcXG4gKiBTZXQgJiBnZXQgdGltZW91dCBgbXNgLlxcbiAqXFxuICogQGFwaSBwcml2YXRlXFxuICogQHBhcmFtIHtudW1iZXJ8c3RyaW5nfSBtc1xcbiAqIEByZXR1cm4ge1J1bm5hYmxlfG51bWJlcn0gbXMgb3IgUnVubmFibGUgaW5zdGFuY2UuXFxuICovXFxuUnVubmFibGUucHJvdG90eXBlLnRpbWVvdXQgPSBmdW5jdGlvbiAobXMpIHtcXG4gIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xcbiAgICByZXR1cm4gdGhpcy5fdGltZW91dDtcXG4gIH1cXG4gIC8vIHNlZSAjMTY1MiBmb3IgcmVhc29uaW5nXFxuICBpZiAobXMgPT09IDAgfHwgbXMgPiBNYXRoLnBvdygyLCAzMSkpIHtcXG4gICAgdGhpcy5fZW5hYmxlVGltZW91dHMgPSBmYWxzZTtcXG4gIH1cXG4gIGlmICh0eXBlb2YgbXMgPT09ICdzdHJpbmcnKSB7XFxuICAgIG1zID0gbWlsbGlzZWNvbmRzKG1zKTtcXG4gIH1cXG4gIGRlYnVnKCd0aW1lb3V0ICVkJywgbXMpO1xcbiAgdGhpcy5fdGltZW91dCA9IG1zO1xcbiAgaWYgKHRoaXMudGltZXIpIHtcXG4gICAgdGhpcy5yZXNldFRpbWVvdXQoKTtcXG4gIH1cXG4gIHJldHVybiB0aGlzO1xcbn07XFxuXFxuLyoqXFxuICogU2V0ICYgZ2V0IHNsb3cgYG1zYC5cXG4gKlxcbiAqIEBhcGkgcHJpdmF0ZVxcbiAqIEBwYXJhbSB7bnVtYmVyfHN0cmluZ30gbXNcXG4gKiBAcmV0dXJuIHtSdW5uYWJsZXxudW1iZXJ9IG1zIG9yIFJ1bm5hYmxlIGluc3RhbmNlLlxcbiAqL1xcblJ1bm5hYmxlLnByb3RvdHlwZS5zbG93ID0gZnVuY3Rpb24gKG1zKSB7XFxuICBpZiAodHlwZW9mIG1zID09PSAndW5kZWZpbmVkJykge1xcbiAgICByZXR1cm4gdGhpcy5fc2xvdztcXG4gIH1cXG4gIGlmICh0eXBlb2YgbXMgPT09ICdzdHJpbmcnKSB7XFxuICAgIG1zID0gbWlsbGlzZWNvbmRzKG1zKTtcXG4gIH1cXG4gIGRlYnVnKCd0aW1lb3V0ICVkJywgbXMpO1xcbiAgdGhpcy5fc2xvdyA9IG1zO1xcbiAgcmV0dXJuIHRoaXM7XFxufTtcXG5cXG4vKipcXG4gKiBTZXQgYW5kIGdldCB3aGV0aGVyIHRpbWVvdXQgaXMgYGVuYWJsZWRgLlxcbiAqXFxuICogQGFwaSBwcml2YXRlXFxuICogQHBhcmFtIHtib29sZWFufSBlbmFibGVkXFxuICogQHJldHVybiB7UnVubmFibGV8Ym9vbGVhbn0gZW5hYmxlZCBvciBSdW5uYWJsZSBpbnN0YW5jZS5cXG4gKi9cXG5SdW5uYWJsZS5wcm90b3R5cGUuZW5hYmxlVGltZW91dHMgPSBmdW5jdGlvbiAoZW5hYmxlZCkge1xcbiAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XFxuICAgIHJldHVybiB0aGlzLl9lbmFibGVUaW1lb3V0cztcXG4gIH1cXG4gIGRlYnVnKCdlbmFibGVUaW1lb3V0cyAlcycsIGVuYWJsZWQpO1xcbiAgdGhpcy5fZW5hYmxlVGltZW91dHMgPSBlbmFibGVkO1xcbiAgcmV0dXJuIHRoaXM7XFxufTtcXG5cXG4vKipcXG4gKiBIYWx0IGFuZCBtYXJrIGFzIHBlbmRpbmcuXFxuICpcXG4gKiBAYXBpIHB1YmxpY1xcbiAqL1xcblJ1bm5hYmxlLnByb3RvdHlwZS5za2lwID0gZnVuY3Rpb24gKCkge1xcbiAgdGhyb3cgbmV3IFBlbmRpbmcoJ3N5bmMgc2tpcCcpO1xcbn07XFxuXFxuLyoqXFxuICogQ2hlY2sgaWYgdGhpcyBydW5uYWJsZSBvciBpdHMgcGFyZW50IHN1aXRlIGlzIG1hcmtlZCBhcyBwZW5kaW5nLlxcbiAqXFxuICogQGFwaSBwcml2YXRlXFxuICovXFxuUnVubmFibGUucHJvdG90eXBlLmlzUGVuZGluZyA9IGZ1bmN0aW9uICgpIHtcXG4gIHJldHVybiB0aGlzLnBlbmRpbmcgfHwgKHRoaXMucGFyZW50ICYmIHRoaXMucGFyZW50LmlzUGVuZGluZygpKTtcXG59O1xcblxcbi8qKlxcbiAqIFNldCBudW1iZXIgb2YgcmV0cmllcy5cXG4gKlxcbiAqIEBhcGkgcHJpdmF0ZVxcbiAqL1xcblJ1bm5hYmxlLnByb3RvdHlwZS5yZXRyaWVzID0gZnVuY3Rpb24gKG4pIHtcXG4gIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xcbiAgICByZXR1cm4gdGhpcy5fcmV0cmllcztcXG4gIH1cXG4gIHRoaXMuX3JldHJpZXMgPSBuO1xcbn07XFxuXFxuLyoqXFxuICogR2V0IGN1cnJlbnQgcmV0cnlcXG4gKlxcbiAqIEBhcGkgcHJpdmF0ZVxcbiAqL1xcblJ1bm5hYmxlLnByb3RvdHlwZS5jdXJyZW50UmV0cnkgPSBmdW5jdGlvbiAobikge1xcbiAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XFxuICAgIHJldHVybiB0aGlzLl9jdXJyZW50UmV0cnk7XFxuICB9XFxuICB0aGlzLl9jdXJyZW50UmV0cnkgPSBuO1xcbn07XFxuXFxuLyoqXFxuICogUmV0dXJuIHRoZSBmdWxsIHRpdGxlIGdlbmVyYXRlZCBieSByZWN1cnNpdmVseSBjb25jYXRlbmF0aW5nIHRoZSBwYXJlbnQnc1xcbiAqIGZ1bGwgdGl0bGUuXFxuICpcXG4gKiBAYXBpIHB1YmxpY1xcbiAqIEByZXR1cm4ge3N0cmluZ31cXG4gKi9cXG5SdW5uYWJsZS5wcm90b3R5cGUuZnVsbFRpdGxlID0gZnVuY3Rpb24gKCkge1xcbiAgcmV0dXJuIHRoaXMucGFyZW50LmZ1bGxUaXRsZSgpICsgJyAnICsgdGhpcy50aXRsZTtcXG59O1xcblxcbi8qKlxcbiAqIENsZWFyIHRoZSB0aW1lb3V0LlxcbiAqXFxuICogQGFwaSBwcml2YXRlXFxuICovXFxuUnVubmFibGUucHJvdG90eXBlLmNsZWFyVGltZW91dCA9IGZ1bmN0aW9uICgpIHtcXG4gIGNsZWFyVGltZW91dCh0aGlzLnRpbWVyKTtcXG59O1xcblxcbi8qKlxcbiAqIEluc3BlY3QgdGhlIHJ1bm5hYmxlIHZvaWQgb2YgcHJpdmF0ZSBwcm9wZXJ0aWVzLlxcbiAqXFxuICogQGFwaSBwcml2YXRlXFxuICogQHJldHVybiB7c3RyaW5nfVxcbiAqL1xcblJ1bm5hYmxlLnByb3RvdHlwZS5pbnNwZWN0ID0gZnVuY3Rpb24gKCkge1xcbiAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHRoaXMsIGZ1bmN0aW9uIChrZXksIHZhbCkge1xcbiAgICBpZiAoa2V5WzBdID09PSAnXycpIHtcXG4gICAgICByZXR1cm47XFxuICAgIH1cXG4gICAgaWYgKGtleSA9PT0gJ3BhcmVudCcpIHtcXG4gICAgICByZXR1cm4gJyM8U3VpdGU+JztcXG4gICAgfVxcbiAgICBpZiAoa2V5ID09PSAnY3R4Jykge1xcbiAgICAgIHJldHVybiAnIzxDb250ZXh0Pic7XFxuICAgIH1cXG4gICAgcmV0dXJuIHZhbDtcXG4gIH0sIDIpO1xcbn07XFxuXFxuLyoqXFxuICogUmVzZXQgdGhlIHRpbWVvdXQuXFxuICpcXG4gKiBAYXBpIHByaXZhdGVcXG4gKi9cXG5SdW5uYWJsZS5wcm90b3R5cGUucmVzZXRUaW1lb3V0ID0gZnVuY3Rpb24gKCkge1xcbiAgdmFyIHNlbGYgPSB0aGlzO1xcbiAgdmFyIG1zID0gdGhpcy50aW1lb3V0KCkgfHwgMWU5O1xcblxcbiAgaWYgKCF0aGlzLl9lbmFibGVUaW1lb3V0cykge1xcbiAgICByZXR1cm47XFxuICB9XFxuICB0aGlzLmNsZWFyVGltZW91dCgpO1xcbiAgdGhpcy50aW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xcbiAgICBpZiAoIXNlbGYuX2VuYWJsZVRpbWVvdXRzKSB7XFxuICAgICAgcmV0dXJuO1xcbiAgICB9XFxuICAgIHNlbGYuY2FsbGJhY2sobmV3IEVycm9yKCdUaW1lb3V0IG9mICcgKyBtcyArXFxuICAgICAgJ21zIGV4Y2VlZGVkLiBGb3IgYXN5bmMgdGVzdHMgYW5kIGhvb2tzLCBlbnN1cmUgXFxcImRvbmUoKVxcXCIgaXMgY2FsbGVkOyBpZiByZXR1cm5pbmcgYSBQcm9taXNlLCBlbnN1cmUgaXQgcmVzb2x2ZXMuJykpO1xcbiAgICBzZWxmLnRpbWVkT3V0ID0gdHJ1ZTtcXG4gIH0sIG1zKTtcXG59O1xcblxcbi8qKlxcbiAqIFdoaXRlbGlzdCBhIGxpc3Qgb2YgZ2xvYmFscyBmb3IgdGhpcyB0ZXN0IHJ1bi5cXG4gKlxcbiAqIEBhcGkgcHJpdmF0ZVxcbiAqIEBwYXJhbSB7c3RyaW5nW119IGdsb2JhbHNcXG4gKi9cXG5SdW5uYWJsZS5wcm90b3R5cGUuZ2xvYmFscyA9IGZ1bmN0aW9uIChnbG9iYWxzKSB7XFxuICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcXG4gICAgcmV0dXJuIHRoaXMuX2FsbG93ZWRHbG9iYWxzO1xcbiAgfVxcbiAgdGhpcy5fYWxsb3dlZEdsb2JhbHMgPSBnbG9iYWxzO1xcbn07XFxuXFxuLyoqXFxuICogUnVuIHRoZSB0ZXN0IGFuZCBpbnZva2UgYGZuKGVycilgLlxcbiAqXFxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cXG4gKiBAYXBpIHByaXZhdGVcXG4gKi9cXG5SdW5uYWJsZS5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKGZuKSB7XFxuICB2YXIgc2VsZiA9IHRoaXM7XFxuICB2YXIgc3RhcnQgPSBuZXcgRGF0ZSgpO1xcbiAgdmFyIGN0eCA9IHRoaXMuY3R4O1xcbiAgdmFyIGZpbmlzaGVkO1xcbiAgdmFyIGVtaXR0ZWQ7XFxuXFxuICAvLyBTb21ldGltZXMgdGhlIGN0eCBleGlzdHMsIGJ1dCBpdCBpcyBub3QgcnVubmFibGVcXG4gIGlmIChjdHggJiYgY3R4LnJ1bm5hYmxlKSB7XFxuICAgIGN0eC5ydW5uYWJsZSh0aGlzKTtcXG4gIH1cXG5cXG4gIC8vIGNhbGxlZCBtdWx0aXBsZSB0aW1lc1xcbiAgZnVuY3Rpb24gbXVsdGlwbGUgKGVycikge1xcbiAgICBpZiAoZW1pdHRlZCkge1xcbiAgICAgIHJldHVybjtcXG4gICAgfVxcbiAgICBlbWl0dGVkID0gdHJ1ZTtcXG4gICAgc2VsZi5lbWl0KCdlcnJvcicsIGVyciB8fCBuZXcgRXJyb3IoJ2RvbmUoKSBjYWxsZWQgbXVsdGlwbGUgdGltZXM7IHN0YWNrdHJhY2UgbWF5IGJlIGluYWNjdXJhdGUnKSk7XFxuICB9XFxuXFxuICAvLyBmaW5pc2hlZFxcbiAgZnVuY3Rpb24gZG9uZSAoZXJyKSB7XFxuICAgIHZhciBtcyA9IHNlbGYudGltZW91dCgpO1xcbiAgICBpZiAoc2VsZi50aW1lZE91dCkge1xcbiAgICAgIHJldHVybjtcXG4gICAgfVxcbiAgICBpZiAoZmluaXNoZWQpIHtcXG4gICAgICByZXR1cm4gbXVsdGlwbGUoZXJyIHx8IHNlbGYuX3RyYWNlKTtcXG4gICAgfVxcblxcbiAgICBzZWxmLmNsZWFyVGltZW91dCgpO1xcbiAgICBzZWxmLmR1cmF0aW9uID0gbmV3IERhdGUoKSAtIHN0YXJ0O1xcbiAgICBmaW5pc2hlZCA9IHRydWU7XFxuICAgIGlmICghZXJyICYmIHNlbGYuZHVyYXRpb24gPiBtcyAmJiBzZWxmLl9lbmFibGVUaW1lb3V0cykge1xcbiAgICAgIGVyciA9IG5ldyBFcnJvcignVGltZW91dCBvZiAnICsgbXMgK1xcbiAgICAgICdtcyBleGNlZWRlZC4gRm9yIGFzeW5jIHRlc3RzIGFuZCBob29rcywgZW5zdXJlIFxcXCJkb25lKClcXFwiIGlzIGNhbGxlZDsgaWYgcmV0dXJuaW5nIGEgUHJvbWlzZSwgZW5zdXJlIGl0IHJlc29sdmVzLicpO1xcbiAgICB9XFxuICAgIGZuKGVycik7XFxuICB9XFxuXFxuICAvLyBmb3IgLnJlc2V0VGltZW91dCgpXFxuICB0aGlzLmNhbGxiYWNrID0gZG9uZTtcXG5cXG4gIC8vIGV4cGxpY2l0IGFzeW5jIHdpdGggYGRvbmVgIGFyZ3VtZW50XFxuICBpZiAodGhpcy5hc3luYykge1xcbiAgICB0aGlzLnJlc2V0VGltZW91dCgpO1xcblxcbiAgICAvLyBhbGxvd3Mgc2tpcCgpIHRvIGJlIHVzZWQgaW4gYW4gZXhwbGljaXQgYXN5bmMgY29udGV4dFxcbiAgICB0aGlzLnNraXAgPSBmdW5jdGlvbiBhc3luY1NraXAgKCkge1xcbiAgICAgIGRvbmUobmV3IFBlbmRpbmcoJ2FzeW5jIHNraXAgY2FsbCcpKTtcXG4gICAgICAvLyBoYWx0IGV4ZWN1dGlvbi4gIHRoZSBSdW5uYWJsZSB3aWxsIGJlIG1hcmtlZCBwZW5kaW5nXFxuICAgICAgLy8gYnkgdGhlIHByZXZpb3VzIGNhbGwsIGFuZCB0aGUgdW5jYXVnaHQgaGFuZGxlciB3aWxsIGlnbm9yZVxcbiAgICAgIC8vIHRoZSBmYWlsdXJlLlxcbiAgICAgIHRocm93IG5ldyBQZW5kaW5nKCdhc3luYyBza2lwOyBhYm9ydGluZyBleGVjdXRpb24nKTtcXG4gICAgfTtcXG5cXG4gICAgaWYgKHRoaXMuYWxsb3dVbmNhdWdodCkge1xcbiAgICAgIHJldHVybiBjYWxsRm5Bc3luYyh0aGlzLmZuKTtcXG4gICAgfVxcbiAgICB0cnkge1xcbiAgICAgIGNhbGxGbkFzeW5jKHRoaXMuZm4pO1xcbiAgICB9IGNhdGNoIChlcnIpIHtcXG4gICAgICBlbWl0dGVkID0gdHJ1ZTtcXG4gICAgICBkb25lKHV0aWxzLmdldEVycm9yKGVycikpO1xcbiAgICB9XFxuICAgIHJldHVybjtcXG4gIH1cXG5cXG4gIGlmICh0aGlzLmFsbG93VW5jYXVnaHQpIHtcXG4gICAgaWYgKHRoaXMuaXNQZW5kaW5nKCkpIHtcXG4gICAgICBkb25lKCk7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgY2FsbEZuKHRoaXMuZm4pO1xcbiAgICB9XFxuICAgIHJldHVybjtcXG4gIH1cXG5cXG4gIC8vIHN5bmMgb3IgcHJvbWlzZS1yZXR1cm5pbmdcXG4gIHRyeSB7XFxuICAgIGlmICh0aGlzLmlzUGVuZGluZygpKSB7XFxuICAgICAgZG9uZSgpO1xcbiAgICB9IGVsc2Uge1xcbiAgICAgIGNhbGxGbih0aGlzLmZuKTtcXG4gICAgfVxcbiAgfSBjYXRjaCAoZXJyKSB7XFxuICAgIGVtaXR0ZWQgPSB0cnVlO1xcbiAgICBkb25lKHV0aWxzLmdldEVycm9yKGVycikpO1xcbiAgfVxcblxcbiAgZnVuY3Rpb24gY2FsbEZuIChmbikge1xcbiAgICB2YXIgcmVzdWx0ID0gZm4uY2FsbChjdHgpO1xcbiAgICBpZiAocmVzdWx0ICYmIHR5cGVvZiByZXN1bHQudGhlbiA9PT0gJ2Z1bmN0aW9uJykge1xcbiAgICAgIHNlbGYucmVzZXRUaW1lb3V0KCk7XFxuICAgICAgcmVzdWx0XFxuICAgICAgICAudGhlbihmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgIGRvbmUoKTtcXG4gICAgICAgICAgLy8gUmV0dXJuIG51bGwgc28gbGlicmFyaWVzIGxpa2UgYmx1ZWJpcmQgZG8gbm90IHdhcm4gYWJvdXRcXG4gICAgICAgICAgLy8gc3Vic2VxdWVudGx5IGNvbnN0cnVjdGVkIFByb21pc2VzLlxcbiAgICAgICAgICByZXR1cm4gbnVsbDtcXG4gICAgICAgIH0sXFxuICAgICAgICBmdW5jdGlvbiAocmVhc29uKSB7XFxuICAgICAgICAgIGRvbmUocmVhc29uIHx8IG5ldyBFcnJvcignUHJvbWlzZSByZWplY3RlZCB3aXRoIG5vIG9yIGZhbHN5IHJlYXNvbicpKTtcXG4gICAgICAgIH0pO1xcbiAgICB9IGVsc2Uge1xcbiAgICAgIGlmIChzZWxmLmFzeW5jT25seSkge1xcbiAgICAgICAgcmV0dXJuIGRvbmUobmV3IEVycm9yKCctLWFzeW5jLW9ubHkgb3B0aW9uIGluIHVzZSB3aXRob3V0IGRlY2xhcmluZyBgZG9uZSgpYCBvciByZXR1cm5pbmcgYSBwcm9taXNlJykpO1xcbiAgICAgIH1cXG5cXG4gICAgICBkb25lKCk7XFxuICAgIH1cXG4gIH1cXG5cXG4gIGZ1bmN0aW9uIGNhbGxGbkFzeW5jIChmbikge1xcbiAgICB2YXIgcmVzdWx0ID0gZm4uY2FsbChjdHgsIGZ1bmN0aW9uIChlcnIpIHtcXG4gICAgICBpZiAoZXJyIGluc3RhbmNlb2YgRXJyb3IgfHwgdG9TdHJpbmcuY2FsbChlcnIpID09PSAnW29iamVjdCBFcnJvcl0nKSB7XFxuICAgICAgICByZXR1cm4gZG9uZShlcnIpO1xcbiAgICAgIH1cXG4gICAgICBpZiAoZXJyKSB7XFxuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGVycikgPT09ICdbb2JqZWN0IE9iamVjdF0nKSB7XFxuICAgICAgICAgIHJldHVybiBkb25lKG5ldyBFcnJvcignZG9uZSgpIGludm9rZWQgd2l0aCBub24tRXJyb3I6ICcgK1xcbiAgICAgICAgICAgIEpTT04uc3RyaW5naWZ5KGVycikpKTtcXG4gICAgICAgIH1cXG4gICAgICAgIHJldHVybiBkb25lKG5ldyBFcnJvcignZG9uZSgpIGludm9rZWQgd2l0aCBub24tRXJyb3I6ICcgKyBlcnIpKTtcXG4gICAgICB9XFxuICAgICAgaWYgKHJlc3VsdCAmJiB1dGlscy5pc1Byb21pc2UocmVzdWx0KSkge1xcbiAgICAgICAgcmV0dXJuIGRvbmUobmV3IEVycm9yKCdSZXNvbHV0aW9uIG1ldGhvZCBpcyBvdmVyc3BlY2lmaWVkLiBTcGVjaWZ5IGEgY2FsbGJhY2sgKm9yKiByZXR1cm4gYSBQcm9taXNlOyBub3QgYm90aC4nKSk7XFxuICAgICAgfVxcblxcbiAgICAgIGRvbmUoKTtcXG4gICAgfSk7XFxuICB9XFxufTtcXG5cXG59KS5jYWxsKHRoaXMsdHlwZW9mIGdsb2JhbCAhPT0gXFxcInVuZGVmaW5lZFxcXCIgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gXFxcInVuZGVmaW5lZFxcXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXFxcInVuZGVmaW5lZFxcXCIgPyB3aW5kb3cgOiB7fSlcXG59LHtcXFwiLi9tc1xcXCI6MTUsXFxcIi4vcGVuZGluZ1xcXCI6MTYsXFxcIi4vdXRpbHNcXFwiOjM4LFxcXCJkZWJ1Z1xcXCI6MixcXFwiZXZlbnRzXFxcIjozLFxcXCJqc29uM1xcXCI6NjksXFxcImxvZGFzaC5jcmVhdGVcXFwiOjc1fV0sMzQ6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xcbihmdW5jdGlvbiAocHJvY2VzcyxnbG9iYWwpe1xcbid1c2Ugc3RyaWN0JztcXG5cXG4vKipcXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxcbiAqL1xcblxcbnZhciBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXI7XFxudmFyIFBlbmRpbmcgPSByZXF1aXJlKCcuL3BlbmRpbmcnKTtcXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyk7XFxudmFyIGluaGVyaXRzID0gdXRpbHMuaW5oZXJpdHM7XFxudmFyIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnbW9jaGE6cnVubmVyJyk7XFxudmFyIFJ1bm5hYmxlID0gcmVxdWlyZSgnLi9ydW5uYWJsZScpO1xcbnZhciBmaWx0ZXIgPSB1dGlscy5maWx0ZXI7XFxudmFyIGluZGV4T2YgPSB1dGlscy5pbmRleE9mO1xcbnZhciBzb21lID0gdXRpbHMuc29tZTtcXG52YXIga2V5cyA9IHV0aWxzLmtleXM7XFxudmFyIHN0YWNrRmlsdGVyID0gdXRpbHMuc3RhY2tUcmFjZUZpbHRlcigpO1xcbnZhciBzdHJpbmdpZnkgPSB1dGlscy5zdHJpbmdpZnk7XFxudmFyIHR5cGUgPSB1dGlscy50eXBlO1xcbnZhciB1bmRlZmluZWRFcnJvciA9IHV0aWxzLnVuZGVmaW5lZEVycm9yO1xcbnZhciBpc0FycmF5ID0gdXRpbHMuaXNBcnJheTtcXG5cXG4vKipcXG4gKiBOb24tZW51bWVyYWJsZSBnbG9iYWxzLlxcbiAqL1xcblxcbnZhciBnbG9iYWxzID0gW1xcbiAgJ3NldFRpbWVvdXQnLFxcbiAgJ2NsZWFyVGltZW91dCcsXFxuICAnc2V0SW50ZXJ2YWwnLFxcbiAgJ2NsZWFySW50ZXJ2YWwnLFxcbiAgJ1hNTEh0dHBSZXF1ZXN0JyxcXG4gICdEYXRlJyxcXG4gICdzZXRJbW1lZGlhdGUnLFxcbiAgJ2NsZWFySW1tZWRpYXRlJ1xcbl07XFxuXFxuLyoqXFxuICogRXhwb3NlIGBSdW5uZXJgLlxcbiAqL1xcblxcbm1vZHVsZS5leHBvcnRzID0gUnVubmVyO1xcblxcbi8qKlxcbiAqIEluaXRpYWxpemUgYSBgUnVubmVyYCBmb3IgdGhlIGdpdmVuIGBzdWl0ZWAuXFxuICpcXG4gKiBFdmVudHM6XFxuICpcXG4gKiAgIC0gYHN0YXJ0YCAgZXhlY3V0aW9uIHN0YXJ0ZWRcXG4gKiAgIC0gYGVuZGAgIGV4ZWN1dGlvbiBjb21wbGV0ZVxcbiAqICAgLSBgc3VpdGVgICAoc3VpdGUpIHRlc3Qgc3VpdGUgZXhlY3V0aW9uIHN0YXJ0ZWRcXG4gKiAgIC0gYHN1aXRlIGVuZGAgIChzdWl0ZSkgYWxsIHRlc3RzIChhbmQgc3ViLXN1aXRlcykgaGF2ZSBmaW5pc2hlZFxcbiAqICAgLSBgdGVzdGAgICh0ZXN0KSB0ZXN0IGV4ZWN1dGlvbiBzdGFydGVkXFxuICogICAtIGB0ZXN0IGVuZGAgICh0ZXN0KSB0ZXN0IGNvbXBsZXRlZFxcbiAqICAgLSBgaG9va2AgIChob29rKSBob29rIGV4ZWN1dGlvbiBzdGFydGVkXFxuICogICAtIGBob29rIGVuZGAgIChob29rKSBob29rIGNvbXBsZXRlXFxuICogICAtIGBwYXNzYCAgKHRlc3QpIHRlc3QgcGFzc2VkXFxuICogICAtIGBmYWlsYCAgKHRlc3QsIGVycikgdGVzdCBmYWlsZWRcXG4gKiAgIC0gYHBlbmRpbmdgICAodGVzdCkgdGVzdCBwZW5kaW5nXFxuICpcXG4gKiBAYXBpIHB1YmxpY1xcbiAqIEBwYXJhbSB7U3VpdGV9IHN1aXRlIFJvb3Qgc3VpdGVcXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtkZWxheV0gV2hldGhlciBvciBub3QgdG8gZGVsYXkgZXhlY3V0aW9uIG9mIHJvb3Qgc3VpdGVcXG4gKiB1bnRpbCByZWFkeS5cXG4gKi9cXG5mdW5jdGlvbiBSdW5uZXIgKHN1aXRlLCBkZWxheSkge1xcbiAgdmFyIHNlbGYgPSB0aGlzO1xcbiAgdGhpcy5fZ2xvYmFscyA9IFtdO1xcbiAgdGhpcy5fYWJvcnQgPSBmYWxzZTtcXG4gIHRoaXMuX2RlbGF5ID0gZGVsYXk7XFxuICB0aGlzLnN1aXRlID0gc3VpdGU7XFxuICB0aGlzLnN0YXJ0ZWQgPSBmYWxzZTtcXG4gIHRoaXMudG90YWwgPSBzdWl0ZS50b3RhbCgpO1xcbiAgdGhpcy5mYWlsdXJlcyA9IDA7XFxuICB0aGlzLm9uKCd0ZXN0IGVuZCcsIGZ1bmN0aW9uICh0ZXN0KSB7XFxuICAgIHNlbGYuY2hlY2tHbG9iYWxzKHRlc3QpO1xcbiAgfSk7XFxuICB0aGlzLm9uKCdob29rIGVuZCcsIGZ1bmN0aW9uIChob29rKSB7XFxuICAgIHNlbGYuY2hlY2tHbG9iYWxzKGhvb2spO1xcbiAgfSk7XFxuICB0aGlzLl9kZWZhdWx0R3JlcCA9IC8uKi87XFxuICB0aGlzLmdyZXAodGhpcy5fZGVmYXVsdEdyZXApO1xcbiAgdGhpcy5nbG9iYWxzKHRoaXMuZ2xvYmFsUHJvcHMoKS5jb25jYXQoZXh0cmFHbG9iYWxzKCkpKTtcXG59XFxuXFxuLyoqXFxuICogV3JhcHBlciBmb3Igc2V0SW1tZWRpYXRlLCBwcm9jZXNzLm5leHRUaWNrLCBvciBicm93c2VyIHBvbHlmaWxsLlxcbiAqXFxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cXG4gKiBAYXBpIHByaXZhdGVcXG4gKi9cXG5SdW5uZXIuaW1tZWRpYXRlbHkgPSBnbG9iYWwuc2V0SW1tZWRpYXRlIHx8IHByb2Nlc3MubmV4dFRpY2s7XFxuXFxuLyoqXFxuICogSW5oZXJpdCBmcm9tIGBFdmVudEVtaXR0ZXIucHJvdG90eXBlYC5cXG4gKi9cXG5pbmhlcml0cyhSdW5uZXIsIEV2ZW50RW1pdHRlcik7XFxuXFxuLyoqXFxuICogUnVuIHRlc3RzIHdpdGggZnVsbCB0aXRsZXMgbWF0Y2hpbmcgYHJlYC4gVXBkYXRlcyBydW5uZXIudG90YWxcXG4gKiB3aXRoIG51bWJlciBvZiB0ZXN0cyBtYXRjaGVkLlxcbiAqXFxuICogQHBhcmFtIHtSZWdFeHB9IHJlXFxuICogQHBhcmFtIHtCb29sZWFufSBpbnZlcnRcXG4gKiBAcmV0dXJuIHtSdW5uZXJ9IGZvciBjaGFpbmluZ1xcbiAqIEBhcGkgcHVibGljXFxuICogQHBhcmFtIHtSZWdFeHB9IHJlXFxuICogQHBhcmFtIHtib29sZWFufSBpbnZlcnRcXG4gKiBAcmV0dXJuIHtSdW5uZXJ9IFJ1bm5lciBpbnN0YW5jZS5cXG4gKi9cXG5SdW5uZXIucHJvdG90eXBlLmdyZXAgPSBmdW5jdGlvbiAocmUsIGludmVydCkge1xcbiAgZGVidWcoJ2dyZXAgJXMnLCByZSk7XFxuICB0aGlzLl9ncmVwID0gcmU7XFxuICB0aGlzLl9pbnZlcnQgPSBpbnZlcnQ7XFxuICB0aGlzLnRvdGFsID0gdGhpcy5ncmVwVG90YWwodGhpcy5zdWl0ZSk7XFxuICByZXR1cm4gdGhpcztcXG59O1xcblxcbi8qKlxcbiAqIFJldHVybnMgdGhlIG51bWJlciBvZiB0ZXN0cyBtYXRjaGluZyB0aGUgZ3JlcCBzZWFyY2ggZm9yIHRoZVxcbiAqIGdpdmVuIHN1aXRlLlxcbiAqXFxuICogQHBhcmFtIHtTdWl0ZX0gc3VpdGVcXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XFxuICogQGFwaSBwdWJsaWNcXG4gKiBAcGFyYW0ge1N1aXRlfSBzdWl0ZVxcbiAqIEByZXR1cm4ge251bWJlcn1cXG4gKi9cXG5SdW5uZXIucHJvdG90eXBlLmdyZXBUb3RhbCA9IGZ1bmN0aW9uIChzdWl0ZSkge1xcbiAgdmFyIHNlbGYgPSB0aGlzO1xcbiAgdmFyIHRvdGFsID0gMDtcXG5cXG4gIHN1aXRlLmVhY2hUZXN0KGZ1bmN0aW9uICh0ZXN0KSB7XFxuICAgIHZhciBtYXRjaCA9IHNlbGYuX2dyZXAudGVzdCh0ZXN0LmZ1bGxUaXRsZSgpKTtcXG4gICAgaWYgKHNlbGYuX2ludmVydCkge1xcbiAgICAgIG1hdGNoID0gIW1hdGNoO1xcbiAgICB9XFxuICAgIGlmIChtYXRjaCkge1xcbiAgICAgIHRvdGFsKys7XFxuICAgIH1cXG4gIH0pO1xcblxcbiAgcmV0dXJuIHRvdGFsO1xcbn07XFxuXFxuLyoqXFxuICogUmV0dXJuIGEgbGlzdCBvZiBnbG9iYWwgcHJvcGVydGllcy5cXG4gKlxcbiAqIEByZXR1cm4ge0FycmF5fVxcbiAqIEBhcGkgcHJpdmF0ZVxcbiAqL1xcblJ1bm5lci5wcm90b3R5cGUuZ2xvYmFsUHJvcHMgPSBmdW5jdGlvbiAoKSB7XFxuICB2YXIgcHJvcHMgPSBrZXlzKGdsb2JhbCk7XFxuXFxuICAvLyBub24tZW51bWVyYWJsZXNcXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZ2xvYmFscy5sZW5ndGg7ICsraSkge1xcbiAgICBpZiAofmluZGV4T2YocHJvcHMsIGdsb2JhbHNbaV0pKSB7XFxuICAgICAgY29udGludWU7XFxuICAgIH1cXG4gICAgcHJvcHMucHVzaChnbG9iYWxzW2ldKTtcXG4gIH1cXG5cXG4gIHJldHVybiBwcm9wcztcXG59O1xcblxcbi8qKlxcbiAqIEFsbG93IHRoZSBnaXZlbiBgYXJyYCBvZiBnbG9iYWxzLlxcbiAqXFxuICogQHBhcmFtIHtBcnJheX0gYXJyXFxuICogQHJldHVybiB7UnVubmVyfSBmb3IgY2hhaW5pbmdcXG4gKiBAYXBpIHB1YmxpY1xcbiAqIEBwYXJhbSB7QXJyYXl9IGFyclxcbiAqIEByZXR1cm4ge1J1bm5lcn0gUnVubmVyIGluc3RhbmNlLlxcbiAqL1xcblJ1bm5lci5wcm90b3R5cGUuZ2xvYmFscyA9IGZ1bmN0aW9uIChhcnIpIHtcXG4gIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xcbiAgICByZXR1cm4gdGhpcy5fZ2xvYmFscztcXG4gIH1cXG4gIGRlYnVnKCdnbG9iYWxzICVqJywgYXJyKTtcXG4gIHRoaXMuX2dsb2JhbHMgPSB0aGlzLl9nbG9iYWxzLmNvbmNhdChhcnIpO1xcbiAgcmV0dXJuIHRoaXM7XFxufTtcXG5cXG4vKipcXG4gKiBDaGVjayBmb3IgZ2xvYmFsIHZhcmlhYmxlIGxlYWtzLlxcbiAqXFxuICogQGFwaSBwcml2YXRlXFxuICovXFxuUnVubmVyLnByb3RvdHlwZS5jaGVja0dsb2JhbHMgPSBmdW5jdGlvbiAodGVzdCkge1xcbiAgaWYgKHRoaXMuaWdub3JlTGVha3MpIHtcXG4gICAgcmV0dXJuO1xcbiAgfVxcbiAgdmFyIG9rID0gdGhpcy5fZ2xvYmFscztcXG5cXG4gIHZhciBnbG9iYWxzID0gdGhpcy5nbG9iYWxQcm9wcygpO1xcbiAgdmFyIGxlYWtzO1xcblxcbiAgaWYgKHRlc3QpIHtcXG4gICAgb2sgPSBvay5jb25jYXQodGVzdC5fYWxsb3dlZEdsb2JhbHMgfHwgW10pO1xcbiAgfVxcblxcbiAgaWYgKHRoaXMucHJldkdsb2JhbHNMZW5ndGggPT09IGdsb2JhbHMubGVuZ3RoKSB7XFxuICAgIHJldHVybjtcXG4gIH1cXG4gIHRoaXMucHJldkdsb2JhbHNMZW5ndGggPSBnbG9iYWxzLmxlbmd0aDtcXG5cXG4gIGxlYWtzID0gZmlsdGVyTGVha3Mob2ssIGdsb2JhbHMpO1xcbiAgdGhpcy5fZ2xvYmFscyA9IHRoaXMuX2dsb2JhbHMuY29uY2F0KGxlYWtzKTtcXG5cXG4gIGlmIChsZWFrcy5sZW5ndGggPiAxKSB7XFxuICAgIHRoaXMuZmFpbCh0ZXN0LCBuZXcgRXJyb3IoJ2dsb2JhbCBsZWFrcyBkZXRlY3RlZDogJyArIGxlYWtzLmpvaW4oJywgJykgKyAnJykpO1xcbiAgfSBlbHNlIGlmIChsZWFrcy5sZW5ndGgpIHtcXG4gICAgdGhpcy5mYWlsKHRlc3QsIG5ldyBFcnJvcignZ2xvYmFsIGxlYWsgZGV0ZWN0ZWQ6ICcgKyBsZWFrc1swXSkpO1xcbiAgfVxcbn07XFxuXFxuLyoqXFxuICogRmFpbCB0aGUgZ2l2ZW4gYHRlc3RgLlxcbiAqXFxuICogQGFwaSBwcml2YXRlXFxuICogQHBhcmFtIHtUZXN0fSB0ZXN0XFxuICogQHBhcmFtIHtFcnJvcn0gZXJyXFxuICovXFxuUnVubmVyLnByb3RvdHlwZS5mYWlsID0gZnVuY3Rpb24gKHRlc3QsIGVycikge1xcbiAgaWYgKHRlc3QuaXNQZW5kaW5nKCkpIHtcXG4gICAgcmV0dXJuO1xcbiAgfVxcblxcbiAgKyt0aGlzLmZhaWx1cmVzO1xcbiAgdGVzdC5zdGF0ZSA9ICdmYWlsZWQnO1xcblxcbiAgaWYgKCEoZXJyIGluc3RhbmNlb2YgRXJyb3IgfHwgZXJyICYmIHR5cGVvZiBlcnIubWVzc2FnZSA9PT0gJ3N0cmluZycpKSB7XFxuICAgIGVyciA9IG5ldyBFcnJvcigndGhlICcgKyB0eXBlKGVycikgKyAnICcgKyBzdHJpbmdpZnkoZXJyKSArICcgd2FzIHRocm93biwgdGhyb3cgYW4gRXJyb3IgOiknKTtcXG4gIH1cXG5cXG4gIHRyeSB7XFxuICAgIGVyci5zdGFjayA9ICh0aGlzLmZ1bGxTdGFja1RyYWNlIHx8ICFlcnIuc3RhY2spXFxuICAgICAgPyBlcnIuc3RhY2tcXG4gICAgICA6IHN0YWNrRmlsdGVyKGVyci5zdGFjayk7XFxuICB9IGNhdGNoIChpZ25vcmVkKSB7XFxuICAgIC8vIHNvbWUgZW52aXJvbm1lbnRzIGRvIG5vdCB0YWtlIGtpbmRseSB0byBtb25rZXlpbmcgd2l0aCB0aGUgc3RhY2tcXG4gIH1cXG5cXG4gIHRoaXMuZW1pdCgnZmFpbCcsIHRlc3QsIGVycik7XFxufTtcXG5cXG4vKipcXG4gKiBGYWlsIHRoZSBnaXZlbiBgaG9va2Agd2l0aCBgZXJyYC5cXG4gKlxcbiAqIEhvb2sgZmFpbHVyZXMgd29yayBpbiB0aGUgZm9sbG93aW5nIHBhdHRlcm46XFxuICogLSBJZiBiYWlsLCB0aGVuIGV4aXRcXG4gKiAtIEZhaWxlZCBgYmVmb3JlYCBob29rIHNraXBzIGFsbCB0ZXN0cyBpbiBhIHN1aXRlIGFuZCBzdWJzdWl0ZXMsXFxuICogICBidXQganVtcHMgdG8gY29ycmVzcG9uZGluZyBgYWZ0ZXJgIGhvb2tcXG4gKiAtIEZhaWxlZCBgYmVmb3JlIGVhY2hgIGhvb2sgc2tpcHMgcmVtYWluaW5nIHRlc3RzIGluIGFcXG4gKiAgIHN1aXRlIGFuZCBqdW1wcyB0byBjb3JyZXNwb25kaW5nIGBhZnRlciBlYWNoYCBob29rLFxcbiAqICAgd2hpY2ggaXMgcnVuIG9ubHkgb25jZVxcbiAqIC0gRmFpbGVkIGBhZnRlcmAgaG9vayBkb2VzIG5vdCBhbHRlclxcbiAqICAgZXhlY3V0aW9uIG9yZGVyXFxuICogLSBGYWlsZWQgYGFmdGVyIGVhY2hgIGhvb2sgc2tpcHMgcmVtYWluaW5nIHRlc3RzIGluIGFcXG4gKiAgIHN1aXRlIGFuZCBzdWJzdWl0ZXMsIGJ1dCBleGVjdXRlcyBvdGhlciBgYWZ0ZXIgZWFjaGBcXG4gKiAgIGhvb2tzXFxuICpcXG4gKiBAYXBpIHByaXZhdGVcXG4gKiBAcGFyYW0ge0hvb2t9IGhvb2tcXG4gKiBAcGFyYW0ge0Vycm9yfSBlcnJcXG4gKi9cXG5SdW5uZXIucHJvdG90eXBlLmZhaWxIb29rID0gZnVuY3Rpb24gKGhvb2ssIGVycikge1xcbiAgaWYgKGhvb2suY3R4ICYmIGhvb2suY3R4LmN1cnJlbnRUZXN0KSB7XFxuICAgIGhvb2sub3JpZ2luYWxUaXRsZSA9IGhvb2sub3JpZ2luYWxUaXRsZSB8fCBob29rLnRpdGxlO1xcbiAgICBob29rLnRpdGxlID0gaG9vay5vcmlnaW5hbFRpdGxlICsgJyBmb3IgXFxcIicgKyBob29rLmN0eC5jdXJyZW50VGVzdC50aXRsZSArICdcXFwiJztcXG4gIH1cXG5cXG4gIHRoaXMuZmFpbChob29rLCBlcnIpO1xcbiAgaWYgKHRoaXMuc3VpdGUuYmFpbCgpKSB7XFxuICAgIHRoaXMuZW1pdCgnZW5kJyk7XFxuICB9XFxufTtcXG5cXG4vKipcXG4gKiBSdW4gaG9vayBgbmFtZWAgY2FsbGJhY2tzIGFuZCB0aGVuIGludm9rZSBgZm4oKWAuXFxuICpcXG4gKiBAYXBpIHByaXZhdGVcXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXFxuICovXFxuXFxuUnVubmVyLnByb3RvdHlwZS5ob29rID0gZnVuY3Rpb24gKG5hbWUsIGZuKSB7XFxuICB2YXIgc3VpdGUgPSB0aGlzLnN1aXRlO1xcbiAgdmFyIGhvb2tzID0gc3VpdGVbJ18nICsgbmFtZV07XFxuICB2YXIgc2VsZiA9IHRoaXM7XFxuXFxuICBmdW5jdGlvbiBuZXh0IChpKSB7XFxuICAgIHZhciBob29rID0gaG9va3NbaV07XFxuICAgIGlmICghaG9vaykge1xcbiAgICAgIHJldHVybiBmbigpO1xcbiAgICB9XFxuICAgIHNlbGYuY3VycmVudFJ1bm5hYmxlID0gaG9vaztcXG5cXG4gICAgaG9vay5jdHguY3VycmVudFRlc3QgPSBzZWxmLnRlc3Q7XFxuXFxuICAgIHNlbGYuZW1pdCgnaG9vaycsIGhvb2spO1xcblxcbiAgICBpZiAoIWhvb2subGlzdGVuZXJzKCdlcnJvcicpLmxlbmd0aCkge1xcbiAgICAgIGhvb2sub24oJ2Vycm9yJywgZnVuY3Rpb24gKGVycikge1xcbiAgICAgICAgc2VsZi5mYWlsSG9vayhob29rLCBlcnIpO1xcbiAgICAgIH0pO1xcbiAgICB9XFxuXFxuICAgIGhvb2sucnVuKGZ1bmN0aW9uIChlcnIpIHtcXG4gICAgICB2YXIgdGVzdEVycm9yID0gaG9vay5lcnJvcigpO1xcbiAgICAgIGlmICh0ZXN0RXJyb3IpIHtcXG4gICAgICAgIHNlbGYuZmFpbChzZWxmLnRlc3QsIHRlc3RFcnJvcik7XFxuICAgICAgfVxcbiAgICAgIGlmIChlcnIpIHtcXG4gICAgICAgIGlmIChlcnIgaW5zdGFuY2VvZiBQZW5kaW5nKSB7XFxuICAgICAgICAgIGlmIChuYW1lID09PSAnYmVmb3JlRWFjaCcgfHwgbmFtZSA9PT0gJ2FmdGVyRWFjaCcpIHtcXG4gICAgICAgICAgICBzZWxmLnRlc3QucGVuZGluZyA9IHRydWU7XFxuICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgdXRpbHMuZm9yRWFjaChzdWl0ZS50ZXN0cywgZnVuY3Rpb24gKHRlc3QpIHtcXG4gICAgICAgICAgICAgIHRlc3QucGVuZGluZyA9IHRydWU7XFxuICAgICAgICAgICAgfSk7XFxuICAgICAgICAgICAgLy8gYSBwZW5kaW5nIGhvb2sgd29uJ3QgYmUgZXhlY3V0ZWQgdHdpY2UuXFxuICAgICAgICAgICAgaG9vay5wZW5kaW5nID0gdHJ1ZTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgc2VsZi5mYWlsSG9vayhob29rLCBlcnIpO1xcblxcbiAgICAgICAgICAvLyBzdG9wIGV4ZWN1dGluZyBob29rcywgbm90aWZ5IGNhbGxlZSBvZiBob29rIGVyclxcbiAgICAgICAgICByZXR1cm4gZm4oZXJyKTtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuICAgICAgc2VsZi5lbWl0KCdob29rIGVuZCcsIGhvb2spO1xcbiAgICAgIGRlbGV0ZSBob29rLmN0eC5jdXJyZW50VGVzdDtcXG4gICAgICBuZXh0KCsraSk7XFxuICAgIH0pO1xcbiAgfVxcblxcbiAgUnVubmVyLmltbWVkaWF0ZWx5KGZ1bmN0aW9uICgpIHtcXG4gICAgbmV4dCgwKTtcXG4gIH0pO1xcbn07XFxuXFxuLyoqXFxuICogUnVuIGhvb2sgYG5hbWVgIGZvciB0aGUgZ2l2ZW4gYXJyYXkgb2YgYHN1aXRlc2BcXG4gKiBpbiBvcmRlciwgYW5kIGNhbGxiYWNrIGBmbihlcnIsIGVyclN1aXRlKWAuXFxuICpcXG4gKiBAYXBpIHByaXZhdGVcXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxcbiAqIEBwYXJhbSB7QXJyYXl9IHN1aXRlc1xcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXFxuICovXFxuUnVubmVyLnByb3RvdHlwZS5ob29rcyA9IGZ1bmN0aW9uIChuYW1lLCBzdWl0ZXMsIGZuKSB7XFxuICB2YXIgc2VsZiA9IHRoaXM7XFxuICB2YXIgb3JpZyA9IHRoaXMuc3VpdGU7XFxuXFxuICBmdW5jdGlvbiBuZXh0IChzdWl0ZSkge1xcbiAgICBzZWxmLnN1aXRlID0gc3VpdGU7XFxuXFxuICAgIGlmICghc3VpdGUpIHtcXG4gICAgICBzZWxmLnN1aXRlID0gb3JpZztcXG4gICAgICByZXR1cm4gZm4oKTtcXG4gICAgfVxcblxcbiAgICBzZWxmLmhvb2sobmFtZSwgZnVuY3Rpb24gKGVycikge1xcbiAgICAgIGlmIChlcnIpIHtcXG4gICAgICAgIHZhciBlcnJTdWl0ZSA9IHNlbGYuc3VpdGU7XFxuICAgICAgICBzZWxmLnN1aXRlID0gb3JpZztcXG4gICAgICAgIHJldHVybiBmbihlcnIsIGVyclN1aXRlKTtcXG4gICAgICB9XFxuXFxuICAgICAgbmV4dChzdWl0ZXMucG9wKCkpO1xcbiAgICB9KTtcXG4gIH1cXG5cXG4gIG5leHQoc3VpdGVzLnBvcCgpKTtcXG59O1xcblxcbi8qKlxcbiAqIFJ1biBob29rcyBmcm9tIHRoZSB0b3AgbGV2ZWwgZG93bi5cXG4gKlxcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXFxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cXG4gKiBAYXBpIHByaXZhdGVcXG4gKi9cXG5SdW5uZXIucHJvdG90eXBlLmhvb2tVcCA9IGZ1bmN0aW9uIChuYW1lLCBmbikge1xcbiAgdmFyIHN1aXRlcyA9IFt0aGlzLnN1aXRlXS5jb25jYXQodGhpcy5wYXJlbnRzKCkpLnJldmVyc2UoKTtcXG4gIHRoaXMuaG9va3MobmFtZSwgc3VpdGVzLCBmbik7XFxufTtcXG5cXG4vKipcXG4gKiBSdW4gaG9va3MgZnJvbSB0aGUgYm90dG9tIHVwLlxcbiAqXFxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxcbiAqIEBhcGkgcHJpdmF0ZVxcbiAqL1xcblJ1bm5lci5wcm90b3R5cGUuaG9va0Rvd24gPSBmdW5jdGlvbiAobmFtZSwgZm4pIHtcXG4gIHZhciBzdWl0ZXMgPSBbdGhpcy5zdWl0ZV0uY29uY2F0KHRoaXMucGFyZW50cygpKTtcXG4gIHRoaXMuaG9va3MobmFtZSwgc3VpdGVzLCBmbik7XFxufTtcXG5cXG4vKipcXG4gKiBSZXR1cm4gYW4gYXJyYXkgb2YgcGFyZW50IFN1aXRlcyBmcm9tXFxuICogY2xvc2VzdCB0byBmdXJ0aGVzdC5cXG4gKlxcbiAqIEByZXR1cm4ge0FycmF5fVxcbiAqIEBhcGkgcHJpdmF0ZVxcbiAqL1xcblJ1bm5lci5wcm90b3R5cGUucGFyZW50cyA9IGZ1bmN0aW9uICgpIHtcXG4gIHZhciBzdWl0ZSA9IHRoaXMuc3VpdGU7XFxuICB2YXIgc3VpdGVzID0gW107XFxuICB3aGlsZSAoc3VpdGUucGFyZW50KSB7XFxuICAgIHN1aXRlID0gc3VpdGUucGFyZW50O1xcbiAgICBzdWl0ZXMucHVzaChzdWl0ZSk7XFxuICB9XFxuICByZXR1cm4gc3VpdGVzO1xcbn07XFxuXFxuLyoqXFxuICogUnVuIHRoZSBjdXJyZW50IHRlc3QgYW5kIGNhbGxiYWNrIGBmbihlcnIpYC5cXG4gKlxcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXFxuICogQGFwaSBwcml2YXRlXFxuICovXFxuUnVubmVyLnByb3RvdHlwZS5ydW5UZXN0ID0gZnVuY3Rpb24gKGZuKSB7XFxuICB2YXIgc2VsZiA9IHRoaXM7XFxuICB2YXIgdGVzdCA9IHRoaXMudGVzdDtcXG5cXG4gIGlmICghdGVzdCkge1xcbiAgICByZXR1cm47XFxuICB9XFxuICBpZiAodGhpcy5hc3luY09ubHkpIHtcXG4gICAgdGVzdC5hc3luY09ubHkgPSB0cnVlO1xcbiAgfVxcbiAgdGVzdC5vbignZXJyb3InLCBmdW5jdGlvbiAoZXJyKSB7XFxuICAgIHNlbGYuZmFpbCh0ZXN0LCBlcnIpO1xcbiAgfSk7XFxuICBpZiAodGhpcy5hbGxvd1VuY2F1Z2h0KSB7XFxuICAgIHRlc3QuYWxsb3dVbmNhdWdodCA9IHRydWU7XFxuICAgIHJldHVybiB0ZXN0LnJ1bihmbik7XFxuICB9XFxuICB0cnkge1xcbiAgICB0ZXN0LnJ1bihmbik7XFxuICB9IGNhdGNoIChlcnIpIHtcXG4gICAgZm4oZXJyKTtcXG4gIH1cXG59O1xcblxcbi8qKlxcbiAqIFJ1biB0ZXN0cyBpbiB0aGUgZ2l2ZW4gYHN1aXRlYCBhbmQgaW52b2tlIHRoZSBjYWxsYmFjayBgZm4oKWAgd2hlbiBjb21wbGV0ZS5cXG4gKlxcbiAqIEBhcGkgcHJpdmF0ZVxcbiAqIEBwYXJhbSB7U3VpdGV9IHN1aXRlXFxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cXG4gKi9cXG5SdW5uZXIucHJvdG90eXBlLnJ1blRlc3RzID0gZnVuY3Rpb24gKHN1aXRlLCBmbikge1xcbiAgdmFyIHNlbGYgPSB0aGlzO1xcbiAgdmFyIHRlc3RzID0gc3VpdGUudGVzdHMuc2xpY2UoKTtcXG4gIHZhciB0ZXN0O1xcblxcbiAgZnVuY3Rpb24gaG9va0VyciAoXywgZXJyU3VpdGUsIGFmdGVyKSB7XFxuICAgIC8vIGJlZm9yZS9hZnRlciBFYWNoIGhvb2sgZm9yIGVyclN1aXRlIGZhaWxlZDpcXG4gICAgdmFyIG9yaWcgPSBzZWxmLnN1aXRlO1xcblxcbiAgICAvLyBmb3IgZmFpbGVkICdhZnRlciBlYWNoJyBob29rIHN0YXJ0IGZyb20gZXJyU3VpdGUgcGFyZW50LFxcbiAgICAvLyBvdGhlcndpc2Ugc3RhcnQgZnJvbSBlcnJTdWl0ZSBpdHNlbGZcXG4gICAgc2VsZi5zdWl0ZSA9IGFmdGVyID8gZXJyU3VpdGUucGFyZW50IDogZXJyU3VpdGU7XFxuXFxuICAgIGlmIChzZWxmLnN1aXRlKSB7XFxuICAgICAgLy8gY2FsbCBob29rVXAgYWZ0ZXJFYWNoXFxuICAgICAgc2VsZi5ob29rVXAoJ2FmdGVyRWFjaCcsIGZ1bmN0aW9uIChlcnIyLCBlcnJTdWl0ZTIpIHtcXG4gICAgICAgIHNlbGYuc3VpdGUgPSBvcmlnO1xcbiAgICAgICAgLy8gc29tZSBob29rcyBtYXkgZmFpbCBldmVuIG5vd1xcbiAgICAgICAgaWYgKGVycjIpIHtcXG4gICAgICAgICAgcmV0dXJuIGhvb2tFcnIoZXJyMiwgZXJyU3VpdGUyLCB0cnVlKTtcXG4gICAgICAgIH1cXG4gICAgICAgIC8vIHJlcG9ydCBlcnJvciBzdWl0ZVxcbiAgICAgICAgZm4oZXJyU3VpdGUpO1xcbiAgICAgIH0pO1xcbiAgICB9IGVsc2Uge1xcbiAgICAgIC8vIHRoZXJlIGlzIG5vIG5lZWQgY2FsbGluZyBvdGhlciAnYWZ0ZXIgZWFjaCcgaG9va3NcXG4gICAgICBzZWxmLnN1aXRlID0gb3JpZztcXG4gICAgICBmbihlcnJTdWl0ZSk7XFxuICAgIH1cXG4gIH1cXG5cXG4gIGZ1bmN0aW9uIG5leHQgKGVyciwgZXJyU3VpdGUpIHtcXG4gICAgLy8gaWYgd2UgYmFpbCBhZnRlciBmaXJzdCBlcnJcXG4gICAgaWYgKHNlbGYuZmFpbHVyZXMgJiYgc3VpdGUuX2JhaWwpIHtcXG4gICAgICByZXR1cm4gZm4oKTtcXG4gICAgfVxcblxcbiAgICBpZiAoc2VsZi5fYWJvcnQpIHtcXG4gICAgICByZXR1cm4gZm4oKTtcXG4gICAgfVxcblxcbiAgICBpZiAoZXJyKSB7XFxuICAgICAgcmV0dXJuIGhvb2tFcnIoZXJyLCBlcnJTdWl0ZSwgdHJ1ZSk7XFxuICAgIH1cXG5cXG4gICAgLy8gbmV4dCB0ZXN0XFxuICAgIHRlc3QgPSB0ZXN0cy5zaGlmdCgpO1xcblxcbiAgICAvLyBhbGwgZG9uZVxcbiAgICBpZiAoIXRlc3QpIHtcXG4gICAgICByZXR1cm4gZm4oKTtcXG4gICAgfVxcblxcbiAgICAvLyBncmVwXFxuICAgIHZhciBtYXRjaCA9IHNlbGYuX2dyZXAudGVzdCh0ZXN0LmZ1bGxUaXRsZSgpKTtcXG4gICAgaWYgKHNlbGYuX2ludmVydCkge1xcbiAgICAgIG1hdGNoID0gIW1hdGNoO1xcbiAgICB9XFxuICAgIGlmICghbWF0Y2gpIHtcXG4gICAgICAvLyBSdW4gaW1tZWRpYXRlbHkgb25seSBpZiB3ZSBoYXZlIGRlZmluZWQgYSBncmVwLiBXaGVuIHdlXFxuICAgICAgLy8gZGVmaW5lIGEgZ3JlcCDigJQgSXQgY2FuIGNhdXNlIG1heGltdW0gY2FsbHN0YWNrIGVycm9yIGlmXFxuICAgICAgLy8gdGhlIGdyZXAgaXMgZG9pbmcgYSBsYXJnZSByZWN1cnNpdmUgbG9vcCBieSBuZWdsZWN0aW5nXFxuICAgICAgLy8gYWxsIHRlc3RzLiBUaGUgcnVuIGltbWVkaWF0ZWx5IGZ1bmN0aW9uIGFsc28gY29tZXMgd2l0aFxcbiAgICAgIC8vIGEgcGVyZm9ybWFuY2UgY29zdC4gU28gd2UgZG9uJ3Qgd2FudCB0byBydW4gaW1tZWRpYXRlbHlcXG4gICAgICAvLyBpZiB3ZSBydW4gdGhlIHdob2xlIHRlc3Qgc3VpdGUsIGJlY2F1c2UgcnVubmluZyB0aGUgd2hvbGVcXG4gICAgICAvLyB0ZXN0IHN1aXRlIGRvbid0IGRvIGFueSBpbW1lZGlhdGUgcmVjdXJzaXZlIGxvb3BzLiBUaHVzLFxcbiAgICAgIC8vIGFsbG93aW5nIGEgSlMgcnVudGltZSB0byBicmVhdGhlLlxcbiAgICAgIGlmIChzZWxmLl9ncmVwICE9PSBzZWxmLl9kZWZhdWx0R3JlcCkge1xcbiAgICAgICAgUnVubmVyLmltbWVkaWF0ZWx5KG5leHQpO1xcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICBuZXh0KCk7XFxuICAgICAgfVxcbiAgICAgIHJldHVybjtcXG4gICAgfVxcblxcbiAgICBpZiAodGVzdC5pc1BlbmRpbmcoKSkge1xcbiAgICAgIHNlbGYuZW1pdCgncGVuZGluZycsIHRlc3QpO1xcbiAgICAgIHNlbGYuZW1pdCgndGVzdCBlbmQnLCB0ZXN0KTtcXG4gICAgICByZXR1cm4gbmV4dCgpO1xcbiAgICB9XFxuXFxuICAgIC8vIGV4ZWN1dGUgdGVzdCBhbmQgaG9vayhzKVxcbiAgICBzZWxmLmVtaXQoJ3Rlc3QnLCBzZWxmLnRlc3QgPSB0ZXN0KTtcXG4gICAgc2VsZi5ob29rRG93bignYmVmb3JlRWFjaCcsIGZ1bmN0aW9uIChlcnIsIGVyclN1aXRlKSB7XFxuICAgICAgaWYgKHRlc3QuaXNQZW5kaW5nKCkpIHtcXG4gICAgICAgIHNlbGYuZW1pdCgncGVuZGluZycsIHRlc3QpO1xcbiAgICAgICAgc2VsZi5lbWl0KCd0ZXN0IGVuZCcsIHRlc3QpO1xcbiAgICAgICAgcmV0dXJuIG5leHQoKTtcXG4gICAgICB9XFxuICAgICAgaWYgKGVycikge1xcbiAgICAgICAgcmV0dXJuIGhvb2tFcnIoZXJyLCBlcnJTdWl0ZSwgZmFsc2UpO1xcbiAgICAgIH1cXG4gICAgICBzZWxmLmN1cnJlbnRSdW5uYWJsZSA9IHNlbGYudGVzdDtcXG4gICAgICBzZWxmLnJ1blRlc3QoZnVuY3Rpb24gKGVycikge1xcbiAgICAgICAgdGVzdCA9IHNlbGYudGVzdDtcXG4gICAgICAgIGlmIChlcnIpIHtcXG4gICAgICAgICAgdmFyIHJldHJ5ID0gdGVzdC5jdXJyZW50UmV0cnkoKTtcXG4gICAgICAgICAgaWYgKGVyciBpbnN0YW5jZW9mIFBlbmRpbmcpIHtcXG4gICAgICAgICAgICB0ZXN0LnBlbmRpbmcgPSB0cnVlO1xcbiAgICAgICAgICAgIHNlbGYuZW1pdCgncGVuZGluZycsIHRlc3QpO1xcbiAgICAgICAgICB9IGVsc2UgaWYgKHJldHJ5IDwgdGVzdC5yZXRyaWVzKCkpIHtcXG4gICAgICAgICAgICB2YXIgY2xvbmVkVGVzdCA9IHRlc3QuY2xvbmUoKTtcXG4gICAgICAgICAgICBjbG9uZWRUZXN0LmN1cnJlbnRSZXRyeShyZXRyeSArIDEpO1xcbiAgICAgICAgICAgIHRlc3RzLnVuc2hpZnQoY2xvbmVkVGVzdCk7XFxuXFxuICAgICAgICAgICAgLy8gRWFybHkgcmV0dXJuICsgaG9vayB0cmlnZ2VyIHNvIHRoYXQgaXQgZG9lc24ndFxcbiAgICAgICAgICAgIC8vIGluY3JlbWVudCB0aGUgY291bnQgd3JvbmdcXG4gICAgICAgICAgICByZXR1cm4gc2VsZi5ob29rVXAoJ2FmdGVyRWFjaCcsIG5leHQpO1xcbiAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgIHNlbGYuZmFpbCh0ZXN0LCBlcnIpO1xcbiAgICAgICAgICB9XFxuICAgICAgICAgIHNlbGYuZW1pdCgndGVzdCBlbmQnLCB0ZXN0KTtcXG5cXG4gICAgICAgICAgaWYgKGVyciBpbnN0YW5jZW9mIFBlbmRpbmcpIHtcXG4gICAgICAgICAgICByZXR1cm4gbmV4dCgpO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIHJldHVybiBzZWxmLmhvb2tVcCgnYWZ0ZXJFYWNoJywgbmV4dCk7XFxuICAgICAgICB9XFxuXFxuICAgICAgICB0ZXN0LnN0YXRlID0gJ3Bhc3NlZCc7XFxuICAgICAgICBzZWxmLmVtaXQoJ3Bhc3MnLCB0ZXN0KTtcXG4gICAgICAgIHNlbGYuZW1pdCgndGVzdCBlbmQnLCB0ZXN0KTtcXG4gICAgICAgIHNlbGYuaG9va1VwKCdhZnRlckVhY2gnLCBuZXh0KTtcXG4gICAgICB9KTtcXG4gICAgfSk7XFxuICB9XFxuXFxuICB0aGlzLm5leHQgPSBuZXh0O1xcbiAgdGhpcy5ob29rRXJyID0gaG9va0VycjtcXG4gIG5leHQoKTtcXG59O1xcblxcbi8qKlxcbiAqIFJ1biB0aGUgZ2l2ZW4gYHN1aXRlYCBhbmQgaW52b2tlIHRoZSBjYWxsYmFjayBgZm4oKWAgd2hlbiBjb21wbGV0ZS5cXG4gKlxcbiAqIEBhcGkgcHJpdmF0ZVxcbiAqIEBwYXJhbSB7U3VpdGV9IHN1aXRlXFxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cXG4gKi9cXG5SdW5uZXIucHJvdG90eXBlLnJ1blN1aXRlID0gZnVuY3Rpb24gKHN1aXRlLCBmbikge1xcbiAgdmFyIGkgPSAwO1xcbiAgdmFyIHNlbGYgPSB0aGlzO1xcbiAgdmFyIHRvdGFsID0gdGhpcy5ncmVwVG90YWwoc3VpdGUpO1xcbiAgdmFyIGFmdGVyQWxsSG9va0NhbGxlZCA9IGZhbHNlO1xcblxcbiAgZGVidWcoJ3J1biBzdWl0ZSAlcycsIHN1aXRlLmZ1bGxUaXRsZSgpKTtcXG5cXG4gIGlmICghdG90YWwgfHwgKHNlbGYuZmFpbHVyZXMgJiYgc3VpdGUuX2JhaWwpKSB7XFxuICAgIHJldHVybiBmbigpO1xcbiAgfVxcblxcbiAgdGhpcy5lbWl0KCdzdWl0ZScsIHRoaXMuc3VpdGUgPSBzdWl0ZSk7XFxuXFxuICBmdW5jdGlvbiBuZXh0IChlcnJTdWl0ZSkge1xcbiAgICBpZiAoZXJyU3VpdGUpIHtcXG4gICAgICAvLyBjdXJyZW50IHN1aXRlIGZhaWxlZCBvbiBhIGhvb2sgZnJvbSBlcnJTdWl0ZVxcbiAgICAgIGlmIChlcnJTdWl0ZSA9PT0gc3VpdGUpIHtcXG4gICAgICAgIC8vIGlmIGVyclN1aXRlIGlzIGN1cnJlbnQgc3VpdGVcXG4gICAgICAgIC8vIGNvbnRpbnVlIHRvIHRoZSBuZXh0IHNpYmxpbmcgc3VpdGVcXG4gICAgICAgIHJldHVybiBkb25lKCk7XFxuICAgICAgfVxcbiAgICAgIC8vIGVyclN1aXRlIGlzIGFtb25nIHRoZSBwYXJlbnRzIG9mIGN1cnJlbnQgc3VpdGVcXG4gICAgICAvLyBzdG9wIGV4ZWN1dGlvbiBvZiBlcnJTdWl0ZSBhbmQgYWxsIHN1Yi1zdWl0ZXNcXG4gICAgICByZXR1cm4gZG9uZShlcnJTdWl0ZSk7XFxuICAgIH1cXG5cXG4gICAgaWYgKHNlbGYuX2Fib3J0KSB7XFxuICAgICAgcmV0dXJuIGRvbmUoKTtcXG4gICAgfVxcblxcbiAgICB2YXIgY3VyciA9IHN1aXRlLnN1aXRlc1tpKytdO1xcbiAgICBpZiAoIWN1cnIpIHtcXG4gICAgICByZXR1cm4gZG9uZSgpO1xcbiAgICB9XFxuXFxuICAgIC8vIEF2b2lkIGdyZXAgbmVnbGVjdGluZyBsYXJnZSBudW1iZXIgb2YgdGVzdHMgY2F1c2luZyBhXFxuICAgIC8vIGh1Z2UgcmVjdXJzaXZlIGxvb3AgYW5kIHRodXMgYSBtYXhpbXVtIGNhbGwgc3RhY2sgZXJyb3IuXFxuICAgIC8vIFNlZSBjb21tZW50IGluIGB0aGlzLnJ1blRlc3RzKClgIGZvciBtb3JlIGluZm9ybWF0aW9uLlxcbiAgICBpZiAoc2VsZi5fZ3JlcCAhPT0gc2VsZi5fZGVmYXVsdEdyZXApIHtcXG4gICAgICBSdW5uZXIuaW1tZWRpYXRlbHkoZnVuY3Rpb24gKCkge1xcbiAgICAgICAgc2VsZi5ydW5TdWl0ZShjdXJyLCBuZXh0KTtcXG4gICAgICB9KTtcXG4gICAgfSBlbHNlIHtcXG4gICAgICBzZWxmLnJ1blN1aXRlKGN1cnIsIG5leHQpO1xcbiAgICB9XFxuICB9XFxuXFxuICBmdW5jdGlvbiBkb25lIChlcnJTdWl0ZSkge1xcbiAgICBzZWxmLnN1aXRlID0gc3VpdGU7XFxuICAgIHNlbGYubmV4dFN1aXRlID0gbmV4dDtcXG5cXG4gICAgaWYgKGFmdGVyQWxsSG9va0NhbGxlZCkge1xcbiAgICAgIGZuKGVyclN1aXRlKTtcXG4gICAgfSBlbHNlIHtcXG4gICAgICAvLyBtYXJrIHRoYXQgdGhlIGFmdGVyQWxsIGJsb2NrIGhhcyBiZWVuIGNhbGxlZCBvbmNlXFxuICAgICAgLy8gYW5kIHNvIGNhbiBiZSBza2lwcGVkIGlmIHRoZXJlIGlzIGFuIGVycm9yIGluIGl0LlxcbiAgICAgIGFmdGVyQWxsSG9va0NhbGxlZCA9IHRydWU7XFxuXFxuICAgICAgLy8gcmVtb3ZlIHJlZmVyZW5jZSB0byB0ZXN0XFxuICAgICAgZGVsZXRlIHNlbGYudGVzdDtcXG5cXG4gICAgICBzZWxmLmhvb2soJ2FmdGVyQWxsJywgZnVuY3Rpb24gKCkge1xcbiAgICAgICAgc2VsZi5lbWl0KCdzdWl0ZSBlbmQnLCBzdWl0ZSk7XFxuICAgICAgICBmbihlcnJTdWl0ZSk7XFxuICAgICAgfSk7XFxuICAgIH1cXG4gIH1cXG5cXG4gIHRoaXMubmV4dFN1aXRlID0gbmV4dDtcXG5cXG4gIHRoaXMuaG9vaygnYmVmb3JlQWxsJywgZnVuY3Rpb24gKGVycikge1xcbiAgICBpZiAoZXJyKSB7XFxuICAgICAgcmV0dXJuIGRvbmUoKTtcXG4gICAgfVxcbiAgICBzZWxmLnJ1blRlc3RzKHN1aXRlLCBuZXh0KTtcXG4gIH0pO1xcbn07XFxuXFxuLyoqXFxuICogSGFuZGxlIHVuY2F1Z2h0IGV4Y2VwdGlvbnMuXFxuICpcXG4gKiBAcGFyYW0ge0Vycm9yfSBlcnJcXG4gKiBAYXBpIHByaXZhdGVcXG4gKi9cXG5SdW5uZXIucHJvdG90eXBlLnVuY2F1Z2h0ID0gZnVuY3Rpb24gKGVycikge1xcbiAgaWYgKGVycikge1xcbiAgICBkZWJ1ZygndW5jYXVnaHQgZXhjZXB0aW9uICVzJywgZXJyID09PSAoZnVuY3Rpb24gKCkge1xcbiAgICAgIHJldHVybiB0aGlzO1xcbiAgICB9LmNhbGwoZXJyKSkgPyAoZXJyLm1lc3NhZ2UgfHwgZXJyKSA6IGVycik7XFxuICB9IGVsc2Uge1xcbiAgICBkZWJ1ZygndW5jYXVnaHQgdW5kZWZpbmVkIGV4Y2VwdGlvbicpO1xcbiAgICBlcnIgPSB1bmRlZmluZWRFcnJvcigpO1xcbiAgfVxcbiAgZXJyLnVuY2F1Z2h0ID0gdHJ1ZTtcXG5cXG4gIHZhciBydW5uYWJsZSA9IHRoaXMuY3VycmVudFJ1bm5hYmxlO1xcblxcbiAgaWYgKCFydW5uYWJsZSkge1xcbiAgICBydW5uYWJsZSA9IG5ldyBSdW5uYWJsZSgnVW5jYXVnaHQgZXJyb3Igb3V0c2lkZSB0ZXN0IHN1aXRlJyk7XFxuICAgIHJ1bm5hYmxlLnBhcmVudCA9IHRoaXMuc3VpdGU7XFxuXFxuICAgIGlmICh0aGlzLnN0YXJ0ZWQpIHtcXG4gICAgICB0aGlzLmZhaWwocnVubmFibGUsIGVycik7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgLy8gQ2FuJ3QgcmVjb3ZlciBmcm9tIHRoaXMgZmFpbHVyZVxcbiAgICAgIHRoaXMuZW1pdCgnc3RhcnQnKTtcXG4gICAgICB0aGlzLmZhaWwocnVubmFibGUsIGVycik7XFxuICAgICAgdGhpcy5lbWl0KCdlbmQnKTtcXG4gICAgfVxcblxcbiAgICByZXR1cm47XFxuICB9XFxuXFxuICBydW5uYWJsZS5jbGVhclRpbWVvdXQoKTtcXG5cXG4gIC8vIElnbm9yZSBlcnJvcnMgaWYgY29tcGxldGUgb3IgcGVuZGluZ1xcbiAgaWYgKHJ1bm5hYmxlLnN0YXRlIHx8IHJ1bm5hYmxlLmlzUGVuZGluZygpKSB7XFxuICAgIHJldHVybjtcXG4gIH1cXG4gIHRoaXMuZmFpbChydW5uYWJsZSwgZXJyKTtcXG5cXG4gIC8vIHJlY292ZXIgZnJvbSB0ZXN0XFxuICBpZiAocnVubmFibGUudHlwZSA9PT0gJ3Rlc3QnKSB7XFxuICAgIHRoaXMuZW1pdCgndGVzdCBlbmQnLCBydW5uYWJsZSk7XFxuICAgIHRoaXMuaG9va1VwKCdhZnRlckVhY2gnLCB0aGlzLm5leHQpO1xcbiAgICByZXR1cm47XFxuICB9XFxuXFxuIC8vIHJlY292ZXIgZnJvbSBob29rc1xcbiAgaWYgKHJ1bm5hYmxlLnR5cGUgPT09ICdob29rJykge1xcbiAgICB2YXIgZXJyU3VpdGUgPSB0aGlzLnN1aXRlO1xcbiAgICAvLyBpZiBob29rIGZhaWx1cmUgaXMgaW4gYWZ0ZXJFYWNoIGJsb2NrXFxuICAgIGlmIChydW5uYWJsZS5mdWxsVGl0bGUoKS5pbmRleE9mKCdhZnRlciBlYWNoJykgPiAtMSkge1xcbiAgICAgIHJldHVybiB0aGlzLmhvb2tFcnIoZXJyLCBlcnJTdWl0ZSwgdHJ1ZSk7XFxuICAgIH1cXG4gICAgLy8gaWYgaG9vayBmYWlsdXJlIGlzIGluIGJlZm9yZUVhY2ggYmxvY2tcXG4gICAgaWYgKHJ1bm5hYmxlLmZ1bGxUaXRsZSgpLmluZGV4T2YoJ2JlZm9yZSBlYWNoJykgPiAtMSkge1xcbiAgICAgIHJldHVybiB0aGlzLmhvb2tFcnIoZXJyLCBlcnJTdWl0ZSwgZmFsc2UpO1xcbiAgICB9XFxuICAgIC8vIGlmIGhvb2sgZmFpbHVyZSBpcyBpbiBhZnRlciBvciBiZWZvcmUgYmxvY2tzXFxuICAgIHJldHVybiB0aGlzLm5leHRTdWl0ZShlcnJTdWl0ZSk7XFxuICB9XFxuXFxuICAvLyBiYWlsXFxuICB0aGlzLmVtaXQoJ2VuZCcpO1xcbn07XFxuXFxuLyoqXFxuICogQ2xlYW5zIHVwIHRoZSByZWZlcmVuY2VzIHRvIGFsbCB0aGUgZGVmZXJyZWQgZnVuY3Rpb25zXFxuICogKGJlZm9yZS9hZnRlci9iZWZvcmVFYWNoL2FmdGVyRWFjaCkgYW5kIHRlc3RzIG9mIGEgU3VpdGUuXFxuICogVGhlc2UgbXVzdCBiZSBkZWxldGVkIG90aGVyd2lzZSBhIG1lbW9yeSBsZWFrIGNhbiBoYXBwZW4sXFxuICogYXMgdGhvc2UgZnVuY3Rpb25zIG1heSByZWZlcmVuY2UgdmFyaWFibGVzIGZyb20gY2xvc3VyZXMsXFxuICogdGh1cyB0aG9zZSB2YXJpYWJsZXMgY2FuIG5ldmVyIGJlIGdhcmJhZ2UgY29sbGVjdGVkIGFzIGxvbmdcXG4gKiBhcyB0aGUgZGVmZXJyZWQgZnVuY3Rpb25zIGV4aXN0LlxcbiAqXFxuICogQHBhcmFtIHtTdWl0ZX0gc3VpdGVcXG4gKi9cXG5mdW5jdGlvbiBjbGVhblN1aXRlUmVmZXJlbmNlcyAoc3VpdGUpIHtcXG4gIGZ1bmN0aW9uIGNsZWFuQXJyUmVmZXJlbmNlcyAoYXJyKSB7XFxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XFxuICAgICAgZGVsZXRlIGFycltpXS5mbjtcXG4gICAgfVxcbiAgfVxcblxcbiAgaWYgKGlzQXJyYXkoc3VpdGUuX2JlZm9yZUFsbCkpIHtcXG4gICAgY2xlYW5BcnJSZWZlcmVuY2VzKHN1aXRlLl9iZWZvcmVBbGwpO1xcbiAgfVxcblxcbiAgaWYgKGlzQXJyYXkoc3VpdGUuX2JlZm9yZUVhY2gpKSB7XFxuICAgIGNsZWFuQXJyUmVmZXJlbmNlcyhzdWl0ZS5fYmVmb3JlRWFjaCk7XFxuICB9XFxuXFxuICBpZiAoaXNBcnJheShzdWl0ZS5fYWZ0ZXJBbGwpKSB7XFxuICAgIGNsZWFuQXJyUmVmZXJlbmNlcyhzdWl0ZS5fYWZ0ZXJBbGwpO1xcbiAgfVxcblxcbiAgaWYgKGlzQXJyYXkoc3VpdGUuX2FmdGVyRWFjaCkpIHtcXG4gICAgY2xlYW5BcnJSZWZlcmVuY2VzKHN1aXRlLl9hZnRlckVhY2gpO1xcbiAgfVxcblxcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdWl0ZS50ZXN0cy5sZW5ndGg7IGkrKykge1xcbiAgICBkZWxldGUgc3VpdGUudGVzdHNbaV0uZm47XFxuICB9XFxufVxcblxcbi8qKlxcbiAqIFJ1biB0aGUgcm9vdCBzdWl0ZSBhbmQgaW52b2tlIGBmbihmYWlsdXJlcylgXFxuICogb24gY29tcGxldGlvbi5cXG4gKlxcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXFxuICogQHJldHVybiB7UnVubmVyfSBmb3IgY2hhaW5pbmdcXG4gKiBAYXBpIHB1YmxpY1xcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXFxuICogQHJldHVybiB7UnVubmVyfSBSdW5uZXIgaW5zdGFuY2UuXFxuICovXFxuUnVubmVyLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoZm4pIHtcXG4gIHZhciBzZWxmID0gdGhpcztcXG4gIHZhciByb290U3VpdGUgPSB0aGlzLnN1aXRlO1xcblxcbiAgLy8gSWYgdGhlcmUgaXMgYW4gYG9ubHlgIGZpbHRlclxcbiAgaWYgKHRoaXMuaGFzT25seSkge1xcbiAgICBmaWx0ZXJPbmx5KHJvb3RTdWl0ZSk7XFxuICB9XFxuXFxuICBmbiA9IGZuIHx8IGZ1bmN0aW9uICgpIHt9O1xcblxcbiAgZnVuY3Rpb24gdW5jYXVnaHQgKGVycikge1xcbiAgICBzZWxmLnVuY2F1Z2h0KGVycik7XFxuICB9XFxuXFxuICBmdW5jdGlvbiBzdGFydCAoKSB7XFxuICAgIHNlbGYuc3RhcnRlZCA9IHRydWU7XFxuICAgIHNlbGYuZW1pdCgnc3RhcnQnKTtcXG4gICAgc2VsZi5ydW5TdWl0ZShyb290U3VpdGUsIGZ1bmN0aW9uICgpIHtcXG4gICAgICBkZWJ1ZygnZmluaXNoZWQgcnVubmluZycpO1xcbiAgICAgIHNlbGYuZW1pdCgnZW5kJyk7XFxuICAgIH0pO1xcbiAgfVxcblxcbiAgZGVidWcoJ3N0YXJ0Jyk7XFxuXFxuICAvLyByZWZlcmVuY2VzIGNsZWFudXAgdG8gYXZvaWQgbWVtb3J5IGxlYWtzXFxuICB0aGlzLm9uKCdzdWl0ZSBlbmQnLCBjbGVhblN1aXRlUmVmZXJlbmNlcyk7XFxuXFxuICAvLyBjYWxsYmFja1xcbiAgdGhpcy5vbignZW5kJywgZnVuY3Rpb24gKCkge1xcbiAgICBpZiAoc2VsZi5mb3JiaWRPbmx5ICYmIHNlbGYuaGFzT25seSkge1xcbiAgICAgIHNlbGYuZmFpbHVyZXMgKz0gc2VsZi5zdGF0cy50ZXN0cztcXG4gICAgfVxcbiAgICBpZiAoc2VsZi5mb3JiaWRQZW5kaW5nKSB7XFxuICAgICAgc2VsZi5mYWlsdXJlcyArPSBzZWxmLnN0YXRzLnBlbmRpbmc7XFxuICAgIH1cXG4gICAgZGVidWcoJ2VuZCcpO1xcbiAgICBwcm9jZXNzLnJlbW92ZUxpc3RlbmVyKCd1bmNhdWdodEV4Y2VwdGlvbicsIHVuY2F1Z2h0KTtcXG4gICAgZm4oc2VsZi5mYWlsdXJlcyk7XFxuICB9KTtcXG5cXG4gIC8vIHVuY2F1Z2h0IGV4Y2VwdGlvblxcbiAgcHJvY2Vzcy5vbigndW5jYXVnaHRFeGNlcHRpb24nLCB1bmNhdWdodCk7XFxuXFxuICBpZiAodGhpcy5fZGVsYXkpIHtcXG4gICAgLy8gZm9yIHJlcG9ydGVycywgSSBndWVzcy5cXG4gICAgLy8gbWlnaHQgYmUgbmljZSB0byBkZWJvdW5jZSBzb21lIGRvdHMgd2hpbGUgd2Ugd2FpdC5cXG4gICAgdGhpcy5lbWl0KCd3YWl0aW5nJywgcm9vdFN1aXRlKTtcXG4gICAgcm9vdFN1aXRlLm9uY2UoJ3J1bicsIHN0YXJ0KTtcXG4gIH0gZWxzZSB7XFxuICAgIHN0YXJ0KCk7XFxuICB9XFxuXFxuICByZXR1cm4gdGhpcztcXG59O1xcblxcbi8qKlxcbiAqIENsZWFubHkgYWJvcnQgZXhlY3V0aW9uLlxcbiAqXFxuICogQGFwaSBwdWJsaWNcXG4gKiBAcmV0dXJuIHtSdW5uZXJ9IFJ1bm5lciBpbnN0YW5jZS5cXG4gKi9cXG5SdW5uZXIucHJvdG90eXBlLmFib3J0ID0gZnVuY3Rpb24gKCkge1xcbiAgZGVidWcoJ2Fib3J0aW5nJyk7XFxuICB0aGlzLl9hYm9ydCA9IHRydWU7XFxuXFxuICByZXR1cm4gdGhpcztcXG59O1xcblxcbi8qKlxcbiAqIEZpbHRlciBzdWl0ZXMgYmFzZWQgb24gYGlzT25seWAgbG9naWMuXFxuICpcXG4gKiBAcGFyYW0ge0FycmF5fSBzdWl0ZVxcbiAqIEByZXR1cm5zIHtCb29sZWFufVxcbiAqIEBhcGkgcHJpdmF0ZVxcbiAqL1xcbmZ1bmN0aW9uIGZpbHRlck9ubHkgKHN1aXRlKSB7XFxuICBpZiAoc3VpdGUuX29ubHlUZXN0cy5sZW5ndGgpIHtcXG4gICAgLy8gSWYgdGhlIHN1aXRlIGNvbnRhaW5zIGBvbmx5YCB0ZXN0cywgcnVuIHRob3NlIGFuZCBpZ25vcmUgYW55IG5lc3RlZCBzdWl0ZXMuXFxuICAgIHN1aXRlLnRlc3RzID0gc3VpdGUuX29ubHlUZXN0cztcXG4gICAgc3VpdGUuc3VpdGVzID0gW107XFxuICB9IGVsc2Uge1xcbiAgICAvLyBPdGhlcndpc2UsIGRvIG5vdCBydW4gYW55IG9mIHRoZSB0ZXN0cyBpbiB0aGlzIHN1aXRlLlxcbiAgICBzdWl0ZS50ZXN0cyA9IFtdO1xcbiAgICB1dGlscy5mb3JFYWNoKHN1aXRlLl9vbmx5U3VpdGVzLCBmdW5jdGlvbiAob25seVN1aXRlKSB7XFxuICAgICAgLy8gSWYgdGhlcmUgYXJlIG90aGVyIGBvbmx5YCB0ZXN0cy9zdWl0ZXMgbmVzdGVkIGluIHRoZSBjdXJyZW50IGBvbmx5YCBzdWl0ZSwgdGhlbiBmaWx0ZXIgdGhhdCBgb25seWAgc3VpdGUuXFxuICAgICAgLy8gT3RoZXJ3aXNlLCBhbGwgb2YgdGhlIHRlc3RzIG9uIHRoaXMgYG9ubHlgIHN1aXRlIHNob3VsZCBiZSBydW4sIHNvIGRvbid0IGZpbHRlciBpdC5cXG4gICAgICBpZiAoaGFzT25seShvbmx5U3VpdGUpKSB7XFxuICAgICAgICBmaWx0ZXJPbmx5KG9ubHlTdWl0ZSk7XFxuICAgICAgfVxcbiAgICB9KTtcXG4gICAgLy8gUnVuIHRoZSBgb25seWAgc3VpdGVzLCBhcyB3ZWxsIGFzIGFueSBvdGhlciBzdWl0ZXMgdGhhdCBoYXZlIGBvbmx5YCB0ZXN0cy9zdWl0ZXMgYXMgZGVzY2VuZGFudHMuXFxuICAgIHN1aXRlLnN1aXRlcyA9IGZpbHRlcihzdWl0ZS5zdWl0ZXMsIGZ1bmN0aW9uIChjaGlsZFN1aXRlKSB7XFxuICAgICAgcmV0dXJuIGluZGV4T2Yoc3VpdGUuX29ubHlTdWl0ZXMsIGNoaWxkU3VpdGUpICE9PSAtMSB8fCBmaWx0ZXJPbmx5KGNoaWxkU3VpdGUpO1xcbiAgICB9KTtcXG4gIH1cXG4gIC8vIEtlZXAgdGhlIHN1aXRlIG9ubHkgaWYgdGhlcmUgaXMgc29tZXRoaW5nIHRvIHJ1blxcbiAgcmV0dXJuIHN1aXRlLnRlc3RzLmxlbmd0aCB8fCBzdWl0ZS5zdWl0ZXMubGVuZ3RoO1xcbn1cXG5cXG4vKipcXG4gKiBEZXRlcm1pbmVzIHdoZXRoZXIgYSBzdWl0ZSBoYXMgYW4gYG9ubHlgIHRlc3Qgb3Igc3VpdGUgYXMgYSBkZXNjZW5kYW50LlxcbiAqXFxuICogQHBhcmFtIHtBcnJheX0gc3VpdGVcXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn1cXG4gKiBAYXBpIHByaXZhdGVcXG4gKi9cXG5mdW5jdGlvbiBoYXNPbmx5IChzdWl0ZSkge1xcbiAgcmV0dXJuIHN1aXRlLl9vbmx5VGVzdHMubGVuZ3RoIHx8IHN1aXRlLl9vbmx5U3VpdGVzLmxlbmd0aCB8fCBzb21lKHN1aXRlLnN1aXRlcywgaGFzT25seSk7XFxufVxcblxcbi8qKlxcbiAqIEZpbHRlciBsZWFrcyB3aXRoIHRoZSBnaXZlbiBnbG9iYWxzIGZsYWdnZWQgYXMgYG9rYC5cXG4gKlxcbiAqIEBhcGkgcHJpdmF0ZVxcbiAqIEBwYXJhbSB7QXJyYXl9IG9rXFxuICogQHBhcmFtIHtBcnJheX0gZ2xvYmFsc1xcbiAqIEByZXR1cm4ge0FycmF5fVxcbiAqL1xcbmZ1bmN0aW9uIGZpbHRlckxlYWtzIChvaywgZ2xvYmFscykge1xcbiAgcmV0dXJuIGZpbHRlcihnbG9iYWxzLCBmdW5jdGlvbiAoa2V5KSB7XFxuICAgIC8vIEZpcmVmb3ggYW5kIENocm9tZSBleHBvc2VzIGlmcmFtZXMgYXMgaW5kZXggaW5zaWRlIHRoZSB3aW5kb3cgb2JqZWN0XFxuICAgIGlmICgvXlxcXFxkKy8udGVzdChrZXkpKSB7XFxuICAgICAgcmV0dXJuIGZhbHNlO1xcbiAgICB9XFxuXFxuICAgIC8vIGluIGZpcmVmb3hcXG4gICAgLy8gaWYgcnVubmVyIHJ1bnMgaW4gYW4gaWZyYW1lLCB0aGlzIGlmcmFtZSdzIHdpbmRvdy5nZXRJbnRlcmZhY2UgbWV0aG9kXFxuICAgIC8vIG5vdCBpbml0IGF0IGZpcnN0IGl0IGlzIGFzc2lnbmVkIGluIHNvbWUgc2Vjb25kc1xcbiAgICBpZiAoZ2xvYmFsLm5hdmlnYXRvciAmJiAoL15nZXRJbnRlcmZhY2UvKS50ZXN0KGtleSkpIHtcXG4gICAgICByZXR1cm4gZmFsc2U7XFxuICAgIH1cXG5cXG4gICAgLy8gYW4gaWZyYW1lIGNvdWxkIGJlIGFwcHJvYWNoZWQgYnkgd2luZG93W2lmcmFtZUluZGV4XVxcbiAgICAvLyBpbiBpZTYsNyw4IGFuZCBvcGVyYSwgaWZyYW1lSW5kZXggaXMgZW51bWVyYWJsZSwgdGhpcyBjb3VsZCBjYXVzZSBsZWFrXFxuICAgIGlmIChnbG9iYWwubmF2aWdhdG9yICYmICgvXlxcXFxkKy8pLnRlc3Qoa2V5KSkge1xcbiAgICAgIHJldHVybiBmYWxzZTtcXG4gICAgfVxcblxcbiAgICAvLyBPcGVyYSBhbmQgSUUgZXhwb3NlIGdsb2JhbCB2YXJpYWJsZXMgZm9yIEhUTUwgZWxlbWVudCBJRHMgKGlzc3VlICMyNDMpXFxuICAgIGlmICgvXm1vY2hhLS8udGVzdChrZXkpKSB7XFxuICAgICAgcmV0dXJuIGZhbHNlO1xcbiAgICB9XFxuXFxuICAgIHZhciBtYXRjaGVkID0gZmlsdGVyKG9rLCBmdW5jdGlvbiAob2spIHtcXG4gICAgICBpZiAofm9rLmluZGV4T2YoJyonKSkge1xcbiAgICAgICAgcmV0dXJuIGtleS5pbmRleE9mKG9rLnNwbGl0KCcqJylbMF0pID09PSAwO1xcbiAgICAgIH1cXG4gICAgICByZXR1cm4ga2V5ID09PSBvaztcXG4gICAgfSk7XFxuICAgIHJldHVybiAhbWF0Y2hlZC5sZW5ndGggJiYgKCFnbG9iYWwubmF2aWdhdG9yIHx8IGtleSAhPT0gJ29uZXJyb3InKTtcXG4gIH0pO1xcbn1cXG5cXG4vKipcXG4gKiBBcnJheSBvZiBnbG9iYWxzIGRlcGVuZGVudCBvbiB0aGUgZW52aXJvbm1lbnQuXFxuICpcXG4gKiBAcmV0dXJuIHtBcnJheX1cXG4gKiBAYXBpIHByaXZhdGVcXG4gKi9cXG5mdW5jdGlvbiBleHRyYUdsb2JhbHMgKCkge1xcbiAgaWYgKHR5cGVvZiBwcm9jZXNzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgcHJvY2Vzcy52ZXJzaW9uID09PSAnc3RyaW5nJykge1xcbiAgICB2YXIgcGFydHMgPSBwcm9jZXNzLnZlcnNpb24uc3BsaXQoJy4nKTtcXG4gICAgdmFyIG5vZGVWZXJzaW9uID0gdXRpbHMucmVkdWNlKHBhcnRzLCBmdW5jdGlvbiAoYSwgdikge1xcbiAgICAgIHJldHVybiBhIDw8IDggfCB2O1xcbiAgICB9KTtcXG5cXG4gICAgLy8gJ2Vycm5vJyB3YXMgcmVuYW1lZCB0byBwcm9jZXNzLl9lcnJubyBpbiB2MC45LjExLlxcblxcbiAgICBpZiAobm9kZVZlcnNpb24gPCAweDAwMDkwQikge1xcbiAgICAgIHJldHVybiBbJ2Vycm5vJ107XFxuICAgIH1cXG4gIH1cXG5cXG4gIHJldHVybiBbXTtcXG59XFxuXFxufSkuY2FsbCh0aGlzLHJlcXVpcmUoJ19wcm9jZXNzJyksdHlwZW9mIGdsb2JhbCAhPT0gXFxcInVuZGVmaW5lZFxcXCIgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gXFxcInVuZGVmaW5lZFxcXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXFxcInVuZGVmaW5lZFxcXCIgPyB3aW5kb3cgOiB7fSlcXG59LHtcXFwiLi9wZW5kaW5nXFxcIjoxNixcXFwiLi9ydW5uYWJsZVxcXCI6MzMsXFxcIi4vdXRpbHNcXFwiOjM4LFxcXCJfcHJvY2Vzc1xcXCI6ODIsXFxcImRlYnVnXFxcIjoyLFxcXCJldmVudHNcXFwiOjN9XSwzNTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XFxuJ3VzZSBzdHJpY3QnO1xcblxcbi8qKlxcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXFxuICovXFxuXFxudmFyIEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlcjtcXG52YXIgSG9vayA9IHJlcXVpcmUoJy4vaG9vaycpO1xcbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcXG52YXIgaW5oZXJpdHMgPSB1dGlscy5pbmhlcml0cztcXG52YXIgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdtb2NoYTpzdWl0ZScpO1xcbnZhciBtaWxsaXNlY29uZHMgPSByZXF1aXJlKCcuL21zJyk7XFxuXFxuLyoqXFxuICogRXhwb3NlIGBTdWl0ZWAuXFxuICovXFxuXFxuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gU3VpdGU7XFxuXFxuLyoqXFxuICogQ3JlYXRlIGEgbmV3IGBTdWl0ZWAgd2l0aCB0aGUgZ2l2ZW4gYHRpdGxlYCBhbmQgcGFyZW50IGBTdWl0ZWAuIFdoZW4gYSBzdWl0ZVxcbiAqIHdpdGggdGhlIHNhbWUgdGl0bGUgaXMgYWxyZWFkeSBwcmVzZW50LCB0aGF0IHN1aXRlIGlzIHJldHVybmVkIHRvIHByb3ZpZGVcXG4gKiBuaWNlciByZXBvcnRlciBhbmQgbW9yZSBmbGV4aWJsZSBtZXRhLXRlc3RpbmcuXFxuICpcXG4gKiBAYXBpIHB1YmxpY1xcbiAqIEBwYXJhbSB7U3VpdGV9IHBhcmVudFxcbiAqIEBwYXJhbSB7c3RyaW5nfSB0aXRsZVxcbiAqIEByZXR1cm4ge1N1aXRlfVxcbiAqL1xcbmV4cG9ydHMuY3JlYXRlID0gZnVuY3Rpb24gKHBhcmVudCwgdGl0bGUpIHtcXG4gIHZhciBzdWl0ZSA9IG5ldyBTdWl0ZSh0aXRsZSwgcGFyZW50LmN0eCk7XFxuICBzdWl0ZS5wYXJlbnQgPSBwYXJlbnQ7XFxuICB0aXRsZSA9IHN1aXRlLmZ1bGxUaXRsZSgpO1xcbiAgcGFyZW50LmFkZFN1aXRlKHN1aXRlKTtcXG4gIHJldHVybiBzdWl0ZTtcXG59O1xcblxcbi8qKlxcbiAqIEluaXRpYWxpemUgYSBuZXcgYFN1aXRlYCB3aXRoIHRoZSBnaXZlbiBgdGl0bGVgIGFuZCBgY3R4YC5cXG4gKlxcbiAqIEBhcGkgcHJpdmF0ZVxcbiAqIEBwYXJhbSB7c3RyaW5nfSB0aXRsZVxcbiAqIEBwYXJhbSB7Q29udGV4dH0gcGFyZW50Q29udGV4dFxcbiAqL1xcbmZ1bmN0aW9uIFN1aXRlICh0aXRsZSwgcGFyZW50Q29udGV4dCkge1xcbiAgaWYgKCF1dGlscy5pc1N0cmluZyh0aXRsZSkpIHtcXG4gICAgdGhyb3cgbmV3IEVycm9yKCdTdWl0ZSBgdGl0bGVgIHNob3VsZCBiZSBhIFxcXCJzdHJpbmdcXFwiIGJ1dCBcXFwiJyArIHR5cGVvZiB0aXRsZSArICdcXFwiIHdhcyBnaXZlbiBpbnN0ZWFkLicpO1xcbiAgfVxcbiAgdGhpcy50aXRsZSA9IHRpdGxlO1xcbiAgZnVuY3Rpb24gQ29udGV4dCAoKSB7fVxcbiAgQ29udGV4dC5wcm90b3R5cGUgPSBwYXJlbnRDb250ZXh0O1xcbiAgdGhpcy5jdHggPSBuZXcgQ29udGV4dCgpO1xcbiAgdGhpcy5zdWl0ZXMgPSBbXTtcXG4gIHRoaXMudGVzdHMgPSBbXTtcXG4gIHRoaXMucGVuZGluZyA9IGZhbHNlO1xcbiAgdGhpcy5fYmVmb3JlRWFjaCA9IFtdO1xcbiAgdGhpcy5fYmVmb3JlQWxsID0gW107XFxuICB0aGlzLl9hZnRlckVhY2ggPSBbXTtcXG4gIHRoaXMuX2FmdGVyQWxsID0gW107XFxuICB0aGlzLnJvb3QgPSAhdGl0bGU7XFxuICB0aGlzLl90aW1lb3V0ID0gMjAwMDtcXG4gIHRoaXMuX2VuYWJsZVRpbWVvdXRzID0gdHJ1ZTtcXG4gIHRoaXMuX3Nsb3cgPSA3NTtcXG4gIHRoaXMuX2JhaWwgPSBmYWxzZTtcXG4gIHRoaXMuX3JldHJpZXMgPSAtMTtcXG4gIHRoaXMuX29ubHlUZXN0cyA9IFtdO1xcbiAgdGhpcy5fb25seVN1aXRlcyA9IFtdO1xcbiAgdGhpcy5kZWxheWVkID0gZmFsc2U7XFxufVxcblxcbi8qKlxcbiAqIEluaGVyaXQgZnJvbSBgRXZlbnRFbWl0dGVyLnByb3RvdHlwZWAuXFxuICovXFxuaW5oZXJpdHMoU3VpdGUsIEV2ZW50RW1pdHRlcik7XFxuXFxuLyoqXFxuICogUmV0dXJuIGEgY2xvbmUgb2YgdGhpcyBgU3VpdGVgLlxcbiAqXFxuICogQGFwaSBwcml2YXRlXFxuICogQHJldHVybiB7U3VpdGV9XFxuICovXFxuU3VpdGUucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gKCkge1xcbiAgdmFyIHN1aXRlID0gbmV3IFN1aXRlKHRoaXMudGl0bGUpO1xcbiAgZGVidWcoJ2Nsb25lJyk7XFxuICBzdWl0ZS5jdHggPSB0aGlzLmN0eDtcXG4gIHN1aXRlLnRpbWVvdXQodGhpcy50aW1lb3V0KCkpO1xcbiAgc3VpdGUucmV0cmllcyh0aGlzLnJldHJpZXMoKSk7XFxuICBzdWl0ZS5lbmFibGVUaW1lb3V0cyh0aGlzLmVuYWJsZVRpbWVvdXRzKCkpO1xcbiAgc3VpdGUuc2xvdyh0aGlzLnNsb3coKSk7XFxuICBzdWl0ZS5iYWlsKHRoaXMuYmFpbCgpKTtcXG4gIHJldHVybiBzdWl0ZTtcXG59O1xcblxcbi8qKlxcbiAqIFNldCB0aW1lb3V0IGBtc2Agb3Igc2hvcnQtaGFuZCBzdWNoIGFzIFxcXCIyc1xcXCIuXFxuICpcXG4gKiBAYXBpIHByaXZhdGVcXG4gKiBAcGFyYW0ge251bWJlcnxzdHJpbmd9IG1zXFxuICogQHJldHVybiB7U3VpdGV8bnVtYmVyfSBmb3IgY2hhaW5pbmdcXG4gKi9cXG5TdWl0ZS5wcm90b3R5cGUudGltZW91dCA9IGZ1bmN0aW9uIChtcykge1xcbiAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XFxuICAgIHJldHVybiB0aGlzLl90aW1lb3V0O1xcbiAgfVxcbiAgaWYgKG1zLnRvU3RyaW5nKCkgPT09ICcwJykge1xcbiAgICB0aGlzLl9lbmFibGVUaW1lb3V0cyA9IGZhbHNlO1xcbiAgfVxcbiAgaWYgKHR5cGVvZiBtcyA9PT0gJ3N0cmluZycpIHtcXG4gICAgbXMgPSBtaWxsaXNlY29uZHMobXMpO1xcbiAgfVxcbiAgZGVidWcoJ3RpbWVvdXQgJWQnLCBtcyk7XFxuICB0aGlzLl90aW1lb3V0ID0gcGFyc2VJbnQobXMsIDEwKTtcXG4gIHJldHVybiB0aGlzO1xcbn07XFxuXFxuLyoqXFxuICogU2V0IG51bWJlciBvZiB0aW1lcyB0byByZXRyeSBhIGZhaWxlZCB0ZXN0LlxcbiAqXFxuICogQGFwaSBwcml2YXRlXFxuICogQHBhcmFtIHtudW1iZXJ8c3RyaW5nfSBuXFxuICogQHJldHVybiB7U3VpdGV8bnVtYmVyfSBmb3IgY2hhaW5pbmdcXG4gKi9cXG5TdWl0ZS5wcm90b3R5cGUucmV0cmllcyA9IGZ1bmN0aW9uIChuKSB7XFxuICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcXG4gICAgcmV0dXJuIHRoaXMuX3JldHJpZXM7XFxuICB9XFxuICBkZWJ1ZygncmV0cmllcyAlZCcsIG4pO1xcbiAgdGhpcy5fcmV0cmllcyA9IHBhcnNlSW50KG4sIDEwKSB8fCAwO1xcbiAgcmV0dXJuIHRoaXM7XFxufTtcXG5cXG4vKipcXG4gICogU2V0IHRpbWVvdXQgdG8gYGVuYWJsZWRgLlxcbiAgKlxcbiAgKiBAYXBpIHByaXZhdGVcXG4gICogQHBhcmFtIHtib29sZWFufSBlbmFibGVkXFxuICAqIEByZXR1cm4ge1N1aXRlfGJvb2xlYW59IHNlbGYgb3IgZW5hYmxlZFxcbiAgKi9cXG5TdWl0ZS5wcm90b3R5cGUuZW5hYmxlVGltZW91dHMgPSBmdW5jdGlvbiAoZW5hYmxlZCkge1xcbiAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XFxuICAgIHJldHVybiB0aGlzLl9lbmFibGVUaW1lb3V0cztcXG4gIH1cXG4gIGRlYnVnKCdlbmFibGVUaW1lb3V0cyAlcycsIGVuYWJsZWQpO1xcbiAgdGhpcy5fZW5hYmxlVGltZW91dHMgPSBlbmFibGVkO1xcbiAgcmV0dXJuIHRoaXM7XFxufTtcXG5cXG4vKipcXG4gKiBTZXQgc2xvdyBgbXNgIG9yIHNob3J0LWhhbmQgc3VjaCBhcyBcXFwiMnNcXFwiLlxcbiAqXFxuICogQGFwaSBwcml2YXRlXFxuICogQHBhcmFtIHtudW1iZXJ8c3RyaW5nfSBtc1xcbiAqIEByZXR1cm4ge1N1aXRlfG51bWJlcn0gZm9yIGNoYWluaW5nXFxuICovXFxuU3VpdGUucHJvdG90eXBlLnNsb3cgPSBmdW5jdGlvbiAobXMpIHtcXG4gIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xcbiAgICByZXR1cm4gdGhpcy5fc2xvdztcXG4gIH1cXG4gIGlmICh0eXBlb2YgbXMgPT09ICdzdHJpbmcnKSB7XFxuICAgIG1zID0gbWlsbGlzZWNvbmRzKG1zKTtcXG4gIH1cXG4gIGRlYnVnKCdzbG93ICVkJywgbXMpO1xcbiAgdGhpcy5fc2xvdyA9IG1zO1xcbiAgcmV0dXJuIHRoaXM7XFxufTtcXG5cXG4vKipcXG4gKiBTZXRzIHdoZXRoZXIgdG8gYmFpbCBhZnRlciBmaXJzdCBlcnJvci5cXG4gKlxcbiAqIEBhcGkgcHJpdmF0ZVxcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gYmFpbFxcbiAqIEByZXR1cm4ge1N1aXRlfG51bWJlcn0gZm9yIGNoYWluaW5nXFxuICovXFxuU3VpdGUucHJvdG90eXBlLmJhaWwgPSBmdW5jdGlvbiAoYmFpbCkge1xcbiAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XFxuICAgIHJldHVybiB0aGlzLl9iYWlsO1xcbiAgfVxcbiAgZGVidWcoJ2JhaWwgJXMnLCBiYWlsKTtcXG4gIHRoaXMuX2JhaWwgPSBiYWlsO1xcbiAgcmV0dXJuIHRoaXM7XFxufTtcXG5cXG4vKipcXG4gKiBDaGVjayBpZiB0aGlzIHN1aXRlIG9yIGl0cyBwYXJlbnQgc3VpdGUgaXMgbWFya2VkIGFzIHBlbmRpbmcuXFxuICpcXG4gKiBAYXBpIHByaXZhdGVcXG4gKi9cXG5TdWl0ZS5wcm90b3R5cGUuaXNQZW5kaW5nID0gZnVuY3Rpb24gKCkge1xcbiAgcmV0dXJuIHRoaXMucGVuZGluZyB8fCAodGhpcy5wYXJlbnQgJiYgdGhpcy5wYXJlbnQuaXNQZW5kaW5nKCkpO1xcbn07XFxuXFxuLyoqXFxuICogUnVuIGBmbih0ZXN0WywgZG9uZV0pYCBiZWZvcmUgcnVubmluZyB0ZXN0cy5cXG4gKlxcbiAqIEBhcGkgcHJpdmF0ZVxcbiAqIEBwYXJhbSB7c3RyaW5nfSB0aXRsZVxcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXFxuICogQHJldHVybiB7U3VpdGV9IGZvciBjaGFpbmluZ1xcbiAqL1xcblN1aXRlLnByb3RvdHlwZS5iZWZvcmVBbGwgPSBmdW5jdGlvbiAodGl0bGUsIGZuKSB7XFxuICBpZiAodGhpcy5pc1BlbmRpbmcoKSkge1xcbiAgICByZXR1cm4gdGhpcztcXG4gIH1cXG4gIGlmICh0eXBlb2YgdGl0bGUgPT09ICdmdW5jdGlvbicpIHtcXG4gICAgZm4gPSB0aXRsZTtcXG4gICAgdGl0bGUgPSBmbi5uYW1lO1xcbiAgfVxcbiAgdGl0bGUgPSAnXFxcImJlZm9yZSBhbGxcXFwiIGhvb2snICsgKHRpdGxlID8gJzogJyArIHRpdGxlIDogJycpO1xcblxcbiAgdmFyIGhvb2sgPSBuZXcgSG9vayh0aXRsZSwgZm4pO1xcbiAgaG9vay5wYXJlbnQgPSB0aGlzO1xcbiAgaG9vay50aW1lb3V0KHRoaXMudGltZW91dCgpKTtcXG4gIGhvb2sucmV0cmllcyh0aGlzLnJldHJpZXMoKSk7XFxuICBob29rLmVuYWJsZVRpbWVvdXRzKHRoaXMuZW5hYmxlVGltZW91dHMoKSk7XFxuICBob29rLnNsb3codGhpcy5zbG93KCkpO1xcbiAgaG9vay5jdHggPSB0aGlzLmN0eDtcXG4gIHRoaXMuX2JlZm9yZUFsbC5wdXNoKGhvb2spO1xcbiAgdGhpcy5lbWl0KCdiZWZvcmVBbGwnLCBob29rKTtcXG4gIHJldHVybiB0aGlzO1xcbn07XFxuXFxuLyoqXFxuICogUnVuIGBmbih0ZXN0WywgZG9uZV0pYCBhZnRlciBydW5uaW5nIHRlc3RzLlxcbiAqXFxuICogQGFwaSBwcml2YXRlXFxuICogQHBhcmFtIHtzdHJpbmd9IHRpdGxlXFxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cXG4gKiBAcmV0dXJuIHtTdWl0ZX0gZm9yIGNoYWluaW5nXFxuICovXFxuU3VpdGUucHJvdG90eXBlLmFmdGVyQWxsID0gZnVuY3Rpb24gKHRpdGxlLCBmbikge1xcbiAgaWYgKHRoaXMuaXNQZW5kaW5nKCkpIHtcXG4gICAgcmV0dXJuIHRoaXM7XFxuICB9XFxuICBpZiAodHlwZW9mIHRpdGxlID09PSAnZnVuY3Rpb24nKSB7XFxuICAgIGZuID0gdGl0bGU7XFxuICAgIHRpdGxlID0gZm4ubmFtZTtcXG4gIH1cXG4gIHRpdGxlID0gJ1xcXCJhZnRlciBhbGxcXFwiIGhvb2snICsgKHRpdGxlID8gJzogJyArIHRpdGxlIDogJycpO1xcblxcbiAgdmFyIGhvb2sgPSBuZXcgSG9vayh0aXRsZSwgZm4pO1xcbiAgaG9vay5wYXJlbnQgPSB0aGlzO1xcbiAgaG9vay50aW1lb3V0KHRoaXMudGltZW91dCgpKTtcXG4gIGhvb2sucmV0cmllcyh0aGlzLnJldHJpZXMoKSk7XFxuICBob29rLmVuYWJsZVRpbWVvdXRzKHRoaXMuZW5hYmxlVGltZW91dHMoKSk7XFxuICBob29rLnNsb3codGhpcy5zbG93KCkpO1xcbiAgaG9vay5jdHggPSB0aGlzLmN0eDtcXG4gIHRoaXMuX2FmdGVyQWxsLnB1c2goaG9vayk7XFxuICB0aGlzLmVtaXQoJ2FmdGVyQWxsJywgaG9vayk7XFxuICByZXR1cm4gdGhpcztcXG59O1xcblxcbi8qKlxcbiAqIFJ1biBgZm4odGVzdFssIGRvbmVdKWAgYmVmb3JlIGVhY2ggdGVzdCBjYXNlLlxcbiAqXFxuICogQGFwaSBwcml2YXRlXFxuICogQHBhcmFtIHtzdHJpbmd9IHRpdGxlXFxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cXG4gKiBAcmV0dXJuIHtTdWl0ZX0gZm9yIGNoYWluaW5nXFxuICovXFxuU3VpdGUucHJvdG90eXBlLmJlZm9yZUVhY2ggPSBmdW5jdGlvbiAodGl0bGUsIGZuKSB7XFxuICBpZiAodGhpcy5pc1BlbmRpbmcoKSkge1xcbiAgICByZXR1cm4gdGhpcztcXG4gIH1cXG4gIGlmICh0eXBlb2YgdGl0bGUgPT09ICdmdW5jdGlvbicpIHtcXG4gICAgZm4gPSB0aXRsZTtcXG4gICAgdGl0bGUgPSBmbi5uYW1lO1xcbiAgfVxcbiAgdGl0bGUgPSAnXFxcImJlZm9yZSBlYWNoXFxcIiBob29rJyArICh0aXRsZSA/ICc6ICcgKyB0aXRsZSA6ICcnKTtcXG5cXG4gIHZhciBob29rID0gbmV3IEhvb2sodGl0bGUsIGZuKTtcXG4gIGhvb2sucGFyZW50ID0gdGhpcztcXG4gIGhvb2sudGltZW91dCh0aGlzLnRpbWVvdXQoKSk7XFxuICBob29rLnJldHJpZXModGhpcy5yZXRyaWVzKCkpO1xcbiAgaG9vay5lbmFibGVUaW1lb3V0cyh0aGlzLmVuYWJsZVRpbWVvdXRzKCkpO1xcbiAgaG9vay5zbG93KHRoaXMuc2xvdygpKTtcXG4gIGhvb2suY3R4ID0gdGhpcy5jdHg7XFxuICB0aGlzLl9iZWZvcmVFYWNoLnB1c2goaG9vayk7XFxuICB0aGlzLmVtaXQoJ2JlZm9yZUVhY2gnLCBob29rKTtcXG4gIHJldHVybiB0aGlzO1xcbn07XFxuXFxuLyoqXFxuICogUnVuIGBmbih0ZXN0WywgZG9uZV0pYCBhZnRlciBlYWNoIHRlc3QgY2FzZS5cXG4gKlxcbiAqIEBhcGkgcHJpdmF0ZVxcbiAqIEBwYXJhbSB7c3RyaW5nfSB0aXRsZVxcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXFxuICogQHJldHVybiB7U3VpdGV9IGZvciBjaGFpbmluZ1xcbiAqL1xcblN1aXRlLnByb3RvdHlwZS5hZnRlckVhY2ggPSBmdW5jdGlvbiAodGl0bGUsIGZuKSB7XFxuICBpZiAodGhpcy5pc1BlbmRpbmcoKSkge1xcbiAgICByZXR1cm4gdGhpcztcXG4gIH1cXG4gIGlmICh0eXBlb2YgdGl0bGUgPT09ICdmdW5jdGlvbicpIHtcXG4gICAgZm4gPSB0aXRsZTtcXG4gICAgdGl0bGUgPSBmbi5uYW1lO1xcbiAgfVxcbiAgdGl0bGUgPSAnXFxcImFmdGVyIGVhY2hcXFwiIGhvb2snICsgKHRpdGxlID8gJzogJyArIHRpdGxlIDogJycpO1xcblxcbiAgdmFyIGhvb2sgPSBuZXcgSG9vayh0aXRsZSwgZm4pO1xcbiAgaG9vay5wYXJlbnQgPSB0aGlzO1xcbiAgaG9vay50aW1lb3V0KHRoaXMudGltZW91dCgpKTtcXG4gIGhvb2sucmV0cmllcyh0aGlzLnJldHJpZXMoKSk7XFxuICBob29rLmVuYWJsZVRpbWVvdXRzKHRoaXMuZW5hYmxlVGltZW91dHMoKSk7XFxuICBob29rLnNsb3codGhpcy5zbG93KCkpO1xcbiAgaG9vay5jdHggPSB0aGlzLmN0eDtcXG4gIHRoaXMuX2FmdGVyRWFjaC5wdXNoKGhvb2spO1xcbiAgdGhpcy5lbWl0KCdhZnRlckVhY2gnLCBob29rKTtcXG4gIHJldHVybiB0aGlzO1xcbn07XFxuXFxuLyoqXFxuICogQWRkIGEgdGVzdCBgc3VpdGVgLlxcbiAqXFxuICogQGFwaSBwcml2YXRlXFxuICogQHBhcmFtIHtTdWl0ZX0gc3VpdGVcXG4gKiBAcmV0dXJuIHtTdWl0ZX0gZm9yIGNoYWluaW5nXFxuICovXFxuU3VpdGUucHJvdG90eXBlLmFkZFN1aXRlID0gZnVuY3Rpb24gKHN1aXRlKSB7XFxuICBzdWl0ZS5wYXJlbnQgPSB0aGlzO1xcbiAgc3VpdGUudGltZW91dCh0aGlzLnRpbWVvdXQoKSk7XFxuICBzdWl0ZS5yZXRyaWVzKHRoaXMucmV0cmllcygpKTtcXG4gIHN1aXRlLmVuYWJsZVRpbWVvdXRzKHRoaXMuZW5hYmxlVGltZW91dHMoKSk7XFxuICBzdWl0ZS5zbG93KHRoaXMuc2xvdygpKTtcXG4gIHN1aXRlLmJhaWwodGhpcy5iYWlsKCkpO1xcbiAgdGhpcy5zdWl0ZXMucHVzaChzdWl0ZSk7XFxuICB0aGlzLmVtaXQoJ3N1aXRlJywgc3VpdGUpO1xcbiAgcmV0dXJuIHRoaXM7XFxufTtcXG5cXG4vKipcXG4gKiBBZGQgYSBgdGVzdGAgdG8gdGhpcyBzdWl0ZS5cXG4gKlxcbiAqIEBhcGkgcHJpdmF0ZVxcbiAqIEBwYXJhbSB7VGVzdH0gdGVzdFxcbiAqIEByZXR1cm4ge1N1aXRlfSBmb3IgY2hhaW5pbmdcXG4gKi9cXG5TdWl0ZS5wcm90b3R5cGUuYWRkVGVzdCA9IGZ1bmN0aW9uICh0ZXN0KSB7XFxuICB0ZXN0LnBhcmVudCA9IHRoaXM7XFxuICB0ZXN0LnRpbWVvdXQodGhpcy50aW1lb3V0KCkpO1xcbiAgdGVzdC5yZXRyaWVzKHRoaXMucmV0cmllcygpKTtcXG4gIHRlc3QuZW5hYmxlVGltZW91dHModGhpcy5lbmFibGVUaW1lb3V0cygpKTtcXG4gIHRlc3Quc2xvdyh0aGlzLnNsb3coKSk7XFxuICB0ZXN0LmN0eCA9IHRoaXMuY3R4O1xcbiAgdGhpcy50ZXN0cy5wdXNoKHRlc3QpO1xcbiAgdGhpcy5lbWl0KCd0ZXN0JywgdGVzdCk7XFxuICByZXR1cm4gdGhpcztcXG59O1xcblxcbi8qKlxcbiAqIFJldHVybiB0aGUgZnVsbCB0aXRsZSBnZW5lcmF0ZWQgYnkgcmVjdXJzaXZlbHkgY29uY2F0ZW5hdGluZyB0aGUgcGFyZW50J3NcXG4gKiBmdWxsIHRpdGxlLlxcbiAqXFxuICogQGFwaSBwdWJsaWNcXG4gKiBAcmV0dXJuIHtzdHJpbmd9XFxuICovXFxuU3VpdGUucHJvdG90eXBlLmZ1bGxUaXRsZSA9IGZ1bmN0aW9uICgpIHtcXG4gIGlmICh0aGlzLnBhcmVudCkge1xcbiAgICB2YXIgZnVsbCA9IHRoaXMucGFyZW50LmZ1bGxUaXRsZSgpO1xcbiAgICBpZiAoZnVsbCkge1xcbiAgICAgIHJldHVybiBmdWxsICsgJyAnICsgdGhpcy50aXRsZTtcXG4gICAgfVxcbiAgfVxcbiAgcmV0dXJuIHRoaXMudGl0bGU7XFxufTtcXG5cXG4vKipcXG4gKiBSZXR1cm4gdGhlIHRvdGFsIG51bWJlciBvZiB0ZXN0cy5cXG4gKlxcbiAqIEBhcGkgcHVibGljXFxuICogQHJldHVybiB7bnVtYmVyfVxcbiAqL1xcblN1aXRlLnByb3RvdHlwZS50b3RhbCA9IGZ1bmN0aW9uICgpIHtcXG4gIHJldHVybiB1dGlscy5yZWR1Y2UodGhpcy5zdWl0ZXMsIGZ1bmN0aW9uIChzdW0sIHN1aXRlKSB7XFxuICAgIHJldHVybiBzdW0gKyBzdWl0ZS50b3RhbCgpO1xcbiAgfSwgMCkgKyB0aGlzLnRlc3RzLmxlbmd0aDtcXG59O1xcblxcbi8qKlxcbiAqIEl0ZXJhdGVzIHRocm91Z2ggZWFjaCBzdWl0ZSByZWN1cnNpdmVseSB0byBmaW5kIGFsbCB0ZXN0cy4gQXBwbGllcyBhXFxuICogZnVuY3Rpb24gaW4gdGhlIGZvcm1hdCBgZm4odGVzdClgLlxcbiAqXFxuICogQGFwaSBwcml2YXRlXFxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cXG4gKiBAcmV0dXJuIHtTdWl0ZX1cXG4gKi9cXG5TdWl0ZS5wcm90b3R5cGUuZWFjaFRlc3QgPSBmdW5jdGlvbiAoZm4pIHtcXG4gIHV0aWxzLmZvckVhY2godGhpcy50ZXN0cywgZm4pO1xcbiAgdXRpbHMuZm9yRWFjaCh0aGlzLnN1aXRlcywgZnVuY3Rpb24gKHN1aXRlKSB7XFxuICAgIHN1aXRlLmVhY2hUZXN0KGZuKTtcXG4gIH0pO1xcbiAgcmV0dXJuIHRoaXM7XFxufTtcXG5cXG4vKipcXG4gKiBUaGlzIHdpbGwgcnVuIHRoZSByb290IHN1aXRlIGlmIHdlIGhhcHBlbiB0byBiZSBydW5uaW5nIGluIGRlbGF5ZWQgbW9kZS5cXG4gKi9cXG5TdWl0ZS5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gcnVuICgpIHtcXG4gIGlmICh0aGlzLnJvb3QpIHtcXG4gICAgdGhpcy5lbWl0KCdydW4nKTtcXG4gIH1cXG59O1xcblxcbn0se1xcXCIuL2hvb2tcXFwiOjcsXFxcIi4vbXNcXFwiOjE1LFxcXCIuL3V0aWxzXFxcIjozOCxcXFwiZGVidWdcXFwiOjIsXFxcImV2ZW50c1xcXCI6M31dLDM2OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcXG4ndXNlIHN0cmljdCc7XFxuXFxuLyoqXFxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cXG4gKi9cXG5cXG52YXIgUnVubmFibGUgPSByZXF1aXJlKCcuL3J1bm5hYmxlJyk7XFxudmFyIGNyZWF0ZSA9IHJlcXVpcmUoJ2xvZGFzaC5jcmVhdGUnKTtcXG52YXIgaXNTdHJpbmcgPSByZXF1aXJlKCcuL3V0aWxzJykuaXNTdHJpbmc7XFxuXFxuLyoqXFxuICogRXhwb3NlIGBUZXN0YC5cXG4gKi9cXG5cXG5tb2R1bGUuZXhwb3J0cyA9IFRlc3Q7XFxuXFxuLyoqXFxuICogSW5pdGlhbGl6ZSBhIG5ldyBgVGVzdGAgd2l0aCB0aGUgZ2l2ZW4gYHRpdGxlYCBhbmQgY2FsbGJhY2sgYGZuYC5cXG4gKlxcbiAqIEBhcGkgcHJpdmF0ZVxcbiAqIEBwYXJhbSB7U3RyaW5nfSB0aXRsZVxcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXFxuICovXFxuZnVuY3Rpb24gVGVzdCAodGl0bGUsIGZuKSB7XFxuICBpZiAoIWlzU3RyaW5nKHRpdGxlKSkge1xcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1Rlc3QgYHRpdGxlYCBzaG91bGQgYmUgYSBcXFwic3RyaW5nXFxcIiBidXQgXFxcIicgKyB0eXBlb2YgdGl0bGUgKyAnXFxcIiB3YXMgZ2l2ZW4gaW5zdGVhZC4nKTtcXG4gIH1cXG4gIFJ1bm5hYmxlLmNhbGwodGhpcywgdGl0bGUsIGZuKTtcXG4gIHRoaXMucGVuZGluZyA9ICFmbjtcXG4gIHRoaXMudHlwZSA9ICd0ZXN0JztcXG59XFxuXFxuLyoqXFxuICogSW5oZXJpdCBmcm9tIGBSdW5uYWJsZS5wcm90b3R5cGVgLlxcbiAqL1xcblRlc3QucHJvdG90eXBlID0gY3JlYXRlKFJ1bm5hYmxlLnByb3RvdHlwZSwge1xcbiAgY29uc3RydWN0b3I6IFRlc3RcXG59KTtcXG5cXG5UZXN0LnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uICgpIHtcXG4gIHZhciB0ZXN0ID0gbmV3IFRlc3QodGhpcy50aXRsZSwgdGhpcy5mbik7XFxuICB0ZXN0LnRpbWVvdXQodGhpcy50aW1lb3V0KCkpO1xcbiAgdGVzdC5zbG93KHRoaXMuc2xvdygpKTtcXG4gIHRlc3QuZW5hYmxlVGltZW91dHModGhpcy5lbmFibGVUaW1lb3V0cygpKTtcXG4gIHRlc3QucmV0cmllcyh0aGlzLnJldHJpZXMoKSk7XFxuICB0ZXN0LmN1cnJlbnRSZXRyeSh0aGlzLmN1cnJlbnRSZXRyeSgpKTtcXG4gIHRlc3QuZ2xvYmFscyh0aGlzLmdsb2JhbHMoKSk7XFxuICB0ZXN0LnBhcmVudCA9IHRoaXMucGFyZW50O1xcbiAgdGVzdC5maWxlID0gdGhpcy5maWxlO1xcbiAgdGVzdC5jdHggPSB0aGlzLmN0eDtcXG4gIHJldHVybiB0ZXN0O1xcbn07XFxuXFxufSx7XFxcIi4vcnVubmFibGVcXFwiOjMzLFxcXCIuL3V0aWxzXFxcIjozOCxcXFwibG9kYXNoLmNyZWF0ZVxcXCI6NzV9XSwzNzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XFxuJ3VzZSBzdHJpY3QnO1xcblxcbi8qKlxcbiAqIFBhZCBhIGBudW1iZXJgIHdpdGggYSB0ZW4ncyBwbGFjZSB6ZXJvLlxcbiAqXFxuICogQHBhcmFtIHtudW1iZXJ9IG51bWJlclxcbiAqIEByZXR1cm4ge3N0cmluZ31cXG4gKi9cXG5mdW5jdGlvbiBwYWQobnVtYmVyKSB7XFxuICB2YXIgbiA9IG51bWJlci50b1N0cmluZygpO1xcbiAgcmV0dXJuIG4ubGVuZ3RoID09PSAxID8gJzAnICsgbiA6IG47XFxufVxcblxcbi8qKlxcbiAqIFR1cm4gYSBgZGF0ZWAgaW50byBhbiBJU08gc3RyaW5nLlxcbiAqXFxuICogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvRGF0ZS90b0lTT1N0cmluZ1xcbiAqXFxuICogQHBhcmFtIHtEYXRlfSBkYXRlXFxuICogQHJldHVybiB7c3RyaW5nfVxcbiAqL1xcbmZ1bmN0aW9uIHRvSVNPU3RyaW5nKGRhdGUpIHtcXG4gIHJldHVybiBkYXRlLmdldFVUQ0Z1bGxZZWFyKClcXG4gICAgKyAnLScgKyBwYWQoZGF0ZS5nZXRVVENNb250aCgpICsgMSlcXG4gICAgKyAnLScgKyBwYWQoZGF0ZS5nZXRVVENEYXRlKCkpXFxuICAgICsgJ1QnICsgcGFkKGRhdGUuZ2V0VVRDSG91cnMoKSlcXG4gICAgKyAnOicgKyBwYWQoZGF0ZS5nZXRVVENNaW51dGVzKCkpXFxuICAgICsgJzonICsgcGFkKGRhdGUuZ2V0VVRDU2Vjb25kcygpKVxcbiAgICArICcuJyArIFN0cmluZygoZGF0ZS5nZXRVVENNaWxsaXNlY29uZHMoKS8xMDAwKS50b0ZpeGVkKDMpKS5zbGljZSgyLCA1KVxcbiAgICArICdaJztcXG59XFxuXFxuLypcXG4gKiBFeHBvcnRzLlxcbiAqL1xcblxcbm1vZHVsZS5leHBvcnRzID0gdG9JU09TdHJpbmc7XFxuXFxufSx7fV0sMzg6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xcbihmdW5jdGlvbiAocHJvY2VzcyxCdWZmZXIpe1xcbid1c2Ugc3RyaWN0JztcXG5cXG4vKiBlc2xpbnQtZW52IGJyb3dzZXIgKi9cXG5cXG4vKipcXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxcbiAqL1xcblxcbnZhciBKU09OID0gcmVxdWlyZSgnanNvbjMnKTtcXG52YXIgYmFzZW5hbWUgPSByZXF1aXJlKCdwYXRoJykuYmFzZW5hbWU7XFxudmFyIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnbW9jaGE6d2F0Y2gnKTtcXG52YXIgZXhpc3RzID0gcmVxdWlyZSgnZnMnKS5leGlzdHNTeW5jIHx8IHJlcXVpcmUoJ3BhdGgnKS5leGlzdHNTeW5jO1xcbnZhciBnbG9iID0gcmVxdWlyZSgnZ2xvYicpO1xcbnZhciBwYXRoID0gcmVxdWlyZSgncGF0aCcpO1xcbnZhciBqb2luID0gcGF0aC5qb2luO1xcbnZhciByZWFkZGlyU3luYyA9IHJlcXVpcmUoJ2ZzJykucmVhZGRpclN5bmM7XFxudmFyIHN0YXRTeW5jID0gcmVxdWlyZSgnZnMnKS5zdGF0U3luYztcXG52YXIgd2F0Y2hGaWxlID0gcmVxdWlyZSgnZnMnKS53YXRjaEZpbGU7XFxudmFyIGxzdGF0U3luYyA9IHJlcXVpcmUoJ2ZzJykubHN0YXRTeW5jO1xcbnZhciB0b0lTT1N0cmluZyA9IHJlcXVpcmUoJy4vdG8taXNvLXN0cmluZycpO1xcbnZhciBoZSA9IHJlcXVpcmUoJ2hlJyk7XFxuXFxuLyoqXFxuICogSWdub3JlZCBkaXJlY3Rvcmllcy5cXG4gKi9cXG5cXG52YXIgaWdub3JlID0gWydub2RlX21vZHVsZXMnLCAnLmdpdCddO1xcblxcbmV4cG9ydHMuaW5oZXJpdHMgPSByZXF1aXJlKCd1dGlsJykuaW5oZXJpdHM7XFxuXFxuLyoqXFxuICogRXNjYXBlIHNwZWNpYWwgY2hhcmFjdGVycyBpbiB0aGUgZ2l2ZW4gc3RyaW5nIG9mIGh0bWwuXFxuICpcXG4gKiBAYXBpIHByaXZhdGVcXG4gKiBAcGFyYW0gIHtzdHJpbmd9IGh0bWxcXG4gKiBAcmV0dXJuIHtzdHJpbmd9XFxuICovXFxuZXhwb3J0cy5lc2NhcGUgPSBmdW5jdGlvbiAoaHRtbCkge1xcbiAgcmV0dXJuIGhlLmVuY29kZShTdHJpbmcoaHRtbCksIHsgdXNlTmFtZWRSZWZlcmVuY2VzOiBmYWxzZSB9KTtcXG59O1xcblxcbi8qKlxcbiAqIEFycmF5I2ZvckVhY2ggKDw9SUU4KVxcbiAqXFxuICogQGFwaSBwcml2YXRlXFxuICogQHBhcmFtIHtBcnJheX0gYXJyXFxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cXG4gKiBAcGFyYW0ge09iamVjdH0gc2NvcGVcXG4gKi9cXG5leHBvcnRzLmZvckVhY2ggPSBmdW5jdGlvbiAoYXJyLCBmbiwgc2NvcGUpIHtcXG4gIGZvciAodmFyIGkgPSAwLCBsID0gYXJyLmxlbmd0aDsgaSA8IGw7IGkrKykge1xcbiAgICBmbi5jYWxsKHNjb3BlLCBhcnJbaV0sIGkpO1xcbiAgfVxcbn07XFxuXFxuLyoqXFxuICogVGVzdCBpZiB0aGUgZ2l2ZW4gb2JqIGlzIHR5cGUgb2Ygc3RyaW5nLlxcbiAqXFxuICogQGFwaSBwcml2YXRlXFxuICogQHBhcmFtIHtPYmplY3R9IG9ialxcbiAqIEByZXR1cm4ge2Jvb2xlYW59XFxuICovXFxuZXhwb3J0cy5pc1N0cmluZyA9IGZ1bmN0aW9uIChvYmopIHtcXG4gIHJldHVybiB0eXBlb2Ygb2JqID09PSAnc3RyaW5nJztcXG59O1xcblxcbi8qKlxcbiAqIEFycmF5I21hcCAoPD1JRTgpXFxuICpcXG4gKiBAYXBpIHByaXZhdGVcXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJcXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxcbiAqIEBwYXJhbSB7T2JqZWN0fSBzY29wZVxcbiAqIEByZXR1cm4ge0FycmF5fVxcbiAqL1xcbmV4cG9ydHMubWFwID0gZnVuY3Rpb24gKGFyciwgZm4sIHNjb3BlKSB7XFxuICB2YXIgcmVzdWx0ID0gW107XFxuICBmb3IgKHZhciBpID0gMCwgbCA9IGFyci5sZW5ndGg7IGkgPCBsOyBpKyspIHtcXG4gICAgcmVzdWx0LnB1c2goZm4uY2FsbChzY29wZSwgYXJyW2ldLCBpLCBhcnIpKTtcXG4gIH1cXG4gIHJldHVybiByZXN1bHQ7XFxufTtcXG5cXG4vKipcXG4gKiBBcnJheSNpbmRleE9mICg8PUlFOClcXG4gKlxcbiAqIEBhcGkgcHJpdmF0ZVxcbiAqIEBwYXJhbSB7QXJyYXl9IGFyclxcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmogdG8gZmluZCBpbmRleCBvZlxcbiAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydFxcbiAqIEByZXR1cm4ge251bWJlcn1cXG4gKi9cXG52YXIgaW5kZXhPZiA9IGV4cG9ydHMuaW5kZXhPZiA9IGZ1bmN0aW9uIChhcnIsIG9iaiwgc3RhcnQpIHtcXG4gIGZvciAodmFyIGkgPSBzdGFydCB8fCAwLCBsID0gYXJyLmxlbmd0aDsgaSA8IGw7IGkrKykge1xcbiAgICBpZiAoYXJyW2ldID09PSBvYmopIHtcXG4gICAgICByZXR1cm4gaTtcXG4gICAgfVxcbiAgfVxcbiAgcmV0dXJuIC0xO1xcbn07XFxuXFxuLyoqXFxuICogQXJyYXkjcmVkdWNlICg8PUlFOClcXG4gKlxcbiAqIEBhcGkgcHJpdmF0ZVxcbiAqIEBwYXJhbSB7QXJyYXl9IGFyclxcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXFxuICogQHBhcmFtIHtPYmplY3R9IHZhbCBJbml0aWFsIHZhbHVlLlxcbiAqIEByZXR1cm4geyp9XFxuICovXFxudmFyIHJlZHVjZSA9IGV4cG9ydHMucmVkdWNlID0gZnVuY3Rpb24gKGFyciwgZm4sIHZhbCkge1xcbiAgdmFyIHJ2YWwgPSB2YWw7XFxuXFxuICBmb3IgKHZhciBpID0gMCwgbCA9IGFyci5sZW5ndGg7IGkgPCBsOyBpKyspIHtcXG4gICAgcnZhbCA9IGZuKHJ2YWwsIGFycltpXSwgaSwgYXJyKTtcXG4gIH1cXG5cXG4gIHJldHVybiBydmFsO1xcbn07XFxuXFxuLyoqXFxuICogQXJyYXkjZmlsdGVyICg8PUlFOClcXG4gKlxcbiAqIEBhcGkgcHJpdmF0ZVxcbiAqIEBwYXJhbSB7QXJyYXl9IGFyclxcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXFxuICogQHJldHVybiB7QXJyYXl9XFxuICovXFxuZXhwb3J0cy5maWx0ZXIgPSBmdW5jdGlvbiAoYXJyLCBmbikge1xcbiAgdmFyIHJldCA9IFtdO1xcblxcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBhcnIubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XFxuICAgIHZhciB2YWwgPSBhcnJbaV07XFxuICAgIGlmIChmbih2YWwsIGksIGFycikpIHtcXG4gICAgICByZXQucHVzaCh2YWwpO1xcbiAgICB9XFxuICB9XFxuXFxuICByZXR1cm4gcmV0O1xcbn07XFxuXFxuLyoqXFxuICogQXJyYXkjc29tZSAoPD1JRTgpXFxuICpcXG4gKiBAYXBpIHByaXZhdGVcXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJcXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxcbiAqIEByZXR1cm4ge0FycmF5fVxcbiAqL1xcbmV4cG9ydHMuc29tZSA9IGZ1bmN0aW9uIChhcnIsIGZuKSB7XFxuICBmb3IgKHZhciBpID0gMCwgbCA9IGFyci5sZW5ndGg7IGkgPCBsOyBpKyspIHtcXG4gICAgaWYgKGZuKGFycltpXSkpIHtcXG4gICAgICByZXR1cm4gdHJ1ZTtcXG4gICAgfVxcbiAgfVxcbiAgcmV0dXJuIGZhbHNlO1xcbn07XFxuXFxuLyoqXFxuICogT2JqZWN0LmtleXMgKDw9SUU4KVxcbiAqXFxuICogQGFwaSBwcml2YXRlXFxuICogQHBhcmFtIHtPYmplY3R9IG9ialxcbiAqIEByZXR1cm4ge0FycmF5fSBrZXlzXFxuICovXFxuZXhwb3J0cy5rZXlzID0gdHlwZW9mIE9iamVjdC5rZXlzID09PSAnZnVuY3Rpb24nID8gT2JqZWN0LmtleXMgOiBmdW5jdGlvbiAob2JqKSB7XFxuICB2YXIga2V5cyA9IFtdO1xcbiAgdmFyIGhhcyA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7IC8vIGZvciBgd2luZG93YCBvbiA8PUlFOFxcblxcbiAgZm9yICh2YXIga2V5IGluIG9iaikge1xcbiAgICBpZiAoaGFzLmNhbGwob2JqLCBrZXkpKSB7XFxuICAgICAga2V5cy5wdXNoKGtleSk7XFxuICAgIH1cXG4gIH1cXG5cXG4gIHJldHVybiBrZXlzO1xcbn07XFxuXFxuLyoqXFxuICogV2F0Y2ggdGhlIGdpdmVuIGBmaWxlc2AgZm9yIGNoYW5nZXNcXG4gKiBhbmQgaW52b2tlIGBmbihmaWxlKWAgb24gbW9kaWZpY2F0aW9uLlxcbiAqXFxuICogQGFwaSBwcml2YXRlXFxuICogQHBhcmFtIHtBcnJheX0gZmlsZXNcXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxcbiAqL1xcbmV4cG9ydHMud2F0Y2ggPSBmdW5jdGlvbiAoZmlsZXMsIGZuKSB7XFxuICB2YXIgb3B0aW9ucyA9IHsgaW50ZXJ2YWw6IDEwMCB9O1xcbiAgZmlsZXMuZm9yRWFjaChmdW5jdGlvbiAoZmlsZSkge1xcbiAgICBkZWJ1ZygnZmlsZSAlcycsIGZpbGUpO1xcbiAgICB3YXRjaEZpbGUoZmlsZSwgb3B0aW9ucywgZnVuY3Rpb24gKGN1cnIsIHByZXYpIHtcXG4gICAgICBpZiAocHJldi5tdGltZSA8IGN1cnIubXRpbWUpIHtcXG4gICAgICAgIGZuKGZpbGUpO1xcbiAgICAgIH1cXG4gICAgfSk7XFxuICB9KTtcXG59O1xcblxcbi8qKlxcbiAqIEFycmF5LmlzQXJyYXkgKDw9SUU4KVxcbiAqXFxuICogQGFwaSBwcml2YXRlXFxuICogQHBhcmFtIHtPYmplY3R9IG9ialxcbiAqIEByZXR1cm4ge0Jvb2xlYW59XFxuICovXFxudmFyIGlzQXJyYXkgPSB0eXBlb2YgQXJyYXkuaXNBcnJheSA9PT0gJ2Z1bmN0aW9uJyA/IEFycmF5LmlzQXJyYXkgOiBmdW5jdGlvbiAob2JqKSB7XFxuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iaikgPT09ICdbb2JqZWN0IEFycmF5XSc7XFxufTtcXG5cXG5leHBvcnRzLmlzQXJyYXkgPSBpc0FycmF5O1xcblxcbi8qKlxcbiAqIEJ1ZmZlci5wcm90b3R5cGUudG9KU09OIHBvbHlmaWxsLlxcbiAqXFxuICogQHR5cGUge0Z1bmN0aW9ufVxcbiAqL1xcbmlmICh0eXBlb2YgQnVmZmVyICE9PSAndW5kZWZpbmVkJyAmJiBCdWZmZXIucHJvdG90eXBlKSB7XFxuICBCdWZmZXIucHJvdG90eXBlLnRvSlNPTiA9IEJ1ZmZlci5wcm90b3R5cGUudG9KU09OIHx8IGZ1bmN0aW9uICgpIHtcXG4gICAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKHRoaXMsIDApO1xcbiAgfTtcXG59XFxuXFxuLyoqXFxuICogSWdub3JlZCBmaWxlcy5cXG4gKlxcbiAqIEBhcGkgcHJpdmF0ZVxcbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoXFxuICogQHJldHVybiB7Ym9vbGVhbn1cXG4gKi9cXG5mdW5jdGlvbiBpZ25vcmVkIChwYXRoKSB7XFxuICByZXR1cm4gIX5pZ25vcmUuaW5kZXhPZihwYXRoKTtcXG59XFxuXFxuLyoqXFxuICogTG9va3VwIGZpbGVzIGluIHRoZSBnaXZlbiBgZGlyYC5cXG4gKlxcbiAqIEBhcGkgcHJpdmF0ZVxcbiAqIEBwYXJhbSB7c3RyaW5nfSBkaXJcXG4gKiBAcGFyYW0ge3N0cmluZ1tdfSBbZXh0PVsnLmpzJ11dXFxuICogQHBhcmFtIHtBcnJheX0gW3JldD1bXV1cXG4gKiBAcmV0dXJuIHtBcnJheX1cXG4gKi9cXG5leHBvcnRzLmZpbGVzID0gZnVuY3Rpb24gKGRpciwgZXh0LCByZXQpIHtcXG4gIHJldCA9IHJldCB8fCBbXTtcXG4gIGV4dCA9IGV4dCB8fCBbJ2pzJ107XFxuXFxuICB2YXIgcmUgPSBuZXcgUmVnRXhwKCdcXFxcXFxcXC4oJyArIGV4dC5qb2luKCd8JykgKyAnKSQnKTtcXG5cXG4gIHJlYWRkaXJTeW5jKGRpcilcXG4gICAgLmZpbHRlcihpZ25vcmVkKVxcbiAgICAuZm9yRWFjaChmdW5jdGlvbiAocGF0aCkge1xcbiAgICAgIHBhdGggPSBqb2luKGRpciwgcGF0aCk7XFxuICAgICAgaWYgKGxzdGF0U3luYyhwYXRoKS5pc0RpcmVjdG9yeSgpKSB7XFxuICAgICAgICBleHBvcnRzLmZpbGVzKHBhdGgsIGV4dCwgcmV0KTtcXG4gICAgICB9IGVsc2UgaWYgKHBhdGgubWF0Y2gocmUpKSB7XFxuICAgICAgICByZXQucHVzaChwYXRoKTtcXG4gICAgICB9XFxuICAgIH0pO1xcblxcbiAgcmV0dXJuIHJldDtcXG59O1xcblxcbi8qKlxcbiAqIENvbXB1dGUgYSBzbHVnIGZyb20gdGhlIGdpdmVuIGBzdHJgLlxcbiAqXFxuICogQGFwaSBwcml2YXRlXFxuICogQHBhcmFtIHtzdHJpbmd9IHN0clxcbiAqIEByZXR1cm4ge3N0cmluZ31cXG4gKi9cXG5leHBvcnRzLnNsdWcgPSBmdW5jdGlvbiAoc3RyKSB7XFxuICByZXR1cm4gc3RyXFxuICAgIC50b0xvd2VyQ2FzZSgpXFxuICAgIC5yZXBsYWNlKC8gKy9nLCAnLScpXFxuICAgIC5yZXBsYWNlKC9bXi1cXFxcd10vZywgJycpO1xcbn07XFxuXFxuLyoqXFxuICogU3RyaXAgdGhlIGZ1bmN0aW9uIGRlZmluaXRpb24gZnJvbSBgc3RyYCwgYW5kIHJlLWluZGVudCBmb3IgcHJlIHdoaXRlc3BhY2UuXFxuICpcXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyXFxuICogQHJldHVybiB7c3RyaW5nfVxcbiAqL1xcbmV4cG9ydHMuY2xlYW4gPSBmdW5jdGlvbiAoc3RyKSB7XFxuICBzdHIgPSBzdHJcXG4gICAgLnJlcGxhY2UoL1xcXFxyXFxcXG4/fFtcXFxcblxcXFx1MjAyOFxcXFx1MjAyOV0vZywgJ1xcXFxuJykucmVwbGFjZSgvXlxcXFx1RkVGRi8sICcnKVxcbiAgICAvLyAodHJhZGl0aW9uYWwpLT4gIHNwYWNlL25hbWUgICAgIHBhcmFtZXRlcnMgICAgYm9keSAgICAgKGxhbWJkYSktPiBwYXJhbWV0ZXJzICAgICAgIGJvZHkgICBtdWx0aS1zdGF0ZW1lbnQvc2luZ2xlICAgICAgICAgIGtlZXAgYm9keSBjb250ZW50XFxuICAgIC5yZXBsYWNlKC9eZnVuY3Rpb24oPzpcXFxccyp8XFxcXHMrW14oXSopXFxcXChbXildKlxcXFwpXFxcXHMqXFxcXHsoKD86LnxcXFxcbikqPylcXFxccypcXFxcfSR8XlxcXFwoW14pXSpcXFxcKVxcXFxzKj0+XFxcXHMqKD86XFxcXHsoKD86LnxcXFxcbikqPylcXFxccypcXFxcfXwoKD86LnxcXFxcbikqKSkkLywgJyQxJDIkMycpO1xcblxcbiAgdmFyIHNwYWNlcyA9IHN0ci5tYXRjaCgvXlxcXFxuPyggKikvKVsxXS5sZW5ndGg7XFxuICB2YXIgdGFicyA9IHN0ci5tYXRjaCgvXlxcXFxuPyhcXFxcdCopLylbMV0ubGVuZ3RoO1xcbiAgdmFyIHJlID0gbmV3IFJlZ0V4cCgnXlxcXFxuPycgKyAodGFicyA/ICdcXFxcdCcgOiAnICcpICsgJ3snICsgKHRhYnMgfHwgc3BhY2VzKSArICd9JywgJ2dtJyk7XFxuXFxuICBzdHIgPSBzdHIucmVwbGFjZShyZSwgJycpO1xcblxcbiAgcmV0dXJuIGV4cG9ydHMudHJpbShzdHIpO1xcbn07XFxuXFxuLyoqXFxuICogVHJpbSB0aGUgZ2l2ZW4gYHN0cmAuXFxuICpcXG4gKiBAYXBpIHByaXZhdGVcXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyXFxuICogQHJldHVybiB7c3RyaW5nfVxcbiAqL1xcbmV4cG9ydHMudHJpbSA9IGZ1bmN0aW9uIChzdHIpIHtcXG4gIHJldHVybiBzdHIucmVwbGFjZSgvXlxcXFxzK3xcXFxccyskL2csICcnKTtcXG59O1xcblxcbi8qKlxcbiAqIFBhcnNlIHRoZSBnaXZlbiBgcXNgLlxcbiAqXFxuICogQGFwaSBwcml2YXRlXFxuICogQHBhcmFtIHtzdHJpbmd9IHFzXFxuICogQHJldHVybiB7T2JqZWN0fVxcbiAqL1xcbmV4cG9ydHMucGFyc2VRdWVyeSA9IGZ1bmN0aW9uIChxcykge1xcbiAgcmV0dXJuIHJlZHVjZShxcy5yZXBsYWNlKCc/JywgJycpLnNwbGl0KCcmJyksIGZ1bmN0aW9uIChvYmosIHBhaXIpIHtcXG4gICAgdmFyIGkgPSBwYWlyLmluZGV4T2YoJz0nKTtcXG4gICAgdmFyIGtleSA9IHBhaXIuc2xpY2UoMCwgaSk7XFxuICAgIHZhciB2YWwgPSBwYWlyLnNsaWNlKCsraSk7XFxuXFxuICAgIC8vIER1ZSB0byBob3cgdGhlIFVSTFNlYXJjaFBhcmFtcyBBUEkgdHJlYXRzIHNwYWNlc1xcbiAgICBvYmpba2V5XSA9IGRlY29kZVVSSUNvbXBvbmVudCh2YWwucmVwbGFjZSgvXFxcXCsvZywgJyUyMCcpKTtcXG5cXG4gICAgcmV0dXJuIG9iajtcXG4gIH0sIHt9KTtcXG59O1xcblxcbi8qKlxcbiAqIEhpZ2hsaWdodCB0aGUgZ2l2ZW4gc3RyaW5nIG9mIGBqc2AuXFxuICpcXG4gKiBAYXBpIHByaXZhdGVcXG4gKiBAcGFyYW0ge3N0cmluZ30ganNcXG4gKiBAcmV0dXJuIHtzdHJpbmd9XFxuICovXFxuZnVuY3Rpb24gaGlnaGxpZ2h0IChqcykge1xcbiAgcmV0dXJuIGpzXFxuICAgIC5yZXBsYWNlKC88L2csICcmbHQ7JylcXG4gICAgLnJlcGxhY2UoLz4vZywgJyZndDsnKVxcbiAgICAucmVwbGFjZSgvXFxcXC9cXFxcLyguKikvZ20sICc8c3BhbiBjbGFzcz1cXFwiY29tbWVudFxcXCI+Ly8kMTwvc3Bhbj4nKVxcbiAgICAucmVwbGFjZSgvKCcuKj8nKS9nbSwgJzxzcGFuIGNsYXNzPVxcXCJzdHJpbmdcXFwiPiQxPC9zcGFuPicpXFxuICAgIC5yZXBsYWNlKC8oXFxcXGQrXFxcXC5cXFxcZCspL2dtLCAnPHNwYW4gY2xhc3M9XFxcIm51bWJlclxcXCI+JDE8L3NwYW4+JylcXG4gICAgLnJlcGxhY2UoLyhcXFxcZCspL2dtLCAnPHNwYW4gY2xhc3M9XFxcIm51bWJlclxcXCI+JDE8L3NwYW4+JylcXG4gICAgLnJlcGxhY2UoL1xcXFxibmV3WyBcXFxcdF0rKFxcXFx3KykvZ20sICc8c3BhbiBjbGFzcz1cXFwia2V5d29yZFxcXCI+bmV3PC9zcGFuPiA8c3BhbiBjbGFzcz1cXFwiaW5pdFxcXCI+JDE8L3NwYW4+JylcXG4gICAgLnJlcGxhY2UoL1xcXFxiKGZ1bmN0aW9ufG5ld3x0aHJvd3xyZXR1cm58dmFyfGlmfGVsc2UpXFxcXGIvZ20sICc8c3BhbiBjbGFzcz1cXFwia2V5d29yZFxcXCI+JDE8L3NwYW4+Jyk7XFxufVxcblxcbi8qKlxcbiAqIEhpZ2hsaWdodCB0aGUgY29udGVudHMgb2YgdGFnIGBuYW1lYC5cXG4gKlxcbiAqIEBhcGkgcHJpdmF0ZVxcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXFxuICovXFxuZXhwb3J0cy5oaWdobGlnaHRUYWdzID0gZnVuY3Rpb24gKG5hbWUpIHtcXG4gIHZhciBjb2RlID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ21vY2hhJykuZ2V0RWxlbWVudHNCeVRhZ05hbWUobmFtZSk7XFxuICBmb3IgKHZhciBpID0gMCwgbGVuID0gY29kZS5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xcbiAgICBjb2RlW2ldLmlubmVySFRNTCA9IGhpZ2hsaWdodChjb2RlW2ldLmlubmVySFRNTCk7XFxuICB9XFxufTtcXG5cXG4vKipcXG4gKiBJZiBhIHZhbHVlIGNvdWxkIGhhdmUgcHJvcGVydGllcywgYW5kIGhhcyBub25lLCB0aGlzIGZ1bmN0aW9uIGlzIGNhbGxlZCxcXG4gKiB3aGljaCByZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBlbXB0eSB2YWx1ZS5cXG4gKlxcbiAqIEZ1bmN0aW9ucyB3LyBubyBwcm9wZXJ0aWVzIHJldHVybiBgJ1tGdW5jdGlvbl0nYFxcbiAqIEFycmF5cyB3LyBsZW5ndGggPT09IDAgcmV0dXJuIGAnW10nYFxcbiAqIE9iamVjdHMgdy8gbm8gcHJvcGVydGllcyByZXR1cm4gYCd7fSdgXFxuICogQWxsIGVsc2U6IHJldHVybiByZXN1bHQgb2YgYHZhbHVlLnRvU3RyaW5nKClgXFxuICpcXG4gKiBAYXBpIHByaXZhdGVcXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBpbnNwZWN0LlxcbiAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlSGludCBUaGUgdHlwZSBvZiB0aGUgdmFsdWVcXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxcbiAqL1xcbmZ1bmN0aW9uIGVtcHR5UmVwcmVzZW50YXRpb24gKHZhbHVlLCB0eXBlSGludCkge1xcbiAgc3dpdGNoICh0eXBlSGludCkge1xcbiAgICBjYXNlICdmdW5jdGlvbic6XFxuICAgICAgcmV0dXJuICdbRnVuY3Rpb25dJztcXG4gICAgY2FzZSAnb2JqZWN0JzpcXG4gICAgICByZXR1cm4gJ3t9JztcXG4gICAgY2FzZSAnYXJyYXknOlxcbiAgICAgIHJldHVybiAnW10nO1xcbiAgICBkZWZhdWx0OlxcbiAgICAgIHJldHVybiB2YWx1ZS50b1N0cmluZygpO1xcbiAgfVxcbn1cXG5cXG4vKipcXG4gKiBUYWtlcyBzb21lIHZhcmlhYmxlIGFuZCBhc2tzIGBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nKClgIHdoYXQgaXQgdGhpbmtzIGl0XFxuICogaXMuXFxuICpcXG4gKiBAYXBpIHByaXZhdGVcXG4gKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL09iamVjdC90b1N0cmluZ1xcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHRlc3QuXFxuICogQHJldHVybnMge3N0cmluZ30gQ29tcHV0ZWQgdHlwZVxcbiAqIEBleGFtcGxlXFxuICogdHlwZSh7fSkgLy8gJ29iamVjdCdcXG4gKiB0eXBlKFtdKSAvLyAnYXJyYXknXFxuICogdHlwZSgxKSAvLyAnbnVtYmVyJ1xcbiAqIHR5cGUoZmFsc2UpIC8vICdib29sZWFuJ1xcbiAqIHR5cGUoSW5maW5pdHkpIC8vICdudW1iZXInXFxuICogdHlwZShudWxsKSAvLyAnbnVsbCdcXG4gKiB0eXBlKG5ldyBEYXRlKCkpIC8vICdkYXRlJ1xcbiAqIHR5cGUoL2Zvby8pIC8vICdyZWdleHAnXFxuICogdHlwZSgndHlwZScpIC8vICdzdHJpbmcnXFxuICogdHlwZShnbG9iYWwpIC8vICdnbG9iYWwnXFxuICogdHlwZShuZXcgU3RyaW5nKCdmb28nKSAvLyAnb2JqZWN0J1xcbiAqL1xcbnZhciB0eXBlID0gZXhwb3J0cy50eXBlID0gZnVuY3Rpb24gdHlwZSAodmFsdWUpIHtcXG4gIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XFxuICAgIHJldHVybiAndW5kZWZpbmVkJztcXG4gIH0gZWxzZSBpZiAodmFsdWUgPT09IG51bGwpIHtcXG4gICAgcmV0dXJuICdudWxsJztcXG4gIH0gZWxzZSBpZiAodHlwZW9mIEJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcgJiYgQnVmZmVyLmlzQnVmZmVyKHZhbHVlKSkge1xcbiAgICByZXR1cm4gJ2J1ZmZlcic7XFxuICB9XFxuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKVxcbiAgICAucmVwbGFjZSgvXlxcXFxbLitcXFxccyguKz8pXSQvLCAnJDEnKVxcbiAgICAudG9Mb3dlckNhc2UoKTtcXG59O1xcblxcbi8qKlxcbiAqIFN0cmluZ2lmeSBgdmFsdWVgLiBEaWZmZXJlbnQgYmVoYXZpb3IgZGVwZW5kaW5nIG9uIHR5cGUgb2YgdmFsdWU6XFxuICpcXG4gKiAtIElmIGB2YWx1ZWAgaXMgdW5kZWZpbmVkIG9yIG51bGwsIHJldHVybiBgJ1t1bmRlZmluZWRdJ2Agb3IgYCdbbnVsbF0nYCwgcmVzcGVjdGl2ZWx5LlxcbiAqIC0gSWYgYHZhbHVlYCBpcyBub3QgYW4gb2JqZWN0LCBmdW5jdGlvbiBvciBhcnJheSwgcmV0dXJuIHJlc3VsdCBvZiBgdmFsdWUudG9TdHJpbmcoKWAgd3JhcHBlZCBpbiBkb3VibGUtcXVvdGVzLlxcbiAqIC0gSWYgYHZhbHVlYCBpcyBhbiAqZW1wdHkqIG9iamVjdCwgZnVuY3Rpb24sIG9yIGFycmF5LCByZXR1cm4gcmVzdWx0IG9mIGZ1bmN0aW9uXFxuICogICB7QGxpbmsgZW1wdHlSZXByZXNlbnRhdGlvbn0uXFxuICogLSBJZiBgdmFsdWVgIGhhcyBwcm9wZXJ0aWVzLCBjYWxsIHtAbGluayBleHBvcnRzLmNhbm9uaWNhbGl6ZX0gb24gaXQsIHRoZW4gcmV0dXJuIHJlc3VsdCBvZlxcbiAqICAgSlNPTi5zdHJpbmdpZnkoKS5cXG4gKlxcbiAqIEBhcGkgcHJpdmF0ZVxcbiAqIEBzZWUgZXhwb3J0cy50eXBlXFxuICogQHBhcmFtIHsqfSB2YWx1ZVxcbiAqIEByZXR1cm4ge3N0cmluZ31cXG4gKi9cXG5leHBvcnRzLnN0cmluZ2lmeSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xcbiAgdmFyIHR5cGVIaW50ID0gdHlwZSh2YWx1ZSk7XFxuXFxuICBpZiAoIX5pbmRleE9mKFsnb2JqZWN0JywgJ2FycmF5JywgJ2Z1bmN0aW9uJ10sIHR5cGVIaW50KSkge1xcbiAgICBpZiAodHlwZUhpbnQgPT09ICdidWZmZXInKSB7XFxuICAgICAgdmFyIGpzb24gPSB2YWx1ZS50b0pTT04oKTtcXG4gICAgICAvLyBCYXNlZCBvbiB0aGUgdG9KU09OIHJlc3VsdFxcbiAgICAgIHJldHVybiBqc29uU3RyaW5naWZ5KGpzb24uZGF0YSAmJiBqc29uLnR5cGUgPyBqc29uLmRhdGEgOiBqc29uLCAyKVxcbiAgICAgICAgLnJlcGxhY2UoLywoXFxcXG58JCkvZywgJyQxJyk7XFxuICAgIH1cXG5cXG4gICAgLy8gSUU3L0lFOCBoYXMgYSBiaXphcnJlIFN0cmluZyBjb25zdHJ1Y3RvcjsgbmVlZHMgdG8gYmUgY29lcmNlZFxcbiAgICAvLyBpbnRvIGFuIGFycmF5IGFuZCBiYWNrIHRvIG9iai5cXG4gICAgaWYgKHR5cGVIaW50ID09PSAnc3RyaW5nJyAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnKSB7XFxuICAgICAgdmFsdWUgPSByZWR1Y2UodmFsdWUuc3BsaXQoJycpLCBmdW5jdGlvbiAoYWNjLCBjaGFyLCBpZHgpIHtcXG4gICAgICAgIGFjY1tpZHhdID0gY2hhcjtcXG4gICAgICAgIHJldHVybiBhY2M7XFxuICAgICAgfSwge30pO1xcbiAgICAgIHR5cGVIaW50ID0gJ29iamVjdCc7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgcmV0dXJuIGpzb25TdHJpbmdpZnkodmFsdWUpO1xcbiAgICB9XFxuICB9XFxuXFxuICBmb3IgKHZhciBwcm9wIGluIHZhbHVlKSB7XFxuICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodmFsdWUsIHByb3ApKSB7XFxuICAgICAgcmV0dXJuIGpzb25TdHJpbmdpZnkoZXhwb3J0cy5jYW5vbmljYWxpemUodmFsdWUsIG51bGwsIHR5cGVIaW50KSwgMikucmVwbGFjZSgvLChcXFxcbnwkKS9nLCAnJDEnKTtcXG4gICAgfVxcbiAgfVxcblxcbiAgcmV0dXJuIGVtcHR5UmVwcmVzZW50YXRpb24odmFsdWUsIHR5cGVIaW50KTtcXG59O1xcblxcbi8qKlxcbiAqIGxpa2UgSlNPTi5zdHJpbmdpZnkgYnV0IG1vcmUgc2Vuc2UuXFxuICpcXG4gKiBAYXBpIHByaXZhdGVcXG4gKiBAcGFyYW0ge09iamVjdH0gIG9iamVjdFxcbiAqIEBwYXJhbSB7bnVtYmVyPX0gc3BhY2VzXFxuICogQHBhcmFtIHtudW1iZXI9fSBkZXB0aFxcbiAqIEByZXR1cm5zIHsqfVxcbiAqL1xcbmZ1bmN0aW9uIGpzb25TdHJpbmdpZnkgKG9iamVjdCwgc3BhY2VzLCBkZXB0aCkge1xcbiAgaWYgKHR5cGVvZiBzcGFjZXMgPT09ICd1bmRlZmluZWQnKSB7XFxuICAgIC8vIHByaW1pdGl2ZSB0eXBlc1xcbiAgICByZXR1cm4gX3N0cmluZ2lmeShvYmplY3QpO1xcbiAgfVxcblxcbiAgZGVwdGggPSBkZXB0aCB8fCAxO1xcbiAgdmFyIHNwYWNlID0gc3BhY2VzICogZGVwdGg7XFxuICB2YXIgc3RyID0gaXNBcnJheShvYmplY3QpID8gJ1snIDogJ3snO1xcbiAgdmFyIGVuZCA9IGlzQXJyYXkob2JqZWN0KSA/ICddJyA6ICd9JztcXG4gIHZhciBsZW5ndGggPSB0eXBlb2Ygb2JqZWN0Lmxlbmd0aCA9PT0gJ251bWJlcicgPyBvYmplY3QubGVuZ3RoIDogZXhwb3J0cy5rZXlzKG9iamVjdCkubGVuZ3RoO1xcbiAgLy8gYC5yZXBlYXQoKWAgcG9seWZpbGxcXG4gIGZ1bmN0aW9uIHJlcGVhdCAocywgbikge1xcbiAgICByZXR1cm4gbmV3IEFycmF5KG4pLmpvaW4ocyk7XFxuICB9XFxuXFxuICBmdW5jdGlvbiBfc3RyaW5naWZ5ICh2YWwpIHtcXG4gICAgc3dpdGNoICh0eXBlKHZhbCkpIHtcXG4gICAgICBjYXNlICdudWxsJzpcXG4gICAgICBjYXNlICd1bmRlZmluZWQnOlxcbiAgICAgICAgdmFsID0gJ1snICsgdmFsICsgJ10nO1xcbiAgICAgICAgYnJlYWs7XFxuICAgICAgY2FzZSAnYXJyYXknOlxcbiAgICAgIGNhc2UgJ29iamVjdCc6XFxuICAgICAgICB2YWwgPSBqc29uU3RyaW5naWZ5KHZhbCwgc3BhY2VzLCBkZXB0aCArIDEpO1xcbiAgICAgICAgYnJlYWs7XFxuICAgICAgY2FzZSAnYm9vbGVhbic6XFxuICAgICAgY2FzZSAncmVnZXhwJzpcXG4gICAgICBjYXNlICdzeW1ib2wnOlxcbiAgICAgIGNhc2UgJ251bWJlcic6XFxuICAgICAgICB2YWwgPSB2YWwgPT09IDAgJiYgKDEgLyB2YWwpID09PSAtSW5maW5pdHkgLy8gYC0wYFxcbiAgICAgICAgICA/ICctMCdcXG4gICAgICAgICAgOiB2YWwudG9TdHJpbmcoKTtcXG4gICAgICAgIGJyZWFrO1xcbiAgICAgIGNhc2UgJ2RhdGUnOlxcbiAgICAgICAgdmFyIHNEYXRlO1xcbiAgICAgICAgaWYgKGlzTmFOKHZhbC5nZXRUaW1lKCkpKSB7IC8vIEludmFsaWQgZGF0ZVxcbiAgICAgICAgICBzRGF0ZSA9IHZhbC50b1N0cmluZygpO1xcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgc0RhdGUgPSB2YWwudG9JU09TdHJpbmcgPyB2YWwudG9JU09TdHJpbmcoKSA6IHRvSVNPU3RyaW5nKHZhbCk7XFxuICAgICAgICB9XFxuICAgICAgICB2YWwgPSAnW0RhdGU6ICcgKyBzRGF0ZSArICddJztcXG4gICAgICAgIGJyZWFrO1xcbiAgICAgIGNhc2UgJ2J1ZmZlcic6XFxuICAgICAgICB2YXIganNvbiA9IHZhbC50b0pTT04oKTtcXG4gICAgICAgIC8vIEJhc2VkIG9uIHRoZSB0b0pTT04gcmVzdWx0XFxuICAgICAgICBqc29uID0ganNvbi5kYXRhICYmIGpzb24udHlwZSA/IGpzb24uZGF0YSA6IGpzb247XFxuICAgICAgICB2YWwgPSAnW0J1ZmZlcjogJyArIGpzb25TdHJpbmdpZnkoanNvbiwgMiwgZGVwdGggKyAxKSArICddJztcXG4gICAgICAgIGJyZWFrO1xcbiAgICAgIGRlZmF1bHQ6XFxuICAgICAgICB2YWwgPSAodmFsID09PSAnW0Z1bmN0aW9uXScgfHwgdmFsID09PSAnW0NpcmN1bGFyXScpXFxuICAgICAgICAgID8gdmFsXFxuICAgICAgICAgIDogSlNPTi5zdHJpbmdpZnkodmFsKTsgLy8gc3RyaW5nXFxuICAgIH1cXG4gICAgcmV0dXJuIHZhbDtcXG4gIH1cXG5cXG4gIGZvciAodmFyIGkgaW4gb2JqZWN0KSB7XFxuICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgaSkpIHtcXG4gICAgICBjb250aW51ZTsgLy8gbm90IG15IGJ1c2luZXNzXFxuICAgIH1cXG4gICAgLS1sZW5ndGg7XFxuICAgIHN0ciArPSAnXFxcXG4gJyArIHJlcGVhdCgnICcsIHNwYWNlKSArXFxuICAgICAgKGlzQXJyYXkob2JqZWN0KSA/ICcnIDogJ1xcXCInICsgaSArICdcXFwiOiAnKSArIC8vIGtleVxcbiAgICAgIF9zdHJpbmdpZnkob2JqZWN0W2ldKSArICAgICAgICAgICAgICAgICAgICAvLyB2YWx1ZVxcbiAgICAgIChsZW5ndGggPyAnLCcgOiAnJyk7ICAgICAgICAgICAgICAgICAgICAgICAvLyBjb21tYVxcbiAgfVxcblxcbiAgcmV0dXJuIHN0ciArXFxuICAgIC8vIFtdLCB7fVxcbiAgICAoc3RyLmxlbmd0aCAhPT0gMSA/ICdcXFxcbicgKyByZXBlYXQoJyAnLCAtLXNwYWNlKSArIGVuZCA6IGVuZCk7XFxufVxcblxcbi8qKlxcbiAqIFRlc3QgaWYgYSB2YWx1ZSBpcyBhIGJ1ZmZlci5cXG4gKlxcbiAqIEBhcGkgcHJpdmF0ZVxcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHRlc3QuXFxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBgdmFsdWVgIGlzIGEgYnVmZmVyLCBvdGhlcndpc2UgZmFsc2VcXG4gKi9cXG5leHBvcnRzLmlzQnVmZmVyID0gZnVuY3Rpb24gKHZhbHVlKSB7XFxuICByZXR1cm4gdHlwZW9mIEJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcgJiYgQnVmZmVyLmlzQnVmZmVyKHZhbHVlKTtcXG59O1xcblxcbi8qKlxcbiAqIFJldHVybiBhIG5ldyBUaGluZyB0aGF0IGhhcyB0aGUga2V5cyBpbiBzb3J0ZWQgb3JkZXIuIFJlY3Vyc2l2ZS5cXG4gKlxcbiAqIElmIHRoZSBUaGluZy4uLlxcbiAqIC0gaGFzIGFscmVhZHkgYmVlbiBzZWVuLCByZXR1cm4gc3RyaW5nIGAnW0NpcmN1bGFyXSdgXFxuICogLSBpcyBgdW5kZWZpbmVkYCwgcmV0dXJuIHN0cmluZyBgJ1t1bmRlZmluZWRdJ2BcXG4gKiAtIGlzIGBudWxsYCwgcmV0dXJuIHZhbHVlIGBudWxsYFxcbiAqIC0gaXMgc29tZSBvdGhlciBwcmltaXRpdmUsIHJldHVybiB0aGUgdmFsdWVcXG4gKiAtIGlzIG5vdCBhIHByaW1pdGl2ZSBvciBhbiBgQXJyYXlgLCBgT2JqZWN0YCwgb3IgYEZ1bmN0aW9uYCwgcmV0dXJuIHRoZSB2YWx1ZSBvZiB0aGUgVGhpbmcncyBgdG9TdHJpbmcoKWAgbWV0aG9kXFxuICogLSBpcyBhIG5vbi1lbXB0eSBgQXJyYXlgLCBgT2JqZWN0YCwgb3IgYEZ1bmN0aW9uYCwgcmV0dXJuIHRoZSByZXN1bHQgb2YgY2FsbGluZyB0aGlzIGZ1bmN0aW9uIGFnYWluLlxcbiAqIC0gaXMgYW4gZW1wdHkgYEFycmF5YCwgYE9iamVjdGAsIG9yIGBGdW5jdGlvbmAsIHJldHVybiB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGVtcHR5UmVwcmVzZW50YXRpb24oKWBcXG4gKlxcbiAqIEBhcGkgcHJpdmF0ZVxcbiAqIEBzZWUge0BsaW5rIGV4cG9ydHMuc3RyaW5naWZ5fVxcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhpbmcgdG8gaW5zcGVjdC4gIE1heSBvciBtYXkgbm90IGhhdmUgcHJvcGVydGllcy5cXG4gKiBAcGFyYW0ge0FycmF5fSBbc3RhY2s9W11dIFN0YWNrIG9mIHNlZW4gdmFsdWVzXFxuICogQHBhcmFtIHtzdHJpbmd9IFt0eXBlSGludF0gVHlwZSBoaW50XFxuICogQHJldHVybiB7KE9iamVjdHxBcnJheXxGdW5jdGlvbnxzdHJpbmd8dW5kZWZpbmVkKX1cXG4gKi9cXG5leHBvcnRzLmNhbm9uaWNhbGl6ZSA9IGZ1bmN0aW9uIGNhbm9uaWNhbGl6ZSAodmFsdWUsIHN0YWNrLCB0eXBlSGludCkge1xcbiAgdmFyIGNhbm9uaWNhbGl6ZWRPYmo7XFxuICAvKiBlc2xpbnQtZGlzYWJsZSBuby11bnVzZWQtdmFycyAqL1xcbiAgdmFyIHByb3A7XFxuICAvKiBlc2xpbnQtZW5hYmxlIG5vLXVudXNlZC12YXJzICovXFxuICB0eXBlSGludCA9IHR5cGVIaW50IHx8IHR5cGUodmFsdWUpO1xcbiAgZnVuY3Rpb24gd2l0aFN0YWNrICh2YWx1ZSwgZm4pIHtcXG4gICAgc3RhY2sucHVzaCh2YWx1ZSk7XFxuICAgIGZuKCk7XFxuICAgIHN0YWNrLnBvcCgpO1xcbiAgfVxcblxcbiAgc3RhY2sgPSBzdGFjayB8fCBbXTtcXG5cXG4gIGlmIChpbmRleE9mKHN0YWNrLCB2YWx1ZSkgIT09IC0xKSB7XFxuICAgIHJldHVybiAnW0NpcmN1bGFyXSc7XFxuICB9XFxuXFxuICBzd2l0Y2ggKHR5cGVIaW50KSB7XFxuICAgIGNhc2UgJ3VuZGVmaW5lZCc6XFxuICAgIGNhc2UgJ2J1ZmZlcic6XFxuICAgIGNhc2UgJ251bGwnOlxcbiAgICAgIGNhbm9uaWNhbGl6ZWRPYmogPSB2YWx1ZTtcXG4gICAgICBicmVhaztcXG4gICAgY2FzZSAnYXJyYXknOlxcbiAgICAgIHdpdGhTdGFjayh2YWx1ZSwgZnVuY3Rpb24gKCkge1xcbiAgICAgICAgY2Fub25pY2FsaXplZE9iaiA9IGV4cG9ydHMubWFwKHZhbHVlLCBmdW5jdGlvbiAoaXRlbSkge1xcbiAgICAgICAgICByZXR1cm4gZXhwb3J0cy5jYW5vbmljYWxpemUoaXRlbSwgc3RhY2spO1xcbiAgICAgICAgfSk7XFxuICAgICAgfSk7XFxuICAgICAgYnJlYWs7XFxuICAgIGNhc2UgJ2Z1bmN0aW9uJzpcXG4gICAgICAvKiBlc2xpbnQtZGlzYWJsZSBndWFyZC1mb3ItaW4gKi9cXG4gICAgICBmb3IgKHByb3AgaW4gdmFsdWUpIHtcXG4gICAgICAgIGNhbm9uaWNhbGl6ZWRPYmogPSB7fTtcXG4gICAgICAgIGJyZWFrO1xcbiAgICAgIH1cXG4gICAgICAvKiBlc2xpbnQtZW5hYmxlIGd1YXJkLWZvci1pbiAqL1xcbiAgICAgIGlmICghY2Fub25pY2FsaXplZE9iaikge1xcbiAgICAgICAgY2Fub25pY2FsaXplZE9iaiA9IGVtcHR5UmVwcmVzZW50YXRpb24odmFsdWUsIHR5cGVIaW50KTtcXG4gICAgICAgIGJyZWFrO1xcbiAgICAgIH1cXG4gICAgLyogZmFsbHMgdGhyb3VnaCAqL1xcbiAgICBjYXNlICdvYmplY3QnOlxcbiAgICAgIGNhbm9uaWNhbGl6ZWRPYmogPSBjYW5vbmljYWxpemVkT2JqIHx8IHt9O1xcbiAgICAgIHdpdGhTdGFjayh2YWx1ZSwgZnVuY3Rpb24gKCkge1xcbiAgICAgICAgZXhwb3J0cy5mb3JFYWNoKGV4cG9ydHMua2V5cyh2YWx1ZSkuc29ydCgpLCBmdW5jdGlvbiAoa2V5KSB7XFxuICAgICAgICAgIGNhbm9uaWNhbGl6ZWRPYmpba2V5XSA9IGV4cG9ydHMuY2Fub25pY2FsaXplKHZhbHVlW2tleV0sIHN0YWNrKTtcXG4gICAgICAgIH0pO1xcbiAgICAgIH0pO1xcbiAgICAgIGJyZWFrO1xcbiAgICBjYXNlICdkYXRlJzpcXG4gICAgY2FzZSAnbnVtYmVyJzpcXG4gICAgY2FzZSAncmVnZXhwJzpcXG4gICAgY2FzZSAnYm9vbGVhbic6XFxuICAgIGNhc2UgJ3N5bWJvbCc6XFxuICAgICAgY2Fub25pY2FsaXplZE9iaiA9IHZhbHVlO1xcbiAgICAgIGJyZWFrO1xcbiAgICBkZWZhdWx0OlxcbiAgICAgIGNhbm9uaWNhbGl6ZWRPYmogPSB2YWx1ZSArICcnO1xcbiAgfVxcblxcbiAgcmV0dXJuIGNhbm9uaWNhbGl6ZWRPYmo7XFxufTtcXG5cXG4vKipcXG4gKiBMb29rdXAgZmlsZSBuYW1lcyBhdCB0aGUgZ2l2ZW4gYHBhdGhgLlxcbiAqXFxuICogQGFwaSBwdWJsaWNcXG4gKiBAcGFyYW0ge3N0cmluZ30gcGF0aCBCYXNlIHBhdGggdG8gc3RhcnQgc2VhcmNoaW5nIGZyb20uXFxuICogQHBhcmFtIHtzdHJpbmdbXX0gZXh0ZW5zaW9ucyBGaWxlIGV4dGVuc2lvbnMgdG8gbG9vayBmb3IuXFxuICogQHBhcmFtIHtib29sZWFufSByZWN1cnNpdmUgV2hldGhlciBvciBub3QgdG8gcmVjdXJzZSBpbnRvIHN1YmRpcmVjdG9yaWVzLlxcbiAqIEByZXR1cm4ge3N0cmluZ1tdfSBBbiBhcnJheSBvZiBwYXRocy5cXG4gKi9cXG5leHBvcnRzLmxvb2t1cEZpbGVzID0gZnVuY3Rpb24gbG9va3VwRmlsZXMgKHBhdGgsIGV4dGVuc2lvbnMsIHJlY3Vyc2l2ZSkge1xcbiAgdmFyIGZpbGVzID0gW107XFxuICB2YXIgcmUgPSBuZXcgUmVnRXhwKCdcXFxcXFxcXC4oJyArIGV4dGVuc2lvbnMuam9pbignfCcpICsgJykkJyk7XFxuXFxuICBpZiAoIWV4aXN0cyhwYXRoKSkge1xcbiAgICBpZiAoZXhpc3RzKHBhdGggKyAnLmpzJykpIHtcXG4gICAgICBwYXRoICs9ICcuanMnO1xcbiAgICB9IGVsc2Uge1xcbiAgICAgIGZpbGVzID0gZ2xvYi5zeW5jKHBhdGgpO1xcbiAgICAgIGlmICghZmlsZXMubGVuZ3RoKSB7XFxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXFxcImNhbm5vdCByZXNvbHZlIHBhdGggKG9yIHBhdHRlcm4pICdcXFwiICsgcGF0aCArIFxcXCInXFxcIik7XFxuICAgICAgfVxcbiAgICAgIHJldHVybiBmaWxlcztcXG4gICAgfVxcbiAgfVxcblxcbiAgdHJ5IHtcXG4gICAgdmFyIHN0YXQgPSBzdGF0U3luYyhwYXRoKTtcXG4gICAgaWYgKHN0YXQuaXNGaWxlKCkpIHtcXG4gICAgICByZXR1cm4gcGF0aDtcXG4gICAgfVxcbiAgfSBjYXRjaCAoZXJyKSB7XFxuICAgIC8vIGlnbm9yZSBlcnJvclxcbiAgICByZXR1cm47XFxuICB9XFxuXFxuICByZWFkZGlyU3luYyhwYXRoKS5mb3JFYWNoKGZ1bmN0aW9uIChmaWxlKSB7XFxuICAgIGZpbGUgPSBqb2luKHBhdGgsIGZpbGUpO1xcbiAgICB0cnkge1xcbiAgICAgIHZhciBzdGF0ID0gc3RhdFN5bmMoZmlsZSk7XFxuICAgICAgaWYgKHN0YXQuaXNEaXJlY3RvcnkoKSkge1xcbiAgICAgICAgaWYgKHJlY3Vyc2l2ZSkge1xcbiAgICAgICAgICBmaWxlcyA9IGZpbGVzLmNvbmNhdChsb29rdXBGaWxlcyhmaWxlLCBleHRlbnNpb25zLCByZWN1cnNpdmUpKTtcXG4gICAgICAgIH1cXG4gICAgICAgIHJldHVybjtcXG4gICAgICB9XFxuICAgIH0gY2F0Y2ggKGVycikge1xcbiAgICAgIC8vIGlnbm9yZSBlcnJvclxcbiAgICAgIHJldHVybjtcXG4gICAgfVxcbiAgICBpZiAoIXN0YXQuaXNGaWxlKCkgfHwgIXJlLnRlc3QoZmlsZSkgfHwgYmFzZW5hbWUoZmlsZSlbMF0gPT09ICcuJykge1xcbiAgICAgIHJldHVybjtcXG4gICAgfVxcbiAgICBmaWxlcy5wdXNoKGZpbGUpO1xcbiAgfSk7XFxuXFxuICByZXR1cm4gZmlsZXM7XFxufTtcXG5cXG4vKipcXG4gKiBHZW5lcmF0ZSBhbiB1bmRlZmluZWQgZXJyb3Igd2l0aCBhIG1lc3NhZ2Ugd2FybmluZyB0aGUgdXNlci5cXG4gKlxcbiAqIEByZXR1cm4ge0Vycm9yfVxcbiAqL1xcblxcbmV4cG9ydHMudW5kZWZpbmVkRXJyb3IgPSBmdW5jdGlvbiAoKSB7XFxuICByZXR1cm4gbmV3IEVycm9yKCdDYXVnaHQgdW5kZWZpbmVkIGVycm9yLCBkaWQgeW91IHRocm93IHdpdGhvdXQgc3BlY2lmeWluZyB3aGF0PycpO1xcbn07XFxuXFxuLyoqXFxuICogR2VuZXJhdGUgYW4gdW5kZWZpbmVkIGVycm9yIGlmIGBlcnJgIGlzIG5vdCBkZWZpbmVkLlxcbiAqXFxuICogQHBhcmFtIHtFcnJvcn0gZXJyXFxuICogQHJldHVybiB7RXJyb3J9XFxuICovXFxuXFxuZXhwb3J0cy5nZXRFcnJvciA9IGZ1bmN0aW9uIChlcnIpIHtcXG4gIHJldHVybiBlcnIgfHwgZXhwb3J0cy51bmRlZmluZWRFcnJvcigpO1xcbn07XFxuXFxuLyoqXFxuICogQHN1bW1hcnlcXG4gKiBUaGlzIEZpbHRlciBiYXNlZCBvbiBgbW9jaGEtY2xlYW5gIG1vZHVsZS4oc2VlOiBgZ2l0aHViLmNvbS9yc3RhY3J1ei9tb2NoYS1jbGVhbmApXFxuICogQGRlc2NyaXB0aW9uXFxuICogV2hlbiBpbnZva2luZyB0aGlzIGZ1bmN0aW9uIHlvdSBnZXQgYSBmaWx0ZXIgZnVuY3Rpb24gdGhhdCBnZXQgdGhlIEVycm9yLnN0YWNrIGFzIGFuIGlucHV0LFxcbiAqIGFuZCByZXR1cm4gYSBwcmV0dGlmeSBvdXRwdXQuXFxuICogKGkuZTogc3RyaXAgTW9jaGEgYW5kIGludGVybmFsIG5vZGUgZnVuY3Rpb25zIGZyb20gc3RhY2sgdHJhY2UpLlxcbiAqIEByZXR1cm5zIHtGdW5jdGlvbn1cXG4gKi9cXG5leHBvcnRzLnN0YWNrVHJhY2VGaWx0ZXIgPSBmdW5jdGlvbiAoKSB7XFxuICAvLyBUT0RPOiBSZXBsYWNlIHdpdGggYHByb2Nlc3MuYnJvd3NlcmBcXG4gIHZhciBpcyA9IHR5cGVvZiBkb2N1bWVudCA9PT0gJ3VuZGVmaW5lZCcgPyB7IG5vZGU6IHRydWUgfSA6IHsgYnJvd3NlcjogdHJ1ZSB9O1xcbiAgdmFyIHNsYXNoID0gcGF0aC5zZXA7XFxuICB2YXIgY3dkO1xcbiAgaWYgKGlzLm5vZGUpIHtcXG4gICAgY3dkID0gcHJvY2Vzcy5jd2QoKSArIHNsYXNoO1xcbiAgfSBlbHNlIHtcXG4gICAgY3dkID0gKHR5cGVvZiBsb2NhdGlvbiA9PT0gJ3VuZGVmaW5lZCdcXG4gICAgICA/IHdpbmRvdy5sb2NhdGlvblxcbiAgICAgIDogbG9jYXRpb24pLmhyZWYucmVwbGFjZSgvXFxcXC9bXi9dKiQvLCAnLycpO1xcbiAgICBzbGFzaCA9ICcvJztcXG4gIH1cXG5cXG4gIGZ1bmN0aW9uIGlzTW9jaGFJbnRlcm5hbCAobGluZSkge1xcbiAgICByZXR1cm4gKH5saW5lLmluZGV4T2YoJ25vZGVfbW9kdWxlcycgKyBzbGFzaCArICdtb2NoYScgKyBzbGFzaCkpIHx8XFxuICAgICAgKH5saW5lLmluZGV4T2YoJ25vZGVfbW9kdWxlcycgKyBzbGFzaCArICdtb2NoYS5qcycpKSB8fFxcbiAgICAgICh+bGluZS5pbmRleE9mKCdib3dlcl9jb21wb25lbnRzJyArIHNsYXNoICsgJ21vY2hhLmpzJykpIHx8XFxuICAgICAgKH5saW5lLmluZGV4T2Yoc2xhc2ggKyAnbW9jaGEuanMnKSk7XFxuICB9XFxuXFxuICBmdW5jdGlvbiBpc05vZGVJbnRlcm5hbCAobGluZSkge1xcbiAgICByZXR1cm4gKH5saW5lLmluZGV4T2YoJyh0aW1lcnMuanM6JykpIHx8XFxuICAgICAgKH5saW5lLmluZGV4T2YoJyhldmVudHMuanM6JykpIHx8XFxuICAgICAgKH5saW5lLmluZGV4T2YoJyhub2RlLmpzOicpKSB8fFxcbiAgICAgICh+bGluZS5pbmRleE9mKCcobW9kdWxlLmpzOicpKSB8fFxcbiAgICAgICh+bGluZS5pbmRleE9mKCdHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZS5uZXh0IChuYXRpdmUpJykpIHx8XFxuICAgICAgZmFsc2U7XFxuICB9XFxuXFxuICByZXR1cm4gZnVuY3Rpb24gKHN0YWNrKSB7XFxuICAgIHN0YWNrID0gc3RhY2suc3BsaXQoJ1xcXFxuJyk7XFxuXFxuICAgIHN0YWNrID0gcmVkdWNlKHN0YWNrLCBmdW5jdGlvbiAobGlzdCwgbGluZSkge1xcbiAgICAgIGlmIChpc01vY2hhSW50ZXJuYWwobGluZSkpIHtcXG4gICAgICAgIHJldHVybiBsaXN0O1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAoaXMubm9kZSAmJiBpc05vZGVJbnRlcm5hbChsaW5lKSkge1xcbiAgICAgICAgcmV0dXJuIGxpc3Q7XFxuICAgICAgfVxcblxcbiAgICAgIC8vIENsZWFuIHVwIGN3ZChhYnNvbHV0ZSlcXG4gICAgICBpZiAoL1xcXFwoPy4rOlxcXFxkKzpcXFxcZCtcXFxcKT8kLy50ZXN0KGxpbmUpKSB7XFxuICAgICAgICBsaW5lID0gbGluZS5yZXBsYWNlKGN3ZCwgJycpO1xcbiAgICAgIH1cXG5cXG4gICAgICBsaXN0LnB1c2gobGluZSk7XFxuICAgICAgcmV0dXJuIGxpc3Q7XFxuICAgIH0sIFtdKTtcXG5cXG4gICAgcmV0dXJuIHN0YWNrLmpvaW4oJ1xcXFxuJyk7XFxuICB9O1xcbn07XFxuXFxuLyoqXFxuICogQ3J1ZGUsIGJ1dCBlZmZlY3RpdmUuXFxuICogQGFwaVxcbiAqIEBwYXJhbSB7Kn0gdmFsdWVcXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gV2hldGhlciBvciBub3QgYHZhbHVlYCBpcyBhIFByb21pc2VcXG4gKi9cXG5leHBvcnRzLmlzUHJvbWlzZSA9IGZ1bmN0aW9uIGlzUHJvbWlzZSAodmFsdWUpIHtcXG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIHR5cGVvZiB2YWx1ZS50aGVuID09PSAnZnVuY3Rpb24nO1xcbn07XFxuXFxuLyoqXFxuICogSXQncyBhIG5vb3AuXFxuICogQGFwaVxcbiAqL1xcbmV4cG9ydHMubm9vcCA9IGZ1bmN0aW9uICgpIHt9O1xcblxcbn0pLmNhbGwodGhpcyxyZXF1aXJlKCdfcHJvY2VzcycpLHJlcXVpcmUoXFxcImJ1ZmZlclxcXCIpLkJ1ZmZlcilcXG59LHtcXFwiLi90by1pc28tc3RyaW5nXFxcIjozNyxcXFwiX3Byb2Nlc3NcXFwiOjgyLFxcXCJidWZmZXJcXFwiOjQzLFxcXCJkZWJ1Z1xcXCI6MixcXFwiZnNcXFwiOjQyLFxcXCJnbG9iXFxcIjo0MixcXFwiaGVcXFwiOjY0LFxcXCJqc29uM1xcXCI6NjksXFxcInBhdGhcXFwiOjQyLFxcXCJ1dGlsXFxcIjoxMDJ9XSwzOTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XFxuJ3VzZSBzdHJpY3QnXFxuXFxuZXhwb3J0cy5ieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aFxcbmV4cG9ydHMudG9CeXRlQXJyYXkgPSB0b0J5dGVBcnJheVxcbmV4cG9ydHMuZnJvbUJ5dGVBcnJheSA9IGZyb21CeXRlQXJyYXlcXG5cXG52YXIgbG9va3VwID0gW11cXG52YXIgcmV2TG9va3VwID0gW11cXG52YXIgQXJyID0gdHlwZW9mIFVpbnQ4QXJyYXkgIT09ICd1bmRlZmluZWQnID8gVWludDhBcnJheSA6IEFycmF5XFxuXFxudmFyIGNvZGUgPSAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLydcXG5mb3IgKHZhciBpID0gMCwgbGVuID0gY29kZS5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xcbiAgbG9va3VwW2ldID0gY29kZVtpXVxcbiAgcmV2TG9va3VwW2NvZGUuY2hhckNvZGVBdChpKV0gPSBpXFxufVxcblxcbnJldkxvb2t1cFsnLScuY2hhckNvZGVBdCgwKV0gPSA2MlxcbnJldkxvb2t1cFsnXycuY2hhckNvZGVBdCgwKV0gPSA2M1xcblxcbmZ1bmN0aW9uIHBsYWNlSG9sZGVyc0NvdW50IChiNjQpIHtcXG4gIHZhciBsZW4gPSBiNjQubGVuZ3RoXFxuICBpZiAobGVuICUgNCA+IDApIHtcXG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHN0cmluZy4gTGVuZ3RoIG11c3QgYmUgYSBtdWx0aXBsZSBvZiA0JylcXG4gIH1cXG5cXG4gIC8vIHRoZSBudW1iZXIgb2YgZXF1YWwgc2lnbnMgKHBsYWNlIGhvbGRlcnMpXFxuICAvLyBpZiB0aGVyZSBhcmUgdHdvIHBsYWNlaG9sZGVycywgdGhhbiB0aGUgdHdvIGNoYXJhY3RlcnMgYmVmb3JlIGl0XFxuICAvLyByZXByZXNlbnQgb25lIGJ5dGVcXG4gIC8vIGlmIHRoZXJlIGlzIG9ubHkgb25lLCB0aGVuIHRoZSB0aHJlZSBjaGFyYWN0ZXJzIGJlZm9yZSBpdCByZXByZXNlbnQgMiBieXRlc1xcbiAgLy8gdGhpcyBpcyBqdXN0IGEgY2hlYXAgaGFjayB0byBub3QgZG8gaW5kZXhPZiB0d2ljZVxcbiAgcmV0dXJuIGI2NFtsZW4gLSAyXSA9PT0gJz0nID8gMiA6IGI2NFtsZW4gLSAxXSA9PT0gJz0nID8gMSA6IDBcXG59XFxuXFxuZnVuY3Rpb24gYnl0ZUxlbmd0aCAoYjY0KSB7XFxuICAvLyBiYXNlNjQgaXMgNC8zICsgdXAgdG8gdHdvIGNoYXJhY3RlcnMgb2YgdGhlIG9yaWdpbmFsIGRhdGFcXG4gIHJldHVybiAoYjY0Lmxlbmd0aCAqIDMgLyA0KSAtIHBsYWNlSG9sZGVyc0NvdW50KGI2NClcXG59XFxuXFxuZnVuY3Rpb24gdG9CeXRlQXJyYXkgKGI2NCkge1xcbiAgdmFyIGksIGwsIHRtcCwgcGxhY2VIb2xkZXJzLCBhcnJcXG4gIHZhciBsZW4gPSBiNjQubGVuZ3RoXFxuICBwbGFjZUhvbGRlcnMgPSBwbGFjZUhvbGRlcnNDb3VudChiNjQpXFxuXFxuICBhcnIgPSBuZXcgQXJyKChsZW4gKiAzIC8gNCkgLSBwbGFjZUhvbGRlcnMpXFxuXFxuICAvLyBpZiB0aGVyZSBhcmUgcGxhY2Vob2xkZXJzLCBvbmx5IGdldCB1cCB0byB0aGUgbGFzdCBjb21wbGV0ZSA0IGNoYXJzXFxuICBsID0gcGxhY2VIb2xkZXJzID4gMCA/IGxlbiAtIDQgOiBsZW5cXG5cXG4gIHZhciBMID0gMFxcblxcbiAgZm9yIChpID0gMDsgaSA8IGw7IGkgKz0gNCkge1xcbiAgICB0bXAgPSAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkpXSA8PCAxOCkgfCAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAxKV0gPDwgMTIpIHwgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMildIDw8IDYpIHwgcmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAzKV1cXG4gICAgYXJyW0wrK10gPSAodG1wID4+IDE2KSAmIDB4RkZcXG4gICAgYXJyW0wrK10gPSAodG1wID4+IDgpICYgMHhGRlxcbiAgICBhcnJbTCsrXSA9IHRtcCAmIDB4RkZcXG4gIH1cXG5cXG4gIGlmIChwbGFjZUhvbGRlcnMgPT09IDIpIHtcXG4gICAgdG1wID0gKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpKV0gPDwgMikgfCAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAxKV0gPj4gNClcXG4gICAgYXJyW0wrK10gPSB0bXAgJiAweEZGXFxuICB9IGVsc2UgaWYgKHBsYWNlSG9sZGVycyA9PT0gMSkge1xcbiAgICB0bXAgPSAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkpXSA8PCAxMCkgfCAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAxKV0gPDwgNCkgfCAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAyKV0gPj4gMilcXG4gICAgYXJyW0wrK10gPSAodG1wID4+IDgpICYgMHhGRlxcbiAgICBhcnJbTCsrXSA9IHRtcCAmIDB4RkZcXG4gIH1cXG5cXG4gIHJldHVybiBhcnJcXG59XFxuXFxuZnVuY3Rpb24gdHJpcGxldFRvQmFzZTY0IChudW0pIHtcXG4gIHJldHVybiBsb29rdXBbbnVtID4+IDE4ICYgMHgzRl0gKyBsb29rdXBbbnVtID4+IDEyICYgMHgzRl0gKyBsb29rdXBbbnVtID4+IDYgJiAweDNGXSArIGxvb2t1cFtudW0gJiAweDNGXVxcbn1cXG5cXG5mdW5jdGlvbiBlbmNvZGVDaHVuayAodWludDgsIHN0YXJ0LCBlbmQpIHtcXG4gIHZhciB0bXBcXG4gIHZhciBvdXRwdXQgPSBbXVxcbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpICs9IDMpIHtcXG4gICAgdG1wID0gKHVpbnQ4W2ldIDw8IDE2KSArICh1aW50OFtpICsgMV0gPDwgOCkgKyAodWludDhbaSArIDJdKVxcbiAgICBvdXRwdXQucHVzaCh0cmlwbGV0VG9CYXNlNjQodG1wKSlcXG4gIH1cXG4gIHJldHVybiBvdXRwdXQuam9pbignJylcXG59XFxuXFxuZnVuY3Rpb24gZnJvbUJ5dGVBcnJheSAodWludDgpIHtcXG4gIHZhciB0bXBcXG4gIHZhciBsZW4gPSB1aW50OC5sZW5ndGhcXG4gIHZhciBleHRyYUJ5dGVzID0gbGVuICUgMyAvLyBpZiB3ZSBoYXZlIDEgYnl0ZSBsZWZ0LCBwYWQgMiBieXRlc1xcbiAgdmFyIG91dHB1dCA9ICcnXFxuICB2YXIgcGFydHMgPSBbXVxcbiAgdmFyIG1heENodW5rTGVuZ3RoID0gMTYzODMgLy8gbXVzdCBiZSBtdWx0aXBsZSBvZiAzXFxuXFxuICAvLyBnbyB0aHJvdWdoIHRoZSBhcnJheSBldmVyeSB0aHJlZSBieXRlcywgd2UnbGwgZGVhbCB3aXRoIHRyYWlsaW5nIHN0dWZmIGxhdGVyXFxuICBmb3IgKHZhciBpID0gMCwgbGVuMiA9IGxlbiAtIGV4dHJhQnl0ZXM7IGkgPCBsZW4yOyBpICs9IG1heENodW5rTGVuZ3RoKSB7XFxuICAgIHBhcnRzLnB1c2goZW5jb2RlQ2h1bmsodWludDgsIGksIChpICsgbWF4Q2h1bmtMZW5ndGgpID4gbGVuMiA/IGxlbjIgOiAoaSArIG1heENodW5rTGVuZ3RoKSkpXFxuICB9XFxuXFxuICAvLyBwYWQgdGhlIGVuZCB3aXRoIHplcm9zLCBidXQgbWFrZSBzdXJlIHRvIG5vdCBmb3JnZXQgdGhlIGV4dHJhIGJ5dGVzXFxuICBpZiAoZXh0cmFCeXRlcyA9PT0gMSkge1xcbiAgICB0bXAgPSB1aW50OFtsZW4gLSAxXVxcbiAgICBvdXRwdXQgKz0gbG9va3VwW3RtcCA+PiAyXVxcbiAgICBvdXRwdXQgKz0gbG9va3VwWyh0bXAgPDwgNCkgJiAweDNGXVxcbiAgICBvdXRwdXQgKz0gJz09J1xcbiAgfSBlbHNlIGlmIChleHRyYUJ5dGVzID09PSAyKSB7XFxuICAgIHRtcCA9ICh1aW50OFtsZW4gLSAyXSA8PCA4KSArICh1aW50OFtsZW4gLSAxXSlcXG4gICAgb3V0cHV0ICs9IGxvb2t1cFt0bXAgPj4gMTBdXFxuICAgIG91dHB1dCArPSBsb29rdXBbKHRtcCA+PiA0KSAmIDB4M0ZdXFxuICAgIG91dHB1dCArPSBsb29rdXBbKHRtcCA8PCAyKSAmIDB4M0ZdXFxuICAgIG91dHB1dCArPSAnPSdcXG4gIH1cXG5cXG4gIHBhcnRzLnB1c2gob3V0cHV0KVxcblxcbiAgcmV0dXJuIHBhcnRzLmpvaW4oJycpXFxufVxcblxcbn0se31dLDQwOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcXG5cXG59LHt9XSw0MTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XFxuKGZ1bmN0aW9uIChwcm9jZXNzKXtcXG52YXIgV3JpdGFibGVTdHJlYW0gPSByZXF1aXJlKCdzdHJlYW0nKS5Xcml0YWJsZVxcbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ3V0aWwnKS5pbmhlcml0c1xcblxcbm1vZHVsZS5leHBvcnRzID0gQnJvd3NlclN0ZG91dFxcblxcblxcbmluaGVyaXRzKEJyb3dzZXJTdGRvdXQsIFdyaXRhYmxlU3RyZWFtKVxcblxcbmZ1bmN0aW9uIEJyb3dzZXJTdGRvdXQob3B0cykge1xcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIEJyb3dzZXJTdGRvdXQpKSByZXR1cm4gbmV3IEJyb3dzZXJTdGRvdXQob3B0cylcXG5cXG4gIG9wdHMgPSBvcHRzIHx8IHt9XFxuICBXcml0YWJsZVN0cmVhbS5jYWxsKHRoaXMsIG9wdHMpXFxuICB0aGlzLmxhYmVsID0gKG9wdHMubGFiZWwgIT09IHVuZGVmaW5lZCkgPyBvcHRzLmxhYmVsIDogJ3N0ZG91dCdcXG59XFxuXFxuQnJvd3NlclN0ZG91dC5wcm90b3R5cGUuX3dyaXRlID0gZnVuY3Rpb24oY2h1bmtzLCBlbmNvZGluZywgY2IpIHtcXG4gIHZhciBvdXRwdXQgPSBjaHVua3MudG9TdHJpbmcgPyBjaHVua3MudG9TdHJpbmcoKSA6IGNodW5rc1xcbiAgaWYgKHRoaXMubGFiZWwgPT09IGZhbHNlKSB7XFxuICAgIGNvbnNvbGUubG9nKG91dHB1dClcXG4gIH0gZWxzZSB7XFxuICAgIGNvbnNvbGUubG9nKHRoaXMubGFiZWwrJzonLCBvdXRwdXQpXFxuICB9XFxuICBwcm9jZXNzLm5leHRUaWNrKGNiKVxcbn1cXG5cXG59KS5jYWxsKHRoaXMscmVxdWlyZSgnX3Byb2Nlc3MnKSlcXG59LHtcXFwiX3Byb2Nlc3NcXFwiOjgyLFxcXCJzdHJlYW1cXFwiOjk2LFxcXCJ1dGlsXFxcIjoxMDJ9XSw0MjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XFxuYXJndW1lbnRzWzRdWzQwXVswXS5hcHBseShleHBvcnRzLGFyZ3VtZW50cylcXG59LHtcXFwiZHVwXFxcIjo0MH1dLDQzOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcXG4oZnVuY3Rpb24gKGdsb2JhbCl7XFxuLyohXFxuICogVGhlIGJ1ZmZlciBtb2R1bGUgZnJvbSBub2RlLmpzLCBmb3IgdGhlIGJyb3dzZXIuXFxuICpcXG4gKiBAYXV0aG9yICAgRmVyb3NzIEFib3VraGFkaWplaCA8ZmVyb3NzQGZlcm9zcy5vcmc+IDxodHRwOi8vZmVyb3NzLm9yZz5cXG4gKiBAbGljZW5zZSAgTUlUXFxuICovXFxuLyogZXNsaW50LWRpc2FibGUgbm8tcHJvdG8gKi9cXG5cXG4ndXNlIHN0cmljdCdcXG5cXG52YXIgYmFzZTY0ID0gcmVxdWlyZSgnYmFzZTY0LWpzJylcXG52YXIgaWVlZTc1NCA9IHJlcXVpcmUoJ2llZWU3NTQnKVxcbnZhciBpc0FycmF5ID0gcmVxdWlyZSgnaXNhcnJheScpXFxuXFxuZXhwb3J0cy5CdWZmZXIgPSBCdWZmZXJcXG5leHBvcnRzLlNsb3dCdWZmZXIgPSBTbG93QnVmZmVyXFxuZXhwb3J0cy5JTlNQRUNUX01BWF9CWVRFUyA9IDUwXFxuXFxuLyoqXFxuICogSWYgYEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUYDpcXG4gKiAgID09PSB0cnVlICAgIFVzZSBVaW50OEFycmF5IGltcGxlbWVudGF0aW9uIChmYXN0ZXN0KVxcbiAqICAgPT09IGZhbHNlICAgVXNlIE9iamVjdCBpbXBsZW1lbnRhdGlvbiAobW9zdCBjb21wYXRpYmxlLCBldmVuIElFNilcXG4gKlxcbiAqIEJyb3dzZXJzIHRoYXQgc3VwcG9ydCB0eXBlZCBhcnJheXMgYXJlIElFIDEwKywgRmlyZWZveCA0KywgQ2hyb21lIDcrLCBTYWZhcmkgNS4xKyxcXG4gKiBPcGVyYSAxMS42KywgaU9TIDQuMisuXFxuICpcXG4gKiBEdWUgdG8gdmFyaW91cyBicm93c2VyIGJ1Z3MsIHNvbWV0aW1lcyB0aGUgT2JqZWN0IGltcGxlbWVudGF0aW9uIHdpbGwgYmUgdXNlZCBldmVuXFxuICogd2hlbiB0aGUgYnJvd3NlciBzdXBwb3J0cyB0eXBlZCBhcnJheXMuXFxuICpcXG4gKiBOb3RlOlxcbiAqXFxuICogICAtIEZpcmVmb3ggNC0yOSBsYWNrcyBzdXBwb3J0IGZvciBhZGRpbmcgbmV3IHByb3BlcnRpZXMgdG8gYFVpbnQ4QXJyYXlgIGluc3RhbmNlcyxcXG4gKiAgICAgU2VlOiBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD02OTU0MzguXFxuICpcXG4gKiAgIC0gQ2hyb21lIDktMTAgaXMgbWlzc2luZyB0aGUgYFR5cGVkQXJyYXkucHJvdG90eXBlLnN1YmFycmF5YCBmdW5jdGlvbi5cXG4gKlxcbiAqICAgLSBJRTEwIGhhcyBhIGJyb2tlbiBgVHlwZWRBcnJheS5wcm90b3R5cGUuc3ViYXJyYXlgIGZ1bmN0aW9uIHdoaWNoIHJldHVybnMgYXJyYXlzIG9mXFxuICogICAgIGluY29ycmVjdCBsZW5ndGggaW4gc29tZSBzaXR1YXRpb25zLlxcblxcbiAqIFdlIGRldGVjdCB0aGVzZSBidWdneSBicm93c2VycyBhbmQgc2V0IGBCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVGAgdG8gYGZhbHNlYCBzbyB0aGV5XFxuICogZ2V0IHRoZSBPYmplY3QgaW1wbGVtZW50YXRpb24sIHdoaWNoIGlzIHNsb3dlciBidXQgYmVoYXZlcyBjb3JyZWN0bHkuXFxuICovXFxuQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQgPSBnbG9iYWwuVFlQRURfQVJSQVlfU1VQUE9SVCAhPT0gdW5kZWZpbmVkXFxuICA/IGdsb2JhbC5UWVBFRF9BUlJBWV9TVVBQT1JUXFxuICA6IHR5cGVkQXJyYXlTdXBwb3J0KClcXG5cXG4vKlxcbiAqIEV4cG9ydCBrTWF4TGVuZ3RoIGFmdGVyIHR5cGVkIGFycmF5IHN1cHBvcnQgaXMgZGV0ZXJtaW5lZC5cXG4gKi9cXG5leHBvcnRzLmtNYXhMZW5ndGggPSBrTWF4TGVuZ3RoKClcXG5cXG5mdW5jdGlvbiB0eXBlZEFycmF5U3VwcG9ydCAoKSB7XFxuICB0cnkge1xcbiAgICB2YXIgYXJyID0gbmV3IFVpbnQ4QXJyYXkoMSlcXG4gICAgYXJyLl9fcHJvdG9fXyA9IHtfX3Byb3RvX186IFVpbnQ4QXJyYXkucHJvdG90eXBlLCBmb286IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDQyIH19XFxuICAgIHJldHVybiBhcnIuZm9vKCkgPT09IDQyICYmIC8vIHR5cGVkIGFycmF5IGluc3RhbmNlcyBjYW4gYmUgYXVnbWVudGVkXFxuICAgICAgICB0eXBlb2YgYXJyLnN1YmFycmF5ID09PSAnZnVuY3Rpb24nICYmIC8vIGNocm9tZSA5LTEwIGxhY2sgYHN1YmFycmF5YFxcbiAgICAgICAgYXJyLnN1YmFycmF5KDEsIDEpLmJ5dGVMZW5ndGggPT09IDAgLy8gaWUxMCBoYXMgYnJva2VuIGBzdWJhcnJheWBcXG4gIH0gY2F0Y2ggKGUpIHtcXG4gICAgcmV0dXJuIGZhbHNlXFxuICB9XFxufVxcblxcbmZ1bmN0aW9uIGtNYXhMZW5ndGggKCkge1xcbiAgcmV0dXJuIEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUXFxuICAgID8gMHg3ZmZmZmZmZlxcbiAgICA6IDB4M2ZmZmZmZmZcXG59XFxuXFxuZnVuY3Rpb24gY3JlYXRlQnVmZmVyICh0aGF0LCBsZW5ndGgpIHtcXG4gIGlmIChrTWF4TGVuZ3RoKCkgPCBsZW5ndGgpIHtcXG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0ludmFsaWQgdHlwZWQgYXJyYXkgbGVuZ3RoJylcXG4gIH1cXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xcbiAgICAvLyBSZXR1cm4gYW4gYXVnbWVudGVkIGBVaW50OEFycmF5YCBpbnN0YW5jZSwgZm9yIGJlc3QgcGVyZm9ybWFuY2VcXG4gICAgdGhhdCA9IG5ldyBVaW50OEFycmF5KGxlbmd0aClcXG4gICAgdGhhdC5fX3Byb3RvX18gPSBCdWZmZXIucHJvdG90eXBlXFxuICB9IGVsc2Uge1xcbiAgICAvLyBGYWxsYmFjazogUmV0dXJuIGFuIG9iamVjdCBpbnN0YW5jZSBvZiB0aGUgQnVmZmVyIGNsYXNzXFxuICAgIGlmICh0aGF0ID09PSBudWxsKSB7XFxuICAgICAgdGhhdCA9IG5ldyBCdWZmZXIobGVuZ3RoKVxcbiAgICB9XFxuICAgIHRoYXQubGVuZ3RoID0gbGVuZ3RoXFxuICB9XFxuXFxuICByZXR1cm4gdGhhdFxcbn1cXG5cXG4vKipcXG4gKiBUaGUgQnVmZmVyIGNvbnN0cnVjdG9yIHJldHVybnMgaW5zdGFuY2VzIG9mIGBVaW50OEFycmF5YCB0aGF0IGhhdmUgdGhlaXJcXG4gKiBwcm90b3R5cGUgY2hhbmdlZCB0byBgQnVmZmVyLnByb3RvdHlwZWAuIEZ1cnRoZXJtb3JlLCBgQnVmZmVyYCBpcyBhIHN1YmNsYXNzIG9mXFxuICogYFVpbnQ4QXJyYXlgLCBzbyB0aGUgcmV0dXJuZWQgaW5zdGFuY2VzIHdpbGwgaGF2ZSBhbGwgdGhlIG5vZGUgYEJ1ZmZlcmAgbWV0aG9kc1xcbiAqIGFuZCB0aGUgYFVpbnQ4QXJyYXlgIG1ldGhvZHMuIFNxdWFyZSBicmFja2V0IG5vdGF0aW9uIHdvcmtzIGFzIGV4cGVjdGVkIC0tIGl0XFxuICogcmV0dXJucyBhIHNpbmdsZSBvY3RldC5cXG4gKlxcbiAqIFRoZSBgVWludDhBcnJheWAgcHJvdG90eXBlIHJlbWFpbnMgdW5tb2RpZmllZC5cXG4gKi9cXG5cXG5mdW5jdGlvbiBCdWZmZXIgKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XFxuICBpZiAoIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUICYmICEodGhpcyBpbnN0YW5jZW9mIEJ1ZmZlcikpIHtcXG4gICAgcmV0dXJuIG5ldyBCdWZmZXIoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXFxuICB9XFxuXFxuICAvLyBDb21tb24gY2FzZS5cXG4gIGlmICh0eXBlb2YgYXJnID09PSAnbnVtYmVyJykge1xcbiAgICBpZiAodHlwZW9mIGVuY29kaW5nT3JPZmZzZXQgPT09ICdzdHJpbmcnKSB7XFxuICAgICAgdGhyb3cgbmV3IEVycm9yKFxcbiAgICAgICAgJ0lmIGVuY29kaW5nIGlzIHNwZWNpZmllZCB0aGVuIHRoZSBmaXJzdCBhcmd1bWVudCBtdXN0IGJlIGEgc3RyaW5nJ1xcbiAgICAgIClcXG4gICAgfVxcbiAgICByZXR1cm4gYWxsb2NVbnNhZmUodGhpcywgYXJnKVxcbiAgfVxcbiAgcmV0dXJuIGZyb20odGhpcywgYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXFxufVxcblxcbkJ1ZmZlci5wb29sU2l6ZSA9IDgxOTIgLy8gbm90IHVzZWQgYnkgdGhpcyBpbXBsZW1lbnRhdGlvblxcblxcbi8vIFRPRE86IExlZ2FjeSwgbm90IG5lZWRlZCBhbnltb3JlLiBSZW1vdmUgaW4gbmV4dCBtYWpvciB2ZXJzaW9uLlxcbkJ1ZmZlci5fYXVnbWVudCA9IGZ1bmN0aW9uIChhcnIpIHtcXG4gIGFyci5fX3Byb3RvX18gPSBCdWZmZXIucHJvdG90eXBlXFxuICByZXR1cm4gYXJyXFxufVxcblxcbmZ1bmN0aW9uIGZyb20gKHRoYXQsIHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcXG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XFxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1xcXCJ2YWx1ZVxcXCIgYXJndW1lbnQgbXVzdCBub3QgYmUgYSBudW1iZXInKVxcbiAgfVxcblxcbiAgaWYgKHR5cGVvZiBBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcgJiYgdmFsdWUgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xcbiAgICByZXR1cm4gZnJvbUFycmF5QnVmZmVyKHRoYXQsIHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXFxuICB9XFxuXFxuICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xcbiAgICByZXR1cm4gZnJvbVN0cmluZyh0aGF0LCB2YWx1ZSwgZW5jb2RpbmdPck9mZnNldClcXG4gIH1cXG5cXG4gIHJldHVybiBmcm9tT2JqZWN0KHRoYXQsIHZhbHVlKVxcbn1cXG5cXG4vKipcXG4gKiBGdW5jdGlvbmFsbHkgZXF1aXZhbGVudCB0byBCdWZmZXIoYXJnLCBlbmNvZGluZykgYnV0IHRocm93cyBhIFR5cGVFcnJvclxcbiAqIGlmIHZhbHVlIGlzIGEgbnVtYmVyLlxcbiAqIEJ1ZmZlci5mcm9tKHN0clssIGVuY29kaW5nXSlcXG4gKiBCdWZmZXIuZnJvbShhcnJheSlcXG4gKiBCdWZmZXIuZnJvbShidWZmZXIpXFxuICogQnVmZmVyLmZyb20oYXJyYXlCdWZmZXJbLCBieXRlT2Zmc2V0WywgbGVuZ3RoXV0pXFxuICoqL1xcbkJ1ZmZlci5mcm9tID0gZnVuY3Rpb24gKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcXG4gIHJldHVybiBmcm9tKG51bGwsIHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXFxufVxcblxcbmlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xcbiAgQnVmZmVyLnByb3RvdHlwZS5fX3Byb3RvX18gPSBVaW50OEFycmF5LnByb3RvdHlwZVxcbiAgQnVmZmVyLl9fcHJvdG9fXyA9IFVpbnQ4QXJyYXlcXG4gIGlmICh0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wuc3BlY2llcyAmJlxcbiAgICAgIEJ1ZmZlcltTeW1ib2wuc3BlY2llc10gPT09IEJ1ZmZlcikge1xcbiAgICAvLyBGaXggc3ViYXJyYXkoKSBpbiBFUzIwMTYuIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXIvcHVsbC85N1xcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQnVmZmVyLCBTeW1ib2wuc3BlY2llcywge1xcbiAgICAgIHZhbHVlOiBudWxsLFxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxcbiAgICB9KVxcbiAgfVxcbn1cXG5cXG5mdW5jdGlvbiBhc3NlcnRTaXplIChzaXplKSB7XFxuICBpZiAodHlwZW9mIHNpemUgIT09ICdudW1iZXInKSB7XFxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1xcXCJzaXplXFxcIiBhcmd1bWVudCBtdXN0IGJlIGEgbnVtYmVyJylcXG4gIH0gZWxzZSBpZiAoc2l6ZSA8IDApIHtcXG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1xcXCJzaXplXFxcIiBhcmd1bWVudCBtdXN0IG5vdCBiZSBuZWdhdGl2ZScpXFxuICB9XFxufVxcblxcbmZ1bmN0aW9uIGFsbG9jICh0aGF0LCBzaXplLCBmaWxsLCBlbmNvZGluZykge1xcbiAgYXNzZXJ0U2l6ZShzaXplKVxcbiAgaWYgKHNpemUgPD0gMCkge1xcbiAgICByZXR1cm4gY3JlYXRlQnVmZmVyKHRoYXQsIHNpemUpXFxuICB9XFxuICBpZiAoZmlsbCAhPT0gdW5kZWZpbmVkKSB7XFxuICAgIC8vIE9ubHkgcGF5IGF0dGVudGlvbiB0byBlbmNvZGluZyBpZiBpdCdzIGEgc3RyaW5nLiBUaGlzXFxuICAgIC8vIHByZXZlbnRzIGFjY2lkZW50YWxseSBzZW5kaW5nIGluIGEgbnVtYmVyIHRoYXQgd291bGRcXG4gICAgLy8gYmUgaW50ZXJwcmV0dGVkIGFzIGEgc3RhcnQgb2Zmc2V0LlxcbiAgICByZXR1cm4gdHlwZW9mIGVuY29kaW5nID09PSAnc3RyaW5nJ1xcbiAgICAgID8gY3JlYXRlQnVmZmVyKHRoYXQsIHNpemUpLmZpbGwoZmlsbCwgZW5jb2RpbmcpXFxuICAgICAgOiBjcmVhdGVCdWZmZXIodGhhdCwgc2l6ZSkuZmlsbChmaWxsKVxcbiAgfVxcbiAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcih0aGF0LCBzaXplKVxcbn1cXG5cXG4vKipcXG4gKiBDcmVhdGVzIGEgbmV3IGZpbGxlZCBCdWZmZXIgaW5zdGFuY2UuXFxuICogYWxsb2Moc2l6ZVssIGZpbGxbLCBlbmNvZGluZ11dKVxcbiAqKi9cXG5CdWZmZXIuYWxsb2MgPSBmdW5jdGlvbiAoc2l6ZSwgZmlsbCwgZW5jb2RpbmcpIHtcXG4gIHJldHVybiBhbGxvYyhudWxsLCBzaXplLCBmaWxsLCBlbmNvZGluZylcXG59XFxuXFxuZnVuY3Rpb24gYWxsb2NVbnNhZmUgKHRoYXQsIHNpemUpIHtcXG4gIGFzc2VydFNpemUoc2l6ZSlcXG4gIHRoYXQgPSBjcmVhdGVCdWZmZXIodGhhdCwgc2l6ZSA8IDAgPyAwIDogY2hlY2tlZChzaXplKSB8IDApXFxuICBpZiAoIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XFxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2l6ZTsgKytpKSB7XFxuICAgICAgdGhhdFtpXSA9IDBcXG4gICAgfVxcbiAgfVxcbiAgcmV0dXJuIHRoYXRcXG59XFxuXFxuLyoqXFxuICogRXF1aXZhbGVudCB0byBCdWZmZXIobnVtKSwgYnkgZGVmYXVsdCBjcmVhdGVzIGEgbm9uLXplcm8tZmlsbGVkIEJ1ZmZlciBpbnN0YW5jZS5cXG4gKiAqL1xcbkJ1ZmZlci5hbGxvY1Vuc2FmZSA9IGZ1bmN0aW9uIChzaXplKSB7XFxuICByZXR1cm4gYWxsb2NVbnNhZmUobnVsbCwgc2l6ZSlcXG59XFxuLyoqXFxuICogRXF1aXZhbGVudCB0byBTbG93QnVmZmVyKG51bSksIGJ5IGRlZmF1bHQgY3JlYXRlcyBhIG5vbi16ZXJvLWZpbGxlZCBCdWZmZXIgaW5zdGFuY2UuXFxuICovXFxuQnVmZmVyLmFsbG9jVW5zYWZlU2xvdyA9IGZ1bmN0aW9uIChzaXplKSB7XFxuICByZXR1cm4gYWxsb2NVbnNhZmUobnVsbCwgc2l6ZSlcXG59XFxuXFxuZnVuY3Rpb24gZnJvbVN0cmluZyAodGhhdCwgc3RyaW5nLCBlbmNvZGluZykge1xcbiAgaWYgKHR5cGVvZiBlbmNvZGluZyAhPT0gJ3N0cmluZycgfHwgZW5jb2RpbmcgPT09ICcnKSB7XFxuICAgIGVuY29kaW5nID0gJ3V0ZjgnXFxuICB9XFxuXFxuICBpZiAoIUJ1ZmZlci5pc0VuY29kaW5nKGVuY29kaW5nKSkge1xcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcXFwiZW5jb2RpbmdcXFwiIG11c3QgYmUgYSB2YWxpZCBzdHJpbmcgZW5jb2RpbmcnKVxcbiAgfVxcblxcbiAgdmFyIGxlbmd0aCA9IGJ5dGVMZW5ndGgoc3RyaW5nLCBlbmNvZGluZykgfCAwXFxuICB0aGF0ID0gY3JlYXRlQnVmZmVyKHRoYXQsIGxlbmd0aClcXG5cXG4gIHZhciBhY3R1YWwgPSB0aGF0LndyaXRlKHN0cmluZywgZW5jb2RpbmcpXFxuXFxuICBpZiAoYWN0dWFsICE9PSBsZW5ndGgpIHtcXG4gICAgLy8gV3JpdGluZyBhIGhleCBzdHJpbmcsIGZvciBleGFtcGxlLCB0aGF0IGNvbnRhaW5zIGludmFsaWQgY2hhcmFjdGVycyB3aWxsXFxuICAgIC8vIGNhdXNlIGV2ZXJ5dGhpbmcgYWZ0ZXIgdGhlIGZpcnN0IGludmFsaWQgY2hhcmFjdGVyIHRvIGJlIGlnbm9yZWQuIChlLmcuXFxuICAgIC8vICdhYnh4Y2QnIHdpbGwgYmUgdHJlYXRlZCBhcyAnYWInKVxcbiAgICB0aGF0ID0gdGhhdC5zbGljZSgwLCBhY3R1YWwpXFxuICB9XFxuXFxuICByZXR1cm4gdGhhdFxcbn1cXG5cXG5mdW5jdGlvbiBmcm9tQXJyYXlMaWtlICh0aGF0LCBhcnJheSkge1xcbiAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCA8IDAgPyAwIDogY2hlY2tlZChhcnJheS5sZW5ndGgpIHwgMFxcbiAgdGhhdCA9IGNyZWF0ZUJ1ZmZlcih0aGF0LCBsZW5ndGgpXFxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSArPSAxKSB7XFxuICAgIHRoYXRbaV0gPSBhcnJheVtpXSAmIDI1NVxcbiAgfVxcbiAgcmV0dXJuIHRoYXRcXG59XFxuXFxuZnVuY3Rpb24gZnJvbUFycmF5QnVmZmVyICh0aGF0LCBhcnJheSwgYnl0ZU9mZnNldCwgbGVuZ3RoKSB7XFxuICBhcnJheS5ieXRlTGVuZ3RoIC8vIHRoaXMgdGhyb3dzIGlmIGBhcnJheWAgaXMgbm90IGEgdmFsaWQgQXJyYXlCdWZmZXJcXG5cXG4gIGlmIChieXRlT2Zmc2V0IDwgMCB8fCBhcnJheS5ieXRlTGVuZ3RoIDwgYnl0ZU9mZnNldCkge1xcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXFxcXCdvZmZzZXRcXFxcJyBpcyBvdXQgb2YgYm91bmRzJylcXG4gIH1cXG5cXG4gIGlmIChhcnJheS5ieXRlTGVuZ3RoIDwgYnl0ZU9mZnNldCArIChsZW5ndGggfHwgMCkpIHtcXG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1xcXFwnbGVuZ3RoXFxcXCcgaXMgb3V0IG9mIGJvdW5kcycpXFxuICB9XFxuXFxuICBpZiAoYnl0ZU9mZnNldCA9PT0gdW5kZWZpbmVkICYmIGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XFxuICAgIGFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXkpXFxuICB9IGVsc2UgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XFxuICAgIGFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXksIGJ5dGVPZmZzZXQpXFxuICB9IGVsc2Uge1xcbiAgICBhcnJheSA9IG5ldyBVaW50OEFycmF5KGFycmF5LCBieXRlT2Zmc2V0LCBsZW5ndGgpXFxuICB9XFxuXFxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcXG4gICAgLy8gUmV0dXJuIGFuIGF1Z21lbnRlZCBgVWludDhBcnJheWAgaW5zdGFuY2UsIGZvciBiZXN0IHBlcmZvcm1hbmNlXFxuICAgIHRoYXQgPSBhcnJheVxcbiAgICB0aGF0Ll9fcHJvdG9fXyA9IEJ1ZmZlci5wcm90b3R5cGVcXG4gIH0gZWxzZSB7XFxuICAgIC8vIEZhbGxiYWNrOiBSZXR1cm4gYW4gb2JqZWN0IGluc3RhbmNlIG9mIHRoZSBCdWZmZXIgY2xhc3NcXG4gICAgdGhhdCA9IGZyb21BcnJheUxpa2UodGhhdCwgYXJyYXkpXFxuICB9XFxuICByZXR1cm4gdGhhdFxcbn1cXG5cXG5mdW5jdGlvbiBmcm9tT2JqZWN0ICh0aGF0LCBvYmopIHtcXG4gIGlmIChCdWZmZXIuaXNCdWZmZXIob2JqKSkge1xcbiAgICB2YXIgbGVuID0gY2hlY2tlZChvYmoubGVuZ3RoKSB8IDBcXG4gICAgdGhhdCA9IGNyZWF0ZUJ1ZmZlcih0aGF0LCBsZW4pXFxuXFxuICAgIGlmICh0aGF0Lmxlbmd0aCA9PT0gMCkge1xcbiAgICAgIHJldHVybiB0aGF0XFxuICAgIH1cXG5cXG4gICAgb2JqLmNvcHkodGhhdCwgMCwgMCwgbGVuKVxcbiAgICByZXR1cm4gdGhhdFxcbiAgfVxcblxcbiAgaWYgKG9iaikge1xcbiAgICBpZiAoKHR5cGVvZiBBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcgJiZcXG4gICAgICAgIG9iai5idWZmZXIgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikgfHwgJ2xlbmd0aCcgaW4gb2JqKSB7XFxuICAgICAgaWYgKHR5cGVvZiBvYmoubGVuZ3RoICE9PSAnbnVtYmVyJyB8fCBpc25hbihvYmoubGVuZ3RoKSkge1xcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcih0aGF0LCAwKVxcbiAgICAgIH1cXG4gICAgICByZXR1cm4gZnJvbUFycmF5TGlrZSh0aGF0LCBvYmopXFxuICAgIH1cXG5cXG4gICAgaWYgKG9iai50eXBlID09PSAnQnVmZmVyJyAmJiBpc0FycmF5KG9iai5kYXRhKSkge1xcbiAgICAgIHJldHVybiBmcm9tQXJyYXlMaWtlKHRoYXQsIG9iai5kYXRhKVxcbiAgICB9XFxuICB9XFxuXFxuICB0aHJvdyBuZXcgVHlwZUVycm9yKCdGaXJzdCBhcmd1bWVudCBtdXN0IGJlIGEgc3RyaW5nLCBCdWZmZXIsIEFycmF5QnVmZmVyLCBBcnJheSwgb3IgYXJyYXktbGlrZSBvYmplY3QuJylcXG59XFxuXFxuZnVuY3Rpb24gY2hlY2tlZCAobGVuZ3RoKSB7XFxuICAvLyBOb3RlOiBjYW5ub3QgdXNlIGBsZW5ndGggPCBrTWF4TGVuZ3RoKClgIGhlcmUgYmVjYXVzZSB0aGF0IGZhaWxzIHdoZW5cXG4gIC8vIGxlbmd0aCBpcyBOYU4gKHdoaWNoIGlzIG90aGVyd2lzZSBjb2VyY2VkIHRvIHplcm8uKVxcbiAgaWYgKGxlbmd0aCA+PSBrTWF4TGVuZ3RoKCkpIHtcXG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0F0dGVtcHQgdG8gYWxsb2NhdGUgQnVmZmVyIGxhcmdlciB0aGFuIG1heGltdW0gJyArXFxuICAgICAgICAgICAgICAgICAgICAgICAgICdzaXplOiAweCcgKyBrTWF4TGVuZ3RoKCkudG9TdHJpbmcoMTYpICsgJyBieXRlcycpXFxuICB9XFxuICByZXR1cm4gbGVuZ3RoIHwgMFxcbn1cXG5cXG5mdW5jdGlvbiBTbG93QnVmZmVyIChsZW5ndGgpIHtcXG4gIGlmICgrbGVuZ3RoICE9IGxlbmd0aCkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGVxZXFlcVxcbiAgICBsZW5ndGggPSAwXFxuICB9XFxuICByZXR1cm4gQnVmZmVyLmFsbG9jKCtsZW5ndGgpXFxufVxcblxcbkJ1ZmZlci5pc0J1ZmZlciA9IGZ1bmN0aW9uIGlzQnVmZmVyIChiKSB7XFxuICByZXR1cm4gISEoYiAhPSBudWxsICYmIGIuX2lzQnVmZmVyKVxcbn1cXG5cXG5CdWZmZXIuY29tcGFyZSA9IGZ1bmN0aW9uIGNvbXBhcmUgKGEsIGIpIHtcXG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGEpIHx8ICFCdWZmZXIuaXNCdWZmZXIoYikpIHtcXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnRzIG11c3QgYmUgQnVmZmVycycpXFxuICB9XFxuXFxuICBpZiAoYSA9PT0gYikgcmV0dXJuIDBcXG5cXG4gIHZhciB4ID0gYS5sZW5ndGhcXG4gIHZhciB5ID0gYi5sZW5ndGhcXG5cXG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSBNYXRoLm1pbih4LCB5KTsgaSA8IGxlbjsgKytpKSB7XFxuICAgIGlmIChhW2ldICE9PSBiW2ldKSB7XFxuICAgICAgeCA9IGFbaV1cXG4gICAgICB5ID0gYltpXVxcbiAgICAgIGJyZWFrXFxuICAgIH1cXG4gIH1cXG5cXG4gIGlmICh4IDwgeSkgcmV0dXJuIC0xXFxuICBpZiAoeSA8IHgpIHJldHVybiAxXFxuICByZXR1cm4gMFxcbn1cXG5cXG5CdWZmZXIuaXNFbmNvZGluZyA9IGZ1bmN0aW9uIGlzRW5jb2RpbmcgKGVuY29kaW5nKSB7XFxuICBzd2l0Y2ggKFN0cmluZyhlbmNvZGluZykudG9Mb3dlckNhc2UoKSkge1xcbiAgICBjYXNlICdoZXgnOlxcbiAgICBjYXNlICd1dGY4JzpcXG4gICAgY2FzZSAndXRmLTgnOlxcbiAgICBjYXNlICdhc2NpaSc6XFxuICAgIGNhc2UgJ2xhdGluMSc6XFxuICAgIGNhc2UgJ2JpbmFyeSc6XFxuICAgIGNhc2UgJ2Jhc2U2NCc6XFxuICAgIGNhc2UgJ3VjczInOlxcbiAgICBjYXNlICd1Y3MtMic6XFxuICAgIGNhc2UgJ3V0ZjE2bGUnOlxcbiAgICBjYXNlICd1dGYtMTZsZSc6XFxuICAgICAgcmV0dXJuIHRydWVcXG4gICAgZGVmYXVsdDpcXG4gICAgICByZXR1cm4gZmFsc2VcXG4gIH1cXG59XFxuXFxuQnVmZmVyLmNvbmNhdCA9IGZ1bmN0aW9uIGNvbmNhdCAobGlzdCwgbGVuZ3RoKSB7XFxuICBpZiAoIWlzQXJyYXkobGlzdCkpIHtcXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXFxcImxpc3RcXFwiIGFyZ3VtZW50IG11c3QgYmUgYW4gQXJyYXkgb2YgQnVmZmVycycpXFxuICB9XFxuXFxuICBpZiAobGlzdC5sZW5ndGggPT09IDApIHtcXG4gICAgcmV0dXJuIEJ1ZmZlci5hbGxvYygwKVxcbiAgfVxcblxcbiAgdmFyIGlcXG4gIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCkge1xcbiAgICBsZW5ndGggPSAwXFxuICAgIGZvciAoaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgKytpKSB7XFxuICAgICAgbGVuZ3RoICs9IGxpc3RbaV0ubGVuZ3RoXFxuICAgIH1cXG4gIH1cXG5cXG4gIHZhciBidWZmZXIgPSBCdWZmZXIuYWxsb2NVbnNhZmUobGVuZ3RoKVxcbiAgdmFyIHBvcyA9IDBcXG4gIGZvciAoaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgKytpKSB7XFxuICAgIHZhciBidWYgPSBsaXN0W2ldXFxuICAgIGlmICghQnVmZmVyLmlzQnVmZmVyKGJ1ZikpIHtcXG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcXFwibGlzdFxcXCIgYXJndW1lbnQgbXVzdCBiZSBhbiBBcnJheSBvZiBCdWZmZXJzJylcXG4gICAgfVxcbiAgICBidWYuY29weShidWZmZXIsIHBvcylcXG4gICAgcG9zICs9IGJ1Zi5sZW5ndGhcXG4gIH1cXG4gIHJldHVybiBidWZmZXJcXG59XFxuXFxuZnVuY3Rpb24gYnl0ZUxlbmd0aCAoc3RyaW5nLCBlbmNvZGluZykge1xcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihzdHJpbmcpKSB7XFxuICAgIHJldHVybiBzdHJpbmcubGVuZ3RoXFxuICB9XFxuICBpZiAodHlwZW9mIEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgQXJyYXlCdWZmZXIuaXNWaWV3ID09PSAnZnVuY3Rpb24nICYmXFxuICAgICAgKEFycmF5QnVmZmVyLmlzVmlldyhzdHJpbmcpIHx8IHN0cmluZyBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSkge1xcbiAgICByZXR1cm4gc3RyaW5nLmJ5dGVMZW5ndGhcXG4gIH1cXG4gIGlmICh0eXBlb2Ygc3RyaW5nICE9PSAnc3RyaW5nJykge1xcbiAgICBzdHJpbmcgPSAnJyArIHN0cmluZ1xcbiAgfVxcblxcbiAgdmFyIGxlbiA9IHN0cmluZy5sZW5ndGhcXG4gIGlmIChsZW4gPT09IDApIHJldHVybiAwXFxuXFxuICAvLyBVc2UgYSBmb3IgbG9vcCB0byBhdm9pZCByZWN1cnNpb25cXG4gIHZhciBsb3dlcmVkQ2FzZSA9IGZhbHNlXFxuICBmb3IgKDs7KSB7XFxuICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcXG4gICAgICBjYXNlICdhc2NpaSc6XFxuICAgICAgY2FzZSAnbGF0aW4xJzpcXG4gICAgICBjYXNlICdiaW5hcnknOlxcbiAgICAgICAgcmV0dXJuIGxlblxcbiAgICAgIGNhc2UgJ3V0ZjgnOlxcbiAgICAgIGNhc2UgJ3V0Zi04JzpcXG4gICAgICBjYXNlIHVuZGVmaW5lZDpcXG4gICAgICAgIHJldHVybiB1dGY4VG9CeXRlcyhzdHJpbmcpLmxlbmd0aFxcbiAgICAgIGNhc2UgJ3VjczInOlxcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcXG4gICAgICBjYXNlICd1dGYxNmxlJzpcXG4gICAgICBjYXNlICd1dGYtMTZsZSc6XFxuICAgICAgICByZXR1cm4gbGVuICogMlxcbiAgICAgIGNhc2UgJ2hleCc6XFxuICAgICAgICByZXR1cm4gbGVuID4+PiAxXFxuICAgICAgY2FzZSAnYmFzZTY0JzpcXG4gICAgICAgIHJldHVybiBiYXNlNjRUb0J5dGVzKHN0cmluZykubGVuZ3RoXFxuICAgICAgZGVmYXVsdDpcXG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSkgcmV0dXJuIHV0ZjhUb0J5dGVzKHN0cmluZykubGVuZ3RoIC8vIGFzc3VtZSB1dGY4XFxuICAgICAgICBlbmNvZGluZyA9ICgnJyArIGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpXFxuICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWVcXG4gICAgfVxcbiAgfVxcbn1cXG5CdWZmZXIuYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGhcXG5cXG5mdW5jdGlvbiBzbG93VG9TdHJpbmcgKGVuY29kaW5nLCBzdGFydCwgZW5kKSB7XFxuICB2YXIgbG93ZXJlZENhc2UgPSBmYWxzZVxcblxcbiAgLy8gTm8gbmVlZCB0byB2ZXJpZnkgdGhhdCBcXFwidGhpcy5sZW5ndGggPD0gTUFYX1VJTlQzMlxcXCIgc2luY2UgaXQncyBhIHJlYWQtb25seVxcbiAgLy8gcHJvcGVydHkgb2YgYSB0eXBlZCBhcnJheS5cXG5cXG4gIC8vIFRoaXMgYmVoYXZlcyBuZWl0aGVyIGxpa2UgU3RyaW5nIG5vciBVaW50OEFycmF5IGluIHRoYXQgd2Ugc2V0IHN0YXJ0L2VuZFxcbiAgLy8gdG8gdGhlaXIgdXBwZXIvbG93ZXIgYm91bmRzIGlmIHRoZSB2YWx1ZSBwYXNzZWQgaXMgb3V0IG9mIHJhbmdlLlxcbiAgLy8gdW5kZWZpbmVkIGlzIGhhbmRsZWQgc3BlY2lhbGx5IGFzIHBlciBFQ01BLTI2MiA2dGggRWRpdGlvbixcXG4gIC8vIFNlY3Rpb24gMTMuMy4zLjcgUnVudGltZSBTZW1hbnRpY3M6IEtleWVkQmluZGluZ0luaXRpYWxpemF0aW9uLlxcbiAgaWYgKHN0YXJ0ID09PSB1bmRlZmluZWQgfHwgc3RhcnQgPCAwKSB7XFxuICAgIHN0YXJ0ID0gMFxcbiAgfVxcbiAgLy8gUmV0dXJuIGVhcmx5IGlmIHN0YXJ0ID4gdGhpcy5sZW5ndGguIERvbmUgaGVyZSB0byBwcmV2ZW50IHBvdGVudGlhbCB1aW50MzJcXG4gIC8vIGNvZXJjaW9uIGZhaWwgYmVsb3cuXFxuICBpZiAoc3RhcnQgPiB0aGlzLmxlbmd0aCkge1xcbiAgICByZXR1cm4gJydcXG4gIH1cXG5cXG4gIGlmIChlbmQgPT09IHVuZGVmaW5lZCB8fCBlbmQgPiB0aGlzLmxlbmd0aCkge1xcbiAgICBlbmQgPSB0aGlzLmxlbmd0aFxcbiAgfVxcblxcbiAgaWYgKGVuZCA8PSAwKSB7XFxuICAgIHJldHVybiAnJ1xcbiAgfVxcblxcbiAgLy8gRm9yY2UgY29lcnNpb24gdG8gdWludDMyLiBUaGlzIHdpbGwgYWxzbyBjb2VyY2UgZmFsc2V5L05hTiB2YWx1ZXMgdG8gMC5cXG4gIGVuZCA+Pj49IDBcXG4gIHN0YXJ0ID4+Pj0gMFxcblxcbiAgaWYgKGVuZCA8PSBzdGFydCkge1xcbiAgICByZXR1cm4gJydcXG4gIH1cXG5cXG4gIGlmICghZW5jb2RpbmcpIGVuY29kaW5nID0gJ3V0ZjgnXFxuXFxuICB3aGlsZSAodHJ1ZSkge1xcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XFxuICAgICAgY2FzZSAnaGV4JzpcXG4gICAgICAgIHJldHVybiBoZXhTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxcblxcbiAgICAgIGNhc2UgJ3V0ZjgnOlxcbiAgICAgIGNhc2UgJ3V0Zi04JzpcXG4gICAgICAgIHJldHVybiB1dGY4U2xpY2UodGhpcywgc3RhcnQsIGVuZClcXG5cXG4gICAgICBjYXNlICdhc2NpaSc6XFxuICAgICAgICByZXR1cm4gYXNjaWlTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxcblxcbiAgICAgIGNhc2UgJ2xhdGluMSc6XFxuICAgICAgY2FzZSAnYmluYXJ5JzpcXG4gICAgICAgIHJldHVybiBsYXRpbjFTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxcblxcbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XFxuICAgICAgICByZXR1cm4gYmFzZTY0U2xpY2UodGhpcywgc3RhcnQsIGVuZClcXG5cXG4gICAgICBjYXNlICd1Y3MyJzpcXG4gICAgICBjYXNlICd1Y3MtMic6XFxuICAgICAgY2FzZSAndXRmMTZsZSc6XFxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxcbiAgICAgICAgcmV0dXJuIHV0ZjE2bGVTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxcblxcbiAgICAgIGRlZmF1bHQ6XFxuICAgICAgICBpZiAobG93ZXJlZENhc2UpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcXG4gICAgICAgIGVuY29kaW5nID0gKGVuY29kaW5nICsgJycpLnRvTG93ZXJDYXNlKClcXG4gICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZVxcbiAgICB9XFxuICB9XFxufVxcblxcbi8vIFRoZSBwcm9wZXJ0eSBpcyB1c2VkIGJ5IGBCdWZmZXIuaXNCdWZmZXJgIGFuZCBgaXMtYnVmZmVyYCAoaW4gU2FmYXJpIDUtNykgdG8gZGV0ZWN0XFxuLy8gQnVmZmVyIGluc3RhbmNlcy5cXG5CdWZmZXIucHJvdG90eXBlLl9pc0J1ZmZlciA9IHRydWVcXG5cXG5mdW5jdGlvbiBzd2FwIChiLCBuLCBtKSB7XFxuICB2YXIgaSA9IGJbbl1cXG4gIGJbbl0gPSBiW21dXFxuICBiW21dID0gaVxcbn1cXG5cXG5CdWZmZXIucHJvdG90eXBlLnN3YXAxNiA9IGZ1bmN0aW9uIHN3YXAxNiAoKSB7XFxuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcXG4gIGlmIChsZW4gJSAyICE9PSAwKSB7XFxuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgMTYtYml0cycpXFxuICB9XFxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSArPSAyKSB7XFxuICAgIHN3YXAodGhpcywgaSwgaSArIDEpXFxuICB9XFxuICByZXR1cm4gdGhpc1xcbn1cXG5cXG5CdWZmZXIucHJvdG90eXBlLnN3YXAzMiA9IGZ1bmN0aW9uIHN3YXAzMiAoKSB7XFxuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcXG4gIGlmIChsZW4gJSA0ICE9PSAwKSB7XFxuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgMzItYml0cycpXFxuICB9XFxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSArPSA0KSB7XFxuICAgIHN3YXAodGhpcywgaSwgaSArIDMpXFxuICAgIHN3YXAodGhpcywgaSArIDEsIGkgKyAyKVxcbiAgfVxcbiAgcmV0dXJuIHRoaXNcXG59XFxuXFxuQnVmZmVyLnByb3RvdHlwZS5zd2FwNjQgPSBmdW5jdGlvbiBzd2FwNjQgKCkge1xcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXFxuICBpZiAobGVuICUgOCAhPT0gMCkge1xcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDY0LWJpdHMnKVxcbiAgfVxcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkgKz0gOCkge1xcbiAgICBzd2FwKHRoaXMsIGksIGkgKyA3KVxcbiAgICBzd2FwKHRoaXMsIGkgKyAxLCBpICsgNilcXG4gICAgc3dhcCh0aGlzLCBpICsgMiwgaSArIDUpXFxuICAgIHN3YXAodGhpcywgaSArIDMsIGkgKyA0KVxcbiAgfVxcbiAgcmV0dXJuIHRoaXNcXG59XFxuXFxuQnVmZmVyLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nICgpIHtcXG4gIHZhciBsZW5ndGggPSB0aGlzLmxlbmd0aCB8IDBcXG4gIGlmIChsZW5ndGggPT09IDApIHJldHVybiAnJ1xcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHJldHVybiB1dGY4U2xpY2UodGhpcywgMCwgbGVuZ3RoKVxcbiAgcmV0dXJuIHNsb3dUb1N0cmluZy5hcHBseSh0aGlzLCBhcmd1bWVudHMpXFxufVxcblxcbkJ1ZmZlci5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24gZXF1YWxzIChiKSB7XFxuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihiKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlcicpXFxuICBpZiAodGhpcyA9PT0gYikgcmV0dXJuIHRydWVcXG4gIHJldHVybiBCdWZmZXIuY29tcGFyZSh0aGlzLCBiKSA9PT0gMFxcbn1cXG5cXG5CdWZmZXIucHJvdG90eXBlLmluc3BlY3QgPSBmdW5jdGlvbiBpbnNwZWN0ICgpIHtcXG4gIHZhciBzdHIgPSAnJ1xcbiAgdmFyIG1heCA9IGV4cG9ydHMuSU5TUEVDVF9NQVhfQllURVNcXG4gIGlmICh0aGlzLmxlbmd0aCA+IDApIHtcXG4gICAgc3RyID0gdGhpcy50b1N0cmluZygnaGV4JywgMCwgbWF4KS5tYXRjaCgvLnsyfS9nKS5qb2luKCcgJylcXG4gICAgaWYgKHRoaXMubGVuZ3RoID4gbWF4KSBzdHIgKz0gJyAuLi4gJ1xcbiAgfVxcbiAgcmV0dXJuICc8QnVmZmVyICcgKyBzdHIgKyAnPidcXG59XFxuXFxuQnVmZmVyLnByb3RvdHlwZS5jb21wYXJlID0gZnVuY3Rpb24gY29tcGFyZSAodGFyZ2V0LCBzdGFydCwgZW5kLCB0aGlzU3RhcnQsIHRoaXNFbmQpIHtcXG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKHRhcmdldCkpIHtcXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlcicpXFxuICB9XFxuXFxuICBpZiAoc3RhcnQgPT09IHVuZGVmaW5lZCkge1xcbiAgICBzdGFydCA9IDBcXG4gIH1cXG4gIGlmIChlbmQgPT09IHVuZGVmaW5lZCkge1xcbiAgICBlbmQgPSB0YXJnZXQgPyB0YXJnZXQubGVuZ3RoIDogMFxcbiAgfVxcbiAgaWYgKHRoaXNTdGFydCA9PT0gdW5kZWZpbmVkKSB7XFxuICAgIHRoaXNTdGFydCA9IDBcXG4gIH1cXG4gIGlmICh0aGlzRW5kID09PSB1bmRlZmluZWQpIHtcXG4gICAgdGhpc0VuZCA9IHRoaXMubGVuZ3RoXFxuICB9XFxuXFxuICBpZiAoc3RhcnQgPCAwIHx8IGVuZCA+IHRhcmdldC5sZW5ndGggfHwgdGhpc1N0YXJ0IDwgMCB8fCB0aGlzRW5kID4gdGhpcy5sZW5ndGgpIHtcXG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ291dCBvZiByYW5nZSBpbmRleCcpXFxuICB9XFxuXFxuICBpZiAodGhpc1N0YXJ0ID49IHRoaXNFbmQgJiYgc3RhcnQgPj0gZW5kKSB7XFxuICAgIHJldHVybiAwXFxuICB9XFxuICBpZiAodGhpc1N0YXJ0ID49IHRoaXNFbmQpIHtcXG4gICAgcmV0dXJuIC0xXFxuICB9XFxuICBpZiAoc3RhcnQgPj0gZW5kKSB7XFxuICAgIHJldHVybiAxXFxuICB9XFxuXFxuICBzdGFydCA+Pj49IDBcXG4gIGVuZCA+Pj49IDBcXG4gIHRoaXNTdGFydCA+Pj49IDBcXG4gIHRoaXNFbmQgPj4+PSAwXFxuXFxuICBpZiAodGhpcyA9PT0gdGFyZ2V0KSByZXR1cm4gMFxcblxcbiAgdmFyIHggPSB0aGlzRW5kIC0gdGhpc1N0YXJ0XFxuICB2YXIgeSA9IGVuZCAtIHN0YXJ0XFxuICB2YXIgbGVuID0gTWF0aC5taW4oeCwgeSlcXG5cXG4gIHZhciB0aGlzQ29weSA9IHRoaXMuc2xpY2UodGhpc1N0YXJ0LCB0aGlzRW5kKVxcbiAgdmFyIHRhcmdldENvcHkgPSB0YXJnZXQuc2xpY2Uoc3RhcnQsIGVuZClcXG5cXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcXG4gICAgaWYgKHRoaXNDb3B5W2ldICE9PSB0YXJnZXRDb3B5W2ldKSB7XFxuICAgICAgeCA9IHRoaXNDb3B5W2ldXFxuICAgICAgeSA9IHRhcmdldENvcHlbaV1cXG4gICAgICBicmVha1xcbiAgICB9XFxuICB9XFxuXFxuICBpZiAoeCA8IHkpIHJldHVybiAtMVxcbiAgaWYgKHkgPCB4KSByZXR1cm4gMVxcbiAgcmV0dXJuIDBcXG59XFxuXFxuLy8gRmluZHMgZWl0aGVyIHRoZSBmaXJzdCBpbmRleCBvZiBgdmFsYCBpbiBgYnVmZmVyYCBhdCBvZmZzZXQgPj0gYGJ5dGVPZmZzZXRgLFxcbi8vIE9SIHRoZSBsYXN0IGluZGV4IG9mIGB2YWxgIGluIGBidWZmZXJgIGF0IG9mZnNldCA8PSBgYnl0ZU9mZnNldGAuXFxuLy9cXG4vLyBBcmd1bWVudHM6XFxuLy8gLSBidWZmZXIgLSBhIEJ1ZmZlciB0byBzZWFyY2hcXG4vLyAtIHZhbCAtIGEgc3RyaW5nLCBCdWZmZXIsIG9yIG51bWJlclxcbi8vIC0gYnl0ZU9mZnNldCAtIGFuIGluZGV4IGludG8gYGJ1ZmZlcmA7IHdpbGwgYmUgY2xhbXBlZCB0byBhbiBpbnQzMlxcbi8vIC0gZW5jb2RpbmcgLSBhbiBvcHRpb25hbCBlbmNvZGluZywgcmVsZXZhbnQgaXMgdmFsIGlzIGEgc3RyaW5nXFxuLy8gLSBkaXIgLSB0cnVlIGZvciBpbmRleE9mLCBmYWxzZSBmb3IgbGFzdEluZGV4T2ZcXG5mdW5jdGlvbiBiaWRpcmVjdGlvbmFsSW5kZXhPZiAoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpIHtcXG4gIC8vIEVtcHR5IGJ1ZmZlciBtZWFucyBubyBtYXRjaFxcbiAgaWYgKGJ1ZmZlci5sZW5ndGggPT09IDApIHJldHVybiAtMVxcblxcbiAgLy8gTm9ybWFsaXplIGJ5dGVPZmZzZXRcXG4gIGlmICh0eXBlb2YgYnl0ZU9mZnNldCA9PT0gJ3N0cmluZycpIHtcXG4gICAgZW5jb2RpbmcgPSBieXRlT2Zmc2V0XFxuICAgIGJ5dGVPZmZzZXQgPSAwXFxuICB9IGVsc2UgaWYgKGJ5dGVPZmZzZXQgPiAweDdmZmZmZmZmKSB7XFxuICAgIGJ5dGVPZmZzZXQgPSAweDdmZmZmZmZmXFxuICB9IGVsc2UgaWYgKGJ5dGVPZmZzZXQgPCAtMHg4MDAwMDAwMCkge1xcbiAgICBieXRlT2Zmc2V0ID0gLTB4ODAwMDAwMDBcXG4gIH1cXG4gIGJ5dGVPZmZzZXQgPSArYnl0ZU9mZnNldCAgLy8gQ29lcmNlIHRvIE51bWJlci5cXG4gIGlmIChpc05hTihieXRlT2Zmc2V0KSkge1xcbiAgICAvLyBieXRlT2Zmc2V0OiBpdCBpdCdzIHVuZGVmaW5lZCwgbnVsbCwgTmFOLCBcXFwiZm9vXFxcIiwgZXRjLCBzZWFyY2ggd2hvbGUgYnVmZmVyXFxuICAgIGJ5dGVPZmZzZXQgPSBkaXIgPyAwIDogKGJ1ZmZlci5sZW5ndGggLSAxKVxcbiAgfVxcblxcbiAgLy8gTm9ybWFsaXplIGJ5dGVPZmZzZXQ6IG5lZ2F0aXZlIG9mZnNldHMgc3RhcnQgZnJvbSB0aGUgZW5kIG9mIHRoZSBidWZmZXJcXG4gIGlmIChieXRlT2Zmc2V0IDwgMCkgYnl0ZU9mZnNldCA9IGJ1ZmZlci5sZW5ndGggKyBieXRlT2Zmc2V0XFxuICBpZiAoYnl0ZU9mZnNldCA+PSBidWZmZXIubGVuZ3RoKSB7XFxuICAgIGlmIChkaXIpIHJldHVybiAtMVxcbiAgICBlbHNlIGJ5dGVPZmZzZXQgPSBidWZmZXIubGVuZ3RoIC0gMVxcbiAgfSBlbHNlIGlmIChieXRlT2Zmc2V0IDwgMCkge1xcbiAgICBpZiAoZGlyKSBieXRlT2Zmc2V0ID0gMFxcbiAgICBlbHNlIHJldHVybiAtMVxcbiAgfVxcblxcbiAgLy8gTm9ybWFsaXplIHZhbFxcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XFxuICAgIHZhbCA9IEJ1ZmZlci5mcm9tKHZhbCwgZW5jb2RpbmcpXFxuICB9XFxuXFxuICAvLyBGaW5hbGx5LCBzZWFyY2ggZWl0aGVyIGluZGV4T2YgKGlmIGRpciBpcyB0cnVlKSBvciBsYXN0SW5kZXhPZlxcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcih2YWwpKSB7XFxuICAgIC8vIFNwZWNpYWwgY2FzZTogbG9va2luZyBmb3IgZW1wdHkgc3RyaW5nL2J1ZmZlciBhbHdheXMgZmFpbHNcXG4gICAgaWYgKHZhbC5sZW5ndGggPT09IDApIHtcXG4gICAgICByZXR1cm4gLTFcXG4gICAgfVxcbiAgICByZXR1cm4gYXJyYXlJbmRleE9mKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKVxcbiAgfSBlbHNlIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xcbiAgICB2YWwgPSB2YWwgJiAweEZGIC8vIFNlYXJjaCBmb3IgYSBieXRlIHZhbHVlIFswLTI1NV1cXG4gICAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUICYmXFxuICAgICAgICB0eXBlb2YgVWludDhBcnJheS5wcm90b3R5cGUuaW5kZXhPZiA9PT0gJ2Z1bmN0aW9uJykge1xcbiAgICAgIGlmIChkaXIpIHtcXG4gICAgICAgIHJldHVybiBVaW50OEFycmF5LnByb3RvdHlwZS5pbmRleE9mLmNhbGwoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQpXFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIHJldHVybiBVaW50OEFycmF5LnByb3RvdHlwZS5sYXN0SW5kZXhPZi5jYWxsKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0KVxcbiAgICAgIH1cXG4gICAgfVxcbiAgICByZXR1cm4gYXJyYXlJbmRleE9mKGJ1ZmZlciwgWyB2YWwgXSwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcilcXG4gIH1cXG5cXG4gIHRocm93IG5ldyBUeXBlRXJyb3IoJ3ZhbCBtdXN0IGJlIHN0cmluZywgbnVtYmVyIG9yIEJ1ZmZlcicpXFxufVxcblxcbmZ1bmN0aW9uIGFycmF5SW5kZXhPZiAoYXJyLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpIHtcXG4gIHZhciBpbmRleFNpemUgPSAxXFxuICB2YXIgYXJyTGVuZ3RoID0gYXJyLmxlbmd0aFxcbiAgdmFyIHZhbExlbmd0aCA9IHZhbC5sZW5ndGhcXG5cXG4gIGlmIChlbmNvZGluZyAhPT0gdW5kZWZpbmVkKSB7XFxuICAgIGVuY29kaW5nID0gU3RyaW5nKGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpXFxuICAgIGlmIChlbmNvZGluZyA9PT0gJ3VjczInIHx8IGVuY29kaW5nID09PSAndWNzLTInIHx8XFxuICAgICAgICBlbmNvZGluZyA9PT0gJ3V0ZjE2bGUnIHx8IGVuY29kaW5nID09PSAndXRmLTE2bGUnKSB7XFxuICAgICAgaWYgKGFyci5sZW5ndGggPCAyIHx8IHZhbC5sZW5ndGggPCAyKSB7XFxuICAgICAgICByZXR1cm4gLTFcXG4gICAgICB9XFxuICAgICAgaW5kZXhTaXplID0gMlxcbiAgICAgIGFyckxlbmd0aCAvPSAyXFxuICAgICAgdmFsTGVuZ3RoIC89IDJcXG4gICAgICBieXRlT2Zmc2V0IC89IDJcXG4gICAgfVxcbiAgfVxcblxcbiAgZnVuY3Rpb24gcmVhZCAoYnVmLCBpKSB7XFxuICAgIGlmIChpbmRleFNpemUgPT09IDEpIHtcXG4gICAgICByZXR1cm4gYnVmW2ldXFxuICAgIH0gZWxzZSB7XFxuICAgICAgcmV0dXJuIGJ1Zi5yZWFkVUludDE2QkUoaSAqIGluZGV4U2l6ZSlcXG4gICAgfVxcbiAgfVxcblxcbiAgdmFyIGlcXG4gIGlmIChkaXIpIHtcXG4gICAgdmFyIGZvdW5kSW5kZXggPSAtMVxcbiAgICBmb3IgKGkgPSBieXRlT2Zmc2V0OyBpIDwgYXJyTGVuZ3RoOyBpKyspIHtcXG4gICAgICBpZiAocmVhZChhcnIsIGkpID09PSByZWFkKHZhbCwgZm91bmRJbmRleCA9PT0gLTEgPyAwIDogaSAtIGZvdW5kSW5kZXgpKSB7XFxuICAgICAgICBpZiAoZm91bmRJbmRleCA9PT0gLTEpIGZvdW5kSW5kZXggPSBpXFxuICAgICAgICBpZiAoaSAtIGZvdW5kSW5kZXggKyAxID09PSB2YWxMZW5ndGgpIHJldHVybiBmb3VuZEluZGV4ICogaW5kZXhTaXplXFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIGlmIChmb3VuZEluZGV4ICE9PSAtMSkgaSAtPSBpIC0gZm91bmRJbmRleFxcbiAgICAgICAgZm91bmRJbmRleCA9IC0xXFxuICAgICAgfVxcbiAgICB9XFxuICB9IGVsc2Uge1xcbiAgICBpZiAoYnl0ZU9mZnNldCArIHZhbExlbmd0aCA+IGFyckxlbmd0aCkgYnl0ZU9mZnNldCA9IGFyckxlbmd0aCAtIHZhbExlbmd0aFxcbiAgICBmb3IgKGkgPSBieXRlT2Zmc2V0OyBpID49IDA7IGktLSkge1xcbiAgICAgIHZhciBmb3VuZCA9IHRydWVcXG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHZhbExlbmd0aDsgaisrKSB7XFxuICAgICAgICBpZiAocmVhZChhcnIsIGkgKyBqKSAhPT0gcmVhZCh2YWwsIGopKSB7XFxuICAgICAgICAgIGZvdW5kID0gZmFsc2VcXG4gICAgICAgICAgYnJlYWtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuICAgICAgaWYgKGZvdW5kKSByZXR1cm4gaVxcbiAgICB9XFxuICB9XFxuXFxuICByZXR1cm4gLTFcXG59XFxuXFxuQnVmZmVyLnByb3RvdHlwZS5pbmNsdWRlcyA9IGZ1bmN0aW9uIGluY2x1ZGVzICh2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSB7XFxuICByZXR1cm4gdGhpcy5pbmRleE9mKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpICE9PSAtMVxcbn1cXG5cXG5CdWZmZXIucHJvdG90eXBlLmluZGV4T2YgPSBmdW5jdGlvbiBpbmRleE9mICh2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSB7XFxuICByZXR1cm4gYmlkaXJlY3Rpb25hbEluZGV4T2YodGhpcywgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgdHJ1ZSlcXG59XFxuXFxuQnVmZmVyLnByb3RvdHlwZS5sYXN0SW5kZXhPZiA9IGZ1bmN0aW9uIGxhc3RJbmRleE9mICh2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSB7XFxuICByZXR1cm4gYmlkaXJlY3Rpb25hbEluZGV4T2YodGhpcywgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZmFsc2UpXFxufVxcblxcbmZ1bmN0aW9uIGhleFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcXG4gIG9mZnNldCA9IE51bWJlcihvZmZzZXQpIHx8IDBcXG4gIHZhciByZW1haW5pbmcgPSBidWYubGVuZ3RoIC0gb2Zmc2V0XFxuICBpZiAoIWxlbmd0aCkge1xcbiAgICBsZW5ndGggPSByZW1haW5pbmdcXG4gIH0gZWxzZSB7XFxuICAgIGxlbmd0aCA9IE51bWJlcihsZW5ndGgpXFxuICAgIGlmIChsZW5ndGggPiByZW1haW5pbmcpIHtcXG4gICAgICBsZW5ndGggPSByZW1haW5pbmdcXG4gICAgfVxcbiAgfVxcblxcbiAgLy8gbXVzdCBiZSBhbiBldmVuIG51bWJlciBvZiBkaWdpdHNcXG4gIHZhciBzdHJMZW4gPSBzdHJpbmcubGVuZ3RoXFxuICBpZiAoc3RyTGVuICUgMiAhPT0gMCkgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBoZXggc3RyaW5nJylcXG5cXG4gIGlmIChsZW5ndGggPiBzdHJMZW4gLyAyKSB7XFxuICAgIGxlbmd0aCA9IHN0ckxlbiAvIDJcXG4gIH1cXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcXG4gICAgdmFyIHBhcnNlZCA9IHBhcnNlSW50KHN0cmluZy5zdWJzdHIoaSAqIDIsIDIpLCAxNilcXG4gICAgaWYgKGlzTmFOKHBhcnNlZCkpIHJldHVybiBpXFxuICAgIGJ1ZltvZmZzZXQgKyBpXSA9IHBhcnNlZFxcbiAgfVxcbiAgcmV0dXJuIGlcXG59XFxuXFxuZnVuY3Rpb24gdXRmOFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcXG4gIHJldHVybiBibGl0QnVmZmVyKHV0ZjhUb0J5dGVzKHN0cmluZywgYnVmLmxlbmd0aCAtIG9mZnNldCksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXFxufVxcblxcbmZ1bmN0aW9uIGFzY2lpV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xcbiAgcmV0dXJuIGJsaXRCdWZmZXIoYXNjaWlUb0J5dGVzKHN0cmluZyksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXFxufVxcblxcbmZ1bmN0aW9uIGxhdGluMVdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcXG4gIHJldHVybiBhc2NpaVdyaXRlKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcXG59XFxuXFxuZnVuY3Rpb24gYmFzZTY0V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xcbiAgcmV0dXJuIGJsaXRCdWZmZXIoYmFzZTY0VG9CeXRlcyhzdHJpbmcpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxcbn1cXG5cXG5mdW5jdGlvbiB1Y3MyV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xcbiAgcmV0dXJuIGJsaXRCdWZmZXIodXRmMTZsZVRvQnl0ZXMoc3RyaW5nLCBidWYubGVuZ3RoIC0gb2Zmc2V0KSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcXG59XFxuXFxuQnVmZmVyLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uIHdyaXRlIChzdHJpbmcsIG9mZnNldCwgbGVuZ3RoLCBlbmNvZGluZykge1xcbiAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZylcXG4gIGlmIChvZmZzZXQgPT09IHVuZGVmaW5lZCkge1xcbiAgICBlbmNvZGluZyA9ICd1dGY4J1xcbiAgICBsZW5ndGggPSB0aGlzLmxlbmd0aFxcbiAgICBvZmZzZXQgPSAwXFxuICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nLCBlbmNvZGluZylcXG4gIH0gZWxzZSBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQgJiYgdHlwZW9mIG9mZnNldCA9PT0gJ3N0cmluZycpIHtcXG4gICAgZW5jb2RpbmcgPSBvZmZzZXRcXG4gICAgbGVuZ3RoID0gdGhpcy5sZW5ndGhcXG4gICAgb2Zmc2V0ID0gMFxcbiAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZywgb2Zmc2V0WywgbGVuZ3RoXVssIGVuY29kaW5nXSlcXG4gIH0gZWxzZSBpZiAoaXNGaW5pdGUob2Zmc2V0KSkge1xcbiAgICBvZmZzZXQgPSBvZmZzZXQgfCAwXFxuICAgIGlmIChpc0Zpbml0ZShsZW5ndGgpKSB7XFxuICAgICAgbGVuZ3RoID0gbGVuZ3RoIHwgMFxcbiAgICAgIGlmIChlbmNvZGluZyA9PT0gdW5kZWZpbmVkKSBlbmNvZGluZyA9ICd1dGY4J1xcbiAgICB9IGVsc2Uge1xcbiAgICAgIGVuY29kaW5nID0gbGVuZ3RoXFxuICAgICAgbGVuZ3RoID0gdW5kZWZpbmVkXFxuICAgIH1cXG4gIC8vIGxlZ2FjeSB3cml0ZShzdHJpbmcsIGVuY29kaW5nLCBvZmZzZXQsIGxlbmd0aCkgLSByZW1vdmUgaW4gdjAuMTNcXG4gIH0gZWxzZSB7XFxuICAgIHRocm93IG5ldyBFcnJvcihcXG4gICAgICAnQnVmZmVyLndyaXRlKHN0cmluZywgZW5jb2RpbmcsIG9mZnNldFssIGxlbmd0aF0pIGlzIG5vIGxvbmdlciBzdXBwb3J0ZWQnXFxuICAgIClcXG4gIH1cXG5cXG4gIHZhciByZW1haW5pbmcgPSB0aGlzLmxlbmd0aCAtIG9mZnNldFxcbiAgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkIHx8IGxlbmd0aCA+IHJlbWFpbmluZykgbGVuZ3RoID0gcmVtYWluaW5nXFxuXFxuICBpZiAoKHN0cmluZy5sZW5ndGggPiAwICYmIChsZW5ndGggPCAwIHx8IG9mZnNldCA8IDApKSB8fCBvZmZzZXQgPiB0aGlzLmxlbmd0aCkge1xcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQXR0ZW1wdCB0byB3cml0ZSBvdXRzaWRlIGJ1ZmZlciBib3VuZHMnKVxcbiAgfVxcblxcbiAgaWYgKCFlbmNvZGluZykgZW5jb2RpbmcgPSAndXRmOCdcXG5cXG4gIHZhciBsb3dlcmVkQ2FzZSA9IGZhbHNlXFxuICBmb3IgKDs7KSB7XFxuICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcXG4gICAgICBjYXNlICdoZXgnOlxcbiAgICAgICAgcmV0dXJuIGhleFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXFxuXFxuICAgICAgY2FzZSAndXRmOCc6XFxuICAgICAgY2FzZSAndXRmLTgnOlxcbiAgICAgICAgcmV0dXJuIHV0ZjhXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxcblxcbiAgICAgIGNhc2UgJ2FzY2lpJzpcXG4gICAgICAgIHJldHVybiBhc2NpaVdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXFxuXFxuICAgICAgY2FzZSAnbGF0aW4xJzpcXG4gICAgICBjYXNlICdiaW5hcnknOlxcbiAgICAgICAgcmV0dXJuIGxhdGluMVdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXFxuXFxuICAgICAgY2FzZSAnYmFzZTY0JzpcXG4gICAgICAgIC8vIFdhcm5pbmc6IG1heExlbmd0aCBub3QgdGFrZW4gaW50byBhY2NvdW50IGluIGJhc2U2NFdyaXRlXFxuICAgICAgICByZXR1cm4gYmFzZTY0V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcXG5cXG4gICAgICBjYXNlICd1Y3MyJzpcXG4gICAgICBjYXNlICd1Y3MtMic6XFxuICAgICAgY2FzZSAndXRmMTZsZSc6XFxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxcbiAgICAgICAgcmV0dXJuIHVjczJXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxcblxcbiAgICAgIGRlZmF1bHQ6XFxuICAgICAgICBpZiAobG93ZXJlZENhc2UpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcXG4gICAgICAgIGVuY29kaW5nID0gKCcnICsgZW5jb2RpbmcpLnRvTG93ZXJDYXNlKClcXG4gICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZVxcbiAgICB9XFxuICB9XFxufVxcblxcbkJ1ZmZlci5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gdG9KU09OICgpIHtcXG4gIHJldHVybiB7XFxuICAgIHR5cGU6ICdCdWZmZXInLFxcbiAgICBkYXRhOiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCh0aGlzLl9hcnIgfHwgdGhpcywgMClcXG4gIH1cXG59XFxuXFxuZnVuY3Rpb24gYmFzZTY0U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xcbiAgaWYgKHN0YXJ0ID09PSAwICYmIGVuZCA9PT0gYnVmLmxlbmd0aCkge1xcbiAgICByZXR1cm4gYmFzZTY0LmZyb21CeXRlQXJyYXkoYnVmKVxcbiAgfSBlbHNlIHtcXG4gICAgcmV0dXJuIGJhc2U2NC5mcm9tQnl0ZUFycmF5KGJ1Zi5zbGljZShzdGFydCwgZW5kKSlcXG4gIH1cXG59XFxuXFxuZnVuY3Rpb24gdXRmOFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcXG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcXG4gIHZhciByZXMgPSBbXVxcblxcbiAgdmFyIGkgPSBzdGFydFxcbiAgd2hpbGUgKGkgPCBlbmQpIHtcXG4gICAgdmFyIGZpcnN0Qnl0ZSA9IGJ1ZltpXVxcbiAgICB2YXIgY29kZVBvaW50ID0gbnVsbFxcbiAgICB2YXIgYnl0ZXNQZXJTZXF1ZW5jZSA9IChmaXJzdEJ5dGUgPiAweEVGKSA/IDRcXG4gICAgICA6IChmaXJzdEJ5dGUgPiAweERGKSA/IDNcXG4gICAgICA6IChmaXJzdEJ5dGUgPiAweEJGKSA/IDJcXG4gICAgICA6IDFcXG5cXG4gICAgaWYgKGkgKyBieXRlc1BlclNlcXVlbmNlIDw9IGVuZCkge1xcbiAgICAgIHZhciBzZWNvbmRCeXRlLCB0aGlyZEJ5dGUsIGZvdXJ0aEJ5dGUsIHRlbXBDb2RlUG9pbnRcXG5cXG4gICAgICBzd2l0Y2ggKGJ5dGVzUGVyU2VxdWVuY2UpIHtcXG4gICAgICAgIGNhc2UgMTpcXG4gICAgICAgICAgaWYgKGZpcnN0Qnl0ZSA8IDB4ODApIHtcXG4gICAgICAgICAgICBjb2RlUG9pbnQgPSBmaXJzdEJ5dGVcXG4gICAgICAgICAgfVxcbiAgICAgICAgICBicmVha1xcbiAgICAgICAgY2FzZSAyOlxcbiAgICAgICAgICBzZWNvbmRCeXRlID0gYnVmW2kgKyAxXVxcbiAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCkge1xcbiAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHgxRikgPDwgMHg2IHwgKHNlY29uZEJ5dGUgJiAweDNGKVxcbiAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMHg3Rikge1xcbiAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludFxcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgfVxcbiAgICAgICAgICBicmVha1xcbiAgICAgICAgY2FzZSAzOlxcbiAgICAgICAgICBzZWNvbmRCeXRlID0gYnVmW2kgKyAxXVxcbiAgICAgICAgICB0aGlyZEJ5dGUgPSBidWZbaSArIDJdXFxuICAgICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDB4QzApID09PSAweDgwICYmICh0aGlyZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCkge1xcbiAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHhGKSA8PCAweEMgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpIDw8IDB4NiB8ICh0aGlyZEJ5dGUgJiAweDNGKVxcbiAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMHg3RkYgJiYgKHRlbXBDb2RlUG9pbnQgPCAweEQ4MDAgfHwgdGVtcENvZGVQb2ludCA+IDB4REZGRikpIHtcXG4gICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnRcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgIH1cXG4gICAgICAgICAgYnJlYWtcXG4gICAgICAgIGNhc2UgNDpcXG4gICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV1cXG4gICAgICAgICAgdGhpcmRCeXRlID0gYnVmW2kgKyAyXVxcbiAgICAgICAgICBmb3VydGhCeXRlID0gYnVmW2kgKyAzXVxcbiAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCAmJiAodGhpcmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKGZvdXJ0aEJ5dGUgJiAweEMwKSA9PT0gMHg4MCkge1xcbiAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHhGKSA8PCAweDEyIHwgKHNlY29uZEJ5dGUgJiAweDNGKSA8PCAweEMgfCAodGhpcmRCeXRlICYgMHgzRikgPDwgMHg2IHwgKGZvdXJ0aEJ5dGUgJiAweDNGKVxcbiAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMHhGRkZGICYmIHRlbXBDb2RlUG9pbnQgPCAweDExMDAwMCkge1xcbiAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludFxcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgfVxcbiAgICAgIH1cXG4gICAgfVxcblxcbiAgICBpZiAoY29kZVBvaW50ID09PSBudWxsKSB7XFxuICAgICAgLy8gd2UgZGlkIG5vdCBnZW5lcmF0ZSBhIHZhbGlkIGNvZGVQb2ludCBzbyBpbnNlcnQgYVxcbiAgICAgIC8vIHJlcGxhY2VtZW50IGNoYXIgKFUrRkZGRCkgYW5kIGFkdmFuY2Ugb25seSAxIGJ5dGVcXG4gICAgICBjb2RlUG9pbnQgPSAweEZGRkRcXG4gICAgICBieXRlc1BlclNlcXVlbmNlID0gMVxcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA+IDB4RkZGRikge1xcbiAgICAgIC8vIGVuY29kZSB0byB1dGYxNiAoc3Vycm9nYXRlIHBhaXIgZGFuY2UpXFxuICAgICAgY29kZVBvaW50IC09IDB4MTAwMDBcXG4gICAgICByZXMucHVzaChjb2RlUG9pbnQgPj4+IDEwICYgMHgzRkYgfCAweEQ4MDApXFxuICAgICAgY29kZVBvaW50ID0gMHhEQzAwIHwgY29kZVBvaW50ICYgMHgzRkZcXG4gICAgfVxcblxcbiAgICByZXMucHVzaChjb2RlUG9pbnQpXFxuICAgIGkgKz0gYnl0ZXNQZXJTZXF1ZW5jZVxcbiAgfVxcblxcbiAgcmV0dXJuIGRlY29kZUNvZGVQb2ludHNBcnJheShyZXMpXFxufVxcblxcbi8vIEJhc2VkIG9uIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzIyNzQ3MjcyLzY4MDc0MiwgdGhlIGJyb3dzZXIgd2l0aFxcbi8vIHRoZSBsb3dlc3QgbGltaXQgaXMgQ2hyb21lLCB3aXRoIDB4MTAwMDAgYXJncy5cXG4vLyBXZSBnbyAxIG1hZ25pdHVkZSBsZXNzLCBmb3Igc2FmZXR5XFxudmFyIE1BWF9BUkdVTUVOVFNfTEVOR1RIID0gMHgxMDAwXFxuXFxuZnVuY3Rpb24gZGVjb2RlQ29kZVBvaW50c0FycmF5IChjb2RlUG9pbnRzKSB7XFxuICB2YXIgbGVuID0gY29kZVBvaW50cy5sZW5ndGhcXG4gIGlmIChsZW4gPD0gTUFYX0FSR1VNRU5UU19MRU5HVEgpIHtcXG4gICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoU3RyaW5nLCBjb2RlUG9pbnRzKSAvLyBhdm9pZCBleHRyYSBzbGljZSgpXFxuICB9XFxuXFxuICAvLyBEZWNvZGUgaW4gY2h1bmtzIHRvIGF2b2lkIFxcXCJjYWxsIHN0YWNrIHNpemUgZXhjZWVkZWRcXFwiLlxcbiAgdmFyIHJlcyA9ICcnXFxuICB2YXIgaSA9IDBcXG4gIHdoaWxlIChpIDwgbGVuKSB7XFxuICAgIHJlcyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFxcbiAgICAgIFN0cmluZyxcXG4gICAgICBjb2RlUG9pbnRzLnNsaWNlKGksIGkgKz0gTUFYX0FSR1VNRU5UU19MRU5HVEgpXFxuICAgIClcXG4gIH1cXG4gIHJldHVybiByZXNcXG59XFxuXFxuZnVuY3Rpb24gYXNjaWlTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XFxuICB2YXIgcmV0ID0gJydcXG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcXG5cXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XFxuICAgIHJldCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZltpXSAmIDB4N0YpXFxuICB9XFxuICByZXR1cm4gcmV0XFxufVxcblxcbmZ1bmN0aW9uIGxhdGluMVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcXG4gIHZhciByZXQgPSAnJ1xcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxcblxcbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcXG4gICAgcmV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmW2ldKVxcbiAgfVxcbiAgcmV0dXJuIHJldFxcbn1cXG5cXG5mdW5jdGlvbiBoZXhTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XFxuICB2YXIgbGVuID0gYnVmLmxlbmd0aFxcblxcbiAgaWYgKCFzdGFydCB8fCBzdGFydCA8IDApIHN0YXJ0ID0gMFxcbiAgaWYgKCFlbmQgfHwgZW5kIDwgMCB8fCBlbmQgPiBsZW4pIGVuZCA9IGxlblxcblxcbiAgdmFyIG91dCA9ICcnXFxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xcbiAgICBvdXQgKz0gdG9IZXgoYnVmW2ldKVxcbiAgfVxcbiAgcmV0dXJuIG91dFxcbn1cXG5cXG5mdW5jdGlvbiB1dGYxNmxlU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xcbiAgdmFyIGJ5dGVzID0gYnVmLnNsaWNlKHN0YXJ0LCBlbmQpXFxuICB2YXIgcmVzID0gJydcXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpICs9IDIpIHtcXG4gICAgcmVzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnl0ZXNbaV0gKyBieXRlc1tpICsgMV0gKiAyNTYpXFxuICB9XFxuICByZXR1cm4gcmVzXFxufVxcblxcbkJ1ZmZlci5wcm90b3R5cGUuc2xpY2UgPSBmdW5jdGlvbiBzbGljZSAoc3RhcnQsIGVuZCkge1xcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXFxuICBzdGFydCA9IH5+c3RhcnRcXG4gIGVuZCA9IGVuZCA9PT0gdW5kZWZpbmVkID8gbGVuIDogfn5lbmRcXG5cXG4gIGlmIChzdGFydCA8IDApIHtcXG4gICAgc3RhcnQgKz0gbGVuXFxuICAgIGlmIChzdGFydCA8IDApIHN0YXJ0ID0gMFxcbiAgfSBlbHNlIGlmIChzdGFydCA+IGxlbikge1xcbiAgICBzdGFydCA9IGxlblxcbiAgfVxcblxcbiAgaWYgKGVuZCA8IDApIHtcXG4gICAgZW5kICs9IGxlblxcbiAgICBpZiAoZW5kIDwgMCkgZW5kID0gMFxcbiAgfSBlbHNlIGlmIChlbmQgPiBsZW4pIHtcXG4gICAgZW5kID0gbGVuXFxuICB9XFxuXFxuICBpZiAoZW5kIDwgc3RhcnQpIGVuZCA9IHN0YXJ0XFxuXFxuICB2YXIgbmV3QnVmXFxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcXG4gICAgbmV3QnVmID0gdGhpcy5zdWJhcnJheShzdGFydCwgZW5kKVxcbiAgICBuZXdCdWYuX19wcm90b19fID0gQnVmZmVyLnByb3RvdHlwZVxcbiAgfSBlbHNlIHtcXG4gICAgdmFyIHNsaWNlTGVuID0gZW5kIC0gc3RhcnRcXG4gICAgbmV3QnVmID0gbmV3IEJ1ZmZlcihzbGljZUxlbiwgdW5kZWZpbmVkKVxcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNsaWNlTGVuOyArK2kpIHtcXG4gICAgICBuZXdCdWZbaV0gPSB0aGlzW2kgKyBzdGFydF1cXG4gICAgfVxcbiAgfVxcblxcbiAgcmV0dXJuIG5ld0J1Zlxcbn1cXG5cXG4vKlxcbiAqIE5lZWQgdG8gbWFrZSBzdXJlIHRoYXQgYnVmZmVyIGlzbid0IHRyeWluZyB0byB3cml0ZSBvdXQgb2YgYm91bmRzLlxcbiAqL1xcbmZ1bmN0aW9uIGNoZWNrT2Zmc2V0IChvZmZzZXQsIGV4dCwgbGVuZ3RoKSB7XFxuICBpZiAoKG9mZnNldCAlIDEpICE9PSAwIHx8IG9mZnNldCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdvZmZzZXQgaXMgbm90IHVpbnQnKVxcbiAgaWYgKG9mZnNldCArIGV4dCA+IGxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RyeWluZyB0byBhY2Nlc3MgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKVxcbn1cXG5cXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50TEUgPSBmdW5jdGlvbiByZWFkVUludExFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XFxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXFxuXFxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXRdXFxuICB2YXIgbXVsID0gMVxcbiAgdmFyIGkgPSAwXFxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyBpXSAqIG11bFxcbiAgfVxcblxcbiAgcmV0dXJuIHZhbFxcbn1cXG5cXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50QkUgPSBmdW5jdGlvbiByZWFkVUludEJFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XFxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcXG4gIGlmICghbm9Bc3NlcnQpIHtcXG4gICAgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcXG4gIH1cXG5cXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldCArIC0tYnl0ZUxlbmd0aF1cXG4gIHZhciBtdWwgPSAxXFxuICB3aGlsZSAoYnl0ZUxlbmd0aCA+IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcXG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgLS1ieXRlTGVuZ3RoXSAqIG11bFxcbiAgfVxcblxcbiAgcmV0dXJuIHZhbFxcbn1cXG5cXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50OCA9IGZ1bmN0aW9uIHJlYWRVSW50OCAob2Zmc2V0LCBub0Fzc2VydCkge1xcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAxLCB0aGlzLmxlbmd0aClcXG4gIHJldHVybiB0aGlzW29mZnNldF1cXG59XFxuXFxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2TEUgPSBmdW5jdGlvbiByZWFkVUludDE2TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXFxuICByZXR1cm4gdGhpc1tvZmZzZXRdIHwgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOClcXG59XFxuXFxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2QkUgPSBmdW5jdGlvbiByZWFkVUludDE2QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXFxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSA8PCA4KSB8IHRoaXNbb2Zmc2V0ICsgMV1cXG59XFxuXFxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDMyTEUgPSBmdW5jdGlvbiByZWFkVUludDMyTEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXFxuXFxuICByZXR1cm4gKCh0aGlzW29mZnNldF0pIHxcXG4gICAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KSB8XFxuICAgICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgMTYpKSArXFxuICAgICAgKHRoaXNbb2Zmc2V0ICsgM10gKiAweDEwMDAwMDApXFxufVxcblxcbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkJFID0gZnVuY3Rpb24gcmVhZFVJbnQzMkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxcblxcbiAgcmV0dXJuICh0aGlzW29mZnNldF0gKiAweDEwMDAwMDApICtcXG4gICAgKCh0aGlzW29mZnNldCArIDFdIDw8IDE2KSB8XFxuICAgICh0aGlzW29mZnNldCArIDJdIDw8IDgpIHxcXG4gICAgdGhpc1tvZmZzZXQgKyAzXSlcXG59XFxuXFxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50TEUgPSBmdW5jdGlvbiByZWFkSW50TEUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMFxcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcXG5cXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldF1cXG4gIHZhciBtdWwgPSAxXFxuICB2YXIgaSA9IDBcXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XFxuICAgIHZhbCArPSB0aGlzW29mZnNldCArIGldICogbXVsXFxuICB9XFxuICBtdWwgKj0gMHg4MFxcblxcbiAgaWYgKHZhbCA+PSBtdWwpIHZhbCAtPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aClcXG5cXG4gIHJldHVybiB2YWxcXG59XFxuXFxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50QkUgPSBmdW5jdGlvbiByZWFkSW50QkUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMFxcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcXG5cXG4gIHZhciBpID0gYnl0ZUxlbmd0aFxcbiAgdmFyIG11bCA9IDFcXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldCArIC0taV1cXG4gIHdoaWxlIChpID4gMCAmJiAobXVsICo9IDB4MTAwKSkge1xcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyAtLWldICogbXVsXFxuICB9XFxuICBtdWwgKj0gMHg4MFxcblxcbiAgaWYgKHZhbCA+PSBtdWwpIHZhbCAtPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aClcXG5cXG4gIHJldHVybiB2YWxcXG59XFxuXFxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50OCA9IGZ1bmN0aW9uIHJlYWRJbnQ4IChvZmZzZXQsIG5vQXNzZXJ0KSB7XFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDEsIHRoaXMubGVuZ3RoKVxcbiAgaWYgKCEodGhpc1tvZmZzZXRdICYgMHg4MCkpIHJldHVybiAodGhpc1tvZmZzZXRdKVxcbiAgcmV0dXJuICgoMHhmZiAtIHRoaXNbb2Zmc2V0XSArIDEpICogLTEpXFxufVxcblxcbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDE2TEUgPSBmdW5jdGlvbiByZWFkSW50MTZMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldF0gfCAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KVxcbiAgcmV0dXJuICh2YWwgJiAweDgwMDApID8gdmFsIHwgMHhGRkZGMDAwMCA6IHZhbFxcbn1cXG5cXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkJFID0gZnVuY3Rpb24gcmVhZEludDE2QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXFxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXQgKyAxXSB8ICh0aGlzW29mZnNldF0gPDwgOClcXG4gIHJldHVybiAodmFsICYgMHg4MDAwKSA/IHZhbCB8IDB4RkZGRjAwMDAgOiB2YWxcXG59XFxuXFxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MzJMRSA9IGZ1bmN0aW9uIHJlYWRJbnQzMkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxcblxcbiAgcmV0dXJuICh0aGlzW29mZnNldF0pIHxcXG4gICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOCkgfFxcbiAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCAxNikgfFxcbiAgICAodGhpc1tvZmZzZXQgKyAzXSA8PCAyNClcXG59XFxuXFxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MzJCRSA9IGZ1bmN0aW9uIHJlYWRJbnQzMkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxcblxcbiAgcmV0dXJuICh0aGlzW29mZnNldF0gPDwgMjQpIHxcXG4gICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgMTYpIHxcXG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgOCkgfFxcbiAgICAodGhpc1tvZmZzZXQgKyAzXSlcXG59XFxuXFxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRMRSA9IGZ1bmN0aW9uIHJlYWRGbG9hdExFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIHRydWUsIDIzLCA0KVxcbn1cXG5cXG5CdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdEJFID0gZnVuY3Rpb24gcmVhZEZsb2F0QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXFxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgZmFsc2UsIDIzLCA0KVxcbn1cXG5cXG5CdWZmZXIucHJvdG90eXBlLnJlYWREb3VibGVMRSA9IGZ1bmN0aW9uIHJlYWREb3VibGVMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA4LCB0aGlzLmxlbmd0aClcXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCB0cnVlLCA1MiwgOClcXG59XFxuXFxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlQkUgPSBmdW5jdGlvbiByZWFkRG91YmxlQkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgOCwgdGhpcy5sZW5ndGgpXFxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgZmFsc2UsIDUyLCA4KVxcbn1cXG5cXG5mdW5jdGlvbiBjaGVja0ludCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBleHQsIG1heCwgbWluKSB7XFxuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihidWYpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdcXFwiYnVmZmVyXFxcIiBhcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyIGluc3RhbmNlJylcXG4gIGlmICh2YWx1ZSA+IG1heCB8fCB2YWx1ZSA8IG1pbikgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1xcXCJ2YWx1ZVxcXCIgYXJndW1lbnQgaXMgb3V0IG9mIGJvdW5kcycpXFxuICBpZiAob2Zmc2V0ICsgZXh0ID4gYnVmLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpXFxufVxcblxcbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50TEUgPSBmdW5jdGlvbiB3cml0ZVVJbnRMRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcXG4gIHZhbHVlID0gK3ZhbHVlXFxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcXG4gIGlmICghbm9Bc3NlcnQpIHtcXG4gICAgdmFyIG1heEJ5dGVzID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpIC0gMVxcbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBtYXhCeXRlcywgMClcXG4gIH1cXG5cXG4gIHZhciBtdWwgPSAxXFxuICB2YXIgaSA9IDBcXG4gIHRoaXNbb2Zmc2V0XSA9IHZhbHVlICYgMHhGRlxcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcXG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICh2YWx1ZSAvIG11bCkgJiAweEZGXFxuICB9XFxuXFxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxcbn1cXG5cXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludEJFID0gZnVuY3Rpb24gd3JpdGVVSW50QkUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XFxuICB2YWx1ZSA9ICt2YWx1ZVxcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXFxuICBpZiAoIW5vQXNzZXJ0KSB7XFxuICAgIHZhciBtYXhCeXRlcyA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKSAtIDFcXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbWF4Qnl0ZXMsIDApXFxuICB9XFxuXFxuICB2YXIgaSA9IGJ5dGVMZW5ndGggLSAxXFxuICB2YXIgbXVsID0gMVxcbiAgdGhpc1tvZmZzZXQgKyBpXSA9IHZhbHVlICYgMHhGRlxcbiAgd2hpbGUgKC0taSA+PSAwICYmIChtdWwgKj0gMHgxMDApKSB7XFxuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAodmFsdWUgLyBtdWwpICYgMHhGRlxcbiAgfVxcblxcbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcXG59XFxuXFxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQ4ID0gZnVuY3Rpb24gd3JpdGVVSW50OCAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcXG4gIHZhbHVlID0gK3ZhbHVlXFxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAxLCAweGZmLCAwKVxcbiAgaWYgKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkgdmFsdWUgPSBNYXRoLmZsb29yKHZhbHVlKVxcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcXG4gIHJldHVybiBvZmZzZXQgKyAxXFxufVxcblxcbmZ1bmN0aW9uIG9iamVjdFdyaXRlVUludDE2IChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbikge1xcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmZmYgKyB2YWx1ZSArIDFcXG4gIGZvciAodmFyIGkgPSAwLCBqID0gTWF0aC5taW4oYnVmLmxlbmd0aCAtIG9mZnNldCwgMik7IGkgPCBqOyArK2kpIHtcXG4gICAgYnVmW29mZnNldCArIGldID0gKHZhbHVlICYgKDB4ZmYgPDwgKDggKiAobGl0dGxlRW5kaWFuID8gaSA6IDEgLSBpKSkpKSA+Pj5cXG4gICAgICAobGl0dGxlRW5kaWFuID8gaSA6IDEgLSBpKSAqIDhcXG4gIH1cXG59XFxuXFxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkxFID0gZnVuY3Rpb24gd3JpdGVVSW50MTZMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcXG4gIHZhbHVlID0gK3ZhbHVlXFxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweGZmZmYsIDApXFxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcXG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcXG4gIH0gZWxzZSB7XFxuICAgIG9iamVjdFdyaXRlVUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUpXFxuICB9XFxuICByZXR1cm4gb2Zmc2V0ICsgMlxcbn1cXG5cXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDE2QkUgPSBmdW5jdGlvbiB3cml0ZVVJbnQxNkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xcbiAgdmFsdWUgPSArdmFsdWVcXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4ZmZmZiwgMClcXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDgpXFxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgJiAweGZmKVxcbiAgfSBlbHNlIHtcXG4gICAgb2JqZWN0V3JpdGVVSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UpXFxuICB9XFxuICByZXR1cm4gb2Zmc2V0ICsgMlxcbn1cXG5cXG5mdW5jdGlvbiBvYmplY3RXcml0ZVVJbnQzMiAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4pIHtcXG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZmZmZmZmZiArIHZhbHVlICsgMVxcbiAgZm9yICh2YXIgaSA9IDAsIGogPSBNYXRoLm1pbihidWYubGVuZ3RoIC0gb2Zmc2V0LCA0KTsgaSA8IGo7ICsraSkge1xcbiAgICBidWZbb2Zmc2V0ICsgaV0gPSAodmFsdWUgPj4+IChsaXR0bGVFbmRpYW4gPyBpIDogMyAtIGkpICogOCkgJiAweGZmXFxuICB9XFxufVxcblxcbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MzJMRSA9IGZ1bmN0aW9uIHdyaXRlVUludDMyTEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XFxuICB2YWx1ZSA9ICt2YWx1ZVxcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHhmZmZmZmZmZiwgMClcXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xcbiAgICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlID4+PiAyNClcXG4gICAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gMTYpXFxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXFxuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXFxuICB9IGVsc2Uge1xcbiAgICBvYmplY3RXcml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlKVxcbiAgfVxcbiAgcmV0dXJuIG9mZnNldCArIDRcXG59XFxuXFxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkJFID0gZnVuY3Rpb24gd3JpdGVVSW50MzJCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcXG4gIHZhbHVlID0gK3ZhbHVlXFxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweGZmZmZmZmZmLCAwKVxcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XFxuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gMjQpXFxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDE2KVxcbiAgICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiA4KVxcbiAgICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlICYgMHhmZilcXG4gIH0gZWxzZSB7XFxuICAgIG9iamVjdFdyaXRlVUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlKVxcbiAgfVxcbiAgcmV0dXJuIG9mZnNldCArIDRcXG59XFxuXFxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludExFID0gZnVuY3Rpb24gd3JpdGVJbnRMRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcXG4gIHZhbHVlID0gK3ZhbHVlXFxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXFxuICBpZiAoIW5vQXNzZXJ0KSB7XFxuICAgIHZhciBsaW1pdCA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoIC0gMSlcXG5cXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbGltaXQgLSAxLCAtbGltaXQpXFxuICB9XFxuXFxuICB2YXIgaSA9IDBcXG4gIHZhciBtdWwgPSAxXFxuICB2YXIgc3ViID0gMFxcbiAgdGhpc1tvZmZzZXRdID0gdmFsdWUgJiAweEZGXFxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xcbiAgICBpZiAodmFsdWUgPCAwICYmIHN1YiA9PT0gMCAmJiB0aGlzW29mZnNldCArIGkgLSAxXSAhPT0gMCkge1xcbiAgICAgIHN1YiA9IDFcXG4gICAgfVxcbiAgICB0aGlzW29mZnNldCArIGldID0gKCh2YWx1ZSAvIG11bCkgPj4gMCkgLSBzdWIgJiAweEZGXFxuICB9XFxuXFxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxcbn1cXG5cXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50QkUgPSBmdW5jdGlvbiB3cml0ZUludEJFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xcbiAgdmFsdWUgPSArdmFsdWVcXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcXG4gIGlmICghbm9Bc3NlcnQpIHtcXG4gICAgdmFyIGxpbWl0ID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGggLSAxKVxcblxcbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBsaW1pdCAtIDEsIC1saW1pdClcXG4gIH1cXG5cXG4gIHZhciBpID0gYnl0ZUxlbmd0aCAtIDFcXG4gIHZhciBtdWwgPSAxXFxuICB2YXIgc3ViID0gMFxcbiAgdGhpc1tvZmZzZXQgKyBpXSA9IHZhbHVlICYgMHhGRlxcbiAgd2hpbGUgKC0taSA+PSAwICYmIChtdWwgKj0gMHgxMDApKSB7XFxuICAgIGlmICh2YWx1ZSA8IDAgJiYgc3ViID09PSAwICYmIHRoaXNbb2Zmc2V0ICsgaSArIDFdICE9PSAwKSB7XFxuICAgICAgc3ViID0gMVxcbiAgICB9XFxuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAoKHZhbHVlIC8gbXVsKSA+PiAwKSAtIHN1YiAmIDB4RkZcXG4gIH1cXG5cXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXFxufVxcblxcbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQ4ID0gZnVuY3Rpb24gd3JpdGVJbnQ4ICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xcbiAgdmFsdWUgPSArdmFsdWVcXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDEsIDB4N2YsIC0weDgwKVxcbiAgaWYgKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkgdmFsdWUgPSBNYXRoLmZsb29yKHZhbHVlKVxcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmICsgdmFsdWUgKyAxXFxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxcbiAgcmV0dXJuIG9mZnNldCArIDFcXG59XFxuXFxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2TEUgPSBmdW5jdGlvbiB3cml0ZUludDE2TEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XFxuICB2YWx1ZSA9ICt2YWx1ZVxcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHg3ZmZmLCAtMHg4MDAwKVxcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XFxuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXFxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXFxuICB9IGVsc2Uge1xcbiAgICBvYmplY3RXcml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlKVxcbiAgfVxcbiAgcmV0dXJuIG9mZnNldCArIDJcXG59XFxuXFxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2QkUgPSBmdW5jdGlvbiB3cml0ZUludDE2QkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XFxuICB2YWx1ZSA9ICt2YWx1ZVxcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHg3ZmZmLCAtMHg4MDAwKVxcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XFxuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gOClcXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSAmIDB4ZmYpXFxuICB9IGVsc2Uge1xcbiAgICBvYmplY3RXcml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSlcXG4gIH1cXG4gIHJldHVybiBvZmZzZXQgKyAyXFxufVxcblxcbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkxFID0gZnVuY3Rpb24gd3JpdGVJbnQzMkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xcbiAgdmFsdWUgPSArdmFsdWVcXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4N2ZmZmZmZmYsIC0weDgwMDAwMDAwKVxcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XFxuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXFxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXFxuICAgIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDE2KVxcbiAgICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlID4+PiAyNClcXG4gIH0gZWxzZSB7XFxuICAgIG9iamVjdFdyaXRlVUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUpXFxuICB9XFxuICByZXR1cm4gb2Zmc2V0ICsgNFxcbn1cXG5cXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJCRSA9IGZ1bmN0aW9uIHdyaXRlSW50MzJCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcXG4gIHZhbHVlID0gK3ZhbHVlXFxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweDdmZmZmZmZmLCAtMHg4MDAwMDAwMClcXG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZmZmZmZmZiArIHZhbHVlICsgMVxcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XFxuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gMjQpXFxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDE2KVxcbiAgICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiA4KVxcbiAgICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlICYgMHhmZilcXG4gIH0gZWxzZSB7XFxuICAgIG9iamVjdFdyaXRlVUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlKVxcbiAgfVxcbiAgcmV0dXJuIG9mZnNldCArIDRcXG59XFxuXFxuZnVuY3Rpb24gY2hlY2tJRUVFNzU0IChidWYsIHZhbHVlLCBvZmZzZXQsIGV4dCwgbWF4LCBtaW4pIHtcXG4gIGlmIChvZmZzZXQgKyBleHQgPiBidWYubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJylcXG4gIGlmIChvZmZzZXQgPCAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJylcXG59XFxuXFxuZnVuY3Rpb24gd3JpdGVGbG9hdCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XFxuICBpZiAoIW5vQXNzZXJ0KSB7XFxuICAgIGNoZWNrSUVFRTc1NChidWYsIHZhbHVlLCBvZmZzZXQsIDQsIDMuNDAyODIzNDY2Mzg1Mjg4NmUrMzgsIC0zLjQwMjgyMzQ2NjM4NTI4ODZlKzM4KVxcbiAgfVxcbiAgaWVlZTc1NC53cml0ZShidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgMjMsIDQpXFxuICByZXR1cm4gb2Zmc2V0ICsgNFxcbn1cXG5cXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRmxvYXRMRSA9IGZ1bmN0aW9uIHdyaXRlRmxvYXRMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcXG4gIHJldHVybiB3cml0ZUZsb2F0KHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxcbn1cXG5cXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRmxvYXRCRSA9IGZ1bmN0aW9uIHdyaXRlRmxvYXRCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcXG4gIHJldHVybiB3cml0ZUZsb2F0KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcXG59XFxuXFxuZnVuY3Rpb24gd3JpdGVEb3VibGUgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xcbiAgaWYgKCFub0Fzc2VydCkge1xcbiAgICBjaGVja0lFRUU3NTQoYnVmLCB2YWx1ZSwgb2Zmc2V0LCA4LCAxLjc5NzY5MzEzNDg2MjMxNTdFKzMwOCwgLTEuNzk3NjkzMTM0ODYyMzE1N0UrMzA4KVxcbiAgfVxcbiAgaWVlZTc1NC53cml0ZShidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgNTIsIDgpXFxuICByZXR1cm4gb2Zmc2V0ICsgOFxcbn1cXG5cXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRG91YmxlTEUgPSBmdW5jdGlvbiB3cml0ZURvdWJsZUxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xcbiAgcmV0dXJuIHdyaXRlRG91YmxlKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxcbn1cXG5cXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRG91YmxlQkUgPSBmdW5jdGlvbiB3cml0ZURvdWJsZUJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xcbiAgcmV0dXJuIHdyaXRlRG91YmxlKHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcXG59XFxuXFxuLy8gY29weSh0YXJnZXRCdWZmZXIsIHRhcmdldFN0YXJ0PTAsIHNvdXJjZVN0YXJ0PTAsIHNvdXJjZUVuZD1idWZmZXIubGVuZ3RoKVxcbkJ1ZmZlci5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uIGNvcHkgKHRhcmdldCwgdGFyZ2V0U3RhcnQsIHN0YXJ0LCBlbmQpIHtcXG4gIGlmICghc3RhcnQpIHN0YXJ0ID0gMFxcbiAgaWYgKCFlbmQgJiYgZW5kICE9PSAwKSBlbmQgPSB0aGlzLmxlbmd0aFxcbiAgaWYgKHRhcmdldFN0YXJ0ID49IHRhcmdldC5sZW5ndGgpIHRhcmdldFN0YXJ0ID0gdGFyZ2V0Lmxlbmd0aFxcbiAgaWYgKCF0YXJnZXRTdGFydCkgdGFyZ2V0U3RhcnQgPSAwXFxuICBpZiAoZW5kID4gMCAmJiBlbmQgPCBzdGFydCkgZW5kID0gc3RhcnRcXG5cXG4gIC8vIENvcHkgMCBieXRlczsgd2UncmUgZG9uZVxcbiAgaWYgKGVuZCA9PT0gc3RhcnQpIHJldHVybiAwXFxuICBpZiAodGFyZ2V0Lmxlbmd0aCA9PT0gMCB8fCB0aGlzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIDBcXG5cXG4gIC8vIEZhdGFsIGVycm9yIGNvbmRpdGlvbnNcXG4gIGlmICh0YXJnZXRTdGFydCA8IDApIHtcXG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3RhcmdldFN0YXJ0IG91dCBvZiBib3VuZHMnKVxcbiAgfVxcbiAgaWYgKHN0YXJ0IDwgMCB8fCBzdGFydCA+PSB0aGlzLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3NvdXJjZVN0YXJ0IG91dCBvZiBib3VuZHMnKVxcbiAgaWYgKGVuZCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdzb3VyY2VFbmQgb3V0IG9mIGJvdW5kcycpXFxuXFxuICAvLyBBcmUgd2Ugb29iP1xcbiAgaWYgKGVuZCA+IHRoaXMubGVuZ3RoKSBlbmQgPSB0aGlzLmxlbmd0aFxcbiAgaWYgKHRhcmdldC5sZW5ndGggLSB0YXJnZXRTdGFydCA8IGVuZCAtIHN0YXJ0KSB7XFxuICAgIGVuZCA9IHRhcmdldC5sZW5ndGggLSB0YXJnZXRTdGFydCArIHN0YXJ0XFxuICB9XFxuXFxuICB2YXIgbGVuID0gZW5kIC0gc3RhcnRcXG4gIHZhciBpXFxuXFxuICBpZiAodGhpcyA9PT0gdGFyZ2V0ICYmIHN0YXJ0IDwgdGFyZ2V0U3RhcnQgJiYgdGFyZ2V0U3RhcnQgPCBlbmQpIHtcXG4gICAgLy8gZGVzY2VuZGluZyBjb3B5IGZyb20gZW5kXFxuICAgIGZvciAoaSA9IGxlbiAtIDE7IGkgPj0gMDsgLS1pKSB7XFxuICAgICAgdGFyZ2V0W2kgKyB0YXJnZXRTdGFydF0gPSB0aGlzW2kgKyBzdGFydF1cXG4gICAgfVxcbiAgfSBlbHNlIGlmIChsZW4gPCAxMDAwIHx8ICFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xcbiAgICAvLyBhc2NlbmRpbmcgY29weSBmcm9tIHN0YXJ0XFxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47ICsraSkge1xcbiAgICAgIHRhcmdldFtpICsgdGFyZ2V0U3RhcnRdID0gdGhpc1tpICsgc3RhcnRdXFxuICAgIH1cXG4gIH0gZWxzZSB7XFxuICAgIFVpbnQ4QXJyYXkucHJvdG90eXBlLnNldC5jYWxsKFxcbiAgICAgIHRhcmdldCxcXG4gICAgICB0aGlzLnN1YmFycmF5KHN0YXJ0LCBzdGFydCArIGxlbiksXFxuICAgICAgdGFyZ2V0U3RhcnRcXG4gICAgKVxcbiAgfVxcblxcbiAgcmV0dXJuIGxlblxcbn1cXG5cXG4vLyBVc2FnZTpcXG4vLyAgICBidWZmZXIuZmlsbChudW1iZXJbLCBvZmZzZXRbLCBlbmRdXSlcXG4vLyAgICBidWZmZXIuZmlsbChidWZmZXJbLCBvZmZzZXRbLCBlbmRdXSlcXG4vLyAgICBidWZmZXIuZmlsbChzdHJpbmdbLCBvZmZzZXRbLCBlbmRdXVssIGVuY29kaW5nXSlcXG5CdWZmZXIucHJvdG90eXBlLmZpbGwgPSBmdW5jdGlvbiBmaWxsICh2YWwsIHN0YXJ0LCBlbmQsIGVuY29kaW5nKSB7XFxuICAvLyBIYW5kbGUgc3RyaW5nIGNhc2VzOlxcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XFxuICAgIGlmICh0eXBlb2Ygc3RhcnQgPT09ICdzdHJpbmcnKSB7XFxuICAgICAgZW5jb2RpbmcgPSBzdGFydFxcbiAgICAgIHN0YXJ0ID0gMFxcbiAgICAgIGVuZCA9IHRoaXMubGVuZ3RoXFxuICAgIH0gZWxzZSBpZiAodHlwZW9mIGVuZCA9PT0gJ3N0cmluZycpIHtcXG4gICAgICBlbmNvZGluZyA9IGVuZFxcbiAgICAgIGVuZCA9IHRoaXMubGVuZ3RoXFxuICAgIH1cXG4gICAgaWYgKHZhbC5sZW5ndGggPT09IDEpIHtcXG4gICAgICB2YXIgY29kZSA9IHZhbC5jaGFyQ29kZUF0KDApXFxuICAgICAgaWYgKGNvZGUgPCAyNTYpIHtcXG4gICAgICAgIHZhbCA9IGNvZGVcXG4gICAgICB9XFxuICAgIH1cXG4gICAgaWYgKGVuY29kaW5nICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIGVuY29kaW5nICE9PSAnc3RyaW5nJykge1xcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2VuY29kaW5nIG11c3QgYmUgYSBzdHJpbmcnKVxcbiAgICB9XFxuICAgIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdzdHJpbmcnICYmICFCdWZmZXIuaXNFbmNvZGluZyhlbmNvZGluZykpIHtcXG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXFxuICAgIH1cXG4gIH0gZWxzZSBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcXG4gICAgdmFsID0gdmFsICYgMjU1XFxuICB9XFxuXFxuICAvLyBJbnZhbGlkIHJhbmdlcyBhcmUgbm90IHNldCB0byBhIGRlZmF1bHQsIHNvIGNhbiByYW5nZSBjaGVjayBlYXJseS5cXG4gIGlmIChzdGFydCA8IDAgfHwgdGhpcy5sZW5ndGggPCBzdGFydCB8fCB0aGlzLmxlbmd0aCA8IGVuZCkge1xcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignT3V0IG9mIHJhbmdlIGluZGV4JylcXG4gIH1cXG5cXG4gIGlmIChlbmQgPD0gc3RhcnQpIHtcXG4gICAgcmV0dXJuIHRoaXNcXG4gIH1cXG5cXG4gIHN0YXJ0ID0gc3RhcnQgPj4+IDBcXG4gIGVuZCA9IGVuZCA9PT0gdW5kZWZpbmVkID8gdGhpcy5sZW5ndGggOiBlbmQgPj4+IDBcXG5cXG4gIGlmICghdmFsKSB2YWwgPSAwXFxuXFxuICB2YXIgaVxcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XFxuICAgIGZvciAoaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcXG4gICAgICB0aGlzW2ldID0gdmFsXFxuICAgIH1cXG4gIH0gZWxzZSB7XFxuICAgIHZhciBieXRlcyA9IEJ1ZmZlci5pc0J1ZmZlcih2YWwpXFxuICAgICAgPyB2YWxcXG4gICAgICA6IHV0ZjhUb0J5dGVzKG5ldyBCdWZmZXIodmFsLCBlbmNvZGluZykudG9TdHJpbmcoKSlcXG4gICAgdmFyIGxlbiA9IGJ5dGVzLmxlbmd0aFxcbiAgICBmb3IgKGkgPSAwOyBpIDwgZW5kIC0gc3RhcnQ7ICsraSkge1xcbiAgICAgIHRoaXNbaSArIHN0YXJ0XSA9IGJ5dGVzW2kgJSBsZW5dXFxuICAgIH1cXG4gIH1cXG5cXG4gIHJldHVybiB0aGlzXFxufVxcblxcbi8vIEhFTFBFUiBGVU5DVElPTlNcXG4vLyA9PT09PT09PT09PT09PT09XFxuXFxudmFyIElOVkFMSURfQkFTRTY0X1JFID0gL1teK1xcXFwvMC05QS1aYS16LV9dL2dcXG5cXG5mdW5jdGlvbiBiYXNlNjRjbGVhbiAoc3RyKSB7XFxuICAvLyBOb2RlIHN0cmlwcyBvdXQgaW52YWxpZCBjaGFyYWN0ZXJzIGxpa2UgXFxcXG4gYW5kIFxcXFx0IGZyb20gdGhlIHN0cmluZywgYmFzZTY0LWpzIGRvZXMgbm90XFxuICBzdHIgPSBzdHJpbmd0cmltKHN0cikucmVwbGFjZShJTlZBTElEX0JBU0U2NF9SRSwgJycpXFxuICAvLyBOb2RlIGNvbnZlcnRzIHN0cmluZ3Mgd2l0aCBsZW5ndGggPCAyIHRvICcnXFxuICBpZiAoc3RyLmxlbmd0aCA8IDIpIHJldHVybiAnJ1xcbiAgLy8gTm9kZSBhbGxvd3MgZm9yIG5vbi1wYWRkZWQgYmFzZTY0IHN0cmluZ3MgKG1pc3NpbmcgdHJhaWxpbmcgPT09KSwgYmFzZTY0LWpzIGRvZXMgbm90XFxuICB3aGlsZSAoc3RyLmxlbmd0aCAlIDQgIT09IDApIHtcXG4gICAgc3RyID0gc3RyICsgJz0nXFxuICB9XFxuICByZXR1cm4gc3RyXFxufVxcblxcbmZ1bmN0aW9uIHN0cmluZ3RyaW0gKHN0cikge1xcbiAgaWYgKHN0ci50cmltKSByZXR1cm4gc3RyLnRyaW0oKVxcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKC9eXFxcXHMrfFxcXFxzKyQvZywgJycpXFxufVxcblxcbmZ1bmN0aW9uIHRvSGV4IChuKSB7XFxuICBpZiAobiA8IDE2KSByZXR1cm4gJzAnICsgbi50b1N0cmluZygxNilcXG4gIHJldHVybiBuLnRvU3RyaW5nKDE2KVxcbn1cXG5cXG5mdW5jdGlvbiB1dGY4VG9CeXRlcyAoc3RyaW5nLCB1bml0cykge1xcbiAgdW5pdHMgPSB1bml0cyB8fCBJbmZpbml0eVxcbiAgdmFyIGNvZGVQb2ludFxcbiAgdmFyIGxlbmd0aCA9IHN0cmluZy5sZW5ndGhcXG4gIHZhciBsZWFkU3Vycm9nYXRlID0gbnVsbFxcbiAgdmFyIGJ5dGVzID0gW11cXG5cXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcXG4gICAgY29kZVBvaW50ID0gc3RyaW5nLmNoYXJDb2RlQXQoaSlcXG5cXG4gICAgLy8gaXMgc3Vycm9nYXRlIGNvbXBvbmVudFxcbiAgICBpZiAoY29kZVBvaW50ID4gMHhEN0ZGICYmIGNvZGVQb2ludCA8IDB4RTAwMCkge1xcbiAgICAgIC8vIGxhc3QgY2hhciB3YXMgYSBsZWFkXFxuICAgICAgaWYgKCFsZWFkU3Vycm9nYXRlKSB7XFxuICAgICAgICAvLyBubyBsZWFkIHlldFxcbiAgICAgICAgaWYgKGNvZGVQb2ludCA+IDB4REJGRikge1xcbiAgICAgICAgICAvLyB1bmV4cGVjdGVkIHRyYWlsXFxuICAgICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxcbiAgICAgICAgICBjb250aW51ZVxcbiAgICAgICAgfSBlbHNlIGlmIChpICsgMSA9PT0gbGVuZ3RoKSB7XFxuICAgICAgICAgIC8vIHVucGFpcmVkIGxlYWRcXG4gICAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXFxuICAgICAgICAgIGNvbnRpbnVlXFxuICAgICAgICB9XFxuXFxuICAgICAgICAvLyB2YWxpZCBsZWFkXFxuICAgICAgICBsZWFkU3Vycm9nYXRlID0gY29kZVBvaW50XFxuXFxuICAgICAgICBjb250aW51ZVxcbiAgICAgIH1cXG5cXG4gICAgICAvLyAyIGxlYWRzIGluIGEgcm93XFxuICAgICAgaWYgKGNvZGVQb2ludCA8IDB4REMwMCkge1xcbiAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXFxuICAgICAgICBsZWFkU3Vycm9nYXRlID0gY29kZVBvaW50XFxuICAgICAgICBjb250aW51ZVxcbiAgICAgIH1cXG5cXG4gICAgICAvLyB2YWxpZCBzdXJyb2dhdGUgcGFpclxcbiAgICAgIGNvZGVQb2ludCA9IChsZWFkU3Vycm9nYXRlIC0gMHhEODAwIDw8IDEwIHwgY29kZVBvaW50IC0gMHhEQzAwKSArIDB4MTAwMDBcXG4gICAgfSBlbHNlIGlmIChsZWFkU3Vycm9nYXRlKSB7XFxuICAgICAgLy8gdmFsaWQgYm1wIGNoYXIsIGJ1dCBsYXN0IGNoYXIgd2FzIGEgbGVhZFxcbiAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxcbiAgICB9XFxuXFxuICAgIGxlYWRTdXJyb2dhdGUgPSBudWxsXFxuXFxuICAgIC8vIGVuY29kZSB1dGY4XFxuICAgIGlmIChjb2RlUG9pbnQgPCAweDgwKSB7XFxuICAgICAgaWYgKCh1bml0cyAtPSAxKSA8IDApIGJyZWFrXFxuICAgICAgYnl0ZXMucHVzaChjb2RlUG9pbnQpXFxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHg4MDApIHtcXG4gICAgICBpZiAoKHVuaXRzIC09IDIpIDwgMCkgYnJlYWtcXG4gICAgICBieXRlcy5wdXNoKFxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiB8IDB4QzAsXFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxcbiAgICAgIClcXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDEwMDAwKSB7XFxuICAgICAgaWYgKCh1bml0cyAtPSAzKSA8IDApIGJyZWFrXFxuICAgICAgYnl0ZXMucHVzaChcXG4gICAgICAgIGNvZGVQb2ludCA+PiAweEMgfCAweEUwLFxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiAmIDB4M0YgfCAweDgwLFxcbiAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBcXG4gICAgICApXFxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHgxMTAwMDApIHtcXG4gICAgICBpZiAoKHVuaXRzIC09IDQpIDwgMCkgYnJlYWtcXG4gICAgICBieXRlcy5wdXNoKFxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4MTIgfCAweEYwLFxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4QyAmIDB4M0YgfCAweDgwLFxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiAmIDB4M0YgfCAweDgwLFxcbiAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBcXG4gICAgICApXFxuICAgIH0gZWxzZSB7XFxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGNvZGUgcG9pbnQnKVxcbiAgICB9XFxuICB9XFxuXFxuICByZXR1cm4gYnl0ZXNcXG59XFxuXFxuZnVuY3Rpb24gYXNjaWlUb0J5dGVzIChzdHIpIHtcXG4gIHZhciBieXRlQXJyYXkgPSBbXVxcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyArK2kpIHtcXG4gICAgLy8gTm9kZSdzIGNvZGUgc2VlbXMgdG8gYmUgZG9pbmcgdGhpcyBhbmQgbm90ICYgMHg3Ri4uXFxuICAgIGJ5dGVBcnJheS5wdXNoKHN0ci5jaGFyQ29kZUF0KGkpICYgMHhGRilcXG4gIH1cXG4gIHJldHVybiBieXRlQXJyYXlcXG59XFxuXFxuZnVuY3Rpb24gdXRmMTZsZVRvQnl0ZXMgKHN0ciwgdW5pdHMpIHtcXG4gIHZhciBjLCBoaSwgbG9cXG4gIHZhciBieXRlQXJyYXkgPSBbXVxcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyArK2kpIHtcXG4gICAgaWYgKCh1bml0cyAtPSAyKSA8IDApIGJyZWFrXFxuXFxuICAgIGMgPSBzdHIuY2hhckNvZGVBdChpKVxcbiAgICBoaSA9IGMgPj4gOFxcbiAgICBsbyA9IGMgJSAyNTZcXG4gICAgYnl0ZUFycmF5LnB1c2gobG8pXFxuICAgIGJ5dGVBcnJheS5wdXNoKGhpKVxcbiAgfVxcblxcbiAgcmV0dXJuIGJ5dGVBcnJheVxcbn1cXG5cXG5mdW5jdGlvbiBiYXNlNjRUb0J5dGVzIChzdHIpIHtcXG4gIHJldHVybiBiYXNlNjQudG9CeXRlQXJyYXkoYmFzZTY0Y2xlYW4oc3RyKSlcXG59XFxuXFxuZnVuY3Rpb24gYmxpdEJ1ZmZlciAoc3JjLCBkc3QsIG9mZnNldCwgbGVuZ3RoKSB7XFxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XFxuICAgIGlmICgoaSArIG9mZnNldCA+PSBkc3QubGVuZ3RoKSB8fCAoaSA+PSBzcmMubGVuZ3RoKSkgYnJlYWtcXG4gICAgZHN0W2kgKyBvZmZzZXRdID0gc3JjW2ldXFxuICB9XFxuICByZXR1cm4gaVxcbn1cXG5cXG5mdW5jdGlvbiBpc25hbiAodmFsKSB7XFxuICByZXR1cm4gdmFsICE9PSB2YWwgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1zZWxmLWNvbXBhcmVcXG59XFxuXFxufSkuY2FsbCh0aGlzLHR5cGVvZiBnbG9iYWwgIT09IFxcXCJ1bmRlZmluZWRcXFwiID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09IFxcXCJ1bmRlZmluZWRcXFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFxcXCJ1bmRlZmluZWRcXFwiID8gd2luZG93IDoge30pXFxufSx7XFxcImJhc2U2NC1qc1xcXCI6MzksXFxcImllZWU3NTRcXFwiOjY1LFxcXCJpc2FycmF5XFxcIjo2OH1dLDQ0OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcXG4oZnVuY3Rpb24gKEJ1ZmZlcil7XFxuLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXFxuLy9cXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcXG4vLyBcXFwiU29mdHdhcmVcXFwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXFxuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcXG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcXG4vL1xcbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXFxuLy9cXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXFxcIkFTIElTXFxcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xcbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0ZcXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXFxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXFxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXFxuXFxuLy8gTk9URTogVGhlc2UgdHlwZSBjaGVja2luZyBmdW5jdGlvbnMgaW50ZW50aW9uYWxseSBkb24ndCB1c2UgYGluc3RhbmNlb2ZgXFxuLy8gYmVjYXVzZSBpdCBpcyBmcmFnaWxlIGFuZCBjYW4gYmUgZWFzaWx5IGZha2VkIHdpdGggYE9iamVjdC5jcmVhdGUoKWAuXFxuXFxuZnVuY3Rpb24gaXNBcnJheShhcmcpIHtcXG4gIGlmIChBcnJheS5pc0FycmF5KSB7XFxuICAgIHJldHVybiBBcnJheS5pc0FycmF5KGFyZyk7XFxuICB9XFxuICByZXR1cm4gb2JqZWN0VG9TdHJpbmcoYXJnKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcXG59XFxuZXhwb3J0cy5pc0FycmF5ID0gaXNBcnJheTtcXG5cXG5mdW5jdGlvbiBpc0Jvb2xlYW4oYXJnKSB7XFxuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ2Jvb2xlYW4nO1xcbn1cXG5leHBvcnRzLmlzQm9vbGVhbiA9IGlzQm9vbGVhbjtcXG5cXG5mdW5jdGlvbiBpc051bGwoYXJnKSB7XFxuICByZXR1cm4gYXJnID09PSBudWxsO1xcbn1cXG5leHBvcnRzLmlzTnVsbCA9IGlzTnVsbDtcXG5cXG5mdW5jdGlvbiBpc051bGxPclVuZGVmaW5lZChhcmcpIHtcXG4gIHJldHVybiBhcmcgPT0gbnVsbDtcXG59XFxuZXhwb3J0cy5pc051bGxPclVuZGVmaW5lZCA9IGlzTnVsbE9yVW5kZWZpbmVkO1xcblxcbmZ1bmN0aW9uIGlzTnVtYmVyKGFyZykge1xcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdudW1iZXInO1xcbn1cXG5leHBvcnRzLmlzTnVtYmVyID0gaXNOdW1iZXI7XFxuXFxuZnVuY3Rpb24gaXNTdHJpbmcoYXJnKSB7XFxuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ3N0cmluZyc7XFxufVxcbmV4cG9ydHMuaXNTdHJpbmcgPSBpc1N0cmluZztcXG5cXG5mdW5jdGlvbiBpc1N5bWJvbChhcmcpIHtcXG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnc3ltYm9sJztcXG59XFxuZXhwb3J0cy5pc1N5bWJvbCA9IGlzU3ltYm9sO1xcblxcbmZ1bmN0aW9uIGlzVW5kZWZpbmVkKGFyZykge1xcbiAgcmV0dXJuIGFyZyA9PT0gdm9pZCAwO1xcbn1cXG5leHBvcnRzLmlzVW5kZWZpbmVkID0gaXNVbmRlZmluZWQ7XFxuXFxuZnVuY3Rpb24gaXNSZWdFeHAocmUpIHtcXG4gIHJldHVybiBvYmplY3RUb1N0cmluZyhyZSkgPT09ICdbb2JqZWN0IFJlZ0V4cF0nO1xcbn1cXG5leHBvcnRzLmlzUmVnRXhwID0gaXNSZWdFeHA7XFxuXFxuZnVuY3Rpb24gaXNPYmplY3QoYXJnKSB7XFxuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ29iamVjdCcgJiYgYXJnICE9PSBudWxsO1xcbn1cXG5leHBvcnRzLmlzT2JqZWN0ID0gaXNPYmplY3Q7XFxuXFxuZnVuY3Rpb24gaXNEYXRlKGQpIHtcXG4gIHJldHVybiBvYmplY3RUb1N0cmluZyhkKSA9PT0gJ1tvYmplY3QgRGF0ZV0nO1xcbn1cXG5leHBvcnRzLmlzRGF0ZSA9IGlzRGF0ZTtcXG5cXG5mdW5jdGlvbiBpc0Vycm9yKGUpIHtcXG4gIHJldHVybiAob2JqZWN0VG9TdHJpbmcoZSkgPT09ICdbb2JqZWN0IEVycm9yXScgfHwgZSBpbnN0YW5jZW9mIEVycm9yKTtcXG59XFxuZXhwb3J0cy5pc0Vycm9yID0gaXNFcnJvcjtcXG5cXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKGFyZykge1xcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdmdW5jdGlvbic7XFxufVxcbmV4cG9ydHMuaXNGdW5jdGlvbiA9IGlzRnVuY3Rpb247XFxuXFxuZnVuY3Rpb24gaXNQcmltaXRpdmUoYXJnKSB7XFxuICByZXR1cm4gYXJnID09PSBudWxsIHx8XFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ2Jvb2xlYW4nIHx8XFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ251bWJlcicgfHxcXG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnc3RyaW5nJyB8fFxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdzeW1ib2wnIHx8ICAvLyBFUzYgc3ltYm9sXFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ3VuZGVmaW5lZCc7XFxufVxcbmV4cG9ydHMuaXNQcmltaXRpdmUgPSBpc1ByaW1pdGl2ZTtcXG5cXG5leHBvcnRzLmlzQnVmZmVyID0gQnVmZmVyLmlzQnVmZmVyO1xcblxcbmZ1bmN0aW9uIG9iamVjdFRvU3RyaW5nKG8pIHtcXG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobyk7XFxufVxcblxcbn0pLmNhbGwodGhpcyx7XFxcImlzQnVmZmVyXFxcIjpyZXF1aXJlKFxcXCIuLi8uLi9pcy1idWZmZXIvaW5kZXguanNcXFwiKX0pXFxufSx7XFxcIi4uLy4uL2lzLWJ1ZmZlci9pbmRleC5qc1xcXCI6Njd9XSw0NTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XFxuLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL1xcXCJ1c2Ugc3RyaWN0XFxcIjtcXG5cXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xcbmV4cG9ydHMuIC8qaXN0YW5idWwgaWdub3JlIGVuZCovY29udmVydENoYW5nZXNUb0RNUCA9IGNvbnZlcnRDaGFuZ2VzVG9ETVA7XFxuLy8gU2VlOiBodHRwOi8vY29kZS5nb29nbGUuY29tL3AvZ29vZ2xlLWRpZmYtbWF0Y2gtcGF0Y2gvd2lraS9BUElcXG5mdW5jdGlvbiBjb252ZXJ0Q2hhbmdlc1RvRE1QKGNoYW5nZXMpIHtcXG4gIHZhciByZXQgPSBbXSxcXG4gICAgICBjaGFuZ2UgPSAvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovdm9pZCAwIC8qaXN0YW5idWwgaWdub3JlIGVuZCovLFxcbiAgICAgIG9wZXJhdGlvbiA9IC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki92b2lkIDAgLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi87XFxuICBmb3IgKHZhciBpID0gMDsgaSA8IGNoYW5nZXMubGVuZ3RoOyBpKyspIHtcXG4gICAgY2hhbmdlID0gY2hhbmdlc1tpXTtcXG4gICAgaWYgKGNoYW5nZS5hZGRlZCkge1xcbiAgICAgIG9wZXJhdGlvbiA9IDE7XFxuICAgIH0gZWxzZSBpZiAoY2hhbmdlLnJlbW92ZWQpIHtcXG4gICAgICBvcGVyYXRpb24gPSAtMTtcXG4gICAgfSBlbHNlIHtcXG4gICAgICBvcGVyYXRpb24gPSAwO1xcbiAgICB9XFxuXFxuICAgIHJldC5wdXNoKFtvcGVyYXRpb24sIGNoYW5nZS52YWx1ZV0pO1xcbiAgfVxcbiAgcmV0dXJuIHJldDtcXG59XFxuXFxuXFxufSx7fV0sNDY6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xcbi8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki8ndXNlIHN0cmljdCc7XFxuXFxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcXG5leHBvcnRzLiAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqL2NvbnZlcnRDaGFuZ2VzVG9YTUwgPSBjb252ZXJ0Q2hhbmdlc1RvWE1MO1xcbmZ1bmN0aW9uIGNvbnZlcnRDaGFuZ2VzVG9YTUwoY2hhbmdlcykge1xcbiAgdmFyIHJldCA9IFtdO1xcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGFuZ2VzLmxlbmd0aDsgaSsrKSB7XFxuICAgIHZhciBjaGFuZ2UgPSBjaGFuZ2VzW2ldO1xcbiAgICBpZiAoY2hhbmdlLmFkZGVkKSB7XFxuICAgICAgcmV0LnB1c2goJzxpbnM+Jyk7XFxuICAgIH0gZWxzZSBpZiAoY2hhbmdlLnJlbW92ZWQpIHtcXG4gICAgICByZXQucHVzaCgnPGRlbD4nKTtcXG4gICAgfVxcblxcbiAgICByZXQucHVzaChlc2NhcGVIVE1MKGNoYW5nZS52YWx1ZSkpO1xcblxcbiAgICBpZiAoY2hhbmdlLmFkZGVkKSB7XFxuICAgICAgcmV0LnB1c2goJzwvaW5zPicpO1xcbiAgICB9IGVsc2UgaWYgKGNoYW5nZS5yZW1vdmVkKSB7XFxuICAgICAgcmV0LnB1c2goJzwvZGVsPicpO1xcbiAgICB9XFxuICB9XFxuICByZXR1cm4gcmV0LmpvaW4oJycpO1xcbn1cXG5cXG5mdW5jdGlvbiBlc2NhcGVIVE1MKHMpIHtcXG4gIHZhciBuID0gcztcXG4gIG4gPSBuLnJlcGxhY2UoLyYvZywgJyZhbXA7Jyk7XFxuICBuID0gbi5yZXBsYWNlKC88L2csICcmbHQ7Jyk7XFxuICBuID0gbi5yZXBsYWNlKC8+L2csICcmZ3Q7Jyk7XFxuICBuID0gbi5yZXBsYWNlKC9cXFwiL2csICcmcXVvdDsnKTtcXG5cXG4gIHJldHVybiBuO1xcbn1cXG5cXG5cXG59LHt9XSw0NzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XFxuLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqLyd1c2Ugc3RyaWN0JztcXG5cXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xcbmV4cG9ydHMuYXJyYXlEaWZmID0gdW5kZWZpbmVkO1xcbmV4cG9ydHMuIC8qaXN0YW5idWwgaWdub3JlIGVuZCovZGlmZkFycmF5cyA9IGRpZmZBcnJheXM7XFxuXFxudmFyIC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki9fYmFzZSA9IHJlcXVpcmUoJy4vYmFzZScpIC8qaXN0YW5idWwgaWdub3JlIGVuZCovO1xcblxcbi8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki9cXG52YXIgX2Jhc2UyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfYmFzZSk7XFxuXFxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxcblxcbi8qaXN0YW5idWwgaWdub3JlIGVuZCovdmFyIGFycmF5RGlmZiA9IC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki9leHBvcnRzLiAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqL2FycmF5RGlmZiA9IG5ldyAvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovX2Jhc2UyWydkZWZhdWx0J10oKSAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqLztcXG5hcnJheURpZmYudG9rZW5pemUgPSBhcnJheURpZmYuam9pbiA9IGZ1bmN0aW9uICh2YWx1ZSkge1xcbiAgcmV0dXJuIHZhbHVlLnNsaWNlKCk7XFxufTtcXG5cXG5mdW5jdGlvbiBkaWZmQXJyYXlzKG9sZEFyciwgbmV3QXJyLCBjYWxsYmFjaykge1xcbiAgcmV0dXJuIGFycmF5RGlmZi5kaWZmKG9sZEFyciwgbmV3QXJyLCBjYWxsYmFjayk7XFxufVxcblxcblxcbn0se1xcXCIuL2Jhc2VcXFwiOjQ4fV0sNDg6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xcbi8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki8ndXNlIHN0cmljdCc7XFxuXFxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcXG5leHBvcnRzWydkZWZhdWx0J10gPSAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqL0RpZmY7XFxuZnVuY3Rpb24gRGlmZigpIHt9XFxuXFxuRGlmZi5wcm90b3R5cGUgPSB7IC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki9cXG4gIC8qaXN0YW5idWwgaWdub3JlIGVuZCovZGlmZjogZnVuY3Rpb24gZGlmZihvbGRTdHJpbmcsIG5ld1N0cmluZykge1xcbiAgICAvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovdmFyIC8qaXN0YW5idWwgaWdub3JlIGVuZCovb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMiB8fCBhcmd1bWVudHNbMl0gPT09IHVuZGVmaW5lZCA/IHt9IDogYXJndW1lbnRzWzJdO1xcblxcbiAgICB2YXIgY2FsbGJhY2sgPSBvcHRpb25zLmNhbGxiYWNrO1xcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdmdW5jdGlvbicpIHtcXG4gICAgICBjYWxsYmFjayA9IG9wdGlvbnM7XFxuICAgICAgb3B0aW9ucyA9IHt9O1xcbiAgICB9XFxuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XFxuXFxuICAgIHZhciBzZWxmID0gdGhpcztcXG5cXG4gICAgZnVuY3Rpb24gZG9uZSh2YWx1ZSkge1xcbiAgICAgIGlmIChjYWxsYmFjaykge1xcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgIGNhbGxiYWNrKHVuZGVmaW5lZCwgdmFsdWUpO1xcbiAgICAgICAgfSwgMCk7XFxuICAgICAgICByZXR1cm4gdHJ1ZTtcXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xcbiAgICAgIH1cXG4gICAgfVxcblxcbiAgICAvLyBBbGxvdyBzdWJjbGFzc2VzIHRvIG1hc3NhZ2UgdGhlIGlucHV0IHByaW9yIHRvIHJ1bm5pbmdcXG4gICAgb2xkU3RyaW5nID0gdGhpcy5jYXN0SW5wdXQob2xkU3RyaW5nKTtcXG4gICAgbmV3U3RyaW5nID0gdGhpcy5jYXN0SW5wdXQobmV3U3RyaW5nKTtcXG5cXG4gICAgb2xkU3RyaW5nID0gdGhpcy5yZW1vdmVFbXB0eSh0aGlzLnRva2VuaXplKG9sZFN0cmluZykpO1xcbiAgICBuZXdTdHJpbmcgPSB0aGlzLnJlbW92ZUVtcHR5KHRoaXMudG9rZW5pemUobmV3U3RyaW5nKSk7XFxuXFxuICAgIHZhciBuZXdMZW4gPSBuZXdTdHJpbmcubGVuZ3RoLFxcbiAgICAgICAgb2xkTGVuID0gb2xkU3RyaW5nLmxlbmd0aDtcXG4gICAgdmFyIGVkaXRMZW5ndGggPSAxO1xcbiAgICB2YXIgbWF4RWRpdExlbmd0aCA9IG5ld0xlbiArIG9sZExlbjtcXG4gICAgdmFyIGJlc3RQYXRoID0gW3sgbmV3UG9zOiAtMSwgY29tcG9uZW50czogW10gfV07XFxuXFxuICAgIC8vIFNlZWQgZWRpdExlbmd0aCA9IDAsIGkuZS4gdGhlIGNvbnRlbnQgc3RhcnRzIHdpdGggdGhlIHNhbWUgdmFsdWVzXFxuICAgIHZhciBvbGRQb3MgPSB0aGlzLmV4dHJhY3RDb21tb24oYmVzdFBhdGhbMF0sIG5ld1N0cmluZywgb2xkU3RyaW5nLCAwKTtcXG4gICAgaWYgKGJlc3RQYXRoWzBdLm5ld1BvcyArIDEgPj0gbmV3TGVuICYmIG9sZFBvcyArIDEgPj0gb2xkTGVuKSB7XFxuICAgICAgLy8gSWRlbnRpdHkgcGVyIHRoZSBlcXVhbGl0eSBhbmQgdG9rZW5pemVyXFxuICAgICAgcmV0dXJuIGRvbmUoW3sgdmFsdWU6IHRoaXMuam9pbihuZXdTdHJpbmcpLCBjb3VudDogbmV3U3RyaW5nLmxlbmd0aCB9XSk7XFxuICAgIH1cXG5cXG4gICAgLy8gTWFpbiB3b3JrZXIgbWV0aG9kLiBjaGVja3MgYWxsIHBlcm11dGF0aW9ucyBvZiBhIGdpdmVuIGVkaXQgbGVuZ3RoIGZvciBhY2NlcHRhbmNlLlxcbiAgICBmdW5jdGlvbiBleGVjRWRpdExlbmd0aCgpIHtcXG4gICAgICBmb3IgKHZhciBkaWFnb25hbFBhdGggPSAtMSAqIGVkaXRMZW5ndGg7IGRpYWdvbmFsUGF0aCA8PSBlZGl0TGVuZ3RoOyBkaWFnb25hbFBhdGggKz0gMikge1xcbiAgICAgICAgdmFyIGJhc2VQYXRoID0gLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL3ZvaWQgMCAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqLztcXG4gICAgICAgIHZhciBhZGRQYXRoID0gYmVzdFBhdGhbZGlhZ29uYWxQYXRoIC0gMV0sXFxuICAgICAgICAgICAgcmVtb3ZlUGF0aCA9IGJlc3RQYXRoW2RpYWdvbmFsUGF0aCArIDFdLFxcbiAgICAgICAgICAgIF9vbGRQb3MgPSAocmVtb3ZlUGF0aCA/IHJlbW92ZVBhdGgubmV3UG9zIDogMCkgLSBkaWFnb25hbFBhdGg7XFxuICAgICAgICBpZiAoYWRkUGF0aCkge1xcbiAgICAgICAgICAvLyBObyBvbmUgZWxzZSBpcyBnb2luZyB0byBhdHRlbXB0IHRvIHVzZSB0aGlzIHZhbHVlLCBjbGVhciBpdFxcbiAgICAgICAgICBiZXN0UGF0aFtkaWFnb25hbFBhdGggLSAxXSA9IHVuZGVmaW5lZDtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIHZhciBjYW5BZGQgPSBhZGRQYXRoICYmIGFkZFBhdGgubmV3UG9zICsgMSA8IG5ld0xlbixcXG4gICAgICAgICAgICBjYW5SZW1vdmUgPSByZW1vdmVQYXRoICYmIDAgPD0gX29sZFBvcyAmJiBfb2xkUG9zIDwgb2xkTGVuO1xcbiAgICAgICAgaWYgKCFjYW5BZGQgJiYgIWNhblJlbW92ZSkge1xcbiAgICAgICAgICAvLyBJZiB0aGlzIHBhdGggaXMgYSB0ZXJtaW5hbCB0aGVuIHBydW5lXFxuICAgICAgICAgIGJlc3RQYXRoW2RpYWdvbmFsUGF0aF0gPSB1bmRlZmluZWQ7XFxuICAgICAgICAgIGNvbnRpbnVlO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgLy8gU2VsZWN0IHRoZSBkaWFnb25hbCB0aGF0IHdlIHdhbnQgdG8gYnJhbmNoIGZyb20uIFdlIHNlbGVjdCB0aGUgcHJpb3JcXG4gICAgICAgIC8vIHBhdGggd2hvc2UgcG9zaXRpb24gaW4gdGhlIG5ldyBzdHJpbmcgaXMgdGhlIGZhcnRoZXN0IGZyb20gdGhlIG9yaWdpblxcbiAgICAgICAgLy8gYW5kIGRvZXMgbm90IHBhc3MgdGhlIGJvdW5kcyBvZiB0aGUgZGlmZiBncmFwaFxcbiAgICAgICAgaWYgKCFjYW5BZGQgfHwgY2FuUmVtb3ZlICYmIGFkZFBhdGgubmV3UG9zIDwgcmVtb3ZlUGF0aC5uZXdQb3MpIHtcXG4gICAgICAgICAgYmFzZVBhdGggPSBjbG9uZVBhdGgocmVtb3ZlUGF0aCk7XFxuICAgICAgICAgIHNlbGYucHVzaENvbXBvbmVudChiYXNlUGF0aC5jb21wb25lbnRzLCB1bmRlZmluZWQsIHRydWUpO1xcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgYmFzZVBhdGggPSBhZGRQYXRoOyAvLyBObyBuZWVkIHRvIGNsb25lLCB3ZSd2ZSBwdWxsZWQgaXQgZnJvbSB0aGUgbGlzdFxcbiAgICAgICAgICBiYXNlUGF0aC5uZXdQb3MrKztcXG4gICAgICAgICAgc2VsZi5wdXNoQ29tcG9uZW50KGJhc2VQYXRoLmNvbXBvbmVudHMsIHRydWUsIHVuZGVmaW5lZCk7XFxuICAgICAgICB9XFxuXFxuICAgICAgICBfb2xkUG9zID0gc2VsZi5leHRyYWN0Q29tbW9uKGJhc2VQYXRoLCBuZXdTdHJpbmcsIG9sZFN0cmluZywgZGlhZ29uYWxQYXRoKTtcXG5cXG4gICAgICAgIC8vIElmIHdlIGhhdmUgaGl0IHRoZSBlbmQgb2YgYm90aCBzdHJpbmdzLCB0aGVuIHdlIGFyZSBkb25lXFxuICAgICAgICBpZiAoYmFzZVBhdGgubmV3UG9zICsgMSA+PSBuZXdMZW4gJiYgX29sZFBvcyArIDEgPj0gb2xkTGVuKSB7XFxuICAgICAgICAgIHJldHVybiBkb25lKGJ1aWxkVmFsdWVzKHNlbGYsIGJhc2VQYXRoLmNvbXBvbmVudHMsIG5ld1N0cmluZywgb2xkU3RyaW5nLCBzZWxmLnVzZUxvbmdlc3RUb2tlbikpO1xcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgLy8gT3RoZXJ3aXNlIHRyYWNrIHRoaXMgcGF0aCBhcyBhIHBvdGVudGlhbCBjYW5kaWRhdGUgYW5kIGNvbnRpbnVlLlxcbiAgICAgICAgICBiZXN0UGF0aFtkaWFnb25hbFBhdGhdID0gYmFzZVBhdGg7XFxuICAgICAgICB9XFxuICAgICAgfVxcblxcbiAgICAgIGVkaXRMZW5ndGgrKztcXG4gICAgfVxcblxcbiAgICAvLyBQZXJmb3JtcyB0aGUgbGVuZ3RoIG9mIGVkaXQgaXRlcmF0aW9uLiBJcyBhIGJpdCBmdWdseSBhcyB0aGlzIGhhcyB0byBzdXBwb3J0IHRoZVxcbiAgICAvLyBzeW5jIGFuZCBhc3luYyBtb2RlIHdoaWNoIGlzIG5ldmVyIGZ1bi4gTG9vcHMgb3ZlciBleGVjRWRpdExlbmd0aCB1bnRpbCBhIHZhbHVlXFxuICAgIC8vIGlzIHByb2R1Y2VkLlxcbiAgICBpZiAoY2FsbGJhY2spIHtcXG4gICAgICAoZnVuY3Rpb24gZXhlYygpIHtcXG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICAvLyBUaGlzIHNob3VsZCBub3QgaGFwcGVuLCBidXQgd2Ugd2FudCB0byBiZSBzYWZlLlxcbiAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xcbiAgICAgICAgICBpZiAoZWRpdExlbmd0aCA+IG1heEVkaXRMZW5ndGgpIHtcXG4gICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soKTtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBpZiAoIWV4ZWNFZGl0TGVuZ3RoKCkpIHtcXG4gICAgICAgICAgICBleGVjKCk7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH0sIDApO1xcbiAgICAgIH0pKCk7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgd2hpbGUgKGVkaXRMZW5ndGggPD0gbWF4RWRpdExlbmd0aCkge1xcbiAgICAgICAgdmFyIHJldCA9IGV4ZWNFZGl0TGVuZ3RoKCk7XFxuICAgICAgICBpZiAocmV0KSB7XFxuICAgICAgICAgIHJldHVybiByZXQ7XFxuICAgICAgICB9XFxuICAgICAgfVxcbiAgICB9XFxuICB9LFxcbiAgLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqLyAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqL3B1c2hDb21wb25lbnQ6IGZ1bmN0aW9uIHB1c2hDb21wb25lbnQoY29tcG9uZW50cywgYWRkZWQsIHJlbW92ZWQpIHtcXG4gICAgdmFyIGxhc3QgPSBjb21wb25lbnRzW2NvbXBvbmVudHMubGVuZ3RoIC0gMV07XFxuICAgIGlmIChsYXN0ICYmIGxhc3QuYWRkZWQgPT09IGFkZGVkICYmIGxhc3QucmVtb3ZlZCA9PT0gcmVtb3ZlZCkge1xcbiAgICAgIC8vIFdlIG5lZWQgdG8gY2xvbmUgaGVyZSBhcyB0aGUgY29tcG9uZW50IGNsb25lIG9wZXJhdGlvbiBpcyBqdXN0XFxuICAgICAgLy8gYXMgc2hhbGxvdyBhcnJheSBjbG9uZVxcbiAgICAgIGNvbXBvbmVudHNbY29tcG9uZW50cy5sZW5ndGggLSAxXSA9IHsgY291bnQ6IGxhc3QuY291bnQgKyAxLCBhZGRlZDogYWRkZWQsIHJlbW92ZWQ6IHJlbW92ZWQgfTtcXG4gICAgfSBlbHNlIHtcXG4gICAgICBjb21wb25lbnRzLnB1c2goeyBjb3VudDogMSwgYWRkZWQ6IGFkZGVkLCByZW1vdmVkOiByZW1vdmVkIH0pO1xcbiAgICB9XFxuICB9LFxcbiAgLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqLyAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqL2V4dHJhY3RDb21tb246IGZ1bmN0aW9uIGV4dHJhY3RDb21tb24oYmFzZVBhdGgsIG5ld1N0cmluZywgb2xkU3RyaW5nLCBkaWFnb25hbFBhdGgpIHtcXG4gICAgdmFyIG5ld0xlbiA9IG5ld1N0cmluZy5sZW5ndGgsXFxuICAgICAgICBvbGRMZW4gPSBvbGRTdHJpbmcubGVuZ3RoLFxcbiAgICAgICAgbmV3UG9zID0gYmFzZVBhdGgubmV3UG9zLFxcbiAgICAgICAgb2xkUG9zID0gbmV3UG9zIC0gZGlhZ29uYWxQYXRoLFxcbiAgICAgICAgY29tbW9uQ291bnQgPSAwO1xcbiAgICB3aGlsZSAobmV3UG9zICsgMSA8IG5ld0xlbiAmJiBvbGRQb3MgKyAxIDwgb2xkTGVuICYmIHRoaXMuZXF1YWxzKG5ld1N0cmluZ1tuZXdQb3MgKyAxXSwgb2xkU3RyaW5nW29sZFBvcyArIDFdKSkge1xcbiAgICAgIG5ld1BvcysrO1xcbiAgICAgIG9sZFBvcysrO1xcbiAgICAgIGNvbW1vbkNvdW50Kys7XFxuICAgIH1cXG5cXG4gICAgaWYgKGNvbW1vbkNvdW50KSB7XFxuICAgICAgYmFzZVBhdGguY29tcG9uZW50cy5wdXNoKHsgY291bnQ6IGNvbW1vbkNvdW50IH0pO1xcbiAgICB9XFxuXFxuICAgIGJhc2VQYXRoLm5ld1BvcyA9IG5ld1BvcztcXG4gICAgcmV0dXJuIG9sZFBvcztcXG4gIH0sXFxuICAvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovIC8qaXN0YW5idWwgaWdub3JlIGVuZCovZXF1YWxzOiBmdW5jdGlvbiBlcXVhbHMobGVmdCwgcmlnaHQpIHtcXG4gICAgcmV0dXJuIGxlZnQgPT09IHJpZ2h0O1xcbiAgfSxcXG4gIC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki8gLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi9yZW1vdmVFbXB0eTogZnVuY3Rpb24gcmVtb3ZlRW1wdHkoYXJyYXkpIHtcXG4gICAgdmFyIHJldCA9IFtdO1xcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgaSsrKSB7XFxuICAgICAgaWYgKGFycmF5W2ldKSB7XFxuICAgICAgICByZXQucHVzaChhcnJheVtpXSk7XFxuICAgICAgfVxcbiAgICB9XFxuICAgIHJldHVybiByZXQ7XFxuICB9LFxcbiAgLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqLyAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqL2Nhc3RJbnB1dDogZnVuY3Rpb24gY2FzdElucHV0KHZhbHVlKSB7XFxuICAgIHJldHVybiB2YWx1ZTtcXG4gIH0sXFxuICAvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovIC8qaXN0YW5idWwgaWdub3JlIGVuZCovdG9rZW5pemU6IGZ1bmN0aW9uIHRva2VuaXplKHZhbHVlKSB7XFxuICAgIHJldHVybiB2YWx1ZS5zcGxpdCgnJyk7XFxuICB9LFxcbiAgLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqLyAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqL2pvaW46IGZ1bmN0aW9uIGpvaW4oY2hhcnMpIHtcXG4gICAgcmV0dXJuIGNoYXJzLmpvaW4oJycpO1xcbiAgfVxcbn07XFxuXFxuZnVuY3Rpb24gYnVpbGRWYWx1ZXMoZGlmZiwgY29tcG9uZW50cywgbmV3U3RyaW5nLCBvbGRTdHJpbmcsIHVzZUxvbmdlc3RUb2tlbikge1xcbiAgdmFyIGNvbXBvbmVudFBvcyA9IDAsXFxuICAgICAgY29tcG9uZW50TGVuID0gY29tcG9uZW50cy5sZW5ndGgsXFxuICAgICAgbmV3UG9zID0gMCxcXG4gICAgICBvbGRQb3MgPSAwO1xcblxcbiAgZm9yICg7IGNvbXBvbmVudFBvcyA8IGNvbXBvbmVudExlbjsgY29tcG9uZW50UG9zKyspIHtcXG4gICAgdmFyIGNvbXBvbmVudCA9IGNvbXBvbmVudHNbY29tcG9uZW50UG9zXTtcXG4gICAgaWYgKCFjb21wb25lbnQucmVtb3ZlZCkge1xcbiAgICAgIGlmICghY29tcG9uZW50LmFkZGVkICYmIHVzZUxvbmdlc3RUb2tlbikge1xcbiAgICAgICAgdmFyIHZhbHVlID0gbmV3U3RyaW5nLnNsaWNlKG5ld1BvcywgbmV3UG9zICsgY29tcG9uZW50LmNvdW50KTtcXG4gICAgICAgIHZhbHVlID0gdmFsdWUubWFwKGZ1bmN0aW9uICh2YWx1ZSwgaSkge1xcbiAgICAgICAgICB2YXIgb2xkVmFsdWUgPSBvbGRTdHJpbmdbb2xkUG9zICsgaV07XFxuICAgICAgICAgIHJldHVybiBvbGRWYWx1ZS5sZW5ndGggPiB2YWx1ZS5sZW5ndGggPyBvbGRWYWx1ZSA6IHZhbHVlO1xcbiAgICAgICAgfSk7XFxuXFxuICAgICAgICBjb21wb25lbnQudmFsdWUgPSBkaWZmLmpvaW4odmFsdWUpO1xcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICBjb21wb25lbnQudmFsdWUgPSBkaWZmLmpvaW4obmV3U3RyaW5nLnNsaWNlKG5ld1BvcywgbmV3UG9zICsgY29tcG9uZW50LmNvdW50KSk7XFxuICAgICAgfVxcbiAgICAgIG5ld1BvcyArPSBjb21wb25lbnQuY291bnQ7XFxuXFxuICAgICAgLy8gQ29tbW9uIGNhc2VcXG4gICAgICBpZiAoIWNvbXBvbmVudC5hZGRlZCkge1xcbiAgICAgICAgb2xkUG9zICs9IGNvbXBvbmVudC5jb3VudDtcXG4gICAgICB9XFxuICAgIH0gZWxzZSB7XFxuICAgICAgY29tcG9uZW50LnZhbHVlID0gZGlmZi5qb2luKG9sZFN0cmluZy5zbGljZShvbGRQb3MsIG9sZFBvcyArIGNvbXBvbmVudC5jb3VudCkpO1xcbiAgICAgIG9sZFBvcyArPSBjb21wb25lbnQuY291bnQ7XFxuXFxuICAgICAgLy8gUmV2ZXJzZSBhZGQgYW5kIHJlbW92ZSBzbyByZW1vdmVzIGFyZSBvdXRwdXQgZmlyc3QgdG8gbWF0Y2ggY29tbW9uIGNvbnZlbnRpb25cXG4gICAgICAvLyBUaGUgZGlmZmluZyBhbGdvcml0aG0gaXMgdGllZCB0byBhZGQgdGhlbiByZW1vdmUgb3V0cHV0IGFuZCB0aGlzIGlzIHRoZSBzaW1wbGVzdFxcbiAgICAgIC8vIHJvdXRlIHRvIGdldCB0aGUgZGVzaXJlZCBvdXRwdXQgd2l0aCBtaW5pbWFsIG92ZXJoZWFkLlxcbiAgICAgIGlmIChjb21wb25lbnRQb3MgJiYgY29tcG9uZW50c1tjb21wb25lbnRQb3MgLSAxXS5hZGRlZCkge1xcbiAgICAgICAgdmFyIHRtcCA9IGNvbXBvbmVudHNbY29tcG9uZW50UG9zIC0gMV07XFxuICAgICAgICBjb21wb25lbnRzW2NvbXBvbmVudFBvcyAtIDFdID0gY29tcG9uZW50c1tjb21wb25lbnRQb3NdO1xcbiAgICAgICAgY29tcG9uZW50c1tjb21wb25lbnRQb3NdID0gdG1wO1xcbiAgICAgIH1cXG4gICAgfVxcbiAgfVxcblxcbiAgLy8gU3BlY2lhbCBjYXNlIGhhbmRsZSBmb3Igd2hlbiBvbmUgdGVybWluYWwgaXMgaWdub3JlZC4gRm9yIHRoaXMgY2FzZSB3ZSBtZXJnZSB0aGVcXG4gIC8vIHRlcm1pbmFsIGludG8gdGhlIHByaW9yIHN0cmluZyBhbmQgZHJvcCB0aGUgY2hhbmdlLlxcbiAgdmFyIGxhc3RDb21wb25lbnQgPSBjb21wb25lbnRzW2NvbXBvbmVudExlbiAtIDFdO1xcbiAgaWYgKGNvbXBvbmVudExlbiA+IDEgJiYgKGxhc3RDb21wb25lbnQuYWRkZWQgfHwgbGFzdENvbXBvbmVudC5yZW1vdmVkKSAmJiBkaWZmLmVxdWFscygnJywgbGFzdENvbXBvbmVudC52YWx1ZSkpIHtcXG4gICAgY29tcG9uZW50c1tjb21wb25lbnRMZW4gLSAyXS52YWx1ZSArPSBsYXN0Q29tcG9uZW50LnZhbHVlO1xcbiAgICBjb21wb25lbnRzLnBvcCgpO1xcbiAgfVxcblxcbiAgcmV0dXJuIGNvbXBvbmVudHM7XFxufVxcblxcbmZ1bmN0aW9uIGNsb25lUGF0aChwYXRoKSB7XFxuICByZXR1cm4geyBuZXdQb3M6IHBhdGgubmV3UG9zLCBjb21wb25lbnRzOiBwYXRoLmNvbXBvbmVudHMuc2xpY2UoMCkgfTtcXG59XFxuXFxuXFxufSx7fV0sNDk6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xcbi8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki8ndXNlIHN0cmljdCc7XFxuXFxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcXG5leHBvcnRzLmNoYXJhY3RlckRpZmYgPSB1bmRlZmluZWQ7XFxuZXhwb3J0cy4gLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi9kaWZmQ2hhcnMgPSBkaWZmQ2hhcnM7XFxuXFxudmFyIC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki9fYmFzZSA9IHJlcXVpcmUoJy4vYmFzZScpIC8qaXN0YW5idWwgaWdub3JlIGVuZCovO1xcblxcbi8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki9cXG52YXIgX2Jhc2UyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfYmFzZSk7XFxuXFxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxcblxcbi8qaXN0YW5idWwgaWdub3JlIGVuZCovdmFyIGNoYXJhY3RlckRpZmYgPSAvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovZXhwb3J0cy4gLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi9jaGFyYWN0ZXJEaWZmID0gbmV3IC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki9fYmFzZTJbJ2RlZmF1bHQnXSgpIC8qaXN0YW5idWwgaWdub3JlIGVuZCovO1xcbmZ1bmN0aW9uIGRpZmZDaGFycyhvbGRTdHIsIG5ld1N0ciwgY2FsbGJhY2spIHtcXG4gIHJldHVybiBjaGFyYWN0ZXJEaWZmLmRpZmYob2xkU3RyLCBuZXdTdHIsIGNhbGxiYWNrKTtcXG59XFxuXFxuXFxufSx7XFxcIi4vYmFzZVxcXCI6NDh9XSw1MDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XFxuLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqLyd1c2Ugc3RyaWN0JztcXG5cXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xcbmV4cG9ydHMuY3NzRGlmZiA9IHVuZGVmaW5lZDtcXG5leHBvcnRzLiAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqL2RpZmZDc3MgPSBkaWZmQ3NzO1xcblxcbnZhciAvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovX2Jhc2UgPSByZXF1aXJlKCcuL2Jhc2UnKSAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqLztcXG5cXG4vKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovXFxudmFyIF9iYXNlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2Jhc2UpO1xcblxcbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cXG5cXG4vKmlzdGFuYnVsIGlnbm9yZSBlbmQqL3ZhciBjc3NEaWZmID0gLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL2V4cG9ydHMuIC8qaXN0YW5idWwgaWdub3JlIGVuZCovY3NzRGlmZiA9IG5ldyAvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovX2Jhc2UyWydkZWZhdWx0J10oKSAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqLztcXG5jc3NEaWZmLnRva2VuaXplID0gZnVuY3Rpb24gKHZhbHVlKSB7XFxuICByZXR1cm4gdmFsdWUuc3BsaXQoLyhbe306OyxdfFxcXFxzKykvKTtcXG59O1xcblxcbmZ1bmN0aW9uIGRpZmZDc3Mob2xkU3RyLCBuZXdTdHIsIGNhbGxiYWNrKSB7XFxuICByZXR1cm4gY3NzRGlmZi5kaWZmKG9sZFN0ciwgbmV3U3RyLCBjYWxsYmFjayk7XFxufVxcblxcblxcbn0se1xcXCIuL2Jhc2VcXFwiOjQ4fV0sNTE6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xcbi8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki8ndXNlIHN0cmljdCc7XFxuXFxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcXG5leHBvcnRzLmpzb25EaWZmID0gdW5kZWZpbmVkO1xcblxcbnZhciBfdHlwZW9mID0gdHlwZW9mIFN5bWJvbCA9PT0gXFxcImZ1bmN0aW9uXFxcIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcXFwic3ltYm9sXFxcIiA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXFxcImZ1bmN0aW9uXFxcIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCA/IFxcXCJzeW1ib2xcXFwiIDogdHlwZW9mIG9iajsgfTtcXG5cXG5leHBvcnRzLiAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqL2RpZmZKc29uID0gZGlmZkpzb247XFxuLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL2V4cG9ydHMuIC8qaXN0YW5idWwgaWdub3JlIGVuZCovY2Fub25pY2FsaXplID0gY2Fub25pY2FsaXplO1xcblxcbnZhciAvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovX2Jhc2UgPSByZXF1aXJlKCcuL2Jhc2UnKSAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqLztcXG5cXG4vKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovXFxudmFyIF9iYXNlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2Jhc2UpO1xcblxcbi8qaXN0YW5idWwgaWdub3JlIGVuZCovXFxudmFyIC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki9fbGluZSA9IHJlcXVpcmUoJy4vbGluZScpIC8qaXN0YW5idWwgaWdub3JlIGVuZCovO1xcblxcbi8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki9cXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyAnZGVmYXVsdCc6IG9iaiB9OyB9XFxuXFxuLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi9cXG5cXG52YXIgb2JqZWN0UHJvdG90eXBlVG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xcblxcbnZhciBqc29uRGlmZiA9IC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki9leHBvcnRzLiAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqL2pzb25EaWZmID0gbmV3IC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki9fYmFzZTJbJ2RlZmF1bHQnXSgpIC8qaXN0YW5idWwgaWdub3JlIGVuZCovO1xcbi8vIERpc2NyaW1pbmF0ZSBiZXR3ZWVuIHR3byBsaW5lcyBvZiBwcmV0dHktcHJpbnRlZCwgc2VyaWFsaXplZCBKU09OIHdoZXJlIG9uZSBvZiB0aGVtIGhhcyBhXFxuLy8gZGFuZ2xpbmcgY29tbWEgYW5kIHRoZSBvdGhlciBkb2Vzbid0LiBUdXJucyBvdXQgaW5jbHVkaW5nIHRoZSBkYW5nbGluZyBjb21tYSB5aWVsZHMgdGhlIG5pY2VzdCBvdXRwdXQ6XFxuanNvbkRpZmYudXNlTG9uZ2VzdFRva2VuID0gdHJ1ZTtcXG5cXG5qc29uRGlmZi50b2tlbml6ZSA9IC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki9fbGluZS5saW5lRGlmZi4gLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi90b2tlbml6ZTtcXG5qc29uRGlmZi5jYXN0SW5wdXQgPSBmdW5jdGlvbiAodmFsdWUpIHtcXG4gIC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki92YXIgLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi91bmRlZmluZWRSZXBsYWNlbWVudCA9IHRoaXMub3B0aW9ucy51bmRlZmluZWRSZXBsYWNlbWVudDtcXG5cXG5cXG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnID8gdmFsdWUgOiBKU09OLnN0cmluZ2lmeShjYW5vbmljYWxpemUodmFsdWUpLCBmdW5jdGlvbiAoaywgdikge1xcbiAgICBpZiAodHlwZW9mIHYgPT09ICd1bmRlZmluZWQnKSB7XFxuICAgICAgcmV0dXJuIHVuZGVmaW5lZFJlcGxhY2VtZW50O1xcbiAgICB9XFxuXFxuICAgIHJldHVybiB2O1xcbiAgfSwgJyAgJyk7XFxufTtcXG5qc29uRGlmZi5lcXVhbHMgPSBmdW5jdGlvbiAobGVmdCwgcmlnaHQpIHtcXG4gIHJldHVybiAoLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL19iYXNlMlsnZGVmYXVsdCddLiAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqL3Byb3RvdHlwZS5lcXVhbHMobGVmdC5yZXBsYWNlKC8sKFtcXFxcclxcXFxuXSkvZywgJyQxJyksIHJpZ2h0LnJlcGxhY2UoLywoW1xcXFxyXFxcXG5dKS9nLCAnJDEnKSlcXG4gICk7XFxufTtcXG5cXG5mdW5jdGlvbiBkaWZmSnNvbihvbGRPYmosIG5ld09iaiwgb3B0aW9ucykge1xcbiAgcmV0dXJuIGpzb25EaWZmLmRpZmYob2xkT2JqLCBuZXdPYmosIG9wdGlvbnMpO1xcbn1cXG5cXG4vLyBUaGlzIGZ1bmN0aW9uIGhhbmRsZXMgdGhlIHByZXNlbmNlIG9mIGNpcmN1bGFyIHJlZmVyZW5jZXMgYnkgYmFpbGluZyBvdXQgd2hlbiBlbmNvdW50ZXJpbmcgYW5cXG4vLyBvYmplY3QgdGhhdCBpcyBhbHJlYWR5IG9uIHRoZSBcXFwic3RhY2tcXFwiIG9mIGl0ZW1zIGJlaW5nIHByb2Nlc3NlZC5cXG5mdW5jdGlvbiBjYW5vbmljYWxpemUob2JqLCBzdGFjaywgcmVwbGFjZW1lbnRTdGFjaykge1xcbiAgc3RhY2sgPSBzdGFjayB8fCBbXTtcXG4gIHJlcGxhY2VtZW50U3RhY2sgPSByZXBsYWNlbWVudFN0YWNrIHx8IFtdO1xcblxcbiAgdmFyIGkgPSAvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovdm9pZCAwIC8qaXN0YW5idWwgaWdub3JlIGVuZCovO1xcblxcbiAgZm9yIChpID0gMDsgaSA8IHN0YWNrLmxlbmd0aDsgaSArPSAxKSB7XFxuICAgIGlmIChzdGFja1tpXSA9PT0gb2JqKSB7XFxuICAgICAgcmV0dXJuIHJlcGxhY2VtZW50U3RhY2tbaV07XFxuICAgIH1cXG4gIH1cXG5cXG4gIHZhciBjYW5vbmljYWxpemVkT2JqID0gLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL3ZvaWQgMCAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqLztcXG5cXG4gIGlmICgnW29iamVjdCBBcnJheV0nID09PSBvYmplY3RQcm90b3R5cGVUb1N0cmluZy5jYWxsKG9iaikpIHtcXG4gICAgc3RhY2sucHVzaChvYmopO1xcbiAgICBjYW5vbmljYWxpemVkT2JqID0gbmV3IEFycmF5KG9iai5sZW5ndGgpO1xcbiAgICByZXBsYWNlbWVudFN0YWNrLnB1c2goY2Fub25pY2FsaXplZE9iaik7XFxuICAgIGZvciAoaSA9IDA7IGkgPCBvYmoubGVuZ3RoOyBpICs9IDEpIHtcXG4gICAgICBjYW5vbmljYWxpemVkT2JqW2ldID0gY2Fub25pY2FsaXplKG9ialtpXSwgc3RhY2ssIHJlcGxhY2VtZW50U3RhY2spO1xcbiAgICB9XFxuICAgIHN0YWNrLnBvcCgpO1xcbiAgICByZXBsYWNlbWVudFN0YWNrLnBvcCgpO1xcbiAgICByZXR1cm4gY2Fub25pY2FsaXplZE9iajtcXG4gIH1cXG5cXG4gIGlmIChvYmogJiYgb2JqLnRvSlNPTikge1xcbiAgICBvYmogPSBvYmoudG9KU09OKCk7XFxuICB9XFxuXFxuICBpZiAoIC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki8odHlwZW9mIC8qaXN0YW5idWwgaWdub3JlIGVuZCovb2JqID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZihvYmopKSA9PT0gJ29iamVjdCcgJiYgb2JqICE9PSBudWxsKSB7XFxuICAgIHN0YWNrLnB1c2gob2JqKTtcXG4gICAgY2Fub25pY2FsaXplZE9iaiA9IHt9O1xcbiAgICByZXBsYWNlbWVudFN0YWNrLnB1c2goY2Fub25pY2FsaXplZE9iaik7XFxuICAgIHZhciBzb3J0ZWRLZXlzID0gW10sXFxuICAgICAgICBrZXkgPSAvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovdm9pZCAwIC8qaXN0YW5idWwgaWdub3JlIGVuZCovO1xcbiAgICBmb3IgKGtleSBpbiBvYmopIHtcXG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xcbiAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkoa2V5KSkge1xcbiAgICAgICAgc29ydGVkS2V5cy5wdXNoKGtleSk7XFxuICAgICAgfVxcbiAgICB9XFxuICAgIHNvcnRlZEtleXMuc29ydCgpO1xcbiAgICBmb3IgKGkgPSAwOyBpIDwgc29ydGVkS2V5cy5sZW5ndGg7IGkgKz0gMSkge1xcbiAgICAgIGtleSA9IHNvcnRlZEtleXNbaV07XFxuICAgICAgY2Fub25pY2FsaXplZE9ialtrZXldID0gY2Fub25pY2FsaXplKG9ialtrZXldLCBzdGFjaywgcmVwbGFjZW1lbnRTdGFjayk7XFxuICAgIH1cXG4gICAgc3RhY2sucG9wKCk7XFxuICAgIHJlcGxhY2VtZW50U3RhY2sucG9wKCk7XFxuICB9IGVsc2Uge1xcbiAgICBjYW5vbmljYWxpemVkT2JqID0gb2JqO1xcbiAgfVxcbiAgcmV0dXJuIGNhbm9uaWNhbGl6ZWRPYmo7XFxufVxcblxcblxcbn0se1xcXCIuL2Jhc2VcXFwiOjQ4LFxcXCIuL2xpbmVcXFwiOjUyfV0sNTI6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xcbi8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki8ndXNlIHN0cmljdCc7XFxuXFxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcXG5leHBvcnRzLmxpbmVEaWZmID0gdW5kZWZpbmVkO1xcbmV4cG9ydHMuIC8qaXN0YW5idWwgaWdub3JlIGVuZCovZGlmZkxpbmVzID0gZGlmZkxpbmVzO1xcbi8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki9leHBvcnRzLiAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqL2RpZmZUcmltbWVkTGluZXMgPSBkaWZmVHJpbW1lZExpbmVzO1xcblxcbnZhciAvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovX2Jhc2UgPSByZXF1aXJlKCcuL2Jhc2UnKSAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqLztcXG5cXG4vKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovXFxudmFyIF9iYXNlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2Jhc2UpO1xcblxcbi8qaXN0YW5idWwgaWdub3JlIGVuZCovXFxudmFyIC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki9fcGFyYW1zID0gcmVxdWlyZSgnLi4vdXRpbC9wYXJhbXMnKSAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqLztcXG5cXG4vKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovXFxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxcblxcbi8qaXN0YW5idWwgaWdub3JlIGVuZCovdmFyIGxpbmVEaWZmID0gLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL2V4cG9ydHMuIC8qaXN0YW5idWwgaWdub3JlIGVuZCovbGluZURpZmYgPSBuZXcgLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL19iYXNlMlsnZGVmYXVsdCddKCkgLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi87XFxubGluZURpZmYudG9rZW5pemUgPSBmdW5jdGlvbiAodmFsdWUpIHtcXG4gIHZhciByZXRMaW5lcyA9IFtdLFxcbiAgICAgIGxpbmVzQW5kTmV3bGluZXMgPSB2YWx1ZS5zcGxpdCgvKFxcXFxufFxcXFxyXFxcXG4pLyk7XFxuXFxuICAvLyBJZ25vcmUgdGhlIGZpbmFsIGVtcHR5IHRva2VuIHRoYXQgb2NjdXJzIGlmIHRoZSBzdHJpbmcgZW5kcyB3aXRoIGEgbmV3IGxpbmVcXG4gIGlmICghbGluZXNBbmROZXdsaW5lc1tsaW5lc0FuZE5ld2xpbmVzLmxlbmd0aCAtIDFdKSB7XFxuICAgIGxpbmVzQW5kTmV3bGluZXMucG9wKCk7XFxuICB9XFxuXFxuICAvLyBNZXJnZSB0aGUgY29udGVudCBhbmQgbGluZSBzZXBhcmF0b3JzIGludG8gc2luZ2xlIHRva2Vuc1xcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaW5lc0FuZE5ld2xpbmVzLmxlbmd0aDsgaSsrKSB7XFxuICAgIHZhciBsaW5lID0gbGluZXNBbmROZXdsaW5lc1tpXTtcXG5cXG4gICAgaWYgKGkgJSAyICYmICF0aGlzLm9wdGlvbnMubmV3bGluZUlzVG9rZW4pIHtcXG4gICAgICByZXRMaW5lc1tyZXRMaW5lcy5sZW5ndGggLSAxXSArPSBsaW5lO1xcbiAgICB9IGVsc2Uge1xcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuaWdub3JlV2hpdGVzcGFjZSkge1xcbiAgICAgICAgbGluZSA9IGxpbmUudHJpbSgpO1xcbiAgICAgIH1cXG4gICAgICByZXRMaW5lcy5wdXNoKGxpbmUpO1xcbiAgICB9XFxuICB9XFxuXFxuICByZXR1cm4gcmV0TGluZXM7XFxufTtcXG5cXG5mdW5jdGlvbiBkaWZmTGluZXMob2xkU3RyLCBuZXdTdHIsIGNhbGxiYWNrKSB7XFxuICByZXR1cm4gbGluZURpZmYuZGlmZihvbGRTdHIsIG5ld1N0ciwgY2FsbGJhY2spO1xcbn1cXG5mdW5jdGlvbiBkaWZmVHJpbW1lZExpbmVzKG9sZFN0ciwgbmV3U3RyLCBjYWxsYmFjaykge1xcbiAgdmFyIG9wdGlvbnMgPSAvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovKDAsIF9wYXJhbXMuZ2VuZXJhdGVPcHRpb25zKSAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqLyhjYWxsYmFjaywgeyBpZ25vcmVXaGl0ZXNwYWNlOiB0cnVlIH0pO1xcbiAgcmV0dXJuIGxpbmVEaWZmLmRpZmYob2xkU3RyLCBuZXdTdHIsIG9wdGlvbnMpO1xcbn1cXG5cXG5cXG59LHtcXFwiLi4vdXRpbC9wYXJhbXNcXFwiOjYwLFxcXCIuL2Jhc2VcXFwiOjQ4fV0sNTM6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xcbi8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki8ndXNlIHN0cmljdCc7XFxuXFxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcXG5leHBvcnRzLnNlbnRlbmNlRGlmZiA9IHVuZGVmaW5lZDtcXG5leHBvcnRzLiAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqL2RpZmZTZW50ZW5jZXMgPSBkaWZmU2VudGVuY2VzO1xcblxcbnZhciAvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovX2Jhc2UgPSByZXF1aXJlKCcuL2Jhc2UnKSAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqLztcXG5cXG4vKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovXFxudmFyIF9iYXNlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2Jhc2UpO1xcblxcbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cXG5cXG4vKmlzdGFuYnVsIGlnbm9yZSBlbmQqL3ZhciBzZW50ZW5jZURpZmYgPSAvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovZXhwb3J0cy4gLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi9zZW50ZW5jZURpZmYgPSBuZXcgLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL19iYXNlMlsnZGVmYXVsdCddKCkgLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi87XFxuc2VudGVuY2VEaWZmLnRva2VuaXplID0gZnVuY3Rpb24gKHZhbHVlKSB7XFxuICByZXR1cm4gdmFsdWUuc3BsaXQoLyhcXFxcUy4rP1suIT9dKSg/PVxcXFxzK3wkKS8pO1xcbn07XFxuXFxuZnVuY3Rpb24gZGlmZlNlbnRlbmNlcyhvbGRTdHIsIG5ld1N0ciwgY2FsbGJhY2spIHtcXG4gIHJldHVybiBzZW50ZW5jZURpZmYuZGlmZihvbGRTdHIsIG5ld1N0ciwgY2FsbGJhY2spO1xcbn1cXG5cXG5cXG59LHtcXFwiLi9iYXNlXFxcIjo0OH1dLDU0OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcXG4vKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovJ3VzZSBzdHJpY3QnO1xcblxcbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XFxuZXhwb3J0cy53b3JkRGlmZiA9IHVuZGVmaW5lZDtcXG5leHBvcnRzLiAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqL2RpZmZXb3JkcyA9IGRpZmZXb3JkcztcXG4vKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovZXhwb3J0cy4gLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi9kaWZmV29yZHNXaXRoU3BhY2UgPSBkaWZmV29yZHNXaXRoU3BhY2U7XFxuXFxudmFyIC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki9fYmFzZSA9IHJlcXVpcmUoJy4vYmFzZScpIC8qaXN0YW5idWwgaWdub3JlIGVuZCovO1xcblxcbi8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki9cXG52YXIgX2Jhc2UyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfYmFzZSk7XFxuXFxuLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi9cXG52YXIgLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL19wYXJhbXMgPSByZXF1aXJlKCcuLi91dGlsL3BhcmFtcycpIC8qaXN0YW5idWwgaWdub3JlIGVuZCovO1xcblxcbi8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki9cXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyAnZGVmYXVsdCc6IG9iaiB9OyB9XFxuXFxuLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi9cXG5cXG4vLyBCYXNlZCBvbiBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9MYXRpbl9zY3JpcHRfaW5fVW5pY29kZVxcbi8vXFxuLy8gUmFuZ2VzIGFuZCBleGNlcHRpb25zOlxcbi8vIExhdGluLTEgU3VwcGxlbWVudCwgMDA4MOKAkzAwRkZcXG4vLyAgLSBVKzAwRDcgIMOXIE11bHRpcGxpY2F0aW9uIHNpZ25cXG4vLyAgLSBVKzAwRjcgIMO3IERpdmlzaW9uIHNpZ25cXG4vLyBMYXRpbiBFeHRlbmRlZC1BLCAwMTAw4oCTMDE3Rlxcbi8vIExhdGluIEV4dGVuZGVkLUIsIDAxODDigJMwMjRGXFxuLy8gSVBBIEV4dGVuc2lvbnMsIDAyNTDigJMwMkFGXFxuLy8gU3BhY2luZyBNb2RpZmllciBMZXR0ZXJzLCAwMkIw4oCTMDJGRlxcbi8vICAtIFUrMDJDNyAgy4cgJiM3MTE7ICBDYXJvblxcbi8vICAtIFUrMDJEOCAgy5ggJiM3Mjg7ICBCcmV2ZVxcbi8vICAtIFUrMDJEOSAgy5kgJiM3Mjk7ICBEb3QgQWJvdmVcXG4vLyAgLSBVKzAyREEgIMuaICYjNzMwOyAgUmluZyBBYm92ZVxcbi8vICAtIFUrMDJEQiAgy5sgJiM3MzE7ICBPZ29uZWtcXG4vLyAgLSBVKzAyREMgIMucICYjNzMyOyAgU21hbGwgVGlsZGVcXG4vLyAgLSBVKzAyREQgIMudICYjNzMzOyAgRG91YmxlIEFjdXRlIEFjY2VudFxcbi8vIExhdGluIEV4dGVuZGVkIEFkZGl0aW9uYWwsIDFFMDDigJMxRUZGXFxudmFyIGV4dGVuZGVkV29yZENoYXJzID0gL15bQS1aYS16XFxcXHhDMC1cXFxcdTAyQzZcXFxcdTAyQzgtXFxcXHUwMkQ3XFxcXHUwMkRFLVxcXFx1MDJGRlxcXFx1MUUwMC1cXFxcdTFFRkZdKyQvO1xcblxcbnZhciByZVdoaXRlc3BhY2UgPSAvXFxcXFMvO1xcblxcbnZhciB3b3JkRGlmZiA9IC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki9leHBvcnRzLiAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqL3dvcmREaWZmID0gbmV3IC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki9fYmFzZTJbJ2RlZmF1bHQnXSgpIC8qaXN0YW5idWwgaWdub3JlIGVuZCovO1xcbndvcmREaWZmLmVxdWFscyA9IGZ1bmN0aW9uIChsZWZ0LCByaWdodCkge1xcbiAgcmV0dXJuIGxlZnQgPT09IHJpZ2h0IHx8IHRoaXMub3B0aW9ucy5pZ25vcmVXaGl0ZXNwYWNlICYmICFyZVdoaXRlc3BhY2UudGVzdChsZWZ0KSAmJiAhcmVXaGl0ZXNwYWNlLnRlc3QocmlnaHQpO1xcbn07XFxud29yZERpZmYudG9rZW5pemUgPSBmdW5jdGlvbiAodmFsdWUpIHtcXG4gIHZhciB0b2tlbnMgPSB2YWx1ZS5zcGxpdCgvKFxcXFxzK3xcXFxcYikvKTtcXG5cXG4gIC8vIEpvaW4gdGhlIGJvdW5kYXJ5IHNwbGl0cyB0aGF0IHdlIGRvIG5vdCBjb25zaWRlciB0byBiZSBib3VuZGFyaWVzLiBUaGlzIGlzIHByaW1hcmlseSB0aGUgZXh0ZW5kZWQgTGF0aW4gY2hhcmFjdGVyIHNldC5cXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdG9rZW5zLmxlbmd0aCAtIDE7IGkrKykge1xcbiAgICAvLyBJZiB3ZSBoYXZlIGFuIGVtcHR5IHN0cmluZyBpbiB0aGUgbmV4dCBmaWVsZCBhbmQgd2UgaGF2ZSBvbmx5IHdvcmQgY2hhcnMgYmVmb3JlIGFuZCBhZnRlciwgbWVyZ2VcXG4gICAgaWYgKCF0b2tlbnNbaSArIDFdICYmIHRva2Vuc1tpICsgMl0gJiYgZXh0ZW5kZWRXb3JkQ2hhcnMudGVzdCh0b2tlbnNbaV0pICYmIGV4dGVuZGVkV29yZENoYXJzLnRlc3QodG9rZW5zW2kgKyAyXSkpIHtcXG4gICAgICB0b2tlbnNbaV0gKz0gdG9rZW5zW2kgKyAyXTtcXG4gICAgICB0b2tlbnMuc3BsaWNlKGkgKyAxLCAyKTtcXG4gICAgICBpLS07XFxuICAgIH1cXG4gIH1cXG5cXG4gIHJldHVybiB0b2tlbnM7XFxufTtcXG5cXG5mdW5jdGlvbiBkaWZmV29yZHMob2xkU3RyLCBuZXdTdHIsIGNhbGxiYWNrKSB7XFxuICB2YXIgb3B0aW9ucyA9IC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki8oMCwgX3BhcmFtcy5nZW5lcmF0ZU9wdGlvbnMpIC8qaXN0YW5idWwgaWdub3JlIGVuZCovKGNhbGxiYWNrLCB7IGlnbm9yZVdoaXRlc3BhY2U6IHRydWUgfSk7XFxuICByZXR1cm4gd29yZERpZmYuZGlmZihvbGRTdHIsIG5ld1N0ciwgb3B0aW9ucyk7XFxufVxcbmZ1bmN0aW9uIGRpZmZXb3Jkc1dpdGhTcGFjZShvbGRTdHIsIG5ld1N0ciwgY2FsbGJhY2spIHtcXG4gIHJldHVybiB3b3JkRGlmZi5kaWZmKG9sZFN0ciwgbmV3U3RyLCBjYWxsYmFjayk7XFxufVxcblxcblxcbn0se1xcXCIuLi91dGlsL3BhcmFtc1xcXCI6NjAsXFxcIi4vYmFzZVxcXCI6NDh9XSw1NTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XFxuLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqLyd1c2Ugc3RyaWN0JztcXG5cXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xcbmV4cG9ydHMuY2Fub25pY2FsaXplID0gZXhwb3J0cy5jb252ZXJ0Q2hhbmdlc1RvWE1MID0gZXhwb3J0cy5jb252ZXJ0Q2hhbmdlc1RvRE1QID0gZXhwb3J0cy5wYXJzZVBhdGNoID0gZXhwb3J0cy5hcHBseVBhdGNoZXMgPSBleHBvcnRzLmFwcGx5UGF0Y2ggPSBleHBvcnRzLmNyZWF0ZVBhdGNoID0gZXhwb3J0cy5jcmVhdGVUd29GaWxlc1BhdGNoID0gZXhwb3J0cy5zdHJ1Y3R1cmVkUGF0Y2ggPSBleHBvcnRzLmRpZmZBcnJheXMgPSBleHBvcnRzLmRpZmZKc29uID0gZXhwb3J0cy5kaWZmQ3NzID0gZXhwb3J0cy5kaWZmU2VudGVuY2VzID0gZXhwb3J0cy5kaWZmVHJpbW1lZExpbmVzID0gZXhwb3J0cy5kaWZmTGluZXMgPSBleHBvcnRzLmRpZmZXb3Jkc1dpdGhTcGFjZSA9IGV4cG9ydHMuZGlmZldvcmRzID0gZXhwb3J0cy5kaWZmQ2hhcnMgPSBleHBvcnRzLkRpZmYgPSB1bmRlZmluZWQ7XFxuLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi9cXG52YXIgLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL19iYXNlID0gcmVxdWlyZSgnLi9kaWZmL2Jhc2UnKSAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqLztcXG5cXG4vKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovXFxudmFyIF9iYXNlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2Jhc2UpO1xcblxcbi8qaXN0YW5idWwgaWdub3JlIGVuZCovXFxudmFyIC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki9fY2hhcmFjdGVyID0gcmVxdWlyZSgnLi9kaWZmL2NoYXJhY3RlcicpIC8qaXN0YW5idWwgaWdub3JlIGVuZCovO1xcblxcbnZhciAvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovX3dvcmQgPSByZXF1aXJlKCcuL2RpZmYvd29yZCcpIC8qaXN0YW5idWwgaWdub3JlIGVuZCovO1xcblxcbnZhciAvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovX2xpbmUgPSByZXF1aXJlKCcuL2RpZmYvbGluZScpIC8qaXN0YW5idWwgaWdub3JlIGVuZCovO1xcblxcbnZhciAvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovX3NlbnRlbmNlID0gcmVxdWlyZSgnLi9kaWZmL3NlbnRlbmNlJykgLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi87XFxuXFxudmFyIC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki9fY3NzID0gcmVxdWlyZSgnLi9kaWZmL2NzcycpIC8qaXN0YW5idWwgaWdub3JlIGVuZCovO1xcblxcbnZhciAvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovX2pzb24gPSByZXF1aXJlKCcuL2RpZmYvanNvbicpIC8qaXN0YW5idWwgaWdub3JlIGVuZCovO1xcblxcbnZhciAvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovX2FycmF5ID0gcmVxdWlyZSgnLi9kaWZmL2FycmF5JykgLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi87XFxuXFxudmFyIC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki9fYXBwbHkgPSByZXF1aXJlKCcuL3BhdGNoL2FwcGx5JykgLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi87XFxuXFxudmFyIC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki9fcGFyc2UgPSByZXF1aXJlKCcuL3BhdGNoL3BhcnNlJykgLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi87XFxuXFxudmFyIC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki9fY3JlYXRlID0gcmVxdWlyZSgnLi9wYXRjaC9jcmVhdGUnKSAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqLztcXG5cXG52YXIgLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL19kbXAgPSByZXF1aXJlKCcuL2NvbnZlcnQvZG1wJykgLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi87XFxuXFxudmFyIC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki9feG1sID0gcmVxdWlyZSgnLi9jb252ZXJ0L3htbCcpIC8qaXN0YW5idWwgaWdub3JlIGVuZCovO1xcblxcbi8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki9cXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyAnZGVmYXVsdCc6IG9iaiB9OyB9XFxuXFxuZXhwb3J0cy4gLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi9EaWZmID0gX2Jhc2UyWydkZWZhdWx0J107XFxuLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL2V4cG9ydHMuIC8qaXN0YW5idWwgaWdub3JlIGVuZCovZGlmZkNoYXJzID0gX2NoYXJhY3Rlci5kaWZmQ2hhcnM7XFxuLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL2V4cG9ydHMuIC8qaXN0YW5idWwgaWdub3JlIGVuZCovZGlmZldvcmRzID0gX3dvcmQuZGlmZldvcmRzO1xcbi8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki9leHBvcnRzLiAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqL2RpZmZXb3Jkc1dpdGhTcGFjZSA9IF93b3JkLmRpZmZXb3Jkc1dpdGhTcGFjZTtcXG4vKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovZXhwb3J0cy4gLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi9kaWZmTGluZXMgPSBfbGluZS5kaWZmTGluZXM7XFxuLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL2V4cG9ydHMuIC8qaXN0YW5idWwgaWdub3JlIGVuZCovZGlmZlRyaW1tZWRMaW5lcyA9IF9saW5lLmRpZmZUcmltbWVkTGluZXM7XFxuLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL2V4cG9ydHMuIC8qaXN0YW5idWwgaWdub3JlIGVuZCovZGlmZlNlbnRlbmNlcyA9IF9zZW50ZW5jZS5kaWZmU2VudGVuY2VzO1xcbi8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki9leHBvcnRzLiAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqL2RpZmZDc3MgPSBfY3NzLmRpZmZDc3M7XFxuLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL2V4cG9ydHMuIC8qaXN0YW5idWwgaWdub3JlIGVuZCovZGlmZkpzb24gPSBfanNvbi5kaWZmSnNvbjtcXG4vKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovZXhwb3J0cy4gLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi9kaWZmQXJyYXlzID0gX2FycmF5LmRpZmZBcnJheXM7XFxuLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL2V4cG9ydHMuIC8qaXN0YW5idWwgaWdub3JlIGVuZCovc3RydWN0dXJlZFBhdGNoID0gX2NyZWF0ZS5zdHJ1Y3R1cmVkUGF0Y2g7XFxuLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL2V4cG9ydHMuIC8qaXN0YW5idWwgaWdub3JlIGVuZCovY3JlYXRlVHdvRmlsZXNQYXRjaCA9IF9jcmVhdGUuY3JlYXRlVHdvRmlsZXNQYXRjaDtcXG4vKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovZXhwb3J0cy4gLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi9jcmVhdGVQYXRjaCA9IF9jcmVhdGUuY3JlYXRlUGF0Y2g7XFxuLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL2V4cG9ydHMuIC8qaXN0YW5idWwgaWdub3JlIGVuZCovYXBwbHlQYXRjaCA9IF9hcHBseS5hcHBseVBhdGNoO1xcbi8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki9leHBvcnRzLiAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqL2FwcGx5UGF0Y2hlcyA9IF9hcHBseS5hcHBseVBhdGNoZXM7XFxuLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL2V4cG9ydHMuIC8qaXN0YW5idWwgaWdub3JlIGVuZCovcGFyc2VQYXRjaCA9IF9wYXJzZS5wYXJzZVBhdGNoO1xcbi8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki9leHBvcnRzLiAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqL2NvbnZlcnRDaGFuZ2VzVG9ETVAgPSBfZG1wLmNvbnZlcnRDaGFuZ2VzVG9ETVA7XFxuLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL2V4cG9ydHMuIC8qaXN0YW5idWwgaWdub3JlIGVuZCovY29udmVydENoYW5nZXNUb1hNTCA9IF94bWwuY29udmVydENoYW5nZXNUb1hNTDtcXG4vKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovZXhwb3J0cy4gLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi9jYW5vbmljYWxpemUgPSBfanNvbi5jYW5vbmljYWxpemU7IC8qIFNlZSBMSUNFTlNFIGZpbGUgZm9yIHRlcm1zIG9mIHVzZSAqL1xcblxcbi8qXFxuICogVGV4dCBkaWZmIGltcGxlbWVudGF0aW9uLlxcbiAqXFxuICogVGhpcyBsaWJyYXJ5IHN1cHBvcnRzIHRoZSBmb2xsb3dpbmcgQVBJUzpcXG4gKiBKc0RpZmYuZGlmZkNoYXJzOiBDaGFyYWN0ZXIgYnkgY2hhcmFjdGVyIGRpZmZcXG4gKiBKc0RpZmYuZGlmZldvcmRzOiBXb3JkIChhcyBkZWZpbmVkIGJ5IFxcXFxiIHJlZ2V4KSBkaWZmIHdoaWNoIGlnbm9yZXMgd2hpdGVzcGFjZVxcbiAqIEpzRGlmZi5kaWZmTGluZXM6IExpbmUgYmFzZWQgZGlmZlxcbiAqXFxuICogSnNEaWZmLmRpZmZDc3M6IERpZmYgdGFyZ2V0ZWQgYXQgQ1NTIGNvbnRlbnRcXG4gKlxcbiAqIFRoZXNlIG1ldGhvZHMgYXJlIGJhc2VkIG9uIHRoZSBpbXBsZW1lbnRhdGlvbiBwcm9wb3NlZCBpblxcbiAqIFxcXCJBbiBPKE5EKSBEaWZmZXJlbmNlIEFsZ29yaXRobSBhbmQgaXRzIFZhcmlhdGlvbnNcXFwiIChNeWVycywgMTk4NikuXFxuICogaHR0cDovL2NpdGVzZWVyeC5pc3QucHN1LmVkdS92aWV3ZG9jL3N1bW1hcnk/ZG9pPTEwLjEuMS40LjY5MjdcXG4gKi9cXG5cXG5cXG59LHtcXFwiLi9jb252ZXJ0L2RtcFxcXCI6NDUsXFxcIi4vY29udmVydC94bWxcXFwiOjQ2LFxcXCIuL2RpZmYvYXJyYXlcXFwiOjQ3LFxcXCIuL2RpZmYvYmFzZVxcXCI6NDgsXFxcIi4vZGlmZi9jaGFyYWN0ZXJcXFwiOjQ5LFxcXCIuL2RpZmYvY3NzXFxcIjo1MCxcXFwiLi9kaWZmL2pzb25cXFwiOjUxLFxcXCIuL2RpZmYvbGluZVxcXCI6NTIsXFxcIi4vZGlmZi9zZW50ZW5jZVxcXCI6NTMsXFxcIi4vZGlmZi93b3JkXFxcIjo1NCxcXFwiLi9wYXRjaC9hcHBseVxcXCI6NTYsXFxcIi4vcGF0Y2gvY3JlYXRlXFxcIjo1NyxcXFwiLi9wYXRjaC9wYXJzZVxcXCI6NTh9XSw1NjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XFxuLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqLyd1c2Ugc3RyaWN0JztcXG5cXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xcbmV4cG9ydHMuIC8qaXN0YW5idWwgaWdub3JlIGVuZCovYXBwbHlQYXRjaCA9IGFwcGx5UGF0Y2g7XFxuLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL2V4cG9ydHMuIC8qaXN0YW5idWwgaWdub3JlIGVuZCovYXBwbHlQYXRjaGVzID0gYXBwbHlQYXRjaGVzO1xcblxcbnZhciAvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovX3BhcnNlID0gcmVxdWlyZSgnLi9wYXJzZScpIC8qaXN0YW5idWwgaWdub3JlIGVuZCovO1xcblxcbnZhciAvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovX2Rpc3RhbmNlSXRlcmF0b3IgPSByZXF1aXJlKCcuLi91dGlsL2Rpc3RhbmNlLWl0ZXJhdG9yJykgLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi87XFxuXFxuLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL1xcbnZhciBfZGlzdGFuY2VJdGVyYXRvcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9kaXN0YW5jZUl0ZXJhdG9yKTtcXG5cXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyAnZGVmYXVsdCc6IG9iaiB9OyB9XFxuXFxuLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi9mdW5jdGlvbiBhcHBseVBhdGNoKHNvdXJjZSwgdW5pRGlmZikge1xcbiAgLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL3ZhciAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqL29wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDIgfHwgYXJndW1lbnRzWzJdID09PSB1bmRlZmluZWQgPyB7fSA6IGFyZ3VtZW50c1syXTtcXG5cXG4gIGlmICh0eXBlb2YgdW5pRGlmZiA9PT0gJ3N0cmluZycpIHtcXG4gICAgdW5pRGlmZiA9IC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki8oMCwgX3BhcnNlLnBhcnNlUGF0Y2gpIC8qaXN0YW5idWwgaWdub3JlIGVuZCovKHVuaURpZmYpO1xcbiAgfVxcblxcbiAgaWYgKEFycmF5LmlzQXJyYXkodW5pRGlmZikpIHtcXG4gICAgaWYgKHVuaURpZmYubGVuZ3RoID4gMSkge1xcbiAgICAgIHRocm93IG5ldyBFcnJvcignYXBwbHlQYXRjaCBvbmx5IHdvcmtzIHdpdGggYSBzaW5nbGUgaW5wdXQuJyk7XFxuICAgIH1cXG5cXG4gICAgdW5pRGlmZiA9IHVuaURpZmZbMF07XFxuICB9XFxuXFxuICAvLyBBcHBseSB0aGUgZGlmZiB0byB0aGUgaW5wdXRcXG4gIHZhciBsaW5lcyA9IHNvdXJjZS5zcGxpdCgvXFxcXHJcXFxcbnxbXFxcXG5cXFxcdlxcXFxmXFxcXHJcXFxceDg1XS8pLFxcbiAgICAgIGRlbGltaXRlcnMgPSBzb3VyY2UubWF0Y2goL1xcXFxyXFxcXG58W1xcXFxuXFxcXHZcXFxcZlxcXFxyXFxcXHg4NV0vZykgfHwgW10sXFxuICAgICAgaHVua3MgPSB1bmlEaWZmLmh1bmtzLFxcbiAgICAgIGNvbXBhcmVMaW5lID0gb3B0aW9ucy5jb21wYXJlTGluZSB8fCBmdW5jdGlvbiAobGluZU51bWJlciwgbGluZSwgb3BlcmF0aW9uLCBwYXRjaENvbnRlbnQpIC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki97XFxuICAgIHJldHVybiAoLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi9saW5lID09PSBwYXRjaENvbnRlbnRcXG4gICAgKTtcXG4gIH0sXFxuICAgICAgZXJyb3JDb3VudCA9IDAsXFxuICAgICAgZnV6ekZhY3RvciA9IG9wdGlvbnMuZnV6ekZhY3RvciB8fCAwLFxcbiAgICAgIG1pbkxpbmUgPSAwLFxcbiAgICAgIG9mZnNldCA9IDAsXFxuICAgICAgcmVtb3ZlRU9GTkwgPSAvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovdm9pZCAwIC8qaXN0YW5idWwgaWdub3JlIGVuZCovLFxcbiAgICAgIGFkZEVPRk5MID0gLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL3ZvaWQgMCAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqLztcXG5cXG4gIC8qKlxcbiAgICogQ2hlY2tzIGlmIHRoZSBodW5rIGV4YWN0bHkgZml0cyBvbiB0aGUgcHJvdmlkZWQgbG9jYXRpb25cXG4gICAqL1xcbiAgZnVuY3Rpb24gaHVua0ZpdHMoaHVuaywgdG9Qb3MpIHtcXG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCBodW5rLmxpbmVzLmxlbmd0aDsgaisrKSB7XFxuICAgICAgdmFyIGxpbmUgPSBodW5rLmxpbmVzW2pdLFxcbiAgICAgICAgICBvcGVyYXRpb24gPSBsaW5lWzBdLFxcbiAgICAgICAgICBjb250ZW50ID0gbGluZS5zdWJzdHIoMSk7XFxuXFxuICAgICAgaWYgKG9wZXJhdGlvbiA9PT0gJyAnIHx8IG9wZXJhdGlvbiA9PT0gJy0nKSB7XFxuICAgICAgICAvLyBDb250ZXh0IHNhbml0eSBjaGVja1xcbiAgICAgICAgaWYgKCFjb21wYXJlTGluZSh0b1BvcyArIDEsIGxpbmVzW3RvUG9zXSwgb3BlcmF0aW9uLCBjb250ZW50KSkge1xcbiAgICAgICAgICBlcnJvckNvdW50Kys7XFxuXFxuICAgICAgICAgIGlmIChlcnJvckNvdW50ID4gZnV6ekZhY3Rvcikge1xcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgICAgdG9Qb3MrKztcXG4gICAgICB9XFxuICAgIH1cXG5cXG4gICAgcmV0dXJuIHRydWU7XFxuICB9XFxuXFxuICAvLyBTZWFyY2ggYmVzdCBmaXQgb2Zmc2V0cyBmb3IgZWFjaCBodW5rIGJhc2VkIG9uIHRoZSBwcmV2aW91cyBvbmVzXFxuICBmb3IgKHZhciBpID0gMDsgaSA8IGh1bmtzLmxlbmd0aDsgaSsrKSB7XFxuICAgIHZhciBodW5rID0gaHVua3NbaV0sXFxuICAgICAgICBtYXhMaW5lID0gbGluZXMubGVuZ3RoIC0gaHVuay5vbGRMaW5lcyxcXG4gICAgICAgIGxvY2FsT2Zmc2V0ID0gMCxcXG4gICAgICAgIHRvUG9zID0gb2Zmc2V0ICsgaHVuay5vbGRTdGFydCAtIDE7XFxuXFxuICAgIHZhciBpdGVyYXRvciA9IC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki8oMCwgX2Rpc3RhbmNlSXRlcmF0b3IyWydkZWZhdWx0J10pIC8qaXN0YW5idWwgaWdub3JlIGVuZCovKHRvUG9zLCBtaW5MaW5lLCBtYXhMaW5lKTtcXG5cXG4gICAgZm9yICg7IGxvY2FsT2Zmc2V0ICE9PSB1bmRlZmluZWQ7IGxvY2FsT2Zmc2V0ID0gaXRlcmF0b3IoKSkge1xcbiAgICAgIGlmIChodW5rRml0cyhodW5rLCB0b1BvcyArIGxvY2FsT2Zmc2V0KSkge1xcbiAgICAgICAgaHVuay5vZmZzZXQgPSBvZmZzZXQgKz0gbG9jYWxPZmZzZXQ7XFxuICAgICAgICBicmVhaztcXG4gICAgICB9XFxuICAgIH1cXG5cXG4gICAgaWYgKGxvY2FsT2Zmc2V0ID09PSB1bmRlZmluZWQpIHtcXG4gICAgICByZXR1cm4gZmFsc2U7XFxuICAgIH1cXG5cXG4gICAgLy8gU2V0IGxvd2VyIHRleHQgbGltaXQgdG8gZW5kIG9mIHRoZSBjdXJyZW50IGh1bmssIHNvIG5leHQgb25lcyBkb24ndCB0cnlcXG4gICAgLy8gdG8gZml0IG92ZXIgYWxyZWFkeSBwYXRjaGVkIHRleHRcXG4gICAgbWluTGluZSA9IGh1bmsub2Zmc2V0ICsgaHVuay5vbGRTdGFydCArIGh1bmsub2xkTGluZXM7XFxuICB9XFxuXFxuICAvLyBBcHBseSBwYXRjaCBodW5rc1xcbiAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGh1bmtzLmxlbmd0aDsgX2krKykge1xcbiAgICB2YXIgX2h1bmsgPSBodW5rc1tfaV0sXFxuICAgICAgICBfdG9Qb3MgPSBfaHVuay5vZmZzZXQgKyBfaHVuay5uZXdTdGFydCAtIDE7XFxuICAgIGlmIChfaHVuay5uZXdMaW5lcyA9PSAwKSB7XFxuICAgICAgX3RvUG9zKys7XFxuICAgIH1cXG5cXG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCBfaHVuay5saW5lcy5sZW5ndGg7IGorKykge1xcbiAgICAgIHZhciBsaW5lID0gX2h1bmsubGluZXNbal0sXFxuICAgICAgICAgIG9wZXJhdGlvbiA9IGxpbmVbMF0sXFxuICAgICAgICAgIGNvbnRlbnQgPSBsaW5lLnN1YnN0cigxKSxcXG4gICAgICAgICAgZGVsaW1pdGVyID0gX2h1bmsubGluZWRlbGltaXRlcnNbal07XFxuXFxuICAgICAgaWYgKG9wZXJhdGlvbiA9PT0gJyAnKSB7XFxuICAgICAgICBfdG9Qb3MrKztcXG4gICAgICB9IGVsc2UgaWYgKG9wZXJhdGlvbiA9PT0gJy0nKSB7XFxuICAgICAgICBsaW5lcy5zcGxpY2UoX3RvUG9zLCAxKTtcXG4gICAgICAgIGRlbGltaXRlcnMuc3BsaWNlKF90b1BvcywgMSk7XFxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xcbiAgICAgIH0gZWxzZSBpZiAob3BlcmF0aW9uID09PSAnKycpIHtcXG4gICAgICAgICAgbGluZXMuc3BsaWNlKF90b1BvcywgMCwgY29udGVudCk7XFxuICAgICAgICAgIGRlbGltaXRlcnMuc3BsaWNlKF90b1BvcywgMCwgZGVsaW1pdGVyKTtcXG4gICAgICAgICAgX3RvUG9zKys7XFxuICAgICAgICB9IGVsc2UgaWYgKG9wZXJhdGlvbiA9PT0gJ1xcXFxcXFxcJykge1xcbiAgICAgICAgICB2YXIgcHJldmlvdXNPcGVyYXRpb24gPSBfaHVuay5saW5lc1tqIC0gMV0gPyBfaHVuay5saW5lc1tqIC0gMV1bMF0gOiBudWxsO1xcbiAgICAgICAgICBpZiAocHJldmlvdXNPcGVyYXRpb24gPT09ICcrJykge1xcbiAgICAgICAgICAgIHJlbW92ZUVPRk5MID0gdHJ1ZTtcXG4gICAgICAgICAgfSBlbHNlIGlmIChwcmV2aW91c09wZXJhdGlvbiA9PT0gJy0nKSB7XFxuICAgICAgICAgICAgYWRkRU9GTkwgPSB0cnVlO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgIH1cXG4gIH1cXG5cXG4gIC8vIEhhbmRsZSBFT0ZOTCBpbnNlcnRpb24vcmVtb3ZhbFxcbiAgaWYgKHJlbW92ZUVPRk5MKSB7XFxuICAgIHdoaWxlICghbGluZXNbbGluZXMubGVuZ3RoIC0gMV0pIHtcXG4gICAgICBsaW5lcy5wb3AoKTtcXG4gICAgICBkZWxpbWl0ZXJzLnBvcCgpO1xcbiAgICB9XFxuICB9IGVsc2UgaWYgKGFkZEVPRk5MKSB7XFxuICAgIGxpbmVzLnB1c2goJycpO1xcbiAgICBkZWxpbWl0ZXJzLnB1c2goJ1xcXFxuJyk7XFxuICB9XFxuICBmb3IgKHZhciBfayA9IDA7IF9rIDwgbGluZXMubGVuZ3RoIC0gMTsgX2srKykge1xcbiAgICBsaW5lc1tfa10gPSBsaW5lc1tfa10gKyBkZWxpbWl0ZXJzW19rXTtcXG4gIH1cXG4gIHJldHVybiBsaW5lcy5qb2luKCcnKTtcXG59XFxuXFxuLy8gV3JhcHBlciB0aGF0IHN1cHBvcnRzIG11bHRpcGxlIGZpbGUgcGF0Y2hlcyB2aWEgY2FsbGJhY2tzLlxcbmZ1bmN0aW9uIGFwcGx5UGF0Y2hlcyh1bmlEaWZmLCBvcHRpb25zKSB7XFxuICBpZiAodHlwZW9mIHVuaURpZmYgPT09ICdzdHJpbmcnKSB7XFxuICAgIHVuaURpZmYgPSAvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovKDAsIF9wYXJzZS5wYXJzZVBhdGNoKSAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqLyh1bmlEaWZmKTtcXG4gIH1cXG5cXG4gIHZhciBjdXJyZW50SW5kZXggPSAwO1xcbiAgZnVuY3Rpb24gcHJvY2Vzc0luZGV4KCkge1xcbiAgICB2YXIgaW5kZXggPSB1bmlEaWZmW2N1cnJlbnRJbmRleCsrXTtcXG4gICAgaWYgKCFpbmRleCkge1xcbiAgICAgIHJldHVybiBvcHRpb25zLmNvbXBsZXRlKCk7XFxuICAgIH1cXG5cXG4gICAgb3B0aW9ucy5sb2FkRmlsZShpbmRleCwgZnVuY3Rpb24gKGVyciwgZGF0YSkge1xcbiAgICAgIGlmIChlcnIpIHtcXG4gICAgICAgIHJldHVybiBvcHRpb25zLmNvbXBsZXRlKGVycik7XFxuICAgICAgfVxcblxcbiAgICAgIHZhciB1cGRhdGVkQ29udGVudCA9IGFwcGx5UGF0Y2goZGF0YSwgaW5kZXgsIG9wdGlvbnMpO1xcbiAgICAgIG9wdGlvbnMucGF0Y2hlZChpbmRleCwgdXBkYXRlZENvbnRlbnQsIGZ1bmN0aW9uIChlcnIpIHtcXG4gICAgICAgIGlmIChlcnIpIHtcXG4gICAgICAgICAgcmV0dXJuIG9wdGlvbnMuY29tcGxldGUoZXJyKTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIHByb2Nlc3NJbmRleCgpO1xcbiAgICAgIH0pO1xcbiAgICB9KTtcXG4gIH1cXG4gIHByb2Nlc3NJbmRleCgpO1xcbn1cXG5cXG5cXG59LHtcXFwiLi4vdXRpbC9kaXN0YW5jZS1pdGVyYXRvclxcXCI6NTksXFxcIi4vcGFyc2VcXFwiOjU4fV0sNTc6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xcbi8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki8ndXNlIHN0cmljdCc7XFxuXFxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcXG5leHBvcnRzLiAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqL3N0cnVjdHVyZWRQYXRjaCA9IHN0cnVjdHVyZWRQYXRjaDtcXG4vKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovZXhwb3J0cy4gLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi9jcmVhdGVUd29GaWxlc1BhdGNoID0gY3JlYXRlVHdvRmlsZXNQYXRjaDtcXG4vKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovZXhwb3J0cy4gLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi9jcmVhdGVQYXRjaCA9IGNyZWF0ZVBhdGNoO1xcblxcbnZhciAvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovX2xpbmUgPSByZXF1aXJlKCcuLi9kaWZmL2xpbmUnKSAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqLztcXG5cXG4vKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovXFxuZnVuY3Rpb24gX3RvQ29uc3VtYWJsZUFycmF5KGFycikgeyBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSB7IGZvciAodmFyIGkgPSAwLCBhcnIyID0gQXJyYXkoYXJyLmxlbmd0aCk7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHsgYXJyMltpXSA9IGFycltpXTsgfSByZXR1cm4gYXJyMjsgfSBlbHNlIHsgcmV0dXJuIEFycmF5LmZyb20oYXJyKTsgfSB9XFxuXFxuLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi9mdW5jdGlvbiBzdHJ1Y3R1cmVkUGF0Y2gob2xkRmlsZU5hbWUsIG5ld0ZpbGVOYW1lLCBvbGRTdHIsIG5ld1N0ciwgb2xkSGVhZGVyLCBuZXdIZWFkZXIsIG9wdGlvbnMpIHtcXG4gIGlmICghb3B0aW9ucykge1xcbiAgICBvcHRpb25zID0ge307XFxuICB9XFxuICBpZiAodHlwZW9mIG9wdGlvbnMuY29udGV4dCA9PT0gJ3VuZGVmaW5lZCcpIHtcXG4gICAgb3B0aW9ucy5jb250ZXh0ID0gNDtcXG4gIH1cXG5cXG4gIHZhciBkaWZmID0gLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqLygwLCBfbGluZS5kaWZmTGluZXMpIC8qaXN0YW5idWwgaWdub3JlIGVuZCovKG9sZFN0ciwgbmV3U3RyLCBvcHRpb25zKTtcXG4gIGRpZmYucHVzaCh7IHZhbHVlOiAnJywgbGluZXM6IFtdIH0pOyAvLyBBcHBlbmQgYW4gZW1wdHkgdmFsdWUgdG8gbWFrZSBjbGVhbnVwIGVhc2llclxcblxcbiAgZnVuY3Rpb24gY29udGV4dExpbmVzKGxpbmVzKSB7XFxuICAgIHJldHVybiBsaW5lcy5tYXAoZnVuY3Rpb24gKGVudHJ5KSB7XFxuICAgICAgcmV0dXJuICcgJyArIGVudHJ5O1xcbiAgICB9KTtcXG4gIH1cXG5cXG4gIHZhciBodW5rcyA9IFtdO1xcbiAgdmFyIG9sZFJhbmdlU3RhcnQgPSAwLFxcbiAgICAgIG5ld1JhbmdlU3RhcnQgPSAwLFxcbiAgICAgIGN1clJhbmdlID0gW10sXFxuICAgICAgb2xkTGluZSA9IDEsXFxuICAgICAgbmV3TGluZSA9IDE7XFxuICAvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovXFxuICB2YXIgX2xvb3AgPSBmdW5jdGlvbiBfbG9vcCggLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi9pKSB7XFxuICAgIHZhciBjdXJyZW50ID0gZGlmZltpXSxcXG4gICAgICAgIGxpbmVzID0gY3VycmVudC5saW5lcyB8fCBjdXJyZW50LnZhbHVlLnJlcGxhY2UoL1xcXFxuJC8sICcnKS5zcGxpdCgnXFxcXG4nKTtcXG4gICAgY3VycmVudC5saW5lcyA9IGxpbmVzO1xcblxcbiAgICBpZiAoY3VycmVudC5hZGRlZCB8fCBjdXJyZW50LnJlbW92ZWQpIHtcXG4gICAgICAvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovXFxuICAgICAgdmFyIF9jdXJSYW5nZTtcXG5cXG4gICAgICAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqL1xcbiAgICAgIC8vIElmIHdlIGhhdmUgcHJldmlvdXMgY29udGV4dCwgc3RhcnQgd2l0aCB0aGF0XFxuICAgICAgaWYgKCFvbGRSYW5nZVN0YXJ0KSB7XFxuICAgICAgICB2YXIgcHJldiA9IGRpZmZbaSAtIDFdO1xcbiAgICAgICAgb2xkUmFuZ2VTdGFydCA9IG9sZExpbmU7XFxuICAgICAgICBuZXdSYW5nZVN0YXJ0ID0gbmV3TGluZTtcXG5cXG4gICAgICAgIGlmIChwcmV2KSB7XFxuICAgICAgICAgIGN1clJhbmdlID0gb3B0aW9ucy5jb250ZXh0ID4gMCA/IGNvbnRleHRMaW5lcyhwcmV2LmxpbmVzLnNsaWNlKC1vcHRpb25zLmNvbnRleHQpKSA6IFtdO1xcbiAgICAgICAgICBvbGRSYW5nZVN0YXJ0IC09IGN1clJhbmdlLmxlbmd0aDtcXG4gICAgICAgICAgbmV3UmFuZ2VTdGFydCAtPSBjdXJSYW5nZS5sZW5ndGg7XFxuICAgICAgICB9XFxuICAgICAgfVxcblxcbiAgICAgIC8vIE91dHB1dCBvdXIgY2hhbmdlc1xcbiAgICAgIC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki8oX2N1clJhbmdlID0gLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi9jdXJSYW5nZSkucHVzaC4gLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL2FwcGx5IC8qaXN0YW5idWwgaWdub3JlIGVuZCovKCAvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovX2N1clJhbmdlIC8qaXN0YW5idWwgaWdub3JlIGVuZCovLCAvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovX3RvQ29uc3VtYWJsZUFycmF5KCAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqL2xpbmVzLm1hcChmdW5jdGlvbiAoZW50cnkpIHtcXG4gICAgICAgIHJldHVybiAoY3VycmVudC5hZGRlZCA/ICcrJyA6ICctJykgKyBlbnRyeTtcXG4gICAgICB9KSkpO1xcblxcbiAgICAgIC8vIFRyYWNrIHRoZSB1cGRhdGVkIGZpbGUgcG9zaXRpb25cXG4gICAgICBpZiAoY3VycmVudC5hZGRlZCkge1xcbiAgICAgICAgbmV3TGluZSArPSBsaW5lcy5sZW5ndGg7XFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIG9sZExpbmUgKz0gbGluZXMubGVuZ3RoO1xcbiAgICAgIH1cXG4gICAgfSBlbHNlIHtcXG4gICAgICAvLyBJZGVudGljYWwgY29udGV4dCBsaW5lcy4gVHJhY2sgbGluZSBjaGFuZ2VzXFxuICAgICAgaWYgKG9sZFJhbmdlU3RhcnQpIHtcXG4gICAgICAgIC8vIENsb3NlIG91dCBhbnkgY2hhbmdlcyB0aGF0IGhhdmUgYmVlbiBvdXRwdXQgKG9yIGpvaW4gb3ZlcmxhcHBpbmcpXFxuICAgICAgICBpZiAobGluZXMubGVuZ3RoIDw9IG9wdGlvbnMuY29udGV4dCAqIDIgJiYgaSA8IGRpZmYubGVuZ3RoIC0gMikge1xcbiAgICAgICAgICAvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovXFxuICAgICAgICAgIHZhciBfY3VyUmFuZ2UyO1xcblxcbiAgICAgICAgICAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqL1xcbiAgICAgICAgICAvLyBPdmVybGFwcGluZ1xcbiAgICAgICAgICAvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovKF9jdXJSYW5nZTIgPSAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqL2N1clJhbmdlKS5wdXNoLiAvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovYXBwbHkgLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi8oIC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki9fY3VyUmFuZ2UyIC8qaXN0YW5idWwgaWdub3JlIGVuZCovLCAvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovX3RvQ29uc3VtYWJsZUFycmF5KCAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqL2NvbnRleHRMaW5lcyhsaW5lcykpKTtcXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgIC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki9cXG4gICAgICAgICAgdmFyIF9jdXJSYW5nZTM7XFxuXFxuICAgICAgICAgIC8qaXN0YW5idWwgaWdub3JlIGVuZCovXFxuICAgICAgICAgIC8vIGVuZCB0aGUgcmFuZ2UgYW5kIG91dHB1dFxcbiAgICAgICAgICB2YXIgY29udGV4dFNpemUgPSBNYXRoLm1pbihsaW5lcy5sZW5ndGgsIG9wdGlvbnMuY29udGV4dCk7XFxuICAgICAgICAgIC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki8oX2N1clJhbmdlMyA9IC8qaXN0YW5idWwgaWdub3JlIGVuZCovY3VyUmFuZ2UpLnB1c2guIC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki9hcHBseSAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqLyggLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL19jdXJSYW5nZTMgLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi8sIC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki9fdG9Db25zdW1hYmxlQXJyYXkoIC8qaXN0YW5idWwgaWdub3JlIGVuZCovY29udGV4dExpbmVzKGxpbmVzLnNsaWNlKDAsIGNvbnRleHRTaXplKSkpKTtcXG5cXG4gICAgICAgICAgdmFyIGh1bmsgPSB7XFxuICAgICAgICAgICAgb2xkU3RhcnQ6IG9sZFJhbmdlU3RhcnQsXFxuICAgICAgICAgICAgb2xkTGluZXM6IG9sZExpbmUgLSBvbGRSYW5nZVN0YXJ0ICsgY29udGV4dFNpemUsXFxuICAgICAgICAgICAgbmV3U3RhcnQ6IG5ld1JhbmdlU3RhcnQsXFxuICAgICAgICAgICAgbmV3TGluZXM6IG5ld0xpbmUgLSBuZXdSYW5nZVN0YXJ0ICsgY29udGV4dFNpemUsXFxuICAgICAgICAgICAgbGluZXM6IGN1clJhbmdlXFxuICAgICAgICAgIH07XFxuICAgICAgICAgIGlmIChpID49IGRpZmYubGVuZ3RoIC0gMiAmJiBsaW5lcy5sZW5ndGggPD0gb3B0aW9ucy5jb250ZXh0KSB7XFxuICAgICAgICAgICAgLy8gRU9GIGlzIGluc2lkZSB0aGlzIGh1bmtcXG4gICAgICAgICAgICB2YXIgb2xkRU9GTmV3bGluZSA9IC9cXFxcbiQvLnRlc3Qob2xkU3RyKTtcXG4gICAgICAgICAgICB2YXIgbmV3RU9GTmV3bGluZSA9IC9cXFxcbiQvLnRlc3QobmV3U3RyKTtcXG4gICAgICAgICAgICBpZiAobGluZXMubGVuZ3RoID09IDAgJiYgIW9sZEVPRk5ld2xpbmUpIHtcXG4gICAgICAgICAgICAgIC8vIHNwZWNpYWwgY2FzZTogb2xkIGhhcyBubyBlb2wgYW5kIG5vIHRyYWlsaW5nIGNvbnRleHQ7IG5vLW5sIGNhbiBlbmQgdXAgYmVmb3JlIGFkZHNcXG4gICAgICAgICAgICAgIGN1clJhbmdlLnNwbGljZShodW5rLm9sZExpbmVzLCAwLCAnXFxcXFxcXFwgTm8gbmV3bGluZSBhdCBlbmQgb2YgZmlsZScpO1xcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIW9sZEVPRk5ld2xpbmUgfHwgIW5ld0VPRk5ld2xpbmUpIHtcXG4gICAgICAgICAgICAgIGN1clJhbmdlLnB1c2goJ1xcXFxcXFxcIE5vIG5ld2xpbmUgYXQgZW5kIG9mIGZpbGUnKTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgIH1cXG4gICAgICAgICAgaHVua3MucHVzaChodW5rKTtcXG5cXG4gICAgICAgICAgb2xkUmFuZ2VTdGFydCA9IDA7XFxuICAgICAgICAgIG5ld1JhbmdlU3RhcnQgPSAwO1xcbiAgICAgICAgICBjdXJSYW5nZSA9IFtdO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG4gICAgICBvbGRMaW5lICs9IGxpbmVzLmxlbmd0aDtcXG4gICAgICBuZXdMaW5lICs9IGxpbmVzLmxlbmd0aDtcXG4gICAgfVxcbiAgfTtcXG5cXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZGlmZi5sZW5ndGg7IGkrKykge1xcbiAgICAvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovXFxuICAgIF9sb29wKCAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqL2kpO1xcbiAgfVxcblxcbiAgcmV0dXJuIHtcXG4gICAgb2xkRmlsZU5hbWU6IG9sZEZpbGVOYW1lLCBuZXdGaWxlTmFtZTogbmV3RmlsZU5hbWUsXFxuICAgIG9sZEhlYWRlcjogb2xkSGVhZGVyLCBuZXdIZWFkZXI6IG5ld0hlYWRlcixcXG4gICAgaHVua3M6IGh1bmtzXFxuICB9O1xcbn1cXG5cXG5mdW5jdGlvbiBjcmVhdGVUd29GaWxlc1BhdGNoKG9sZEZpbGVOYW1lLCBuZXdGaWxlTmFtZSwgb2xkU3RyLCBuZXdTdHIsIG9sZEhlYWRlciwgbmV3SGVhZGVyLCBvcHRpb25zKSB7XFxuICB2YXIgZGlmZiA9IHN0cnVjdHVyZWRQYXRjaChvbGRGaWxlTmFtZSwgbmV3RmlsZU5hbWUsIG9sZFN0ciwgbmV3U3RyLCBvbGRIZWFkZXIsIG5ld0hlYWRlciwgb3B0aW9ucyk7XFxuXFxuICB2YXIgcmV0ID0gW107XFxuICBpZiAob2xkRmlsZU5hbWUgPT0gbmV3RmlsZU5hbWUpIHtcXG4gICAgcmV0LnB1c2goJ0luZGV4OiAnICsgb2xkRmlsZU5hbWUpO1xcbiAgfVxcbiAgcmV0LnB1c2goJz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0nKTtcXG4gIHJldC5wdXNoKCctLS0gJyArIGRpZmYub2xkRmlsZU5hbWUgKyAodHlwZW9mIGRpZmYub2xkSGVhZGVyID09PSAndW5kZWZpbmVkJyA/ICcnIDogJ1xcXFx0JyArIGRpZmYub2xkSGVhZGVyKSk7XFxuICByZXQucHVzaCgnKysrICcgKyBkaWZmLm5ld0ZpbGVOYW1lICsgKHR5cGVvZiBkaWZmLm5ld0hlYWRlciA9PT0gJ3VuZGVmaW5lZCcgPyAnJyA6ICdcXFxcdCcgKyBkaWZmLm5ld0hlYWRlcikpO1xcblxcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBkaWZmLmh1bmtzLmxlbmd0aDsgaSsrKSB7XFxuICAgIHZhciBodW5rID0gZGlmZi5odW5rc1tpXTtcXG4gICAgcmV0LnB1c2goJ0BAIC0nICsgaHVuay5vbGRTdGFydCArICcsJyArIGh1bmsub2xkTGluZXMgKyAnICsnICsgaHVuay5uZXdTdGFydCArICcsJyArIGh1bmsubmV3TGluZXMgKyAnIEBAJyk7XFxuICAgIHJldC5wdXNoLmFwcGx5KHJldCwgaHVuay5saW5lcyk7XFxuICB9XFxuXFxuICByZXR1cm4gcmV0LmpvaW4oJ1xcXFxuJykgKyAnXFxcXG4nO1xcbn1cXG5cXG5mdW5jdGlvbiBjcmVhdGVQYXRjaChmaWxlTmFtZSwgb2xkU3RyLCBuZXdTdHIsIG9sZEhlYWRlciwgbmV3SGVhZGVyLCBvcHRpb25zKSB7XFxuICByZXR1cm4gY3JlYXRlVHdvRmlsZXNQYXRjaChmaWxlTmFtZSwgZmlsZU5hbWUsIG9sZFN0ciwgbmV3U3RyLCBvbGRIZWFkZXIsIG5ld0hlYWRlciwgb3B0aW9ucyk7XFxufVxcblxcblxcbn0se1xcXCIuLi9kaWZmL2xpbmVcXFwiOjUyfV0sNTg6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xcbi8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki8ndXNlIHN0cmljdCc7XFxuXFxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcXG5leHBvcnRzLiAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqL3BhcnNlUGF0Y2ggPSBwYXJzZVBhdGNoO1xcbmZ1bmN0aW9uIHBhcnNlUGF0Y2godW5pRGlmZikge1xcbiAgLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL3ZhciAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqL29wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDEgfHwgYXJndW1lbnRzWzFdID09PSB1bmRlZmluZWQgPyB7fSA6IGFyZ3VtZW50c1sxXTtcXG5cXG4gIHZhciBkaWZmc3RyID0gdW5pRGlmZi5zcGxpdCgvXFxcXHJcXFxcbnxbXFxcXG5cXFxcdlxcXFxmXFxcXHJcXFxceDg1XS8pLFxcbiAgICAgIGRlbGltaXRlcnMgPSB1bmlEaWZmLm1hdGNoKC9cXFxcclxcXFxufFtcXFxcblxcXFx2XFxcXGZcXFxcclxcXFx4ODVdL2cpIHx8IFtdLFxcbiAgICAgIGxpc3QgPSBbXSxcXG4gICAgICBpID0gMDtcXG5cXG4gIGZ1bmN0aW9uIHBhcnNlSW5kZXgoKSB7XFxuICAgIHZhciBpbmRleCA9IHt9O1xcbiAgICBsaXN0LnB1c2goaW5kZXgpO1xcblxcbiAgICAvLyBQYXJzZSBkaWZmIG1ldGFkYXRhXFxuICAgIHdoaWxlIChpIDwgZGlmZnN0ci5sZW5ndGgpIHtcXG4gICAgICB2YXIgbGluZSA9IGRpZmZzdHJbaV07XFxuXFxuICAgICAgLy8gRmlsZSBoZWFkZXIgZm91bmQsIGVuZCBwYXJzaW5nIGRpZmYgbWV0YWRhdGFcXG4gICAgICBpZiAoL14oXFxcXC1cXFxcLVxcXFwtfFxcXFwrXFxcXCtcXFxcK3xAQClcXFxccy8udGVzdChsaW5lKSkge1xcbiAgICAgICAgYnJlYWs7XFxuICAgICAgfVxcblxcbiAgICAgIC8vIERpZmYgaW5kZXhcXG4gICAgICB2YXIgaGVhZGVyID0gL14oPzpJbmRleDp8ZGlmZig/OiAtciBcXFxcdyspKylcXFxccysoLis/KVxcXFxzKiQvLmV4ZWMobGluZSk7XFxuICAgICAgaWYgKGhlYWRlcikge1xcbiAgICAgICAgaW5kZXguaW5kZXggPSBoZWFkZXJbMV07XFxuICAgICAgfVxcblxcbiAgICAgIGkrKztcXG4gICAgfVxcblxcbiAgICAvLyBQYXJzZSBmaWxlIGhlYWRlcnMgaWYgdGhleSBhcmUgZGVmaW5lZC4gVW5pZmllZCBkaWZmIHJlcXVpcmVzIHRoZW0sIGJ1dFxcbiAgICAvLyB0aGVyZSdzIG5vIHRlY2huaWNhbCBpc3N1ZXMgdG8gaGF2ZSBhbiBpc29sYXRlZCBodW5rIHdpdGhvdXQgZmlsZSBoZWFkZXJcXG4gICAgcGFyc2VGaWxlSGVhZGVyKGluZGV4KTtcXG4gICAgcGFyc2VGaWxlSGVhZGVyKGluZGV4KTtcXG5cXG4gICAgLy8gUGFyc2UgaHVua3NcXG4gICAgaW5kZXguaHVua3MgPSBbXTtcXG5cXG4gICAgd2hpbGUgKGkgPCBkaWZmc3RyLmxlbmd0aCkge1xcbiAgICAgIHZhciBfbGluZSA9IGRpZmZzdHJbaV07XFxuXFxuICAgICAgaWYgKC9eKEluZGV4OnxkaWZmfFxcXFwtXFxcXC1cXFxcLXxcXFxcK1xcXFwrXFxcXCspXFxcXHMvLnRlc3QoX2xpbmUpKSB7XFxuICAgICAgICBicmVhaztcXG4gICAgICB9IGVsc2UgaWYgKC9eQEAvLnRlc3QoX2xpbmUpKSB7XFxuICAgICAgICBpbmRleC5odW5rcy5wdXNoKHBhcnNlSHVuaygpKTtcXG4gICAgICB9IGVsc2UgaWYgKF9saW5lICYmIG9wdGlvbnMuc3RyaWN0KSB7XFxuICAgICAgICAvLyBJZ25vcmUgdW5leHBlY3RlZCBjb250ZW50IHVubGVzcyBpbiBzdHJpY3QgbW9kZVxcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIGxpbmUgJyArIChpICsgMSkgKyAnICcgKyBKU09OLnN0cmluZ2lmeShfbGluZSkpO1xcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICBpKys7XFxuICAgICAgfVxcbiAgICB9XFxuICB9XFxuXFxuICAvLyBQYXJzZXMgdGhlIC0tLSBhbmQgKysrIGhlYWRlcnMsIGlmIG5vbmUgYXJlIGZvdW5kLCBubyBsaW5lc1xcbiAgLy8gYXJlIGNvbnN1bWVkLlxcbiAgZnVuY3Rpb24gcGFyc2VGaWxlSGVhZGVyKGluZGV4KSB7XFxuICAgIHZhciBoZWFkZXJQYXR0ZXJuID0gL14oLS0tfFxcXFwrXFxcXCtcXFxcKylcXFxccysoW1xcXFxTIF0qKSg/OlxcXFx0KC4qPylcXFxccyopPyQvO1xcbiAgICB2YXIgZmlsZUhlYWRlciA9IGhlYWRlclBhdHRlcm4uZXhlYyhkaWZmc3RyW2ldKTtcXG4gICAgaWYgKGZpbGVIZWFkZXIpIHtcXG4gICAgICB2YXIga2V5UHJlZml4ID0gZmlsZUhlYWRlclsxXSA9PT0gJy0tLScgPyAnb2xkJyA6ICduZXcnO1xcbiAgICAgIGluZGV4W2tleVByZWZpeCArICdGaWxlTmFtZSddID0gZmlsZUhlYWRlclsyXTtcXG4gICAgICBpbmRleFtrZXlQcmVmaXggKyAnSGVhZGVyJ10gPSBmaWxlSGVhZGVyWzNdO1xcblxcbiAgICAgIGkrKztcXG4gICAgfVxcbiAgfVxcblxcbiAgLy8gUGFyc2VzIGEgaHVua1xcbiAgLy8gVGhpcyBhc3N1bWVzIHRoYXQgd2UgYXJlIGF0IHRoZSBzdGFydCBvZiBhIGh1bmsuXFxuICBmdW5jdGlvbiBwYXJzZUh1bmsoKSB7XFxuICAgIHZhciBjaHVua0hlYWRlckluZGV4ID0gaSxcXG4gICAgICAgIGNodW5rSGVhZGVyTGluZSA9IGRpZmZzdHJbaSsrXSxcXG4gICAgICAgIGNodW5rSGVhZGVyID0gY2h1bmtIZWFkZXJMaW5lLnNwbGl0KC9AQCAtKFxcXFxkKykoPzosKFxcXFxkKykpPyBcXFxcKyhcXFxcZCspKD86LChcXFxcZCspKT8gQEAvKTtcXG5cXG4gICAgdmFyIGh1bmsgPSB7XFxuICAgICAgb2xkU3RhcnQ6ICtjaHVua0hlYWRlclsxXSxcXG4gICAgICBvbGRMaW5lczogK2NodW5rSGVhZGVyWzJdIHx8IDEsXFxuICAgICAgbmV3U3RhcnQ6ICtjaHVua0hlYWRlclszXSxcXG4gICAgICBuZXdMaW5lczogK2NodW5rSGVhZGVyWzRdIHx8IDEsXFxuICAgICAgbGluZXM6IFtdLFxcbiAgICAgIGxpbmVkZWxpbWl0ZXJzOiBbXVxcbiAgICB9O1xcblxcbiAgICB2YXIgYWRkQ291bnQgPSAwLFxcbiAgICAgICAgcmVtb3ZlQ291bnQgPSAwO1xcbiAgICBmb3IgKDsgaSA8IGRpZmZzdHIubGVuZ3RoOyBpKyspIHtcXG4gICAgICAvLyBMaW5lcyBzdGFydGluZyB3aXRoICctLS0nIGNvdWxkIGJlIG1pc3Rha2VuIGZvciB0aGUgXFxcInJlbW92ZSBsaW5lXFxcIiBvcGVyYXRpb25cXG4gICAgICAvLyBCdXQgdGhleSBjb3VsZCBiZSB0aGUgaGVhZGVyIGZvciB0aGUgbmV4dCBmaWxlLiBUaGVyZWZvcmUgcHJ1bmUgc3VjaCBjYXNlcyBvdXQuXFxuICAgICAgaWYgKGRpZmZzdHJbaV0uaW5kZXhPZignLS0tICcpID09PSAwICYmIGkgKyAyIDwgZGlmZnN0ci5sZW5ndGggJiYgZGlmZnN0cltpICsgMV0uaW5kZXhPZignKysrICcpID09PSAwICYmIGRpZmZzdHJbaSArIDJdLmluZGV4T2YoJ0BAJykgPT09IDApIHtcXG4gICAgICAgIGJyZWFrO1xcbiAgICAgIH1cXG4gICAgICB2YXIgb3BlcmF0aW9uID0gZGlmZnN0cltpXVswXTtcXG5cXG4gICAgICBpZiAob3BlcmF0aW9uID09PSAnKycgfHwgb3BlcmF0aW9uID09PSAnLScgfHwgb3BlcmF0aW9uID09PSAnICcgfHwgb3BlcmF0aW9uID09PSAnXFxcXFxcXFwnKSB7XFxuICAgICAgICBodW5rLmxpbmVzLnB1c2goZGlmZnN0cltpXSk7XFxuICAgICAgICBodW5rLmxpbmVkZWxpbWl0ZXJzLnB1c2goZGVsaW1pdGVyc1tpXSB8fCAnXFxcXG4nKTtcXG5cXG4gICAgICAgIGlmIChvcGVyYXRpb24gPT09ICcrJykge1xcbiAgICAgICAgICBhZGRDb3VudCsrO1xcbiAgICAgICAgfSBlbHNlIGlmIChvcGVyYXRpb24gPT09ICctJykge1xcbiAgICAgICAgICByZW1vdmVDb3VudCsrO1xcbiAgICAgICAgfSBlbHNlIGlmIChvcGVyYXRpb24gPT09ICcgJykge1xcbiAgICAgICAgICBhZGRDb3VudCsrO1xcbiAgICAgICAgICByZW1vdmVDb3VudCsrO1xcbiAgICAgICAgfVxcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICBicmVhaztcXG4gICAgICB9XFxuICAgIH1cXG5cXG4gICAgLy8gSGFuZGxlIHRoZSBlbXB0eSBibG9jayBjb3VudCBjYXNlXFxuICAgIGlmICghYWRkQ291bnQgJiYgaHVuay5uZXdMaW5lcyA9PT0gMSkge1xcbiAgICAgIGh1bmsubmV3TGluZXMgPSAwO1xcbiAgICB9XFxuICAgIGlmICghcmVtb3ZlQ291bnQgJiYgaHVuay5vbGRMaW5lcyA9PT0gMSkge1xcbiAgICAgIGh1bmsub2xkTGluZXMgPSAwO1xcbiAgICB9XFxuXFxuICAgIC8vIFBlcmZvcm0gb3B0aW9uYWwgc2FuaXR5IGNoZWNraW5nXFxuICAgIGlmIChvcHRpb25zLnN0cmljdCkge1xcbiAgICAgIGlmIChhZGRDb3VudCAhPT0gaHVuay5uZXdMaW5lcykge1xcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdBZGRlZCBsaW5lIGNvdW50IGRpZCBub3QgbWF0Y2ggZm9yIGh1bmsgYXQgbGluZSAnICsgKGNodW5rSGVhZGVySW5kZXggKyAxKSk7XFxuICAgICAgfVxcbiAgICAgIGlmIChyZW1vdmVDb3VudCAhPT0gaHVuay5vbGRMaW5lcykge1xcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdSZW1vdmVkIGxpbmUgY291bnQgZGlkIG5vdCBtYXRjaCBmb3IgaHVuayBhdCBsaW5lICcgKyAoY2h1bmtIZWFkZXJJbmRleCArIDEpKTtcXG4gICAgICB9XFxuICAgIH1cXG5cXG4gICAgcmV0dXJuIGh1bms7XFxuICB9XFxuXFxuICB3aGlsZSAoaSA8IGRpZmZzdHIubGVuZ3RoKSB7XFxuICAgIHBhcnNlSW5kZXgoKTtcXG4gIH1cXG5cXG4gIHJldHVybiBsaXN0O1xcbn1cXG5cXG5cXG59LHt9XSw1OTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XFxuLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL1xcXCJ1c2Ugc3RyaWN0XFxcIjtcXG5cXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xcblxcbmV4cG9ydHNbXFxcImRlZmF1bHRcXFwiXSA9IC8qaXN0YW5idWwgaWdub3JlIGVuZCovZnVuY3Rpb24gKHN0YXJ0LCBtaW5MaW5lLCBtYXhMaW5lKSB7XFxuICB2YXIgd2FudEZvcndhcmQgPSB0cnVlLFxcbiAgICAgIGJhY2t3YXJkRXhoYXVzdGVkID0gZmFsc2UsXFxuICAgICAgZm9yd2FyZEV4aGF1c3RlZCA9IGZhbHNlLFxcbiAgICAgIGxvY2FsT2Zmc2V0ID0gMTtcXG5cXG4gIHJldHVybiBmdW5jdGlvbiBpdGVyYXRvcigpIHtcXG4gICAgaWYgKHdhbnRGb3J3YXJkICYmICFmb3J3YXJkRXhoYXVzdGVkKSB7XFxuICAgICAgaWYgKGJhY2t3YXJkRXhoYXVzdGVkKSB7XFxuICAgICAgICBsb2NhbE9mZnNldCsrO1xcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICB3YW50Rm9yd2FyZCA9IGZhbHNlO1xcbiAgICAgIH1cXG5cXG4gICAgICAvLyBDaGVjayBpZiB0cnlpbmcgdG8gZml0IGJleW9uZCB0ZXh0IGxlbmd0aCwgYW5kIGlmIG5vdCwgY2hlY2sgaXQgZml0c1xcbiAgICAgIC8vIGFmdGVyIG9mZnNldCBsb2NhdGlvbiAob3IgZGVzaXJlZCBsb2NhdGlvbiBvbiBmaXJzdCBpdGVyYXRpb24pXFxuICAgICAgaWYgKHN0YXJ0ICsgbG9jYWxPZmZzZXQgPD0gbWF4TGluZSkge1xcbiAgICAgICAgcmV0dXJuIGxvY2FsT2Zmc2V0O1xcbiAgICAgIH1cXG5cXG4gICAgICBmb3J3YXJkRXhoYXVzdGVkID0gdHJ1ZTtcXG4gICAgfVxcblxcbiAgICBpZiAoIWJhY2t3YXJkRXhoYXVzdGVkKSB7XFxuICAgICAgaWYgKCFmb3J3YXJkRXhoYXVzdGVkKSB7XFxuICAgICAgICB3YW50Rm9yd2FyZCA9IHRydWU7XFxuICAgICAgfVxcblxcbiAgICAgIC8vIENoZWNrIGlmIHRyeWluZyB0byBmaXQgYmVmb3JlIHRleHQgYmVnaW5uaW5nLCBhbmQgaWYgbm90LCBjaGVjayBpdCBmaXRzXFxuICAgICAgLy8gYmVmb3JlIG9mZnNldCBsb2NhdGlvblxcbiAgICAgIGlmIChtaW5MaW5lIDw9IHN0YXJ0IC0gbG9jYWxPZmZzZXQpIHtcXG4gICAgICAgIHJldHVybiAtbG9jYWxPZmZzZXQrKztcXG4gICAgICB9XFxuXFxuICAgICAgYmFja3dhcmRFeGhhdXN0ZWQgPSB0cnVlO1xcbiAgICAgIHJldHVybiBpdGVyYXRvcigpO1xcbiAgICB9XFxuXFxuICAgIC8vIFdlIHRyaWVkIHRvIGZpdCBodW5rIGJlZm9yZSB0ZXh0IGJlZ2lubmluZyBhbmQgYmV5b25kIHRleHQgbGVuZ2h0LCB0aGVuXFxuICAgIC8vIGh1bmsgY2FuJ3QgZml0IG9uIHRoZSB0ZXh0LiBSZXR1cm4gdW5kZWZpbmVkXFxuICB9O1xcbn07XFxuXFxuXFxufSx7fV0sNjA6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xcbi8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki8ndXNlIHN0cmljdCc7XFxuXFxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcXG5leHBvcnRzLiAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqL2dlbmVyYXRlT3B0aW9ucyA9IGdlbmVyYXRlT3B0aW9ucztcXG5mdW5jdGlvbiBnZW5lcmF0ZU9wdGlvbnMob3B0aW9ucywgZGVmYXVsdHMpIHtcXG4gIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Z1bmN0aW9uJykge1xcbiAgICBkZWZhdWx0cy5jYWxsYmFjayA9IG9wdGlvbnM7XFxuICB9IGVsc2UgaWYgKG9wdGlvbnMpIHtcXG4gICAgZm9yICh2YXIgbmFtZSBpbiBvcHRpb25zKSB7XFxuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cXG4gICAgICBpZiAob3B0aW9ucy5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xcbiAgICAgICAgZGVmYXVsdHNbbmFtZV0gPSBvcHRpb25zW25hbWVdO1xcbiAgICAgIH1cXG4gICAgfVxcbiAgfVxcbiAgcmV0dXJuIGRlZmF1bHRzO1xcbn1cXG5cXG5cXG59LHt9XSw2MTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XFxuJ3VzZSBzdHJpY3QnO1xcblxcbnZhciBtYXRjaE9wZXJhdG9yc1JlID0gL1t8XFxcXFxcXFx7fSgpW1xcXFxdXiQrKj8uXS9nO1xcblxcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHN0cikge1xcblxcdGlmICh0eXBlb2Ygc3RyICE9PSAnc3RyaW5nJykge1xcblxcdFxcdHRocm93IG5ldyBUeXBlRXJyb3IoJ0V4cGVjdGVkIGEgc3RyaW5nJyk7XFxuXFx0fVxcblxcblxcdHJldHVybiBzdHIucmVwbGFjZShtYXRjaE9wZXJhdG9yc1JlLCAnXFxcXFxcXFwkJicpO1xcbn07XFxuXFxufSx7fV0sNjI6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xcbi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxcbi8vXFxuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXFxuLy8gXFxcIlNvZnR3YXJlXFxcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXFxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XFxuLy9cXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxcbi8vXFxuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFxcXCJBUyBJU1xcXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1NcXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXFxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxcbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxcblxcbmZ1bmN0aW9uIEV2ZW50RW1pdHRlcigpIHtcXG4gIHRoaXMuX2V2ZW50cyA9IHRoaXMuX2V2ZW50cyB8fCB7fTtcXG4gIHRoaXMuX21heExpc3RlbmVycyA9IHRoaXMuX21heExpc3RlbmVycyB8fCB1bmRlZmluZWQ7XFxufVxcbm1vZHVsZS5leHBvcnRzID0gRXZlbnRFbWl0dGVyO1xcblxcbi8vIEJhY2t3YXJkcy1jb21wYXQgd2l0aCBub2RlIDAuMTAueFxcbkV2ZW50RW1pdHRlci5FdmVudEVtaXR0ZXIgPSBFdmVudEVtaXR0ZXI7XFxuXFxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5fZXZlbnRzID0gdW5kZWZpbmVkO1xcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuX21heExpc3RlbmVycyA9IHVuZGVmaW5lZDtcXG5cXG4vLyBCeSBkZWZhdWx0IEV2ZW50RW1pdHRlcnMgd2lsbCBwcmludCBhIHdhcm5pbmcgaWYgbW9yZSB0aGFuIDEwIGxpc3RlbmVycyBhcmVcXG4vLyBhZGRlZCB0byBpdC4gVGhpcyBpcyBhIHVzZWZ1bCBkZWZhdWx0IHdoaWNoIGhlbHBzIGZpbmRpbmcgbWVtb3J5IGxlYWtzLlxcbkV2ZW50RW1pdHRlci5kZWZhdWx0TWF4TGlzdGVuZXJzID0gMTA7XFxuXFxuLy8gT2J2aW91c2x5IG5vdCBhbGwgRW1pdHRlcnMgc2hvdWxkIGJlIGxpbWl0ZWQgdG8gMTAuIFRoaXMgZnVuY3Rpb24gYWxsb3dzXFxuLy8gdGhhdCB0byBiZSBpbmNyZWFzZWQuIFNldCB0byB6ZXJvIGZvciB1bmxpbWl0ZWQuXFxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5zZXRNYXhMaXN0ZW5lcnMgPSBmdW5jdGlvbihuKSB7XFxuICBpZiAoIWlzTnVtYmVyKG4pIHx8IG4gPCAwIHx8IGlzTmFOKG4pKVxcbiAgICB0aHJvdyBUeXBlRXJyb3IoJ24gbXVzdCBiZSBhIHBvc2l0aXZlIG51bWJlcicpO1xcbiAgdGhpcy5fbWF4TGlzdGVuZXJzID0gbjtcXG4gIHJldHVybiB0aGlzO1xcbn07XFxuXFxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5lbWl0ID0gZnVuY3Rpb24odHlwZSkge1xcbiAgdmFyIGVyLCBoYW5kbGVyLCBsZW4sIGFyZ3MsIGksIGxpc3RlbmVycztcXG5cXG4gIGlmICghdGhpcy5fZXZlbnRzKVxcbiAgICB0aGlzLl9ldmVudHMgPSB7fTtcXG5cXG4gIC8vIElmIHRoZXJlIGlzIG5vICdlcnJvcicgZXZlbnQgbGlzdGVuZXIgdGhlbiB0aHJvdy5cXG4gIGlmICh0eXBlID09PSAnZXJyb3InKSB7XFxuICAgIGlmICghdGhpcy5fZXZlbnRzLmVycm9yIHx8XFxuICAgICAgICAoaXNPYmplY3QodGhpcy5fZXZlbnRzLmVycm9yKSAmJiAhdGhpcy5fZXZlbnRzLmVycm9yLmxlbmd0aCkpIHtcXG4gICAgICBlciA9IGFyZ3VtZW50c1sxXTtcXG4gICAgICBpZiAoZXIgaW5zdGFuY2VvZiBFcnJvcikge1xcbiAgICAgICAgdGhyb3cgZXI7IC8vIFVuaGFuZGxlZCAnZXJyb3InIGV2ZW50XFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIC8vIEF0IGxlYXN0IGdpdmUgc29tZSBraW5kIG9mIGNvbnRleHQgdG8gdGhlIHVzZXJcXG4gICAgICAgIHZhciBlcnIgPSBuZXcgRXJyb3IoJ1VuY2F1Z2h0LCB1bnNwZWNpZmllZCBcXFwiZXJyb3JcXFwiIGV2ZW50LiAoJyArIGVyICsgJyknKTtcXG4gICAgICAgIGVyci5jb250ZXh0ID0gZXI7XFxuICAgICAgICB0aHJvdyBlcnI7XFxuICAgICAgfVxcbiAgICB9XFxuICB9XFxuXFxuICBoYW5kbGVyID0gdGhpcy5fZXZlbnRzW3R5cGVdO1xcblxcbiAgaWYgKGlzVW5kZWZpbmVkKGhhbmRsZXIpKVxcbiAgICByZXR1cm4gZmFsc2U7XFxuXFxuICBpZiAoaXNGdW5jdGlvbihoYW5kbGVyKSkge1xcbiAgICBzd2l0Y2ggKGFyZ3VtZW50cy5sZW5ndGgpIHtcXG4gICAgICAvLyBmYXN0IGNhc2VzXFxuICAgICAgY2FzZSAxOlxcbiAgICAgICAgaGFuZGxlci5jYWxsKHRoaXMpO1xcbiAgICAgICAgYnJlYWs7XFxuICAgICAgY2FzZSAyOlxcbiAgICAgICAgaGFuZGxlci5jYWxsKHRoaXMsIGFyZ3VtZW50c1sxXSk7XFxuICAgICAgICBicmVhaztcXG4gICAgICBjYXNlIDM6XFxuICAgICAgICBoYW5kbGVyLmNhbGwodGhpcywgYXJndW1lbnRzWzFdLCBhcmd1bWVudHNbMl0pO1xcbiAgICAgICAgYnJlYWs7XFxuICAgICAgLy8gc2xvd2VyXFxuICAgICAgZGVmYXVsdDpcXG4gICAgICAgIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xcbiAgICAgICAgaGFuZGxlci5hcHBseSh0aGlzLCBhcmdzKTtcXG4gICAgfVxcbiAgfSBlbHNlIGlmIChpc09iamVjdChoYW5kbGVyKSkge1xcbiAgICBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcXG4gICAgbGlzdGVuZXJzID0gaGFuZGxlci5zbGljZSgpO1xcbiAgICBsZW4gPSBsaXN0ZW5lcnMubGVuZ3RoO1xcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspXFxuICAgICAgbGlzdGVuZXJzW2ldLmFwcGx5KHRoaXMsIGFyZ3MpO1xcbiAgfVxcblxcbiAgcmV0dXJuIHRydWU7XFxufTtcXG5cXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmFkZExpc3RlbmVyID0gZnVuY3Rpb24odHlwZSwgbGlzdGVuZXIpIHtcXG4gIHZhciBtO1xcblxcbiAgaWYgKCFpc0Z1bmN0aW9uKGxpc3RlbmVyKSlcXG4gICAgdGhyb3cgVHlwZUVycm9yKCdsaXN0ZW5lciBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcXG5cXG4gIGlmICghdGhpcy5fZXZlbnRzKVxcbiAgICB0aGlzLl9ldmVudHMgPSB7fTtcXG5cXG4gIC8vIFRvIGF2b2lkIHJlY3Vyc2lvbiBpbiB0aGUgY2FzZSB0aGF0IHR5cGUgPT09IFxcXCJuZXdMaXN0ZW5lclxcXCIhIEJlZm9yZVxcbiAgLy8gYWRkaW5nIGl0IHRvIHRoZSBsaXN0ZW5lcnMsIGZpcnN0IGVtaXQgXFxcIm5ld0xpc3RlbmVyXFxcIi5cXG4gIGlmICh0aGlzLl9ldmVudHMubmV3TGlzdGVuZXIpXFxuICAgIHRoaXMuZW1pdCgnbmV3TGlzdGVuZXInLCB0eXBlLFxcbiAgICAgICAgICAgICAgaXNGdW5jdGlvbihsaXN0ZW5lci5saXN0ZW5lcikgP1xcbiAgICAgICAgICAgICAgbGlzdGVuZXIubGlzdGVuZXIgOiBsaXN0ZW5lcik7XFxuXFxuICBpZiAoIXRoaXMuX2V2ZW50c1t0eXBlXSlcXG4gICAgLy8gT3B0aW1pemUgdGhlIGNhc2Ugb2Ygb25lIGxpc3RlbmVyLiBEb24ndCBuZWVkIHRoZSBleHRyYSBhcnJheSBvYmplY3QuXFxuICAgIHRoaXMuX2V2ZW50c1t0eXBlXSA9IGxpc3RlbmVyO1xcbiAgZWxzZSBpZiAoaXNPYmplY3QodGhpcy5fZXZlbnRzW3R5cGVdKSlcXG4gICAgLy8gSWYgd2UndmUgYWxyZWFkeSBnb3QgYW4gYXJyYXksIGp1c3QgYXBwZW5kLlxcbiAgICB0aGlzLl9ldmVudHNbdHlwZV0ucHVzaChsaXN0ZW5lcik7XFxuICBlbHNlXFxuICAgIC8vIEFkZGluZyB0aGUgc2Vjb25kIGVsZW1lbnQsIG5lZWQgdG8gY2hhbmdlIHRvIGFycmF5LlxcbiAgICB0aGlzLl9ldmVudHNbdHlwZV0gPSBbdGhpcy5fZXZlbnRzW3R5cGVdLCBsaXN0ZW5lcl07XFxuXFxuICAvLyBDaGVjayBmb3IgbGlzdGVuZXIgbGVha1xcbiAgaWYgKGlzT2JqZWN0KHRoaXMuX2V2ZW50c1t0eXBlXSkgJiYgIXRoaXMuX2V2ZW50c1t0eXBlXS53YXJuZWQpIHtcXG4gICAgaWYgKCFpc1VuZGVmaW5lZCh0aGlzLl9tYXhMaXN0ZW5lcnMpKSB7XFxuICAgICAgbSA9IHRoaXMuX21heExpc3RlbmVycztcXG4gICAgfSBlbHNlIHtcXG4gICAgICBtID0gRXZlbnRFbWl0dGVyLmRlZmF1bHRNYXhMaXN0ZW5lcnM7XFxuICAgIH1cXG5cXG4gICAgaWYgKG0gJiYgbSA+IDAgJiYgdGhpcy5fZXZlbnRzW3R5cGVdLmxlbmd0aCA+IG0pIHtcXG4gICAgICB0aGlzLl9ldmVudHNbdHlwZV0ud2FybmVkID0gdHJ1ZTtcXG4gICAgICBjb25zb2xlLmVycm9yKCcobm9kZSkgd2FybmluZzogcG9zc2libGUgRXZlbnRFbWl0dGVyIG1lbW9yeSAnICtcXG4gICAgICAgICAgICAgICAgICAgICdsZWFrIGRldGVjdGVkLiAlZCBsaXN0ZW5lcnMgYWRkZWQuICcgK1xcbiAgICAgICAgICAgICAgICAgICAgJ1VzZSBlbWl0dGVyLnNldE1heExpc3RlbmVycygpIHRvIGluY3JlYXNlIGxpbWl0LicsXFxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9ldmVudHNbdHlwZV0ubGVuZ3RoKTtcXG4gICAgICBpZiAodHlwZW9mIGNvbnNvbGUudHJhY2UgPT09ICdmdW5jdGlvbicpIHtcXG4gICAgICAgIC8vIG5vdCBzdXBwb3J0ZWQgaW4gSUUgMTBcXG4gICAgICAgIGNvbnNvbGUudHJhY2UoKTtcXG4gICAgICB9XFxuICAgIH1cXG4gIH1cXG5cXG4gIHJldHVybiB0aGlzO1xcbn07XFxuXFxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbiA9IEV2ZW50RW1pdHRlci5wcm90b3R5cGUuYWRkTGlzdGVuZXI7XFxuXFxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbmNlID0gZnVuY3Rpb24odHlwZSwgbGlzdGVuZXIpIHtcXG4gIGlmICghaXNGdW5jdGlvbihsaXN0ZW5lcikpXFxuICAgIHRocm93IFR5cGVFcnJvcignbGlzdGVuZXIgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XFxuXFxuICB2YXIgZmlyZWQgPSBmYWxzZTtcXG5cXG4gIGZ1bmN0aW9uIGcoKSB7XFxuICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIodHlwZSwgZyk7XFxuXFxuICAgIGlmICghZmlyZWQpIHtcXG4gICAgICBmaXJlZCA9IHRydWU7XFxuICAgICAgbGlzdGVuZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcXG4gICAgfVxcbiAgfVxcblxcbiAgZy5saXN0ZW5lciA9IGxpc3RlbmVyO1xcbiAgdGhpcy5vbih0eXBlLCBnKTtcXG5cXG4gIHJldHVybiB0aGlzO1xcbn07XFxuXFxuLy8gZW1pdHMgYSAncmVtb3ZlTGlzdGVuZXInIGV2ZW50IGlmZiB0aGUgbGlzdGVuZXIgd2FzIHJlbW92ZWRcXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyID0gZnVuY3Rpb24odHlwZSwgbGlzdGVuZXIpIHtcXG4gIHZhciBsaXN0LCBwb3NpdGlvbiwgbGVuZ3RoLCBpO1xcblxcbiAgaWYgKCFpc0Z1bmN0aW9uKGxpc3RlbmVyKSlcXG4gICAgdGhyb3cgVHlwZUVycm9yKCdsaXN0ZW5lciBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcXG5cXG4gIGlmICghdGhpcy5fZXZlbnRzIHx8ICF0aGlzLl9ldmVudHNbdHlwZV0pXFxuICAgIHJldHVybiB0aGlzO1xcblxcbiAgbGlzdCA9IHRoaXMuX2V2ZW50c1t0eXBlXTtcXG4gIGxlbmd0aCA9IGxpc3QubGVuZ3RoO1xcbiAgcG9zaXRpb24gPSAtMTtcXG5cXG4gIGlmIChsaXN0ID09PSBsaXN0ZW5lciB8fFxcbiAgICAgIChpc0Z1bmN0aW9uKGxpc3QubGlzdGVuZXIpICYmIGxpc3QubGlzdGVuZXIgPT09IGxpc3RlbmVyKSkge1xcbiAgICBkZWxldGUgdGhpcy5fZXZlbnRzW3R5cGVdO1xcbiAgICBpZiAodGhpcy5fZXZlbnRzLnJlbW92ZUxpc3RlbmVyKVxcbiAgICAgIHRoaXMuZW1pdCgncmVtb3ZlTGlzdGVuZXInLCB0eXBlLCBsaXN0ZW5lcik7XFxuXFxuICB9IGVsc2UgaWYgKGlzT2JqZWN0KGxpc3QpKSB7XFxuICAgIGZvciAoaSA9IGxlbmd0aDsgaS0tID4gMDspIHtcXG4gICAgICBpZiAobGlzdFtpXSA9PT0gbGlzdGVuZXIgfHxcXG4gICAgICAgICAgKGxpc3RbaV0ubGlzdGVuZXIgJiYgbGlzdFtpXS5saXN0ZW5lciA9PT0gbGlzdGVuZXIpKSB7XFxuICAgICAgICBwb3NpdGlvbiA9IGk7XFxuICAgICAgICBicmVhaztcXG4gICAgICB9XFxuICAgIH1cXG5cXG4gICAgaWYgKHBvc2l0aW9uIDwgMClcXG4gICAgICByZXR1cm4gdGhpcztcXG5cXG4gICAgaWYgKGxpc3QubGVuZ3RoID09PSAxKSB7XFxuICAgICAgbGlzdC5sZW5ndGggPSAwO1xcbiAgICAgIGRlbGV0ZSB0aGlzLl9ldmVudHNbdHlwZV07XFxuICAgIH0gZWxzZSB7XFxuICAgICAgbGlzdC5zcGxpY2UocG9zaXRpb24sIDEpO1xcbiAgICB9XFxuXFxuICAgIGlmICh0aGlzLl9ldmVudHMucmVtb3ZlTGlzdGVuZXIpXFxuICAgICAgdGhpcy5lbWl0KCdyZW1vdmVMaXN0ZW5lcicsIHR5cGUsIGxpc3RlbmVyKTtcXG4gIH1cXG5cXG4gIHJldHVybiB0aGlzO1xcbn07XFxuXFxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBmdW5jdGlvbih0eXBlKSB7XFxuICB2YXIga2V5LCBsaXN0ZW5lcnM7XFxuXFxuICBpZiAoIXRoaXMuX2V2ZW50cylcXG4gICAgcmV0dXJuIHRoaXM7XFxuXFxuICAvLyBub3QgbGlzdGVuaW5nIGZvciByZW1vdmVMaXN0ZW5lciwgbm8gbmVlZCB0byBlbWl0XFxuICBpZiAoIXRoaXMuX2V2ZW50cy5yZW1vdmVMaXN0ZW5lcikge1xcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMClcXG4gICAgICB0aGlzLl9ldmVudHMgPSB7fTtcXG4gICAgZWxzZSBpZiAodGhpcy5fZXZlbnRzW3R5cGVdKVxcbiAgICAgIGRlbGV0ZSB0aGlzLl9ldmVudHNbdHlwZV07XFxuICAgIHJldHVybiB0aGlzO1xcbiAgfVxcblxcbiAgLy8gZW1pdCByZW1vdmVMaXN0ZW5lciBmb3IgYWxsIGxpc3RlbmVycyBvbiBhbGwgZXZlbnRzXFxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xcbiAgICBmb3IgKGtleSBpbiB0aGlzLl9ldmVudHMpIHtcXG4gICAgICBpZiAoa2V5ID09PSAncmVtb3ZlTGlzdGVuZXInKSBjb250aW51ZTtcXG4gICAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycyhrZXkpO1xcbiAgICB9XFxuICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCdyZW1vdmVMaXN0ZW5lcicpO1xcbiAgICB0aGlzLl9ldmVudHMgPSB7fTtcXG4gICAgcmV0dXJuIHRoaXM7XFxuICB9XFxuXFxuICBsaXN0ZW5lcnMgPSB0aGlzLl9ldmVudHNbdHlwZV07XFxuXFxuICBpZiAoaXNGdW5jdGlvbihsaXN0ZW5lcnMpKSB7XFxuICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXJzKTtcXG4gIH0gZWxzZSBpZiAobGlzdGVuZXJzKSB7XFxuICAgIC8vIExJRk8gb3JkZXJcXG4gICAgd2hpbGUgKGxpc3RlbmVycy5sZW5ndGgpXFxuICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcnNbbGlzdGVuZXJzLmxlbmd0aCAtIDFdKTtcXG4gIH1cXG4gIGRlbGV0ZSB0aGlzLl9ldmVudHNbdHlwZV07XFxuXFxuICByZXR1cm4gdGhpcztcXG59O1xcblxcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJzID0gZnVuY3Rpb24odHlwZSkge1xcbiAgdmFyIHJldDtcXG4gIGlmICghdGhpcy5fZXZlbnRzIHx8ICF0aGlzLl9ldmVudHNbdHlwZV0pXFxuICAgIHJldCA9IFtdO1xcbiAgZWxzZSBpZiAoaXNGdW5jdGlvbih0aGlzLl9ldmVudHNbdHlwZV0pKVxcbiAgICByZXQgPSBbdGhpcy5fZXZlbnRzW3R5cGVdXTtcXG4gIGVsc2VcXG4gICAgcmV0ID0gdGhpcy5fZXZlbnRzW3R5cGVdLnNsaWNlKCk7XFxuICByZXR1cm4gcmV0O1xcbn07XFxuXFxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lckNvdW50ID0gZnVuY3Rpb24odHlwZSkge1xcbiAgaWYgKHRoaXMuX2V2ZW50cykge1xcbiAgICB2YXIgZXZsaXN0ZW5lciA9IHRoaXMuX2V2ZW50c1t0eXBlXTtcXG5cXG4gICAgaWYgKGlzRnVuY3Rpb24oZXZsaXN0ZW5lcikpXFxuICAgICAgcmV0dXJuIDE7XFxuICAgIGVsc2UgaWYgKGV2bGlzdGVuZXIpXFxuICAgICAgcmV0dXJuIGV2bGlzdGVuZXIubGVuZ3RoO1xcbiAgfVxcbiAgcmV0dXJuIDA7XFxufTtcXG5cXG5FdmVudEVtaXR0ZXIubGlzdGVuZXJDb3VudCA9IGZ1bmN0aW9uKGVtaXR0ZXIsIHR5cGUpIHtcXG4gIHJldHVybiBlbWl0dGVyLmxpc3RlbmVyQ291bnQodHlwZSk7XFxufTtcXG5cXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKGFyZykge1xcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdmdW5jdGlvbic7XFxufVxcblxcbmZ1bmN0aW9uIGlzTnVtYmVyKGFyZykge1xcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdudW1iZXInO1xcbn1cXG5cXG5mdW5jdGlvbiBpc09iamVjdChhcmcpIHtcXG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnb2JqZWN0JyAmJiBhcmcgIT09IG51bGw7XFxufVxcblxcbmZ1bmN0aW9uIGlzVW5kZWZpbmVkKGFyZykge1xcbiAgcmV0dXJuIGFyZyA9PT0gdm9pZCAwO1xcbn1cXG5cXG59LHt9XSw2MzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XFxuKGZ1bmN0aW9uIChwcm9jZXNzKXtcXG4vLyBHcm93bCAtIENvcHlyaWdodCBUSiBIb2xvd2F5Y2h1ayA8dGpAdmlzaW9uLW1lZGlhLmNhPiAoTUlUIExpY2Vuc2VkKVxcblxcbi8qKlxcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXFxuICovXFxuXFxudmFyIGV4ZWMgPSByZXF1aXJlKCdjaGlsZF9wcm9jZXNzJykuZXhlY1xcbiAgLCBmcyA9IHJlcXVpcmUoJ2ZzJylcXG4gICwgcGF0aCA9IHJlcXVpcmUoJ3BhdGgnKVxcbiAgLCBleGlzdHMgPSBmcy5leGlzdHNTeW5jIHx8IHBhdGguZXhpc3RzU3luY1xcbiAgLCBvcyA9IHJlcXVpcmUoJ29zJylcXG4gICwgcXVvdGUgPSBKU09OLnN0cmluZ2lmeVxcbiAgLCBjbWQ7XFxuXFxuZnVuY3Rpb24gd2hpY2gobmFtZSkge1xcbiAgdmFyIHBhdGhzID0gcHJvY2Vzcy5lbnYuUEFUSC5zcGxpdCgnOicpO1xcbiAgdmFyIGxvYztcXG5cXG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSBwYXRocy5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xcbiAgICBsb2MgPSBwYXRoLmpvaW4ocGF0aHNbaV0sIG5hbWUpO1xcbiAgICBpZiAoZXhpc3RzKGxvYykpIHJldHVybiBsb2M7XFxuICB9XFxufVxcblxcbnN3aXRjaChvcy50eXBlKCkpIHtcXG4gIGNhc2UgJ0Rhcndpbic6XFxuICAgIGlmICh3aGljaCgndGVybWluYWwtbm90aWZpZXInKSkge1xcbiAgICAgIGNtZCA9IHtcXG4gICAgICAgICAgdHlwZTogXFxcIkRhcndpbi1Ob3RpZmljYXRpb25DZW50ZXJcXFwiXFxuICAgICAgICAsIHBrZzogXFxcInRlcm1pbmFsLW5vdGlmaWVyXFxcIlxcbiAgICAgICAgLCBtc2c6ICctbWVzc2FnZSdcXG4gICAgICAgICwgdGl0bGU6ICctdGl0bGUnXFxuICAgICAgICAsIHN1YnRpdGxlOiAnLXN1YnRpdGxlJ1xcbiAgICAgICAgLCBpY29uOiAnLWFwcEljb24nXFxuICAgICAgICAsIHNvdW5kOiAgJy1zb3VuZCdcXG4gICAgICAgICwgdXJsOiAnLW9wZW4nXFxuICAgICAgICAsIHByaW9yaXR5OiB7XFxuICAgICAgICAgICAgICBjbWQ6ICctZXhlY3V0ZSdcXG4gICAgICAgICAgICAsIHJhbmdlOiBbXVxcbiAgICAgICAgICB9XFxuICAgICAgfTtcXG4gICAgfSBlbHNlIHtcXG4gICAgICBjbWQgPSB7XFxuICAgICAgICAgIHR5cGU6IFxcXCJEYXJ3aW4tR3Jvd2xcXFwiXFxuICAgICAgICAsIHBrZzogXFxcImdyb3dsbm90aWZ5XFxcIlxcbiAgICAgICAgLCBtc2c6ICctbSdcXG4gICAgICAgICwgc3RpY2t5OiAnLS1zdGlja3knXFxuICAgICAgICAsIHByaW9yaXR5OiB7XFxuICAgICAgICAgICAgICBjbWQ6ICctLXByaW9yaXR5J1xcbiAgICAgICAgICAgICwgcmFuZ2U6IFtcXG4gICAgICAgICAgICAgICAgLTJcXG4gICAgICAgICAgICAgICwgLTFcXG4gICAgICAgICAgICAgICwgMFxcbiAgICAgICAgICAgICAgLCAxXFxuICAgICAgICAgICAgICAsIDJcXG4gICAgICAgICAgICAgICwgXFxcIlZlcnkgTG93XFxcIlxcbiAgICAgICAgICAgICAgLCBcXFwiTW9kZXJhdGVcXFwiXFxuICAgICAgICAgICAgICAsIFxcXCJOb3JtYWxcXFwiXFxuICAgICAgICAgICAgICAsIFxcXCJIaWdoXFxcIlxcbiAgICAgICAgICAgICAgLCBcXFwiRW1lcmdlbmN5XFxcIlxcbiAgICAgICAgICAgIF1cXG4gICAgICAgICAgfVxcbiAgICAgIH07XFxuICAgIH1cXG4gICAgYnJlYWs7XFxuICBjYXNlICdMaW51eCc6XFxuICAgIGlmICh3aGljaCgnZ3Jvd2wnKSkge1xcbiAgICAgIGNtZCA9IHtcXG4gICAgICAgICAgdHlwZTogXFxcIkxpbnV4LUdyb3dsXFxcIlxcbiAgICAgICAgLCBwa2c6IFxcXCJncm93bFxcXCJcXG4gICAgICAgICwgbXNnOiAnLW0nXFxuICAgICAgICAsIHRpdGxlOiAnLXRpdGxlJ1xcbiAgICAgICAgLCBzdWJ0aXRsZTogJy1zdWJ0aXRsZSdcXG4gICAgICAgICwgaG9zdDoge1xcbiAgICAgICAgICAgIGNtZDogJy1IJ1xcbiAgICAgICAgICAsIGhvc3RuYW1lOiAnMTkyLjE2OC4zMy4xJ1xcbiAgICAgICAgfVxcbiAgICAgIH07XFxuICAgIH0gZWxzZSB7XFxuICAgICAgY21kID0ge1xcbiAgICAgICAgICB0eXBlOiBcXFwiTGludXhcXFwiXFxuICAgICAgICAsIHBrZzogXFxcIm5vdGlmeS1zZW5kXFxcIlxcbiAgICAgICAgLCBtc2c6ICcnXFxuICAgICAgICAsIHN0aWNreTogJy10IDAnXFxuICAgICAgICAsIGljb246ICctaSdcXG4gICAgICAgICwgcHJpb3JpdHk6IHtcXG4gICAgICAgICAgICBjbWQ6ICctdSdcXG4gICAgICAgICAgLCByYW5nZTogW1xcbiAgICAgICAgICAgICAgXFxcImxvd1xcXCJcXG4gICAgICAgICAgICAsIFxcXCJub3JtYWxcXFwiXFxuICAgICAgICAgICAgLCBcXFwiY3JpdGljYWxcXFwiXFxuICAgICAgICAgIF1cXG4gICAgICAgIH1cXG4gICAgICB9O1xcbiAgICB9XFxuICAgIGJyZWFrO1xcbiAgY2FzZSAnV2luZG93c19OVCc6XFxuICAgIGNtZCA9IHtcXG4gICAgICAgIHR5cGU6IFxcXCJXaW5kb3dzXFxcIlxcbiAgICAgICwgcGtnOiBcXFwiZ3Jvd2xub3RpZnlcXFwiXFxuICAgICAgLCBtc2c6ICcnXFxuICAgICAgLCBzdGlja3k6ICcvczp0cnVlJ1xcbiAgICAgICwgdGl0bGU6ICcvdDonXFxuICAgICAgLCBpY29uOiAnL2k6J1xcbiAgICAgICwgdXJsOiAnL2N1OidcXG4gICAgICAsIHByaW9yaXR5OiB7XFxuICAgICAgICAgICAgY21kOiAnL3A6J1xcbiAgICAgICAgICAsIHJhbmdlOiBbXFxuICAgICAgICAgICAgICAtMlxcbiAgICAgICAgICAgICwgLTFcXG4gICAgICAgICAgICAsIDBcXG4gICAgICAgICAgICAsIDFcXG4gICAgICAgICAgICAsIDJcXG4gICAgICAgICAgXVxcbiAgICAgICAgfVxcbiAgICB9O1xcbiAgICBicmVhaztcXG59XFxuXFxuLyoqXFxuICogRXhwb3NlIGBncm93bGAuXFxuICovXFxuXFxuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gZ3Jvd2w7XFxuXFxuLyoqXFxuICogTm9kZS1ncm93bCB2ZXJzaW9uLlxcbiAqL1xcblxcbmV4cG9ydHMudmVyc2lvbiA9ICcxLjQuMSdcXG5cXG4vKipcXG4gKiBTZW5kIGdyb3dsIG5vdGlmaWNhdGlvbiBfbXNnXyB3aXRoIF9vcHRpb25zXy5cXG4gKlxcbiAqIE9wdGlvbnM6XFxuICpcXG4gKiAgLSB0aXRsZSAgIE5vdGlmaWNhdGlvbiB0aXRsZVxcbiAqICAtIHN0aWNreSAgTWFrZSB0aGUgbm90aWZpY2F0aW9uIHN0aWNrIChkZWZhdWx0cyB0byBmYWxzZSlcXG4gKiAgLSBwcmlvcml0eSAgU3BlY2lmeSBhbiBpbnQgb3IgbmFtZWQga2V5IChkZWZhdWx0IGlzIDApXFxuICogIC0gbmFtZSAgICBBcHBsaWNhdGlvbiBuYW1lIChkZWZhdWx0cyB0byBncm93bG5vdGlmeSlcXG4gKiAgLSBzb3VuZCAgIFNvdW5kIGVmZWN0ICggaW4gT1N4IGRlZmluZWQgaW4gcHJlZmVyZW5jZXMgLT4gc291bmQgLT4gZWZmZWN0cykgKiB3b3JrcyBvbmx5IGluIE9TWCA+IDEwLjh4XFxuICogIC0gaW1hZ2VcXG4gKiAgICAtIHBhdGggdG8gYW4gaWNvbiBzZXRzIC0taWNvbnBhdGhcXG4gKiAgICAtIHBhdGggdG8gYW4gaW1hZ2Ugc2V0cyAtLWltYWdlXFxuICogICAgLSBjYXBpdGFsaXplZCB3b3JkIHNldHMgLS1hcHBJY29uXFxuICogICAgLSBmaWxlbmFtZSB1c2VzIGV4dG5hbWUgYXMgLS1pY29uXFxuICogICAgLSBvdGhlcndpc2UgdHJlYXRlZCBhcyAtLWljb25cXG4gKlxcbiAqIEV4YW1wbGVzOlxcbiAqXFxuICogICBncm93bCgnTmV3IGVtYWlsJylcXG4gKiAgIGdyb3dsKCc1IG5ldyBlbWFpbHMnLCB7IHRpdGxlOiAnVGh1bmRlcmJpcmQnIH0pXFxuICogICBncm93bCgnNSBuZXcgZW1haWxzJywgeyB0aXRsZTogJ1RodW5kZXJiaXJkJywgc291bmQ6ICdQdXJyJyB9KVxcbiAqICAgZ3Jvd2woJ0VtYWlsIHNlbnQnLCBmdW5jdGlvbigpe1xcbiAqICAgICAvLyAuLi4gbm90aWZpY2F0aW9uIHNlbnRcXG4gKiAgIH0pXFxuICpcXG4gKiBAcGFyYW0ge3N0cmluZ30gbXNnXFxuICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnNcXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBmblxcbiAqIEBhcGkgcHVibGljXFxuICovXFxuXFxuZnVuY3Rpb24gZ3Jvd2wobXNnLCBvcHRpb25zLCBmbikge1xcbiAgdmFyIGltYWdlXFxuICAgICwgYXJnc1xcbiAgICAsIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9XFxuICAgICwgZm4gPSBmbiB8fCBmdW5jdGlvbigpe307XFxuXFxuICBpZiAob3B0aW9ucy5leGVjKSB7XFxuICAgIGNtZCA9IHtcXG4gICAgICAgIHR5cGU6IFxcXCJDdXN0b21cXFwiXFxuICAgICAgLCBwa2c6IG9wdGlvbnMuZXhlY1xcbiAgICAgICwgcmFuZ2U6IFtdXFxuICAgIH07XFxuICB9XFxuXFxuICAvLyBub29wXFxuICBpZiAoIWNtZCkgcmV0dXJuIGZuKG5ldyBFcnJvcignZ3Jvd2wgbm90IHN1cHBvcnRlZCBvbiB0aGlzIHBsYXRmb3JtJykpO1xcbiAgYXJncyA9IFtjbWQucGtnXTtcXG5cXG4gIC8vIGltYWdlXFxuICBpZiAoaW1hZ2UgPSBvcHRpb25zLmltYWdlKSB7XFxuICAgIHN3aXRjaChjbWQudHlwZSkge1xcbiAgICAgIGNhc2UgJ0Rhcndpbi1Hcm93bCc6XFxuICAgICAgICB2YXIgZmxhZywgZXh0ID0gcGF0aC5leHRuYW1lKGltYWdlKS5zdWJzdHIoMSlcXG4gICAgICAgIGZsYWcgPSBmbGFnIHx8IGV4dCA9PSAnaWNucycgJiYgJ2ljb25wYXRoJ1xcbiAgICAgICAgZmxhZyA9IGZsYWcgfHwgL15bQS1aXS8udGVzdChpbWFnZSkgJiYgJ2FwcEljb24nXFxuICAgICAgICBmbGFnID0gZmxhZyB8fCAvXnBuZ3xnaWZ8anBlP2ckLy50ZXN0KGV4dCkgJiYgJ2ltYWdlJ1xcbiAgICAgICAgZmxhZyA9IGZsYWcgfHwgZXh0ICYmIChpbWFnZSA9IGV4dCkgJiYgJ2ljb24nXFxuICAgICAgICBmbGFnID0gZmxhZyB8fCAnaWNvbidcXG4gICAgICAgIGFyZ3MucHVzaCgnLS0nICsgZmxhZywgcXVvdGUoaW1hZ2UpKVxcbiAgICAgICAgYnJlYWs7XFxuICAgICAgY2FzZSAnRGFyd2luLU5vdGlmaWNhdGlvbkNlbnRlcic6XFxuICAgICAgICBhcmdzLnB1c2goY21kLmljb24sIHF1b3RlKGltYWdlKSk7XFxuICAgICAgICBicmVhaztcXG4gICAgICBjYXNlICdMaW51eCc6XFxuICAgICAgICBhcmdzLnB1c2goY21kLmljb24sIHF1b3RlKGltYWdlKSk7XFxuICAgICAgICAvLyBsaWJub3RpZnkgZGVmYXVsdHMgdG8gc3RpY2t5LCBzZXQgYSBoaW50IGZvciB0cmFuc2llbnQgbm90aWZpY2F0aW9uc1xcbiAgICAgICAgaWYgKCFvcHRpb25zLnN0aWNreSkgYXJncy5wdXNoKCctLWhpbnQ9aW50OnRyYW5zaWVudDoxJyk7XFxuICAgICAgICBicmVhaztcXG4gICAgICBjYXNlICdXaW5kb3dzJzpcXG4gICAgICAgIGFyZ3MucHVzaChjbWQuaWNvbiArIHF1b3RlKGltYWdlKSk7XFxuICAgICAgICBicmVhaztcXG4gICAgfVxcbiAgfVxcblxcbiAgLy8gc3RpY2t5XFxuICBpZiAob3B0aW9ucy5zdGlja3kpIGFyZ3MucHVzaChjbWQuc3RpY2t5KTtcXG5cXG4gIC8vIHByaW9yaXR5XFxuICBpZiAob3B0aW9ucy5wcmlvcml0eSkge1xcbiAgICB2YXIgcHJpb3JpdHkgPSBvcHRpb25zLnByaW9yaXR5ICsgJyc7XFxuICAgIHZhciBjaGVja2luZGV4T2YgPSBjbWQucHJpb3JpdHkucmFuZ2UuaW5kZXhPZihwcmlvcml0eSk7XFxuICAgIGlmICh+Y21kLnByaW9yaXR5LnJhbmdlLmluZGV4T2YocHJpb3JpdHkpKSB7XFxuICAgICAgYXJncy5wdXNoKGNtZC5wcmlvcml0eSwgb3B0aW9ucy5wcmlvcml0eSk7XFxuICAgIH1cXG4gIH1cXG5cXG4gIC8vc291bmRcXG4gIGlmKG9wdGlvbnMuc291bmQgJiYgY21kLnR5cGUgPT09ICdEYXJ3aW4tTm90aWZpY2F0aW9uQ2VudGVyJyl7XFxuICAgIGFyZ3MucHVzaChjbWQuc291bmQsIG9wdGlvbnMuc291bmQpXFxuICB9XFxuXFxuICAvLyBuYW1lXFxuICBpZiAob3B0aW9ucy5uYW1lICYmIGNtZC50eXBlID09PSBcXFwiRGFyd2luLUdyb3dsXFxcIikge1xcbiAgICBhcmdzLnB1c2goJy0tbmFtZScsIG9wdGlvbnMubmFtZSk7XFxuICB9XFxuXFxuICBzd2l0Y2goY21kLnR5cGUpIHtcXG4gICAgY2FzZSAnRGFyd2luLUdyb3dsJzpcXG4gICAgICBhcmdzLnB1c2goY21kLm1zZyk7XFxuICAgICAgYXJncy5wdXNoKHF1b3RlKG1zZykucmVwbGFjZSgvXFxcXFxcXFxuL2csICdcXFxcbicpKTtcXG4gICAgICBpZiAob3B0aW9ucy50aXRsZSkgYXJncy5wdXNoKHF1b3RlKG9wdGlvbnMudGl0bGUpKTtcXG4gICAgICBicmVhaztcXG4gICAgY2FzZSAnRGFyd2luLU5vdGlmaWNhdGlvbkNlbnRlcic6XFxuICAgICAgYXJncy5wdXNoKGNtZC5tc2cpO1xcbiAgICAgIHZhciBzdHJpbmdpZmllZE1zZyA9IHF1b3RlKG1zZyk7XFxuICAgICAgdmFyIGVzY2FwZWRNc2cgPSBzdHJpbmdpZmllZE1zZy5yZXBsYWNlKC9cXFxcXFxcXG4vZywgJ1xcXFxuJyk7XFxuICAgICAgYXJncy5wdXNoKGVzY2FwZWRNc2cpO1xcbiAgICAgIGlmIChvcHRpb25zLnRpdGxlKSB7XFxuICAgICAgICBhcmdzLnB1c2goY21kLnRpdGxlKTtcXG4gICAgICAgIGFyZ3MucHVzaChxdW90ZShvcHRpb25zLnRpdGxlKSk7XFxuICAgICAgfVxcbiAgICAgIGlmIChvcHRpb25zLnN1YnRpdGxlKSB7XFxuICAgICAgICBhcmdzLnB1c2goY21kLnN1YnRpdGxlKTtcXG4gICAgICAgIGFyZ3MucHVzaChxdW90ZShvcHRpb25zLnN1YnRpdGxlKSk7XFxuICAgICAgfVxcbiAgICAgIGlmIChvcHRpb25zLnVybCkge1xcbiAgICAgICAgYXJncy5wdXNoKGNtZC51cmwpO1xcbiAgICAgICAgYXJncy5wdXNoKHF1b3RlKG9wdGlvbnMudXJsKSk7XFxuICAgICAgfVxcbiAgICAgIGJyZWFrO1xcbiAgICBjYXNlICdMaW51eC1Hcm93bCc6XFxuICAgICAgYXJncy5wdXNoKGNtZC5tc2cpO1xcbiAgICAgIGFyZ3MucHVzaChxdW90ZShtc2cpLnJlcGxhY2UoL1xcXFxcXFxcbi9nLCAnXFxcXG4nKSk7XFxuICAgICAgaWYgKG9wdGlvbnMudGl0bGUpIGFyZ3MucHVzaChxdW90ZShvcHRpb25zLnRpdGxlKSk7XFxuICAgICAgaWYgKGNtZC5ob3N0KSB7XFxuICAgICAgICBhcmdzLnB1c2goY21kLmhvc3QuY21kLCBjbWQuaG9zdC5ob3N0bmFtZSlcXG4gICAgICB9XFxuICAgICAgYnJlYWs7XFxuICAgIGNhc2UgJ0xpbnV4JzpcXG4gICAgICBpZiAob3B0aW9ucy50aXRsZSkge1xcbiAgICAgICAgYXJncy5wdXNoKHF1b3RlKG9wdGlvbnMudGl0bGUpKTtcXG4gICAgICAgIGFyZ3MucHVzaChjbWQubXNnKTtcXG4gICAgICAgIGFyZ3MucHVzaChxdW90ZShtc2cpLnJlcGxhY2UoL1xcXFxcXFxcbi9nLCAnXFxcXG4nKSk7XFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIGFyZ3MucHVzaChxdW90ZShtc2cpLnJlcGxhY2UoL1xcXFxcXFxcbi9nLCAnXFxcXG4nKSk7XFxuICAgICAgfVxcbiAgICAgIGJyZWFrO1xcbiAgICBjYXNlICdXaW5kb3dzJzpcXG4gICAgICBhcmdzLnB1c2gocXVvdGUobXNnKS5yZXBsYWNlKC9cXFxcXFxcXG4vZywgJ1xcXFxuJykpO1xcbiAgICAgIGlmIChvcHRpb25zLnRpdGxlKSBhcmdzLnB1c2goY21kLnRpdGxlICsgcXVvdGUob3B0aW9ucy50aXRsZSkpO1xcbiAgICAgIGlmIChvcHRpb25zLnVybCkgYXJncy5wdXNoKGNtZC51cmwgKyBxdW90ZShvcHRpb25zLnVybCkpO1xcbiAgICAgIGJyZWFrO1xcbiAgICBjYXNlICdDdXN0b20nOlxcbiAgICAgIGFyZ3NbMF0gPSAoZnVuY3Rpb24ob3JpZ0NvbW1hbmQpIHtcXG4gICAgICAgIHZhciBtZXNzYWdlID0gb3B0aW9ucy50aXRsZVxcbiAgICAgICAgICA/IG9wdGlvbnMudGl0bGUgKyAnOiAnICsgbXNnXFxuICAgICAgICAgIDogbXNnO1xcbiAgICAgICAgdmFyIGNvbW1hbmQgPSBvcmlnQ29tbWFuZC5yZXBsYWNlKC8oXnxbXiVdKSVzL2csICckMScgKyBxdW90ZShtZXNzYWdlKSk7XFxuICAgICAgICBpZiAoY29tbWFuZCA9PT0gb3JpZ0NvbW1hbmQpIGFyZ3MucHVzaChxdW90ZShtZXNzYWdlKSk7XFxuICAgICAgICByZXR1cm4gY29tbWFuZDtcXG4gICAgICB9KShhcmdzWzBdKTtcXG4gICAgICBicmVhaztcXG4gIH1cXG5cXG4gIC8vIGV4ZWN1dGVcXG4gIGV4ZWMoYXJncy5qb2luKCcgJyksIGZuKTtcXG59O1xcblxcbn0pLmNhbGwodGhpcyxyZXF1aXJlKCdfcHJvY2VzcycpKVxcbn0se1xcXCJfcHJvY2Vzc1xcXCI6ODIsXFxcImNoaWxkX3Byb2Nlc3NcXFwiOjQyLFxcXCJmc1xcXCI6NDIsXFxcIm9zXFxcIjo4MCxcXFwicGF0aFxcXCI6NDJ9XSw2NDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XFxuKGZ1bmN0aW9uIChnbG9iYWwpe1xcbi8qISBodHRwczovL210aHMuYmUvaGUgdjEuMS4xIGJ5IEBtYXRoaWFzIHwgTUlUIGxpY2Vuc2UgKi9cXG47KGZ1bmN0aW9uKHJvb3QpIHtcXG5cXG5cXHQvLyBEZXRlY3QgZnJlZSB2YXJpYWJsZXMgYGV4cG9ydHNgLlxcblxcdHZhciBmcmVlRXhwb3J0cyA9IHR5cGVvZiBleHBvcnRzID09ICdvYmplY3QnICYmIGV4cG9ydHM7XFxuXFxuXFx0Ly8gRGV0ZWN0IGZyZWUgdmFyaWFibGUgYG1vZHVsZWAuXFxuXFx0dmFyIGZyZWVNb2R1bGUgPSB0eXBlb2YgbW9kdWxlID09ICdvYmplY3QnICYmIG1vZHVsZSAmJlxcblxcdFxcdG1vZHVsZS5leHBvcnRzID09IGZyZWVFeHBvcnRzICYmIG1vZHVsZTtcXG5cXG5cXHQvLyBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgZ2xvYmFsYCwgZnJvbSBOb2RlLmpzIG9yIEJyb3dzZXJpZmllZCBjb2RlLFxcblxcdC8vIGFuZCB1c2UgaXQgYXMgYHJvb3RgLlxcblxcdHZhciBmcmVlR2xvYmFsID0gdHlwZW9mIGdsb2JhbCA9PSAnb2JqZWN0JyAmJiBnbG9iYWw7XFxuXFx0aWYgKGZyZWVHbG9iYWwuZ2xvYmFsID09PSBmcmVlR2xvYmFsIHx8IGZyZWVHbG9iYWwud2luZG93ID09PSBmcmVlR2xvYmFsKSB7XFxuXFx0XFx0cm9vdCA9IGZyZWVHbG9iYWw7XFxuXFx0fVxcblxcblxcdC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xcblxcblxcdC8vIEFsbCBhc3RyYWwgc3ltYm9scy5cXG5cXHR2YXIgcmVnZXhBc3RyYWxTeW1ib2xzID0gL1tcXFxcdUQ4MDAtXFxcXHVEQkZGXVtcXFxcdURDMDAtXFxcXHVERkZGXS9nO1xcblxcdC8vIEFsbCBBU0NJSSBzeW1ib2xzIChub3QganVzdCBwcmludGFibGUgQVNDSUkpIGV4Y2VwdCB0aG9zZSBsaXN0ZWQgaW4gdGhlXFxuXFx0Ly8gZmlyc3QgY29sdW1uIG9mIHRoZSBvdmVycmlkZXMgdGFibGUuXFxuXFx0Ly8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjdGFibGUtY2hhcnJlZi1vdmVycmlkZXNcXG5cXHR2YXIgcmVnZXhBc2NpaVdoaXRlbGlzdCA9IC9bXFxcXHgwMS1cXFxceDdGXS9nO1xcblxcdC8vIEFsbCBCTVAgc3ltYm9scyB0aGF0IGFyZSBub3QgQVNDSUkgbmV3bGluZXMsIHByaW50YWJsZSBBU0NJSSBzeW1ib2xzLCBvclxcblxcdC8vIGNvZGUgcG9pbnRzIGxpc3RlZCBpbiB0aGUgZmlyc3QgY29sdW1uIG9mIHRoZSBvdmVycmlkZXMgdGFibGUgb25cXG5cXHQvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCN0YWJsZS1jaGFycmVmLW92ZXJyaWRlcy5cXG5cXHR2YXIgcmVnZXhCbXBXaGl0ZWxpc3QgPSAvW1xcXFx4MDEtXFxcXHRcXFxceDBCXFxcXGZcXFxceDBFLVxcXFx4MUZcXFxceDdGXFxcXHg4MVxcXFx4OERcXFxceDhGXFxcXHg5MFxcXFx4OURcXFxceEEwLVxcXFx1RkZGRl0vZztcXG5cXG5cXHR2YXIgcmVnZXhFbmNvZGVOb25Bc2NpaSA9IC88XFxcXHUyMEQyfD1cXFxcdTIwRTV8PlxcXFx1MjBEMnxcXFxcdTIwNUZcXFxcdTIwMEF8XFxcXHUyMTlEXFxcXHUwMzM4fFxcXFx1MjIwMlxcXFx1MDMzOHxcXFxcdTIyMjBcXFxcdTIwRDJ8XFxcXHUyMjI5XFxcXHVGRTAwfFxcXFx1MjIyQVxcXFx1RkUwMHxcXFxcdTIyM0NcXFxcdTIwRDJ8XFxcXHUyMjNEXFxcXHUwMzMxfFxcXFx1MjIzRVxcXFx1MDMzM3xcXFxcdTIyNDJcXFxcdTAzMzh8XFxcXHUyMjRCXFxcXHUwMzM4fFxcXFx1MjI0RFxcXFx1MjBEMnxcXFxcdTIyNEVcXFxcdTAzMzh8XFxcXHUyMjRGXFxcXHUwMzM4fFxcXFx1MjI1MFxcXFx1MDMzOHxcXFxcdTIyNjFcXFxcdTIwRTV8XFxcXHUyMjY0XFxcXHUyMEQyfFxcXFx1MjI2NVxcXFx1MjBEMnxcXFxcdTIyNjZcXFxcdTAzMzh8XFxcXHUyMjY3XFxcXHUwMzM4fFxcXFx1MjI2OFxcXFx1RkUwMHxcXFxcdTIyNjlcXFxcdUZFMDB8XFxcXHUyMjZBXFxcXHUwMzM4fFxcXFx1MjI2QVxcXFx1MjBEMnxcXFxcdTIyNkJcXFxcdTAzMzh8XFxcXHUyMjZCXFxcXHUyMEQyfFxcXFx1MjI3RlxcXFx1MDMzOHxcXFxcdTIyODJcXFxcdTIwRDJ8XFxcXHUyMjgzXFxcXHUyMEQyfFxcXFx1MjI4QVxcXFx1RkUwMHxcXFxcdTIyOEJcXFxcdUZFMDB8XFxcXHUyMjhGXFxcXHUwMzM4fFxcXFx1MjI5MFxcXFx1MDMzOHxcXFxcdTIyOTNcXFxcdUZFMDB8XFxcXHUyMjk0XFxcXHVGRTAwfFxcXFx1MjJCNFxcXFx1MjBEMnxcXFxcdTIyQjVcXFxcdTIwRDJ8XFxcXHUyMkQ4XFxcXHUwMzM4fFxcXFx1MjJEOVxcXFx1MDMzOHxcXFxcdTIyREFcXFxcdUZFMDB8XFxcXHUyMkRCXFxcXHVGRTAwfFxcXFx1MjJGNVxcXFx1MDMzOHxcXFxcdTIyRjlcXFxcdTAzMzh8XFxcXHUyOTMzXFxcXHUwMzM4fFxcXFx1MjlDRlxcXFx1MDMzOHxcXFxcdTI5RDBcXFxcdTAzMzh8XFxcXHUyQTZEXFxcXHUwMzM4fFxcXFx1MkE3MFxcXFx1MDMzOHxcXFxcdTJBN0RcXFxcdTAzMzh8XFxcXHUyQTdFXFxcXHUwMzM4fFxcXFx1MkFBMVxcXFx1MDMzOHxcXFxcdTJBQTJcXFxcdTAzMzh8XFxcXHUyQUFDXFxcXHVGRTAwfFxcXFx1MkFBRFxcXFx1RkUwMHxcXFxcdTJBQUZcXFxcdTAzMzh8XFxcXHUyQUIwXFxcXHUwMzM4fFxcXFx1MkFDNVxcXFx1MDMzOHxcXFxcdTJBQzZcXFxcdTAzMzh8XFxcXHUyQUNCXFxcXHVGRTAwfFxcXFx1MkFDQ1xcXFx1RkUwMHxcXFxcdTJBRkRcXFxcdTIwRTV8W1xcXFx4QTAtXFxcXHUwMTEzXFxcXHUwMTE2LVxcXFx1MDEyMlxcXFx1MDEyNC1cXFxcdTAxMkJcXFxcdTAxMkUtXFxcXHUwMTREXFxcXHUwMTUwLVxcXFx1MDE3RVxcXFx1MDE5MlxcXFx1MDFCNVxcXFx1MDFGNVxcXFx1MDIzN1xcXFx1MDJDNlxcXFx1MDJDN1xcXFx1MDJEOC1cXFxcdTAyRERcXFxcdTAzMTFcXFxcdTAzOTEtXFxcXHUwM0ExXFxcXHUwM0EzLVxcXFx1MDNBOVxcXFx1MDNCMS1cXFxcdTAzQzlcXFxcdTAzRDFcXFxcdTAzRDJcXFxcdTAzRDVcXFxcdTAzRDZcXFxcdTAzRENcXFxcdTAzRERcXFxcdTAzRjBcXFxcdTAzRjFcXFxcdTAzRjVcXFxcdTAzRjZcXFxcdTA0MDEtXFxcXHUwNDBDXFxcXHUwNDBFLVxcXFx1MDQ0RlxcXFx1MDQ1MS1cXFxcdTA0NUNcXFxcdTA0NUVcXFxcdTA0NUZcXFxcdTIwMDItXFxcXHUyMDA1XFxcXHUyMDA3LVxcXFx1MjAxMFxcXFx1MjAxMy1cXFxcdTIwMTZcXFxcdTIwMTgtXFxcXHUyMDFBXFxcXHUyMDFDLVxcXFx1MjAxRVxcXFx1MjAyMC1cXFxcdTIwMjJcXFxcdTIwMjVcXFxcdTIwMjZcXFxcdTIwMzAtXFxcXHUyMDM1XFxcXHUyMDM5XFxcXHUyMDNBXFxcXHUyMDNFXFxcXHUyMDQxXFxcXHUyMDQzXFxcXHUyMDQ0XFxcXHUyMDRGXFxcXHUyMDU3XFxcXHUyMDVGLVxcXFx1MjA2M1xcXFx1MjBBQ1xcXFx1MjBEQlxcXFx1MjBEQ1xcXFx1MjEwMlxcXFx1MjEwNVxcXFx1MjEwQS1cXFxcdTIxMTNcXFxcdTIxMTUtXFxcXHUyMTFFXFxcXHUyMTIyXFxcXHUyMTI0XFxcXHUyMTI3LVxcXFx1MjEyOVxcXFx1MjEyQ1xcXFx1MjEyRFxcXFx1MjEyRi1cXFxcdTIxMzFcXFxcdTIxMzMtXFxcXHUyMTM4XFxcXHUyMTQ1LVxcXFx1MjE0OFxcXFx1MjE1My1cXFxcdTIxNUVcXFxcdTIxOTAtXFxcXHUyMTlCXFxcXHUyMTlELVxcXFx1MjFBN1xcXFx1MjFBOS1cXFxcdTIxQUVcXFxcdTIxQjAtXFxcXHUyMUIzXFxcXHUyMUI1LVxcXFx1MjFCN1xcXFx1MjFCQS1cXFxcdTIxREJcXFxcdTIxRERcXFxcdTIxRTRcXFxcdTIxRTVcXFxcdTIxRjVcXFxcdTIxRkQtXFxcXHUyMjA1XFxcXHUyMjA3LVxcXFx1MjIwOVxcXFx1MjIwQlxcXFx1MjIwQ1xcXFx1MjIwRi1cXFxcdTIyMTRcXFxcdTIyMTYtXFxcXHUyMjE4XFxcXHUyMjFBXFxcXHUyMjFELVxcXFx1MjIzOFxcXFx1MjIzQS1cXFxcdTIyNTdcXFxcdTIyNTlcXFxcdTIyNUFcXFxcdTIyNUNcXFxcdTIyNUYtXFxcXHUyMjYyXFxcXHUyMjY0LVxcXFx1MjI4QlxcXFx1MjI4RC1cXFxcdTIyOUJcXFxcdTIyOUQtXFxcXHUyMkE1XFxcXHUyMkE3LVxcXFx1MjJCMFxcXFx1MjJCMi1cXFxcdTIyQkJcXFxcdTIyQkQtXFxcXHUyMkRCXFxcXHUyMkRFLVxcXFx1MjJFM1xcXFx1MjJFNi1cXFxcdTIyRjdcXFxcdTIyRjktXFxcXHUyMkZFXFxcXHUyMzA1XFxcXHUyMzA2XFxcXHUyMzA4LVxcXFx1MjMxMFxcXFx1MjMxMlxcXFx1MjMxM1xcXFx1MjMxNVxcXFx1MjMxNlxcXFx1MjMxQy1cXFxcdTIzMUZcXFxcdTIzMjJcXFxcdTIzMjNcXFxcdTIzMkRcXFxcdTIzMkVcXFxcdTIzMzZcXFxcdTIzM0RcXFxcdTIzM0ZcXFxcdTIzN0NcXFxcdTIzQjBcXFxcdTIzQjFcXFxcdTIzQjQtXFxcXHUyM0I2XFxcXHUyM0RDLVxcXFx1MjNERlxcXFx1MjNFMlxcXFx1MjNFN1xcXFx1MjQyM1xcXFx1MjRDOFxcXFx1MjUwMFxcXFx1MjUwMlxcXFx1MjUwQ1xcXFx1MjUxMFxcXFx1MjUxNFxcXFx1MjUxOFxcXFx1MjUxQ1xcXFx1MjUyNFxcXFx1MjUyQ1xcXFx1MjUzNFxcXFx1MjUzQ1xcXFx1MjU1MC1cXFxcdTI1NkNcXFxcdTI1ODBcXFxcdTI1ODRcXFxcdTI1ODhcXFxcdTI1OTEtXFxcXHUyNTkzXFxcXHUyNUExXFxcXHUyNUFBXFxcXHUyNUFCXFxcXHUyNUFEXFxcXHUyNUFFXFxcXHUyNUIxXFxcXHUyNUIzLVxcXFx1MjVCNVxcXFx1MjVCOFxcXFx1MjVCOVxcXFx1MjVCRC1cXFxcdTI1QkZcXFxcdTI1QzJcXFxcdTI1QzNcXFxcdTI1Q0FcXFxcdTI1Q0JcXFxcdTI1RUNcXFxcdTI1RUZcXFxcdTI1RjgtXFxcXHUyNUZDXFxcXHUyNjA1XFxcXHUyNjA2XFxcXHUyNjBFXFxcXHUyNjQwXFxcXHUyNjQyXFxcXHUyNjYwXFxcXHUyNjYzXFxcXHUyNjY1XFxcXHUyNjY2XFxcXHUyNjZBXFxcXHUyNjZELVxcXFx1MjY2RlxcXFx1MjcxM1xcXFx1MjcxN1xcXFx1MjcyMFxcXFx1MjczNlxcXFx1Mjc1OFxcXFx1Mjc3MlxcXFx1Mjc3M1xcXFx1MjdDOFxcXFx1MjdDOVxcXFx1MjdFNi1cXFxcdTI3RURcXFxcdTI3RjUtXFxcXHUyN0ZBXFxcXHUyN0ZDXFxcXHUyN0ZGXFxcXHUyOTAyLVxcXFx1MjkwNVxcXFx1MjkwQy1cXFxcdTI5MTNcXFxcdTI5MTZcXFxcdTI5MTktXFxcXHUyOTIwXFxcXHUyOTIzLVxcXFx1MjkyQVxcXFx1MjkzM1xcXFx1MjkzNS1cXFxcdTI5MzlcXFxcdTI5M0NcXFxcdTI5M0RcXFxcdTI5NDVcXFxcdTI5NDgtXFxcXHUyOTRCXFxcXHUyOTRFLVxcXFx1Mjk3NlxcXFx1Mjk3OFxcXFx1Mjk3OVxcXFx1Mjk3Qi1cXFxcdTI5N0ZcXFxcdTI5ODVcXFxcdTI5ODZcXFxcdTI5OEItXFxcXHUyOTk2XFxcXHUyOTlBXFxcXHUyOTlDXFxcXHUyOTlEXFxcXHUyOUE0LVxcXFx1MjlCN1xcXFx1MjlCOVxcXFx1MjlCQlxcXFx1MjlCQ1xcXFx1MjlCRS1cXFxcdTI5QzVcXFxcdTI5QzlcXFxcdTI5Q0QtXFxcXHUyOUQwXFxcXHUyOURDLVxcXFx1MjlERVxcXFx1MjlFMy1cXFxcdTI5RTVcXFxcdTI5RUJcXFxcdTI5RjRcXFxcdTI5RjZcXFxcdTJBMDAtXFxcXHUyQTAyXFxcXHUyQTA0XFxcXHUyQTA2XFxcXHUyQTBDXFxcXHUyQTBEXFxcXHUyQTEwLVxcXFx1MkExN1xcXFx1MkEyMi1cXFxcdTJBMjdcXFxcdTJBMjlcXFxcdTJBMkFcXFxcdTJBMkQtXFxcXHUyQTMxXFxcXHUyQTMzLVxcXFx1MkEzQ1xcXFx1MkEzRlxcXFx1MkE0MFxcXFx1MkE0Mi1cXFxcdTJBNERcXFxcdTJBNTBcXFxcdTJBNTMtXFxcXHUyQTU4XFxcXHUyQTVBLVxcXFx1MkE1RFxcXFx1MkE1RlxcXFx1MkE2NlxcXFx1MkE2QVxcXFx1MkE2RC1cXFxcdTJBNzVcXFxcdTJBNzctXFxcXHUyQTlBXFxcXHUyQTlELVxcXFx1MkFBMlxcXFx1MkFBNC1cXFxcdTJBQjBcXFxcdTJBQjMtXFxcXHUyQUM4XFxcXHUyQUNCXFxcXHUyQUNDXFxcXHUyQUNGLVxcXFx1MkFEQlxcXFx1MkFFNFxcXFx1MkFFNi1cXFxcdTJBRTlcXFxcdTJBRUItXFxcXHUyQUYzXFxcXHUyQUZEXFxcXHVGQjAwLVxcXFx1RkIwNF18XFxcXHVEODM1W1xcXFx1REM5Q1xcXFx1REM5RVxcXFx1REM5RlxcXFx1RENBMlxcXFx1RENBNVxcXFx1RENBNlxcXFx1RENBOS1cXFxcdURDQUNcXFxcdURDQUUtXFxcXHVEQ0I5XFxcXHVEQ0JCXFxcXHVEQ0JELVxcXFx1RENDM1xcXFx1RENDNS1cXFxcdURDQ0ZcXFxcdUREMDRcXFxcdUREMDVcXFxcdUREMDctXFxcXHVERDBBXFxcXHVERDBELVxcXFx1REQxNFxcXFx1REQxNi1cXFxcdUREMUNcXFxcdUREMUUtXFxcXHVERDM5XFxcXHVERDNCLVxcXFx1REQzRVxcXFx1REQ0MC1cXFxcdURENDRcXFxcdURENDZcXFxcdURENEEtXFxcXHVERDUwXFxcXHVERDUyLVxcXFx1REQ2Ql0vZztcXG5cXHR2YXIgZW5jb2RlTWFwID0geydcXFxceEFEJzonc2h5JywnXFxcXHUyMDBDJzonenduaicsJ1xcXFx1MjAwRCc6J3p3aicsJ1xcXFx1MjAwRSc6J2xybScsJ1xcXFx1MjA2Myc6J2ljJywnXFxcXHUyMDYyJzonaXQnLCdcXFxcdTIwNjEnOidhZicsJ1xcXFx1MjAwRic6J3JsbScsJ1xcXFx1MjAwQic6J1plcm9XaWR0aFNwYWNlJywnXFxcXHUyMDYwJzonTm9CcmVhaycsJ1xcXFx1MDMxMSc6J0Rvd25CcmV2ZScsJ1xcXFx1MjBEQic6J3Rkb3QnLCdcXFxcdTIwREMnOidEb3REb3QnLCdcXFxcdCc6J1RhYicsJ1xcXFxuJzonTmV3TGluZScsJ1xcXFx1MjAwOCc6J3B1bmNzcCcsJ1xcXFx1MjA1Ric6J01lZGl1bVNwYWNlJywnXFxcXHUyMDA5JzondGhpbnNwJywnXFxcXHUyMDBBJzonaGFpcnNwJywnXFxcXHUyMDA0JzonZW1zcDEzJywnXFxcXHUyMDAyJzonZW5zcCcsJ1xcXFx1MjAwNSc6J2Vtc3AxNCcsJ1xcXFx1MjAwMyc6J2Vtc3AnLCdcXFxcdTIwMDcnOidudW1zcCcsJ1xcXFx4QTAnOiduYnNwJywnXFxcXHUyMDVGXFxcXHUyMDBBJzonVGhpY2tTcGFjZScsJ1xcXFx1MjAzRSc6J29saW5lJywnXyc6J2xvd2JhcicsJ1xcXFx1MjAxMCc6J2Rhc2gnLCdcXFxcdTIwMTMnOiduZGFzaCcsJ1xcXFx1MjAxNCc6J21kYXNoJywnXFxcXHUyMDE1JzonaG9yYmFyJywnLCc6J2NvbW1hJywnOyc6J3NlbWknLCdcXFxcdTIwNEYnOidic2VtaScsJzonOidjb2xvbicsJ1xcXFx1MkE3NCc6J0NvbG9uZScsJyEnOidleGNsJywnXFxcXHhBMSc6J2lleGNsJywnPyc6J3F1ZXN0JywnXFxcXHhCRic6J2lxdWVzdCcsJy4nOidwZXJpb2QnLCdcXFxcdTIwMjUnOidubGRyJywnXFxcXHUyMDI2JzonbWxkcicsJ1xcXFx4QjcnOidtaWRkb3QnLCdcXFxcJyc6J2Fwb3MnLCdcXFxcdTIwMTgnOidsc3F1bycsJ1xcXFx1MjAxOSc6J3JzcXVvJywnXFxcXHUyMDFBJzonc2JxdW8nLCdcXFxcdTIwMzknOidsc2FxdW8nLCdcXFxcdTIwM0EnOidyc2FxdW8nLCdcXFwiJzoncXVvdCcsJ1xcXFx1MjAxQyc6J2xkcXVvJywnXFxcXHUyMDFEJzoncmRxdW8nLCdcXFxcdTIwMUUnOidiZHF1bycsJ1xcXFx4QUInOidsYXF1bycsJ1xcXFx4QkInOidyYXF1bycsJygnOidscGFyJywnKSc6J3JwYXInLCdbJzonbHNxYicsJ10nOidyc3FiJywneyc6J2xjdWInLCd9JzoncmN1YicsJ1xcXFx1MjMwOCc6J2xjZWlsJywnXFxcXHUyMzA5JzoncmNlaWwnLCdcXFxcdTIzMEEnOidsZmxvb3InLCdcXFxcdTIzMEInOidyZmxvb3InLCdcXFxcdTI5ODUnOidsb3BhcicsJ1xcXFx1Mjk4Nic6J3JvcGFyJywnXFxcXHUyOThCJzonbGJya2UnLCdcXFxcdTI5OEMnOidyYnJrZScsJ1xcXFx1Mjk4RCc6J2xicmtzbHUnLCdcXFxcdTI5OEUnOidyYnJrc2xkJywnXFxcXHUyOThGJzonbGJya3NsZCcsJ1xcXFx1Mjk5MCc6J3JicmtzbHUnLCdcXFxcdTI5OTEnOidsYW5nZCcsJ1xcXFx1Mjk5Mic6J3JhbmdkJywnXFxcXHUyOTkzJzonbHBhcmx0JywnXFxcXHUyOTk0JzoncnBhcmd0JywnXFxcXHUyOTk1JzonZ3RsUGFyJywnXFxcXHUyOTk2JzonbHRyUGFyJywnXFxcXHUyN0U2JzonbG9icmsnLCdcXFxcdTI3RTcnOidyb2JyaycsJ1xcXFx1MjdFOCc6J2xhbmcnLCdcXFxcdTI3RTknOidyYW5nJywnXFxcXHUyN0VBJzonTGFuZycsJ1xcXFx1MjdFQic6J1JhbmcnLCdcXFxcdTI3RUMnOidsb2FuZycsJ1xcXFx1MjdFRCc6J3JvYW5nJywnXFxcXHUyNzcyJzonbGJicmsnLCdcXFxcdTI3NzMnOidyYmJyaycsJ1xcXFx1MjAxNic6J1ZlcnQnLCdcXFxceEE3Jzonc2VjdCcsJ1xcXFx4QjYnOidwYXJhJywnQCc6J2NvbW1hdCcsJyonOidhc3QnLCcvJzonc29sJywndW5kZWZpbmVkJzpudWxsLCcmJzonYW1wJywnIyc6J251bScsJyUnOidwZXJjbnQnLCdcXFxcdTIwMzAnOidwZXJtaWwnLCdcXFxcdTIwMzEnOidwZXJ0ZW5rJywnXFxcXHUyMDIwJzonZGFnZ2VyJywnXFxcXHUyMDIxJzonRGFnZ2VyJywnXFxcXHUyMDIyJzonYnVsbCcsJ1xcXFx1MjA0Myc6J2h5YnVsbCcsJ1xcXFx1MjAzMic6J3ByaW1lJywnXFxcXHUyMDMzJzonUHJpbWUnLCdcXFxcdTIwMzQnOid0cHJpbWUnLCdcXFxcdTIwNTcnOidxcHJpbWUnLCdcXFxcdTIwMzUnOidicHJpbWUnLCdcXFxcdTIwNDEnOidjYXJldCcsJ2AnOidncmF2ZScsJ1xcXFx4QjQnOidhY3V0ZScsJ1xcXFx1MDJEQyc6J3RpbGRlJywnXic6J0hhdCcsJ1xcXFx4QUYnOidtYWNyJywnXFxcXHUwMkQ4JzonYnJldmUnLCdcXFxcdTAyRDknOidkb3QnLCdcXFxceEE4JzonZGllJywnXFxcXHUwMkRBJzoncmluZycsJ1xcXFx1MDJERCc6J2RibGFjJywnXFxcXHhCOCc6J2NlZGlsJywnXFxcXHUwMkRCJzonb2dvbicsJ1xcXFx1MDJDNic6J2NpcmMnLCdcXFxcdTAyQzcnOidjYXJvbicsJ1xcXFx4QjAnOidkZWcnLCdcXFxceEE5JzonY29weScsJ1xcXFx4QUUnOidyZWcnLCdcXFxcdTIxMTcnOidjb3B5c3InLCdcXFxcdTIxMTgnOid3cCcsJ1xcXFx1MjExRSc6J3J4JywnXFxcXHUyMTI3JzonbWhvJywnXFxcXHUyMTI5JzonaWlvdGEnLCdcXFxcdTIxOTAnOidsYXJyJywnXFxcXHUyMTlBJzonbmxhcnInLCdcXFxcdTIxOTInOidyYXJyJywnXFxcXHUyMTlCJzonbnJhcnInLCdcXFxcdTIxOTEnOid1YXJyJywnXFxcXHUyMTkzJzonZGFycicsJ1xcXFx1MjE5NCc6J2hhcnInLCdcXFxcdTIxQUUnOiduaGFycicsJ1xcXFx1MjE5NSc6J3ZhcnInLCdcXFxcdTIxOTYnOidud2FycicsJ1xcXFx1MjE5Nyc6J25lYXJyJywnXFxcXHUyMTk4Jzonc2VhcnInLCdcXFxcdTIxOTknOidzd2FycicsJ1xcXFx1MjE5RCc6J3JhcnJ3JywnXFxcXHUyMTlEXFxcXHUwMzM4JzonbnJhcnJ3JywnXFxcXHUyMTlFJzonTGFycicsJ1xcXFx1MjE5Ric6J1VhcnInLCdcXFxcdTIxQTAnOidSYXJyJywnXFxcXHUyMUExJzonRGFycicsJ1xcXFx1MjFBMic6J2xhcnJ0bCcsJ1xcXFx1MjFBMyc6J3JhcnJ0bCcsJ1xcXFx1MjFBNCc6J21hcHN0b2xlZnQnLCdcXFxcdTIxQTUnOidtYXBzdG91cCcsJ1xcXFx1MjFBNic6J21hcCcsJ1xcXFx1MjFBNyc6J21hcHN0b2Rvd24nLCdcXFxcdTIxQTknOidsYXJyaGsnLCdcXFxcdTIxQUEnOidyYXJyaGsnLCdcXFxcdTIxQUInOidsYXJybHAnLCdcXFxcdTIxQUMnOidyYXJybHAnLCdcXFxcdTIxQUQnOidoYXJydycsJ1xcXFx1MjFCMCc6J2xzaCcsJ1xcXFx1MjFCMSc6J3JzaCcsJ1xcXFx1MjFCMic6J2xkc2gnLCdcXFxcdTIxQjMnOidyZHNoJywnXFxcXHUyMUI1JzonY3JhcnInLCdcXFxcdTIxQjYnOidjdWxhcnInLCdcXFxcdTIxQjcnOidjdXJhcnInLCdcXFxcdTIxQkEnOidvbGFycicsJ1xcXFx1MjFCQic6J29yYXJyJywnXFxcXHUyMUJDJzonbGhhcnUnLCdcXFxcdTIxQkQnOidsaGFyZCcsJ1xcXFx1MjFCRSc6J3VoYXJyJywnXFxcXHUyMUJGJzondWhhcmwnLCdcXFxcdTIxQzAnOidyaGFydScsJ1xcXFx1MjFDMSc6J3JoYXJkJywnXFxcXHUyMUMyJzonZGhhcnInLCdcXFxcdTIxQzMnOidkaGFybCcsJ1xcXFx1MjFDNCc6J3JsYXJyJywnXFxcXHUyMUM1JzondWRhcnInLCdcXFxcdTIxQzYnOidscmFycicsJ1xcXFx1MjFDNyc6J2xsYXJyJywnXFxcXHUyMUM4JzondXVhcnInLCdcXFxcdTIxQzknOidycmFycicsJ1xcXFx1MjFDQSc6J2RkYXJyJywnXFxcXHUyMUNCJzonbHJoYXInLCdcXFxcdTIxQ0MnOidybGhhcicsJ1xcXFx1MjFEMCc6J2xBcnInLCdcXFxcdTIxQ0QnOidubEFycicsJ1xcXFx1MjFEMSc6J3VBcnInLCdcXFxcdTIxRDInOidyQXJyJywnXFxcXHUyMUNGJzonbnJBcnInLCdcXFxcdTIxRDMnOidkQXJyJywnXFxcXHUyMUQ0JzonaWZmJywnXFxcXHUyMUNFJzonbmhBcnInLCdcXFxcdTIxRDUnOid2QXJyJywnXFxcXHUyMUQ2JzonbndBcnInLCdcXFxcdTIxRDcnOiduZUFycicsJ1xcXFx1MjFEOCc6J3NlQXJyJywnXFxcXHUyMUQ5Jzonc3dBcnInLCdcXFxcdTIxREEnOidsQWFycicsJ1xcXFx1MjFEQic6J3JBYXJyJywnXFxcXHUyMUREJzonemlncmFycicsJ1xcXFx1MjFFNCc6J2xhcnJiJywnXFxcXHUyMUU1JzoncmFycmInLCdcXFxcdTIxRjUnOidkdWFycicsJ1xcXFx1MjFGRCc6J2xvYXJyJywnXFxcXHUyMUZFJzoncm9hcnInLCdcXFxcdTIxRkYnOidob2FycicsJ1xcXFx1MjIwMCc6J2ZvcmFsbCcsJ1xcXFx1MjIwMSc6J2NvbXAnLCdcXFxcdTIyMDInOidwYXJ0JywnXFxcXHUyMjAyXFxcXHUwMzM4JzonbnBhcnQnLCdcXFxcdTIyMDMnOidleGlzdCcsJ1xcXFx1MjIwNCc6J25leGlzdCcsJ1xcXFx1MjIwNSc6J2VtcHR5JywnXFxcXHUyMjA3JzonRGVsJywnXFxcXHUyMjA4JzonaW4nLCdcXFxcdTIyMDknOidub3RpbicsJ1xcXFx1MjIwQic6J25pJywnXFxcXHUyMjBDJzonbm90bmknLCdcXFxcdTAzRjYnOidiZXBzaScsJ1xcXFx1MjIwRic6J3Byb2QnLCdcXFxcdTIyMTAnOidjb3Byb2QnLCdcXFxcdTIyMTEnOidzdW0nLCcrJzoncGx1cycsJ1xcXFx4QjEnOidwbScsJ1xcXFx4RjcnOidkaXYnLCdcXFxceEQ3JzondGltZXMnLCc8JzonbHQnLCdcXFxcdTIyNkUnOidubHQnLCc8XFxcXHUyMEQyJzonbnZsdCcsJz0nOidlcXVhbHMnLCdcXFxcdTIyNjAnOiduZScsJz1cXFxcdTIwRTUnOidibmUnLCdcXFxcdTJBNzUnOidFcXVhbCcsJz4nOidndCcsJ1xcXFx1MjI2Ric6J25ndCcsJz5cXFxcdTIwRDInOidudmd0JywnXFxcXHhBQyc6J25vdCcsJ3wnOid2ZXJ0JywnXFxcXHhBNic6J2JydmJhcicsJ1xcXFx1MjIxMic6J21pbnVzJywnXFxcXHUyMjEzJzonbXAnLCdcXFxcdTIyMTQnOidwbHVzZG8nLCdcXFxcdTIwNDQnOidmcmFzbCcsJ1xcXFx1MjIxNic6J3NldG1uJywnXFxcXHUyMjE3JzonbG93YXN0JywnXFxcXHUyMjE4JzonY29tcGZuJywnXFxcXHUyMjFBJzonU3FydCcsJ1xcXFx1MjIxRCc6J3Byb3AnLCdcXFxcdTIyMUUnOidpbmZpbicsJ1xcXFx1MjIxRic6J2FuZ3J0JywnXFxcXHUyMjIwJzonYW5nJywnXFxcXHUyMjIwXFxcXHUyMEQyJzonbmFuZycsJ1xcXFx1MjIyMSc6J2FuZ21zZCcsJ1xcXFx1MjIyMic6J2FuZ3NwaCcsJ1xcXFx1MjIyMyc6J21pZCcsJ1xcXFx1MjIyNCc6J25taWQnLCdcXFxcdTIyMjUnOidwYXInLCdcXFxcdTIyMjYnOiducGFyJywnXFxcXHUyMjI3JzonYW5kJywnXFxcXHUyMjI4Jzonb3InLCdcXFxcdTIyMjknOidjYXAnLCdcXFxcdTIyMjlcXFxcdUZFMDAnOidjYXBzJywnXFxcXHUyMjJBJzonY3VwJywnXFxcXHUyMjJBXFxcXHVGRTAwJzonY3VwcycsJ1xcXFx1MjIyQic6J2ludCcsJ1xcXFx1MjIyQyc6J0ludCcsJ1xcXFx1MjIyRCc6J3RpbnQnLCdcXFxcdTJBMEMnOidxaW50JywnXFxcXHUyMjJFJzonb2ludCcsJ1xcXFx1MjIyRic6J0NvbmludCcsJ1xcXFx1MjIzMCc6J0Njb25pbnQnLCdcXFxcdTIyMzEnOidjd2ludCcsJ1xcXFx1MjIzMic6J2N3Y29uaW50JywnXFxcXHUyMjMzJzonYXdjb25pbnQnLCdcXFxcdTIyMzQnOid0aGVyZTQnLCdcXFxcdTIyMzUnOidiZWNhdXMnLCdcXFxcdTIyMzYnOidyYXRpbycsJ1xcXFx1MjIzNyc6J0NvbG9uJywnXFxcXHUyMjM4JzonbWludXNkJywnXFxcXHUyMjNBJzonbUREb3QnLCdcXFxcdTIyM0InOidob210aHQnLCdcXFxcdTIyM0MnOidzaW0nLCdcXFxcdTIyNDEnOiduc2ltJywnXFxcXHUyMjNDXFxcXHUyMEQyJzonbnZzaW0nLCdcXFxcdTIyM0QnOidic2ltJywnXFxcXHUyMjNEXFxcXHUwMzMxJzoncmFjZScsJ1xcXFx1MjIzRSc6J2FjJywnXFxcXHUyMjNFXFxcXHUwMzMzJzonYWNFJywnXFxcXHUyMjNGJzonYWNkJywnXFxcXHUyMjQwJzond3InLCdcXFxcdTIyNDInOidlc2ltJywnXFxcXHUyMjQyXFxcXHUwMzM4JzonbmVzaW0nLCdcXFxcdTIyNDMnOidzaW1lJywnXFxcXHUyMjQ0JzonbnNpbWUnLCdcXFxcdTIyNDUnOidjb25nJywnXFxcXHUyMjQ3JzonbmNvbmcnLCdcXFxcdTIyNDYnOidzaW1uZScsJ1xcXFx1MjI0OCc6J2FwJywnXFxcXHUyMjQ5JzonbmFwJywnXFxcXHUyMjRBJzonYXBlJywnXFxcXHUyMjRCJzonYXBpZCcsJ1xcXFx1MjI0QlxcXFx1MDMzOCc6J25hcGlkJywnXFxcXHUyMjRDJzonYmNvbmcnLCdcXFxcdTIyNEQnOidDdXBDYXAnLCdcXFxcdTIyNkQnOidOb3RDdXBDYXAnLCdcXFxcdTIyNERcXFxcdTIwRDInOidudmFwJywnXFxcXHUyMjRFJzonYnVtcCcsJ1xcXFx1MjI0RVxcXFx1MDMzOCc6J25idW1wJywnXFxcXHUyMjRGJzonYnVtcGUnLCdcXFxcdTIyNEZcXFxcdTAzMzgnOiduYnVtcGUnLCdcXFxcdTIyNTAnOidkb3RlcScsJ1xcXFx1MjI1MFxcXFx1MDMzOCc6J25lZG90JywnXFxcXHUyMjUxJzonZURvdCcsJ1xcXFx1MjI1Mic6J2VmRG90JywnXFxcXHUyMjUzJzonZXJEb3QnLCdcXFxcdTIyNTQnOidjb2xvbmUnLCdcXFxcdTIyNTUnOidlY29sb24nLCdcXFxcdTIyNTYnOidlY2lyJywnXFxcXHUyMjU3JzonY2lyZScsJ1xcXFx1MjI1OSc6J3dlZGdlcScsJ1xcXFx1MjI1QSc6J3ZlZWVxJywnXFxcXHUyMjVDJzondHJpZScsJ1xcXFx1MjI1Ric6J2VxdWVzdCcsJ1xcXFx1MjI2MSc6J2VxdWl2JywnXFxcXHUyMjYyJzonbmVxdWl2JywnXFxcXHUyMjYxXFxcXHUyMEU1JzonYm5lcXVpdicsJ1xcXFx1MjI2NCc6J2xlJywnXFxcXHUyMjcwJzonbmxlJywnXFxcXHUyMjY0XFxcXHUyMEQyJzonbnZsZScsJ1xcXFx1MjI2NSc6J2dlJywnXFxcXHUyMjcxJzonbmdlJywnXFxcXHUyMjY1XFxcXHUyMEQyJzonbnZnZScsJ1xcXFx1MjI2Nic6J2xFJywnXFxcXHUyMjY2XFxcXHUwMzM4JzonbmxFJywnXFxcXHUyMjY3JzonZ0UnLCdcXFxcdTIyNjdcXFxcdTAzMzgnOiduZ0UnLCdcXFxcdTIyNjhcXFxcdUZFMDAnOidsdm5FJywnXFxcXHUyMjY4JzonbG5FJywnXFxcXHUyMjY5JzonZ25FJywnXFxcXHUyMjY5XFxcXHVGRTAwJzonZ3ZuRScsJ1xcXFx1MjI2QSc6J2xsJywnXFxcXHUyMjZBXFxcXHUwMzM4Jzonbkx0dicsJ1xcXFx1MjI2QVxcXFx1MjBEMic6J25MdCcsJ1xcXFx1MjI2Qic6J2dnJywnXFxcXHUyMjZCXFxcXHUwMzM4Jzonbkd0dicsJ1xcXFx1MjI2QlxcXFx1MjBEMic6J25HdCcsJ1xcXFx1MjI2Qyc6J3R3aXh0JywnXFxcXHUyMjcyJzonbHNpbScsJ1xcXFx1MjI3NCc6J25sc2ltJywnXFxcXHUyMjczJzonZ3NpbScsJ1xcXFx1MjI3NSc6J25nc2ltJywnXFxcXHUyMjc2JzonbGcnLCdcXFxcdTIyNzgnOidudGxnJywnXFxcXHUyMjc3JzonZ2wnLCdcXFxcdTIyNzknOidudGdsJywnXFxcXHUyMjdBJzoncHInLCdcXFxcdTIyODAnOiducHInLCdcXFxcdTIyN0InOidzYycsJ1xcXFx1MjI4MSc6J25zYycsJ1xcXFx1MjI3Qyc6J3ByY3VlJywnXFxcXHUyMkUwJzonbnByY3VlJywnXFxcXHUyMjdEJzonc2NjdWUnLCdcXFxcdTIyRTEnOiduc2NjdWUnLCdcXFxcdTIyN0UnOidwcnNpbScsJ1xcXFx1MjI3Ric6J3Njc2ltJywnXFxcXHUyMjdGXFxcXHUwMzM4JzonTm90U3VjY2VlZHNUaWxkZScsJ1xcXFx1MjI4Mic6J3N1YicsJ1xcXFx1MjI4NCc6J25zdWInLCdcXFxcdTIyODJcXFxcdTIwRDInOid2bnN1YicsJ1xcXFx1MjI4Myc6J3N1cCcsJ1xcXFx1MjI4NSc6J25zdXAnLCdcXFxcdTIyODNcXFxcdTIwRDInOid2bnN1cCcsJ1xcXFx1MjI4Nic6J3N1YmUnLCdcXFxcdTIyODgnOiduc3ViZScsJ1xcXFx1MjI4Nyc6J3N1cGUnLCdcXFxcdTIyODknOiduc3VwZScsJ1xcXFx1MjI4QVxcXFx1RkUwMCc6J3ZzdWJuZScsJ1xcXFx1MjI4QSc6J3N1Ym5lJywnXFxcXHUyMjhCXFxcXHVGRTAwJzondnN1cG5lJywnXFxcXHUyMjhCJzonc3VwbmUnLCdcXFxcdTIyOEQnOidjdXBkb3QnLCdcXFxcdTIyOEUnOid1cGx1cycsJ1xcXFx1MjI4Ric6J3Nxc3ViJywnXFxcXHUyMjhGXFxcXHUwMzM4JzonTm90U3F1YXJlU3Vic2V0JywnXFxcXHUyMjkwJzonc3FzdXAnLCdcXFxcdTIyOTBcXFxcdTAzMzgnOidOb3RTcXVhcmVTdXBlcnNldCcsJ1xcXFx1MjI5MSc6J3Nxc3ViZScsJ1xcXFx1MjJFMic6J25zcXN1YmUnLCdcXFxcdTIyOTInOidzcXN1cGUnLCdcXFxcdTIyRTMnOiduc3FzdXBlJywnXFxcXHUyMjkzJzonc3FjYXAnLCdcXFxcdTIyOTNcXFxcdUZFMDAnOidzcWNhcHMnLCdcXFxcdTIyOTQnOidzcWN1cCcsJ1xcXFx1MjI5NFxcXFx1RkUwMCc6J3NxY3VwcycsJ1xcXFx1MjI5NSc6J29wbHVzJywnXFxcXHUyMjk2Jzonb21pbnVzJywnXFxcXHUyMjk3Jzonb3RpbWVzJywnXFxcXHUyMjk4Jzonb3NvbCcsJ1xcXFx1MjI5OSc6J29kb3QnLCdcXFxcdTIyOUEnOidvY2lyJywnXFxcXHUyMjlCJzonb2FzdCcsJ1xcXFx1MjI5RCc6J29kYXNoJywnXFxcXHUyMjlFJzoncGx1c2InLCdcXFxcdTIyOUYnOidtaW51c2InLCdcXFxcdTIyQTAnOid0aW1lc2InLCdcXFxcdTIyQTEnOidzZG90YicsJ1xcXFx1MjJBMic6J3ZkYXNoJywnXFxcXHUyMkFDJzonbnZkYXNoJywnXFxcXHUyMkEzJzonZGFzaHYnLCdcXFxcdTIyQTQnOid0b3AnLCdcXFxcdTIyQTUnOidib3QnLCdcXFxcdTIyQTcnOidtb2RlbHMnLCdcXFxcdTIyQTgnOid2RGFzaCcsJ1xcXFx1MjJBRCc6J252RGFzaCcsJ1xcXFx1MjJBOSc6J1ZkYXNoJywnXFxcXHUyMkFFJzonblZkYXNoJywnXFxcXHUyMkFBJzonVnZkYXNoJywnXFxcXHUyMkFCJzonVkRhc2gnLCdcXFxcdTIyQUYnOiduVkRhc2gnLCdcXFxcdTIyQjAnOidwcnVyZWwnLCdcXFxcdTIyQjInOid2bHRyaScsJ1xcXFx1MjJFQSc6J25sdHJpJywnXFxcXHUyMkIzJzondnJ0cmknLCdcXFxcdTIyRUInOiducnRyaScsJ1xcXFx1MjJCNCc6J2x0cmllJywnXFxcXHUyMkVDJzonbmx0cmllJywnXFxcXHUyMkI0XFxcXHUyMEQyJzonbnZsdHJpZScsJ1xcXFx1MjJCNSc6J3J0cmllJywnXFxcXHUyMkVEJzonbnJ0cmllJywnXFxcXHUyMkI1XFxcXHUyMEQyJzonbnZydHJpZScsJ1xcXFx1MjJCNic6J29yaWdvZicsJ1xcXFx1MjJCNyc6J2ltb2YnLCdcXFxcdTIyQjgnOidtdW1hcCcsJ1xcXFx1MjJCOSc6J2hlcmNvbicsJ1xcXFx1MjJCQSc6J2ludGNhbCcsJ1xcXFx1MjJCQic6J3ZlZWJhcicsJ1xcXFx1MjJCRCc6J2JhcnZlZScsJ1xcXFx1MjJCRSc6J2FuZ3J0dmInLCdcXFxcdTIyQkYnOidscnRyaScsJ1xcXFx1MjJDMCc6J1dlZGdlJywnXFxcXHUyMkMxJzonVmVlJywnXFxcXHUyMkMyJzoneGNhcCcsJ1xcXFx1MjJDMyc6J3hjdXAnLCdcXFxcdTIyQzQnOidkaWFtJywnXFxcXHUyMkM1Jzonc2RvdCcsJ1xcXFx1MjJDNic6J1N0YXInLCdcXFxcdTIyQzcnOidkaXZvbngnLCdcXFxcdTIyQzgnOidib3d0aWUnLCdcXFxcdTIyQzknOidsdGltZXMnLCdcXFxcdTIyQ0EnOidydGltZXMnLCdcXFxcdTIyQ0InOidsdGhyZWUnLCdcXFxcdTIyQ0MnOidydGhyZWUnLCdcXFxcdTIyQ0QnOidic2ltZScsJ1xcXFx1MjJDRSc6J2N1dmVlJywnXFxcXHUyMkNGJzonY3V3ZWQnLCdcXFxcdTIyRDAnOidTdWInLCdcXFxcdTIyRDEnOidTdXAnLCdcXFxcdTIyRDInOidDYXAnLCdcXFxcdTIyRDMnOidDdXAnLCdcXFxcdTIyRDQnOidmb3JrJywnXFxcXHUyMkQ1JzonZXBhcicsJ1xcXFx1MjJENic6J2x0ZG90JywnXFxcXHUyMkQ3JzonZ3Rkb3QnLCdcXFxcdTIyRDgnOidMbCcsJ1xcXFx1MjJEOFxcXFx1MDMzOCc6J25MbCcsJ1xcXFx1MjJEOSc6J0dnJywnXFxcXHUyMkQ5XFxcXHUwMzM4JzonbkdnJywnXFxcXHUyMkRBXFxcXHVGRTAwJzonbGVzZycsJ1xcXFx1MjJEQSc6J2xlZycsJ1xcXFx1MjJEQic6J2dlbCcsJ1xcXFx1MjJEQlxcXFx1RkUwMCc6J2dlc2wnLCdcXFxcdTIyREUnOidjdWVwcicsJ1xcXFx1MjJERic6J2N1ZXNjJywnXFxcXHUyMkU2JzonbG5zaW0nLCdcXFxcdTIyRTcnOidnbnNpbScsJ1xcXFx1MjJFOCc6J3BybnNpbScsJ1xcXFx1MjJFOSc6J3NjbnNpbScsJ1xcXFx1MjJFRSc6J3ZlbGxpcCcsJ1xcXFx1MjJFRic6J2N0ZG90JywnXFxcXHUyMkYwJzondXRkb3QnLCdcXFxcdTIyRjEnOidkdGRvdCcsJ1xcXFx1MjJGMic6J2Rpc2luJywnXFxcXHUyMkYzJzonaXNpbnN2JywnXFxcXHUyMkY0JzonaXNpbnMnLCdcXFxcdTIyRjUnOidpc2luZG90JywnXFxcXHUyMkY1XFxcXHUwMzM4Jzonbm90aW5kb3QnLCdcXFxcdTIyRjYnOidub3RpbnZjJywnXFxcXHUyMkY3Jzonbm90aW52YicsJ1xcXFx1MjJGOSc6J2lzaW5FJywnXFxcXHUyMkY5XFxcXHUwMzM4Jzonbm90aW5FJywnXFxcXHUyMkZBJzonbmlzZCcsJ1xcXFx1MjJGQic6J3huaXMnLCdcXFxcdTIyRkMnOiduaXMnLCdcXFxcdTIyRkQnOidub3RuaXZjJywnXFxcXHUyMkZFJzonbm90bml2YicsJ1xcXFx1MjMwNSc6J2JhcndlZCcsJ1xcXFx1MjMwNic6J0JhcndlZCcsJ1xcXFx1MjMwQyc6J2RyY3JvcCcsJ1xcXFx1MjMwRCc6J2RsY3JvcCcsJ1xcXFx1MjMwRSc6J3VyY3JvcCcsJ1xcXFx1MjMwRic6J3VsY3JvcCcsJ1xcXFx1MjMxMCc6J2Jub3QnLCdcXFxcdTIzMTInOidwcm9mbGluZScsJ1xcXFx1MjMxMyc6J3Byb2ZzdXJmJywnXFxcXHUyMzE1JzondGVscmVjJywnXFxcXHUyMzE2JzondGFyZ2V0JywnXFxcXHUyMzFDJzondWxjb3JuJywnXFxcXHUyMzFEJzondXJjb3JuJywnXFxcXHUyMzFFJzonZGxjb3JuJywnXFxcXHUyMzFGJzonZHJjb3JuJywnXFxcXHUyMzIyJzonZnJvd24nLCdcXFxcdTIzMjMnOidzbWlsZScsJ1xcXFx1MjMyRCc6J2N5bGN0eScsJ1xcXFx1MjMyRSc6J3Byb2ZhbGFyJywnXFxcXHUyMzM2JzondG9wYm90JywnXFxcXHUyMzNEJzonb3ZiYXInLCdcXFxcdTIzM0YnOidzb2xiYXInLCdcXFxcdTIzN0MnOidhbmd6YXJyJywnXFxcXHUyM0IwJzonbG1vdXN0JywnXFxcXHUyM0IxJzoncm1vdXN0JywnXFxcXHUyM0I0JzondGJyaycsJ1xcXFx1MjNCNSc6J2JicmsnLCdcXFxcdTIzQjYnOidiYnJrdGJyaycsJ1xcXFx1MjNEQyc6J092ZXJQYXJlbnRoZXNpcycsJ1xcXFx1MjNERCc6J1VuZGVyUGFyZW50aGVzaXMnLCdcXFxcdTIzREUnOidPdmVyQnJhY2UnLCdcXFxcdTIzREYnOidVbmRlckJyYWNlJywnXFxcXHUyM0UyJzondHJwZXppdW0nLCdcXFxcdTIzRTcnOidlbGludGVycycsJ1xcXFx1MjQyMyc6J2JsYW5rJywnXFxcXHUyNTAwJzonYm94aCcsJ1xcXFx1MjUwMic6J2JveHYnLCdcXFxcdTI1MEMnOidib3hkcicsJ1xcXFx1MjUxMCc6J2JveGRsJywnXFxcXHUyNTE0JzonYm94dXInLCdcXFxcdTI1MTgnOidib3h1bCcsJ1xcXFx1MjUxQyc6J2JveHZyJywnXFxcXHUyNTI0JzonYm94dmwnLCdcXFxcdTI1MkMnOidib3hoZCcsJ1xcXFx1MjUzNCc6J2JveGh1JywnXFxcXHUyNTNDJzonYm94dmgnLCdcXFxcdTI1NTAnOidib3hIJywnXFxcXHUyNTUxJzonYm94VicsJ1xcXFx1MjU1Mic6J2JveGRSJywnXFxcXHUyNTUzJzonYm94RHInLCdcXFxcdTI1NTQnOidib3hEUicsJ1xcXFx1MjU1NSc6J2JveGRMJywnXFxcXHUyNTU2JzonYm94RGwnLCdcXFxcdTI1NTcnOidib3hETCcsJ1xcXFx1MjU1OCc6J2JveHVSJywnXFxcXHUyNTU5JzonYm94VXInLCdcXFxcdTI1NUEnOidib3hVUicsJ1xcXFx1MjU1Qic6J2JveHVMJywnXFxcXHUyNTVDJzonYm94VWwnLCdcXFxcdTI1NUQnOidib3hVTCcsJ1xcXFx1MjU1RSc6J2JveHZSJywnXFxcXHUyNTVGJzonYm94VnInLCdcXFxcdTI1NjAnOidib3hWUicsJ1xcXFx1MjU2MSc6J2JveHZMJywnXFxcXHUyNTYyJzonYm94VmwnLCdcXFxcdTI1NjMnOidib3hWTCcsJ1xcXFx1MjU2NCc6J2JveEhkJywnXFxcXHUyNTY1JzonYm94aEQnLCdcXFxcdTI1NjYnOidib3hIRCcsJ1xcXFx1MjU2Nyc6J2JveEh1JywnXFxcXHUyNTY4JzonYm94aFUnLCdcXFxcdTI1NjknOidib3hIVScsJ1xcXFx1MjU2QSc6J2JveHZIJywnXFxcXHUyNTZCJzonYm94VmgnLCdcXFxcdTI1NkMnOidib3hWSCcsJ1xcXFx1MjU4MCc6J3VoYmxrJywnXFxcXHUyNTg0JzonbGhibGsnLCdcXFxcdTI1ODgnOidibG9jaycsJ1xcXFx1MjU5MSc6J2JsazE0JywnXFxcXHUyNTkyJzonYmxrMTInLCdcXFxcdTI1OTMnOidibGszNCcsJ1xcXFx1MjVBMSc6J3NxdScsJ1xcXFx1MjVBQSc6J3NxdWYnLCdcXFxcdTI1QUInOidFbXB0eVZlcnlTbWFsbFNxdWFyZScsJ1xcXFx1MjVBRCc6J3JlY3QnLCdcXFxcdTI1QUUnOidtYXJrZXInLCdcXFxcdTI1QjEnOidmbHRucycsJ1xcXFx1MjVCMyc6J3h1dHJpJywnXFxcXHUyNUI0JzondXRyaWYnLCdcXFxcdTI1QjUnOid1dHJpJywnXFxcXHUyNUI4JzoncnRyaWYnLCdcXFxcdTI1QjknOidydHJpJywnXFxcXHUyNUJEJzoneGR0cmknLCdcXFxcdTI1QkUnOidkdHJpZicsJ1xcXFx1MjVCRic6J2R0cmknLCdcXFxcdTI1QzInOidsdHJpZicsJ1xcXFx1MjVDMyc6J2x0cmknLCdcXFxcdTI1Q0EnOidsb3onLCdcXFxcdTI1Q0InOidjaXInLCdcXFxcdTI1RUMnOid0cmlkb3QnLCdcXFxcdTI1RUYnOid4Y2lyYycsJ1xcXFx1MjVGOCc6J3VsdHJpJywnXFxcXHUyNUY5JzondXJ0cmknLCdcXFxcdTI1RkEnOidsbHRyaScsJ1xcXFx1MjVGQic6J0VtcHR5U21hbGxTcXVhcmUnLCdcXFxcdTI1RkMnOidGaWxsZWRTbWFsbFNxdWFyZScsJ1xcXFx1MjYwNSc6J3N0YXJmJywnXFxcXHUyNjA2Jzonc3RhcicsJ1xcXFx1MjYwRSc6J3Bob25lJywnXFxcXHUyNjQwJzonZmVtYWxlJywnXFxcXHUyNjQyJzonbWFsZScsJ1xcXFx1MjY2MCc6J3NwYWRlcycsJ1xcXFx1MjY2Myc6J2NsdWJzJywnXFxcXHUyNjY1JzonaGVhcnRzJywnXFxcXHUyNjY2JzonZGlhbXMnLCdcXFxcdTI2NkEnOidzdW5nJywnXFxcXHUyNzEzJzonY2hlY2snLCdcXFxcdTI3MTcnOidjcm9zcycsJ1xcXFx1MjcyMCc6J21hbHQnLCdcXFxcdTI3MzYnOidzZXh0JywnXFxcXHUyNzU4JzonVmVydGljYWxTZXBhcmF0b3InLCdcXFxcdTI3QzgnOidic29saHN1YicsJ1xcXFx1MjdDOSc6J3N1cGhzb2wnLCdcXFxcdTI3RjUnOid4bGFycicsJ1xcXFx1MjdGNic6J3hyYXJyJywnXFxcXHUyN0Y3JzoneGhhcnInLCdcXFxcdTI3RjgnOid4bEFycicsJ1xcXFx1MjdGOSc6J3hyQXJyJywnXFxcXHUyN0ZBJzoneGhBcnInLCdcXFxcdTI3RkMnOid4bWFwJywnXFxcXHUyN0ZGJzonZHppZ3JhcnInLCdcXFxcdTI5MDInOidudmxBcnInLCdcXFxcdTI5MDMnOidudnJBcnInLCdcXFxcdTI5MDQnOidudkhhcnInLCdcXFxcdTI5MDUnOidNYXAnLCdcXFxcdTI5MEMnOidsYmFycicsJ1xcXFx1MjkwRCc6J3JiYXJyJywnXFxcXHUyOTBFJzonbEJhcnInLCdcXFxcdTI5MEYnOidyQmFycicsJ1xcXFx1MjkxMCc6J1JCYXJyJywnXFxcXHUyOTExJzonRERvdHJhaGQnLCdcXFxcdTI5MTInOidVcEFycm93QmFyJywnXFxcXHUyOTEzJzonRG93bkFycm93QmFyJywnXFxcXHUyOTE2JzonUmFycnRsJywnXFxcXHUyOTE5JzonbGF0YWlsJywnXFxcXHUyOTFBJzoncmF0YWlsJywnXFxcXHUyOTFCJzonbEF0YWlsJywnXFxcXHUyOTFDJzonckF0YWlsJywnXFxcXHUyOTFEJzonbGFycmZzJywnXFxcXHUyOTFFJzoncmFycmZzJywnXFxcXHUyOTFGJzonbGFycmJmcycsJ1xcXFx1MjkyMCc6J3JhcnJiZnMnLCdcXFxcdTI5MjMnOidud2FyaGsnLCdcXFxcdTI5MjQnOiduZWFyaGsnLCdcXFxcdTI5MjUnOidzZWFyaGsnLCdcXFxcdTI5MjYnOidzd2FyaGsnLCdcXFxcdTI5MjcnOidud25lYXInLCdcXFxcdTI5MjgnOid0b2VhJywnXFxcXHUyOTI5JzondG9zYScsJ1xcXFx1MjkyQSc6J3N3bndhcicsJ1xcXFx1MjkzMyc6J3JhcnJjJywnXFxcXHUyOTMzXFxcXHUwMzM4JzonbnJhcnJjJywnXFxcXHUyOTM1JzonY3VkYXJycicsJ1xcXFx1MjkzNic6J2xkY2EnLCdcXFxcdTI5MzcnOidyZGNhJywnXFxcXHUyOTM4JzonY3VkYXJybCcsJ1xcXFx1MjkzOSc6J2xhcnJwbCcsJ1xcXFx1MjkzQyc6J2N1cmFycm0nLCdcXFxcdTI5M0QnOidjdWxhcnJwJywnXFxcXHUyOTQ1JzoncmFycnBsJywnXFxcXHUyOTQ4JzonaGFycmNpcicsJ1xcXFx1Mjk0OSc6J1VhcnJvY2lyJywnXFxcXHUyOTRBJzonbHVyZHNoYXInLCdcXFxcdTI5NEInOidsZHJ1c2hhcicsJ1xcXFx1Mjk0RSc6J0xlZnRSaWdodFZlY3RvcicsJ1xcXFx1Mjk0Ric6J1JpZ2h0VXBEb3duVmVjdG9yJywnXFxcXHUyOTUwJzonRG93bkxlZnRSaWdodFZlY3RvcicsJ1xcXFx1Mjk1MSc6J0xlZnRVcERvd25WZWN0b3InLCdcXFxcdTI5NTInOidMZWZ0VmVjdG9yQmFyJywnXFxcXHUyOTUzJzonUmlnaHRWZWN0b3JCYXInLCdcXFxcdTI5NTQnOidSaWdodFVwVmVjdG9yQmFyJywnXFxcXHUyOTU1JzonUmlnaHREb3duVmVjdG9yQmFyJywnXFxcXHUyOTU2JzonRG93bkxlZnRWZWN0b3JCYXInLCdcXFxcdTI5NTcnOidEb3duUmlnaHRWZWN0b3JCYXInLCdcXFxcdTI5NTgnOidMZWZ0VXBWZWN0b3JCYXInLCdcXFxcdTI5NTknOidMZWZ0RG93blZlY3RvckJhcicsJ1xcXFx1Mjk1QSc6J0xlZnRUZWVWZWN0b3InLCdcXFxcdTI5NUInOidSaWdodFRlZVZlY3RvcicsJ1xcXFx1Mjk1Qyc6J1JpZ2h0VXBUZWVWZWN0b3InLCdcXFxcdTI5NUQnOidSaWdodERvd25UZWVWZWN0b3InLCdcXFxcdTI5NUUnOidEb3duTGVmdFRlZVZlY3RvcicsJ1xcXFx1Mjk1Ric6J0Rvd25SaWdodFRlZVZlY3RvcicsJ1xcXFx1Mjk2MCc6J0xlZnRVcFRlZVZlY3RvcicsJ1xcXFx1Mjk2MSc6J0xlZnREb3duVGVlVmVjdG9yJywnXFxcXHUyOTYyJzonbEhhcicsJ1xcXFx1Mjk2Myc6J3VIYXInLCdcXFxcdTI5NjQnOidySGFyJywnXFxcXHUyOTY1JzonZEhhcicsJ1xcXFx1Mjk2Nic6J2x1cnVoYXInLCdcXFxcdTI5NjcnOidsZHJkaGFyJywnXFxcXHUyOTY4JzoncnVsdWhhcicsJ1xcXFx1Mjk2OSc6J3JkbGRoYXInLCdcXFxcdTI5NkEnOidsaGFydWwnLCdcXFxcdTI5NkInOidsbGhhcmQnLCdcXFxcdTI5NkMnOidyaGFydWwnLCdcXFxcdTI5NkQnOidscmhhcmQnLCdcXFxcdTI5NkUnOid1ZGhhcicsJ1xcXFx1Mjk2Ric6J2R1aGFyJywnXFxcXHUyOTcwJzonUm91bmRJbXBsaWVzJywnXFxcXHUyOTcxJzonZXJhcnInLCdcXFxcdTI5NzInOidzaW1yYXJyJywnXFxcXHUyOTczJzonbGFycnNpbScsJ1xcXFx1Mjk3NCc6J3JhcnJzaW0nLCdcXFxcdTI5NzUnOidyYXJyYXAnLCdcXFxcdTI5NzYnOidsdGxhcnInLCdcXFxcdTI5NzgnOidndHJhcnInLCdcXFxcdTI5NzknOidzdWJyYXJyJywnXFxcXHUyOTdCJzonc3VwbGFycicsJ1xcXFx1Mjk3Qyc6J2xmaXNodCcsJ1xcXFx1Mjk3RCc6J3JmaXNodCcsJ1xcXFx1Mjk3RSc6J3VmaXNodCcsJ1xcXFx1Mjk3Ric6J2RmaXNodCcsJ1xcXFx1Mjk5QSc6J3Z6aWd6YWcnLCdcXFxcdTI5OUMnOid2YW5ncnQnLCdcXFxcdTI5OUQnOidhbmdydHZiZCcsJ1xcXFx1MjlBNCc6J2FuZ2UnLCdcXFxcdTI5QTUnOidyYW5nZScsJ1xcXFx1MjlBNic6J2R3YW5nbGUnLCdcXFxcdTI5QTcnOid1d2FuZ2xlJywnXFxcXHUyOUE4JzonYW5nbXNkYWEnLCdcXFxcdTI5QTknOidhbmdtc2RhYicsJ1xcXFx1MjlBQSc6J2FuZ21zZGFjJywnXFxcXHUyOUFCJzonYW5nbXNkYWQnLCdcXFxcdTI5QUMnOidhbmdtc2RhZScsJ1xcXFx1MjlBRCc6J2FuZ21zZGFmJywnXFxcXHUyOUFFJzonYW5nbXNkYWcnLCdcXFxcdTI5QUYnOidhbmdtc2RhaCcsJ1xcXFx1MjlCMCc6J2JlbXB0eXYnLCdcXFxcdTI5QjEnOidkZW1wdHl2JywnXFxcXHUyOUIyJzonY2VtcHR5dicsJ1xcXFx1MjlCMyc6J3JhZW1wdHl2JywnXFxcXHUyOUI0JzonbGFlbXB0eXYnLCdcXFxcdTI5QjUnOidvaGJhcicsJ1xcXFx1MjlCNic6J29taWQnLCdcXFxcdTI5QjcnOidvcGFyJywnXFxcXHUyOUI5Jzonb3BlcnAnLCdcXFxcdTI5QkInOidvbGNyb3NzJywnXFxcXHUyOUJDJzonb2Rzb2xkJywnXFxcXHUyOUJFJzonb2xjaXInLCdcXFxcdTI5QkYnOidvZmNpcicsJ1xcXFx1MjlDMCc6J29sdCcsJ1xcXFx1MjlDMSc6J29ndCcsJ1xcXFx1MjlDMic6J2NpcnNjaXInLCdcXFxcdTI5QzMnOidjaXJFJywnXFxcXHUyOUM0Jzonc29sYicsJ1xcXFx1MjlDNSc6J2Jzb2xiJywnXFxcXHUyOUM5JzonYm94Ym94JywnXFxcXHUyOUNEJzondHJpc2InLCdcXFxcdTI5Q0UnOidydHJpbHRyaScsJ1xcXFx1MjlDRic6J0xlZnRUcmlhbmdsZUJhcicsJ1xcXFx1MjlDRlxcXFx1MDMzOCc6J05vdExlZnRUcmlhbmdsZUJhcicsJ1xcXFx1MjlEMCc6J1JpZ2h0VHJpYW5nbGVCYXInLCdcXFxcdTI5RDBcXFxcdTAzMzgnOidOb3RSaWdodFRyaWFuZ2xlQmFyJywnXFxcXHUyOURDJzonaWluZmluJywnXFxcXHUyOUREJzonaW5maW50aWUnLCdcXFxcdTI5REUnOidudmluZmluJywnXFxcXHUyOUUzJzonZXBhcnNsJywnXFxcXHUyOUU0Jzonc21lcGFyc2wnLCdcXFxcdTI5RTUnOidlcXZwYXJzbCcsJ1xcXFx1MjlFQic6J2xvemYnLCdcXFxcdTI5RjQnOidSdWxlRGVsYXllZCcsJ1xcXFx1MjlGNic6J2Rzb2wnLCdcXFxcdTJBMDAnOid4b2RvdCcsJ1xcXFx1MkEwMSc6J3hvcGx1cycsJ1xcXFx1MkEwMic6J3hvdGltZScsJ1xcXFx1MkEwNCc6J3h1cGx1cycsJ1xcXFx1MkEwNic6J3hzcWN1cCcsJ1xcXFx1MkEwRCc6J2ZwYXJ0aW50JywnXFxcXHUyQTEwJzonY2lyZm5pbnQnLCdcXFxcdTJBMTEnOidhd2ludCcsJ1xcXFx1MkExMic6J3JwcG9saW50JywnXFxcXHUyQTEzJzonc2Nwb2xpbnQnLCdcXFxcdTJBMTQnOiducG9saW50JywnXFxcXHUyQTE1JzoncG9pbnRpbnQnLCdcXFxcdTJBMTYnOidxdWF0aW50JywnXFxcXHUyQTE3JzonaW50bGFyaGsnLCdcXFxcdTJBMjInOidwbHVzY2lyJywnXFxcXHUyQTIzJzoncGx1c2FjaXInLCdcXFxcdTJBMjQnOidzaW1wbHVzJywnXFxcXHUyQTI1JzoncGx1c2R1JywnXFxcXHUyQTI2JzoncGx1c3NpbScsJ1xcXFx1MkEyNyc6J3BsdXN0d28nLCdcXFxcdTJBMjknOidtY29tbWEnLCdcXFxcdTJBMkEnOidtaW51c2R1JywnXFxcXHUyQTJEJzonbG9wbHVzJywnXFxcXHUyQTJFJzoncm9wbHVzJywnXFxcXHUyQTJGJzonQ3Jvc3MnLCdcXFxcdTJBMzAnOid0aW1lc2QnLCdcXFxcdTJBMzEnOid0aW1lc2JhcicsJ1xcXFx1MkEzMyc6J3NtYXNocCcsJ1xcXFx1MkEzNCc6J2xvdGltZXMnLCdcXFxcdTJBMzUnOidyb3RpbWVzJywnXFxcXHUyQTM2Jzonb3RpbWVzYXMnLCdcXFxcdTJBMzcnOidPdGltZXMnLCdcXFxcdTJBMzgnOidvZGl2JywnXFxcXHUyQTM5JzondHJpcGx1cycsJ1xcXFx1MkEzQSc6J3RyaW1pbnVzJywnXFxcXHUyQTNCJzondHJpdGltZScsJ1xcXFx1MkEzQyc6J2lwcm9kJywnXFxcXHUyQTNGJzonYW1hbGcnLCdcXFxcdTJBNDAnOidjYXBkb3QnLCdcXFxcdTJBNDInOiduY3VwJywnXFxcXHUyQTQzJzonbmNhcCcsJ1xcXFx1MkE0NCc6J2NhcGFuZCcsJ1xcXFx1MkE0NSc6J2N1cG9yJywnXFxcXHUyQTQ2JzonY3VwY2FwJywnXFxcXHUyQTQ3JzonY2FwY3VwJywnXFxcXHUyQTQ4JzonY3VwYnJjYXAnLCdcXFxcdTJBNDknOidjYXBicmN1cCcsJ1xcXFx1MkE0QSc6J2N1cGN1cCcsJ1xcXFx1MkE0Qic6J2NhcGNhcCcsJ1xcXFx1MkE0Qyc6J2NjdXBzJywnXFxcXHUyQTREJzonY2NhcHMnLCdcXFxcdTJBNTAnOidjY3Vwc3NtJywnXFxcXHUyQTUzJzonQW5kJywnXFxcXHUyQTU0JzonT3InLCdcXFxcdTJBNTUnOidhbmRhbmQnLCdcXFxcdTJBNTYnOidvcm9yJywnXFxcXHUyQTU3Jzonb3JzbG9wZScsJ1xcXFx1MkE1OCc6J2FuZHNsb3BlJywnXFxcXHUyQTVBJzonYW5kdicsJ1xcXFx1MkE1Qic6J29ydicsJ1xcXFx1MkE1Qyc6J2FuZGQnLCdcXFxcdTJBNUQnOidvcmQnLCdcXFxcdTJBNUYnOid3ZWRiYXInLCdcXFxcdTJBNjYnOidzZG90ZScsJ1xcXFx1MkE2QSc6J3NpbWRvdCcsJ1xcXFx1MkE2RCc6J2Nvbmdkb3QnLCdcXFxcdTJBNkRcXFxcdTAzMzgnOiduY29uZ2RvdCcsJ1xcXFx1MkE2RSc6J2Vhc3RlcicsJ1xcXFx1MkE2Ric6J2FwYWNpcicsJ1xcXFx1MkE3MCc6J2FwRScsJ1xcXFx1MkE3MFxcXFx1MDMzOCc6J25hcEUnLCdcXFxcdTJBNzEnOidlcGx1cycsJ1xcXFx1MkE3Mic6J3BsdXNlJywnXFxcXHUyQTczJzonRXNpbScsJ1xcXFx1MkE3Nyc6J2VERG90JywnXFxcXHUyQTc4JzonZXF1aXZERCcsJ1xcXFx1MkE3OSc6J2x0Y2lyJywnXFxcXHUyQTdBJzonZ3RjaXInLCdcXFxcdTJBN0InOidsdHF1ZXN0JywnXFxcXHUyQTdDJzonZ3RxdWVzdCcsJ1xcXFx1MkE3RCc6J2xlcycsJ1xcXFx1MkE3RFxcXFx1MDMzOCc6J25sZXMnLCdcXFxcdTJBN0UnOidnZXMnLCdcXFxcdTJBN0VcXFxcdTAzMzgnOiduZ2VzJywnXFxcXHUyQTdGJzonbGVzZG90JywnXFxcXHUyQTgwJzonZ2VzZG90JywnXFxcXHUyQTgxJzonbGVzZG90bycsJ1xcXFx1MkE4Mic6J2dlc2RvdG8nLCdcXFxcdTJBODMnOidsZXNkb3RvcicsJ1xcXFx1MkE4NCc6J2dlc2RvdG9sJywnXFxcXHUyQTg1JzonbGFwJywnXFxcXHUyQTg2JzonZ2FwJywnXFxcXHUyQTg3JzonbG5lJywnXFxcXHUyQTg4JzonZ25lJywnXFxcXHUyQTg5JzonbG5hcCcsJ1xcXFx1MkE4QSc6J2duYXAnLCdcXFxcdTJBOEInOidsRWcnLCdcXFxcdTJBOEMnOidnRWwnLCdcXFxcdTJBOEQnOidsc2ltZScsJ1xcXFx1MkE4RSc6J2dzaW1lJywnXFxcXHUyQThGJzonbHNpbWcnLCdcXFxcdTJBOTAnOidnc2ltbCcsJ1xcXFx1MkE5MSc6J2xnRScsJ1xcXFx1MkE5Mic6J2dsRScsJ1xcXFx1MkE5Myc6J2xlc2dlcycsJ1xcXFx1MkE5NCc6J2dlc2xlcycsJ1xcXFx1MkE5NSc6J2VscycsJ1xcXFx1MkE5Nic6J2VncycsJ1xcXFx1MkE5Nyc6J2Vsc2RvdCcsJ1xcXFx1MkE5OCc6J2Vnc2RvdCcsJ1xcXFx1MkE5OSc6J2VsJywnXFxcXHUyQTlBJzonZWcnLCdcXFxcdTJBOUQnOidzaW1sJywnXFxcXHUyQTlFJzonc2ltZycsJ1xcXFx1MkE5Ric6J3NpbWxFJywnXFxcXHUyQUEwJzonc2ltZ0UnLCdcXFxcdTJBQTEnOidMZXNzTGVzcycsJ1xcXFx1MkFBMVxcXFx1MDMzOCc6J05vdE5lc3RlZExlc3NMZXNzJywnXFxcXHUyQUEyJzonR3JlYXRlckdyZWF0ZXInLCdcXFxcdTJBQTJcXFxcdTAzMzgnOidOb3ROZXN0ZWRHcmVhdGVyR3JlYXRlcicsJ1xcXFx1MkFBNCc6J2dsaicsJ1xcXFx1MkFBNSc6J2dsYScsJ1xcXFx1MkFBNic6J2x0Y2MnLCdcXFxcdTJBQTcnOidndGNjJywnXFxcXHUyQUE4JzonbGVzY2MnLCdcXFxcdTJBQTknOidnZXNjYycsJ1xcXFx1MkFBQSc6J3NtdCcsJ1xcXFx1MkFBQic6J2xhdCcsJ1xcXFx1MkFBQyc6J3NtdGUnLCdcXFxcdTJBQUNcXFxcdUZFMDAnOidzbXRlcycsJ1xcXFx1MkFBRCc6J2xhdGUnLCdcXFxcdTJBQURcXFxcdUZFMDAnOidsYXRlcycsJ1xcXFx1MkFBRSc6J2J1bXBFJywnXFxcXHUyQUFGJzoncHJlJywnXFxcXHUyQUFGXFxcXHUwMzM4JzonbnByZScsJ1xcXFx1MkFCMCc6J3NjZScsJ1xcXFx1MkFCMFxcXFx1MDMzOCc6J25zY2UnLCdcXFxcdTJBQjMnOidwckUnLCdcXFxcdTJBQjQnOidzY0UnLCdcXFxcdTJBQjUnOidwcm5FJywnXFxcXHUyQUI2Jzonc2NuRScsJ1xcXFx1MkFCNyc6J3ByYXAnLCdcXFxcdTJBQjgnOidzY2FwJywnXFxcXHUyQUI5JzoncHJuYXAnLCdcXFxcdTJBQkEnOidzY25hcCcsJ1xcXFx1MkFCQic6J1ByJywnXFxcXHUyQUJDJzonU2MnLCdcXFxcdTJBQkQnOidzdWJkb3QnLCdcXFxcdTJBQkUnOidzdXBkb3QnLCdcXFxcdTJBQkYnOidzdWJwbHVzJywnXFxcXHUyQUMwJzonc3VwcGx1cycsJ1xcXFx1MkFDMSc6J3N1Ym11bHQnLCdcXFxcdTJBQzInOidzdXBtdWx0JywnXFxcXHUyQUMzJzonc3ViZWRvdCcsJ1xcXFx1MkFDNCc6J3N1cGVkb3QnLCdcXFxcdTJBQzUnOidzdWJFJywnXFxcXHUyQUM1XFxcXHUwMzM4JzonbnN1YkUnLCdcXFxcdTJBQzYnOidzdXBFJywnXFxcXHUyQUM2XFxcXHUwMzM4JzonbnN1cEUnLCdcXFxcdTJBQzcnOidzdWJzaW0nLCdcXFxcdTJBQzgnOidzdXBzaW0nLCdcXFxcdTJBQ0JcXFxcdUZFMDAnOid2c3VibkUnLCdcXFxcdTJBQ0InOidzdWJuRScsJ1xcXFx1MkFDQ1xcXFx1RkUwMCc6J3ZzdXBuRScsJ1xcXFx1MkFDQyc6J3N1cG5FJywnXFxcXHUyQUNGJzonY3N1YicsJ1xcXFx1MkFEMCc6J2NzdXAnLCdcXFxcdTJBRDEnOidjc3ViZScsJ1xcXFx1MkFEMic6J2NzdXBlJywnXFxcXHUyQUQzJzonc3Vic3VwJywnXFxcXHUyQUQ0Jzonc3Vwc3ViJywnXFxcXHUyQUQ1Jzonc3Vic3ViJywnXFxcXHUyQUQ2Jzonc3Vwc3VwJywnXFxcXHUyQUQ3Jzonc3VwaHN1YicsJ1xcXFx1MkFEOCc6J3N1cGRzdWInLCdcXFxcdTJBRDknOidmb3JrdicsJ1xcXFx1MkFEQSc6J3RvcGZvcmsnLCdcXFxcdTJBREInOidtbGNwJywnXFxcXHUyQUU0JzonRGFzaHYnLCdcXFxcdTJBRTYnOidWZGFzaGwnLCdcXFxcdTJBRTcnOidCYXJ2JywnXFxcXHUyQUU4JzondkJhcicsJ1xcXFx1MkFFOSc6J3ZCYXJ2JywnXFxcXHUyQUVCJzonVmJhcicsJ1xcXFx1MkFFQyc6J05vdCcsJ1xcXFx1MkFFRCc6J2JOb3QnLCdcXFxcdTJBRUUnOidybm1pZCcsJ1xcXFx1MkFFRic6J2Npcm1pZCcsJ1xcXFx1MkFGMCc6J21pZGNpcicsJ1xcXFx1MkFGMSc6J3RvcGNpcicsJ1xcXFx1MkFGMic6J25ocGFyJywnXFxcXHUyQUYzJzoncGFyc2ltJywnXFxcXHUyQUZEJzoncGFyc2wnLCdcXFxcdTJBRkRcXFxcdTIwRTUnOiducGFyc2wnLCdcXFxcdTI2NkQnOidmbGF0JywnXFxcXHUyNjZFJzonbmF0dXInLCdcXFxcdTI2NkYnOidzaGFycCcsJ1xcXFx4QTQnOidjdXJyZW4nLCdcXFxceEEyJzonY2VudCcsJyQnOidkb2xsYXInLCdcXFxceEEzJzoncG91bmQnLCdcXFxceEE1JzoneWVuJywnXFxcXHUyMEFDJzonZXVybycsJ1xcXFx4QjknOidzdXAxJywnXFxcXHhCRCc6J2hhbGYnLCdcXFxcdTIxNTMnOidmcmFjMTMnLCdcXFxceEJDJzonZnJhYzE0JywnXFxcXHUyMTU1JzonZnJhYzE1JywnXFxcXHUyMTU5JzonZnJhYzE2JywnXFxcXHUyMTVCJzonZnJhYzE4JywnXFxcXHhCMic6J3N1cDInLCdcXFxcdTIxNTQnOidmcmFjMjMnLCdcXFxcdTIxNTYnOidmcmFjMjUnLCdcXFxceEIzJzonc3VwMycsJ1xcXFx4QkUnOidmcmFjMzQnLCdcXFxcdTIxNTcnOidmcmFjMzUnLCdcXFxcdTIxNUMnOidmcmFjMzgnLCdcXFxcdTIxNTgnOidmcmFjNDUnLCdcXFxcdTIxNUEnOidmcmFjNTYnLCdcXFxcdTIxNUQnOidmcmFjNTgnLCdcXFxcdTIxNUUnOidmcmFjNzgnLCdcXFxcdUQ4MzVcXFxcdURDQjYnOidhc2NyJywnXFxcXHVEODM1XFxcXHVERDUyJzonYW9wZicsJ1xcXFx1RDgzNVxcXFx1REQxRSc6J2FmcicsJ1xcXFx1RDgzNVxcXFx1REQzOCc6J0FvcGYnLCdcXFxcdUQ4MzVcXFxcdUREMDQnOidBZnInLCdcXFxcdUQ4MzVcXFxcdURDOUMnOidBc2NyJywnXFxcXHhBQSc6J29yZGYnLCdcXFxceEUxJzonYWFjdXRlJywnXFxcXHhDMSc6J0FhY3V0ZScsJ1xcXFx4RTAnOidhZ3JhdmUnLCdcXFxceEMwJzonQWdyYXZlJywnXFxcXHUwMTAzJzonYWJyZXZlJywnXFxcXHUwMTAyJzonQWJyZXZlJywnXFxcXHhFMic6J2FjaXJjJywnXFxcXHhDMic6J0FjaXJjJywnXFxcXHhFNSc6J2FyaW5nJywnXFxcXHhDNSc6J2FuZ3N0JywnXFxcXHhFNCc6J2F1bWwnLCdcXFxceEM0JzonQXVtbCcsJ1xcXFx4RTMnOidhdGlsZGUnLCdcXFxceEMzJzonQXRpbGRlJywnXFxcXHUwMTA1JzonYW9nb24nLCdcXFxcdTAxMDQnOidBb2dvbicsJ1xcXFx1MDEwMSc6J2FtYWNyJywnXFxcXHUwMTAwJzonQW1hY3InLCdcXFxceEU2JzonYWVsaWcnLCdcXFxceEM2JzonQUVsaWcnLCdcXFxcdUQ4MzVcXFxcdURDQjcnOidic2NyJywnXFxcXHVEODM1XFxcXHVERDUzJzonYm9wZicsJ1xcXFx1RDgzNVxcXFx1REQxRic6J2JmcicsJ1xcXFx1RDgzNVxcXFx1REQzOSc6J0JvcGYnLCdcXFxcdTIxMkMnOidCc2NyJywnXFxcXHVEODM1XFxcXHVERDA1JzonQmZyJywnXFxcXHVEODM1XFxcXHVERDIwJzonY2ZyJywnXFxcXHVEODM1XFxcXHVEQ0I4JzonY3NjcicsJ1xcXFx1RDgzNVxcXFx1REQ1NCc6J2NvcGYnLCdcXFxcdTIxMkQnOidDZnInLCdcXFxcdUQ4MzVcXFxcdURDOUUnOidDc2NyJywnXFxcXHUyMTAyJzonQ29wZicsJ1xcXFx1MDEwNyc6J2NhY3V0ZScsJ1xcXFx1MDEwNic6J0NhY3V0ZScsJ1xcXFx1MDEwOSc6J2NjaXJjJywnXFxcXHUwMTA4JzonQ2NpcmMnLCdcXFxcdTAxMEQnOidjY2Fyb24nLCdcXFxcdTAxMEMnOidDY2Fyb24nLCdcXFxcdTAxMEInOidjZG90JywnXFxcXHUwMTBBJzonQ2RvdCcsJ1xcXFx4RTcnOidjY2VkaWwnLCdcXFxceEM3JzonQ2NlZGlsJywnXFxcXHUyMTA1JzonaW5jYXJlJywnXFxcXHVEODM1XFxcXHVERDIxJzonZGZyJywnXFxcXHUyMTQ2JzonZGQnLCdcXFxcdUQ4MzVcXFxcdURENTUnOidkb3BmJywnXFxcXHVEODM1XFxcXHVEQ0I5JzonZHNjcicsJ1xcXFx1RDgzNVxcXFx1REM5Ric6J0RzY3InLCdcXFxcdUQ4MzVcXFxcdUREMDcnOidEZnInLCdcXFxcdTIxNDUnOidERCcsJ1xcXFx1RDgzNVxcXFx1REQzQic6J0RvcGYnLCdcXFxcdTAxMEYnOidkY2Fyb24nLCdcXFxcdTAxMEUnOidEY2Fyb24nLCdcXFxcdTAxMTEnOidkc3Ryb2snLCdcXFxcdTAxMTAnOidEc3Ryb2snLCdcXFxceEYwJzonZXRoJywnXFxcXHhEMCc6J0VUSCcsJ1xcXFx1MjE0Nyc6J2VlJywnXFxcXHUyMTJGJzonZXNjcicsJ1xcXFx1RDgzNVxcXFx1REQyMic6J2VmcicsJ1xcXFx1RDgzNVxcXFx1REQ1Nic6J2VvcGYnLCdcXFxcdTIxMzAnOidFc2NyJywnXFxcXHVEODM1XFxcXHVERDA4JzonRWZyJywnXFxcXHVEODM1XFxcXHVERDNDJzonRW9wZicsJ1xcXFx4RTknOidlYWN1dGUnLCdcXFxceEM5JzonRWFjdXRlJywnXFxcXHhFOCc6J2VncmF2ZScsJ1xcXFx4QzgnOidFZ3JhdmUnLCdcXFxceEVBJzonZWNpcmMnLCdcXFxceENBJzonRWNpcmMnLCdcXFxcdTAxMUInOidlY2Fyb24nLCdcXFxcdTAxMUEnOidFY2Fyb24nLCdcXFxceEVCJzonZXVtbCcsJ1xcXFx4Q0InOidFdW1sJywnXFxcXHUwMTE3JzonZWRvdCcsJ1xcXFx1MDExNic6J0Vkb3QnLCdcXFxcdTAxMTknOidlb2dvbicsJ1xcXFx1MDExOCc6J0VvZ29uJywnXFxcXHUwMTEzJzonZW1hY3InLCdcXFxcdTAxMTInOidFbWFjcicsJ1xcXFx1RDgzNVxcXFx1REQyMyc6J2ZmcicsJ1xcXFx1RDgzNVxcXFx1REQ1Nyc6J2ZvcGYnLCdcXFxcdUQ4MzVcXFxcdURDQkInOidmc2NyJywnXFxcXHVEODM1XFxcXHVERDA5JzonRmZyJywnXFxcXHVEODM1XFxcXHVERDNEJzonRm9wZicsJ1xcXFx1MjEzMSc6J0ZzY3InLCdcXFxcdUZCMDAnOidmZmxpZycsJ1xcXFx1RkIwMyc6J2ZmaWxpZycsJ1xcXFx1RkIwNCc6J2ZmbGxpZycsJ1xcXFx1RkIwMSc6J2ZpbGlnJywnZmonOidmamxpZycsJ1xcXFx1RkIwMic6J2ZsbGlnJywnXFxcXHUwMTkyJzonZm5vZicsJ1xcXFx1MjEwQSc6J2dzY3InLCdcXFxcdUQ4MzVcXFxcdURENTgnOidnb3BmJywnXFxcXHVEODM1XFxcXHVERDI0JzonZ2ZyJywnXFxcXHVEODM1XFxcXHVEQ0EyJzonR3NjcicsJ1xcXFx1RDgzNVxcXFx1REQzRSc6J0dvcGYnLCdcXFxcdUQ4MzVcXFxcdUREMEEnOidHZnInLCdcXFxcdTAxRjUnOidnYWN1dGUnLCdcXFxcdTAxMUYnOidnYnJldmUnLCdcXFxcdTAxMUUnOidHYnJldmUnLCdcXFxcdTAxMUQnOidnY2lyYycsJ1xcXFx1MDExQyc6J0djaXJjJywnXFxcXHUwMTIxJzonZ2RvdCcsJ1xcXFx1MDEyMCc6J0dkb3QnLCdcXFxcdTAxMjInOidHY2VkaWwnLCdcXFxcdUQ4MzVcXFxcdUREMjUnOidoZnInLCdcXFxcdTIxMEUnOidwbGFuY2toJywnXFxcXHVEODM1XFxcXHVEQ0JEJzonaHNjcicsJ1xcXFx1RDgzNVxcXFx1REQ1OSc6J2hvcGYnLCdcXFxcdTIxMEInOidIc2NyJywnXFxcXHUyMTBDJzonSGZyJywnXFxcXHUyMTBEJzonSG9wZicsJ1xcXFx1MDEyNSc6J2hjaXJjJywnXFxcXHUwMTI0JzonSGNpcmMnLCdcXFxcdTIxMEYnOidoYmFyJywnXFxcXHUwMTI3JzonaHN0cm9rJywnXFxcXHUwMTI2JzonSHN0cm9rJywnXFxcXHVEODM1XFxcXHVERDVBJzonaW9wZicsJ1xcXFx1RDgzNVxcXFx1REQyNic6J2lmcicsJ1xcXFx1RDgzNVxcXFx1RENCRSc6J2lzY3InLCdcXFxcdTIxNDgnOidpaScsJ1xcXFx1RDgzNVxcXFx1REQ0MCc6J0lvcGYnLCdcXFxcdTIxMTAnOidJc2NyJywnXFxcXHUyMTExJzonSW0nLCdcXFxceEVEJzonaWFjdXRlJywnXFxcXHhDRCc6J0lhY3V0ZScsJ1xcXFx4RUMnOidpZ3JhdmUnLCdcXFxceENDJzonSWdyYXZlJywnXFxcXHhFRSc6J2ljaXJjJywnXFxcXHhDRSc6J0ljaXJjJywnXFxcXHhFRic6J2l1bWwnLCdcXFxceENGJzonSXVtbCcsJ1xcXFx1MDEyOSc6J2l0aWxkZScsJ1xcXFx1MDEyOCc6J0l0aWxkZScsJ1xcXFx1MDEzMCc6J0lkb3QnLCdcXFxcdTAxMkYnOidpb2dvbicsJ1xcXFx1MDEyRSc6J0lvZ29uJywnXFxcXHUwMTJCJzonaW1hY3InLCdcXFxcdTAxMkEnOidJbWFjcicsJ1xcXFx1MDEzMyc6J2lqbGlnJywnXFxcXHUwMTMyJzonSUpsaWcnLCdcXFxcdTAxMzEnOidpbWF0aCcsJ1xcXFx1RDgzNVxcXFx1RENCRic6J2pzY3InLCdcXFxcdUQ4MzVcXFxcdURENUInOidqb3BmJywnXFxcXHVEODM1XFxcXHVERDI3JzonamZyJywnXFxcXHVEODM1XFxcXHVEQ0E1JzonSnNjcicsJ1xcXFx1RDgzNVxcXFx1REQwRCc6J0pmcicsJ1xcXFx1RDgzNVxcXFx1REQ0MSc6J0pvcGYnLCdcXFxcdTAxMzUnOidqY2lyYycsJ1xcXFx1MDEzNCc6J0pjaXJjJywnXFxcXHUwMjM3Jzonam1hdGgnLCdcXFxcdUQ4MzVcXFxcdURENUMnOidrb3BmJywnXFxcXHVEODM1XFxcXHVEQ0MwJzona3NjcicsJ1xcXFx1RDgzNVxcXFx1REQyOCc6J2tmcicsJ1xcXFx1RDgzNVxcXFx1RENBNic6J0tzY3InLCdcXFxcdUQ4MzVcXFxcdURENDInOidLb3BmJywnXFxcXHVEODM1XFxcXHVERDBFJzonS2ZyJywnXFxcXHUwMTM3Jzona2NlZGlsJywnXFxcXHUwMTM2JzonS2NlZGlsJywnXFxcXHVEODM1XFxcXHVERDI5JzonbGZyJywnXFxcXHVEODM1XFxcXHVEQ0MxJzonbHNjcicsJ1xcXFx1MjExMyc6J2VsbCcsJ1xcXFx1RDgzNVxcXFx1REQ1RCc6J2xvcGYnLCdcXFxcdTIxMTInOidMc2NyJywnXFxcXHVEODM1XFxcXHVERDBGJzonTGZyJywnXFxcXHVEODM1XFxcXHVERDQzJzonTG9wZicsJ1xcXFx1MDEzQSc6J2xhY3V0ZScsJ1xcXFx1MDEzOSc6J0xhY3V0ZScsJ1xcXFx1MDEzRSc6J2xjYXJvbicsJ1xcXFx1MDEzRCc6J0xjYXJvbicsJ1xcXFx1MDEzQyc6J2xjZWRpbCcsJ1xcXFx1MDEzQic6J0xjZWRpbCcsJ1xcXFx1MDE0Mic6J2xzdHJvaycsJ1xcXFx1MDE0MSc6J0xzdHJvaycsJ1xcXFx1MDE0MCc6J2xtaWRvdCcsJ1xcXFx1MDEzRic6J0xtaWRvdCcsJ1xcXFx1RDgzNVxcXFx1REQyQSc6J21mcicsJ1xcXFx1RDgzNVxcXFx1REQ1RSc6J21vcGYnLCdcXFxcdUQ4MzVcXFxcdURDQzInOidtc2NyJywnXFxcXHVEODM1XFxcXHVERDEwJzonTWZyJywnXFxcXHVEODM1XFxcXHVERDQ0JzonTW9wZicsJ1xcXFx1MjEzMyc6J01zY3InLCdcXFxcdUQ4MzVcXFxcdUREMkInOiduZnInLCdcXFxcdUQ4MzVcXFxcdURENUYnOidub3BmJywnXFxcXHVEODM1XFxcXHVEQ0MzJzonbnNjcicsJ1xcXFx1MjExNSc6J05vcGYnLCdcXFxcdUQ4MzVcXFxcdURDQTknOidOc2NyJywnXFxcXHVEODM1XFxcXHVERDExJzonTmZyJywnXFxcXHUwMTQ0JzonbmFjdXRlJywnXFxcXHUwMTQzJzonTmFjdXRlJywnXFxcXHUwMTQ4JzonbmNhcm9uJywnXFxcXHUwMTQ3JzonTmNhcm9uJywnXFxcXHhGMSc6J250aWxkZScsJ1xcXFx4RDEnOidOdGlsZGUnLCdcXFxcdTAxNDYnOiduY2VkaWwnLCdcXFxcdTAxNDUnOidOY2VkaWwnLCdcXFxcdTIxMTYnOidudW1lcm8nLCdcXFxcdTAxNEInOidlbmcnLCdcXFxcdTAxNEEnOidFTkcnLCdcXFxcdUQ4MzVcXFxcdURENjAnOidvb3BmJywnXFxcXHVEODM1XFxcXHVERDJDJzonb2ZyJywnXFxcXHUyMTM0Jzonb3NjcicsJ1xcXFx1RDgzNVxcXFx1RENBQSc6J09zY3InLCdcXFxcdUQ4MzVcXFxcdUREMTInOidPZnInLCdcXFxcdUQ4MzVcXFxcdURENDYnOidPb3BmJywnXFxcXHhCQSc6J29yZG0nLCdcXFxceEYzJzonb2FjdXRlJywnXFxcXHhEMyc6J09hY3V0ZScsJ1xcXFx4RjInOidvZ3JhdmUnLCdcXFxceEQyJzonT2dyYXZlJywnXFxcXHhGNCc6J29jaXJjJywnXFxcXHhENCc6J09jaXJjJywnXFxcXHhGNic6J291bWwnLCdcXFxceEQ2JzonT3VtbCcsJ1xcXFx1MDE1MSc6J29kYmxhYycsJ1xcXFx1MDE1MCc6J09kYmxhYycsJ1xcXFx4RjUnOidvdGlsZGUnLCdcXFxceEQ1JzonT3RpbGRlJywnXFxcXHhGOCc6J29zbGFzaCcsJ1xcXFx4RDgnOidPc2xhc2gnLCdcXFxcdTAxNEQnOidvbWFjcicsJ1xcXFx1MDE0Qyc6J09tYWNyJywnXFxcXHUwMTUzJzonb2VsaWcnLCdcXFxcdTAxNTInOidPRWxpZycsJ1xcXFx1RDgzNVxcXFx1REQyRCc6J3BmcicsJ1xcXFx1RDgzNVxcXFx1RENDNSc6J3BzY3InLCdcXFxcdUQ4MzVcXFxcdURENjEnOidwb3BmJywnXFxcXHUyMTE5JzonUG9wZicsJ1xcXFx1RDgzNVxcXFx1REQxMyc6J1BmcicsJ1xcXFx1RDgzNVxcXFx1RENBQic6J1BzY3InLCdcXFxcdUQ4MzVcXFxcdURENjInOidxb3BmJywnXFxcXHVEODM1XFxcXHVERDJFJzoncWZyJywnXFxcXHVEODM1XFxcXHVEQ0M2JzoncXNjcicsJ1xcXFx1RDgzNVxcXFx1RENBQyc6J1FzY3InLCdcXFxcdUQ4MzVcXFxcdUREMTQnOidRZnInLCdcXFxcdTIxMUEnOidRb3BmJywnXFxcXHUwMTM4Jzona2dyZWVuJywnXFxcXHVEODM1XFxcXHVERDJGJzoncmZyJywnXFxcXHVEODM1XFxcXHVERDYzJzoncm9wZicsJ1xcXFx1RDgzNVxcXFx1RENDNyc6J3JzY3InLCdcXFxcdTIxMUInOidSc2NyJywnXFxcXHUyMTFDJzonUmUnLCdcXFxcdTIxMUQnOidSb3BmJywnXFxcXHUwMTU1JzoncmFjdXRlJywnXFxcXHUwMTU0JzonUmFjdXRlJywnXFxcXHUwMTU5JzoncmNhcm9uJywnXFxcXHUwMTU4JzonUmNhcm9uJywnXFxcXHUwMTU3JzoncmNlZGlsJywnXFxcXHUwMTU2JzonUmNlZGlsJywnXFxcXHVEODM1XFxcXHVERDY0Jzonc29wZicsJ1xcXFx1RDgzNVxcXFx1RENDOCc6J3NzY3InLCdcXFxcdUQ4MzVcXFxcdUREMzAnOidzZnInLCdcXFxcdUQ4MzVcXFxcdURENEEnOidTb3BmJywnXFxcXHVEODM1XFxcXHVERDE2JzonU2ZyJywnXFxcXHVEODM1XFxcXHVEQ0FFJzonU3NjcicsJ1xcXFx1MjRDOCc6J29TJywnXFxcXHUwMTVCJzonc2FjdXRlJywnXFxcXHUwMTVBJzonU2FjdXRlJywnXFxcXHUwMTVEJzonc2NpcmMnLCdcXFxcdTAxNUMnOidTY2lyYycsJ1xcXFx1MDE2MSc6J3NjYXJvbicsJ1xcXFx1MDE2MCc6J1NjYXJvbicsJ1xcXFx1MDE1Ric6J3NjZWRpbCcsJ1xcXFx1MDE1RSc6J1NjZWRpbCcsJ1xcXFx4REYnOidzemxpZycsJ1xcXFx1RDgzNVxcXFx1REQzMSc6J3RmcicsJ1xcXFx1RDgzNVxcXFx1RENDOSc6J3RzY3InLCdcXFxcdUQ4MzVcXFxcdURENjUnOid0b3BmJywnXFxcXHVEODM1XFxcXHVEQ0FGJzonVHNjcicsJ1xcXFx1RDgzNVxcXFx1REQxNyc6J1RmcicsJ1xcXFx1RDgzNVxcXFx1REQ0Qic6J1RvcGYnLCdcXFxcdTAxNjUnOid0Y2Fyb24nLCdcXFxcdTAxNjQnOidUY2Fyb24nLCdcXFxcdTAxNjMnOid0Y2VkaWwnLCdcXFxcdTAxNjInOidUY2VkaWwnLCdcXFxcdTIxMjInOid0cmFkZScsJ1xcXFx1MDE2Nyc6J3RzdHJvaycsJ1xcXFx1MDE2Nic6J1RzdHJvaycsJ1xcXFx1RDgzNVxcXFx1RENDQSc6J3VzY3InLCdcXFxcdUQ4MzVcXFxcdURENjYnOid1b3BmJywnXFxcXHVEODM1XFxcXHVERDMyJzondWZyJywnXFxcXHVEODM1XFxcXHVERDRDJzonVW9wZicsJ1xcXFx1RDgzNVxcXFx1REQxOCc6J1VmcicsJ1xcXFx1RDgzNVxcXFx1RENCMCc6J1VzY3InLCdcXFxceEZBJzondWFjdXRlJywnXFxcXHhEQSc6J1VhY3V0ZScsJ1xcXFx4RjknOid1Z3JhdmUnLCdcXFxceEQ5JzonVWdyYXZlJywnXFxcXHUwMTZEJzondWJyZXZlJywnXFxcXHUwMTZDJzonVWJyZXZlJywnXFxcXHhGQic6J3VjaXJjJywnXFxcXHhEQic6J1VjaXJjJywnXFxcXHUwMTZGJzondXJpbmcnLCdcXFxcdTAxNkUnOidVcmluZycsJ1xcXFx4RkMnOid1dW1sJywnXFxcXHhEQyc6J1V1bWwnLCdcXFxcdTAxNzEnOid1ZGJsYWMnLCdcXFxcdTAxNzAnOidVZGJsYWMnLCdcXFxcdTAxNjknOid1dGlsZGUnLCdcXFxcdTAxNjgnOidVdGlsZGUnLCdcXFxcdTAxNzMnOid1b2dvbicsJ1xcXFx1MDE3Mic6J1VvZ29uJywnXFxcXHUwMTZCJzondW1hY3InLCdcXFxcdTAxNkEnOidVbWFjcicsJ1xcXFx1RDgzNVxcXFx1REQzMyc6J3ZmcicsJ1xcXFx1RDgzNVxcXFx1REQ2Nyc6J3ZvcGYnLCdcXFxcdUQ4MzVcXFxcdURDQ0InOid2c2NyJywnXFxcXHVEODM1XFxcXHVERDE5JzonVmZyJywnXFxcXHVEODM1XFxcXHVERDREJzonVm9wZicsJ1xcXFx1RDgzNVxcXFx1RENCMSc6J1ZzY3InLCdcXFxcdUQ4MzVcXFxcdURENjgnOid3b3BmJywnXFxcXHVEODM1XFxcXHVEQ0NDJzond3NjcicsJ1xcXFx1RDgzNVxcXFx1REQzNCc6J3dmcicsJ1xcXFx1RDgzNVxcXFx1RENCMic6J1dzY3InLCdcXFxcdUQ4MzVcXFxcdURENEUnOidXb3BmJywnXFxcXHVEODM1XFxcXHVERDFBJzonV2ZyJywnXFxcXHUwMTc1Jzond2NpcmMnLCdcXFxcdTAxNzQnOidXY2lyYycsJ1xcXFx1RDgzNVxcXFx1REQzNSc6J3hmcicsJ1xcXFx1RDgzNVxcXFx1RENDRCc6J3hzY3InLCdcXFxcdUQ4MzVcXFxcdURENjknOid4b3BmJywnXFxcXHVEODM1XFxcXHVERDRGJzonWG9wZicsJ1xcXFx1RDgzNVxcXFx1REQxQic6J1hmcicsJ1xcXFx1RDgzNVxcXFx1RENCMyc6J1hzY3InLCdcXFxcdUQ4MzVcXFxcdUREMzYnOid5ZnInLCdcXFxcdUQ4MzVcXFxcdURDQ0UnOid5c2NyJywnXFxcXHVEODM1XFxcXHVERDZBJzoneW9wZicsJ1xcXFx1RDgzNVxcXFx1RENCNCc6J1lzY3InLCdcXFxcdUQ4MzVcXFxcdUREMUMnOidZZnInLCdcXFxcdUQ4MzVcXFxcdURENTAnOidZb3BmJywnXFxcXHhGRCc6J3lhY3V0ZScsJ1xcXFx4REQnOidZYWN1dGUnLCdcXFxcdTAxNzcnOid5Y2lyYycsJ1xcXFx1MDE3Nic6J1ljaXJjJywnXFxcXHhGRic6J3l1bWwnLCdcXFxcdTAxNzgnOidZdW1sJywnXFxcXHVEODM1XFxcXHVEQ0NGJzonenNjcicsJ1xcXFx1RDgzNVxcXFx1REQzNyc6J3pmcicsJ1xcXFx1RDgzNVxcXFx1REQ2Qic6J3pvcGYnLCdcXFxcdTIxMjgnOidaZnInLCdcXFxcdTIxMjQnOidab3BmJywnXFxcXHVEODM1XFxcXHVEQ0I1JzonWnNjcicsJ1xcXFx1MDE3QSc6J3phY3V0ZScsJ1xcXFx1MDE3OSc6J1phY3V0ZScsJ1xcXFx1MDE3RSc6J3pjYXJvbicsJ1xcXFx1MDE3RCc6J1pjYXJvbicsJ1xcXFx1MDE3Qyc6J3pkb3QnLCdcXFxcdTAxN0InOidaZG90JywnXFxcXHUwMUI1JzonaW1wZWQnLCdcXFxceEZFJzondGhvcm4nLCdcXFxceERFJzonVEhPUk4nLCdcXFxcdTAxNDknOiduYXBvcycsJ1xcXFx1MDNCMSc6J2FscGhhJywnXFxcXHUwMzkxJzonQWxwaGEnLCdcXFxcdTAzQjInOidiZXRhJywnXFxcXHUwMzkyJzonQmV0YScsJ1xcXFx1MDNCMyc6J2dhbW1hJywnXFxcXHUwMzkzJzonR2FtbWEnLCdcXFxcdTAzQjQnOidkZWx0YScsJ1xcXFx1MDM5NCc6J0RlbHRhJywnXFxcXHUwM0I1JzonZXBzaScsJ1xcXFx1MDNGNSc6J2Vwc2l2JywnXFxcXHUwMzk1JzonRXBzaWxvbicsJ1xcXFx1MDNERCc6J2dhbW1hZCcsJ1xcXFx1MDNEQyc6J0dhbW1hZCcsJ1xcXFx1MDNCNic6J3pldGEnLCdcXFxcdTAzOTYnOidaZXRhJywnXFxcXHUwM0I3JzonZXRhJywnXFxcXHUwMzk3JzonRXRhJywnXFxcXHUwM0I4JzondGhldGEnLCdcXFxcdTAzRDEnOid0aGV0YXYnLCdcXFxcdTAzOTgnOidUaGV0YScsJ1xcXFx1MDNCOSc6J2lvdGEnLCdcXFxcdTAzOTknOidJb3RhJywnXFxcXHUwM0JBJzona2FwcGEnLCdcXFxcdTAzRjAnOidrYXBwYXYnLCdcXFxcdTAzOUEnOidLYXBwYScsJ1xcXFx1MDNCQic6J2xhbWJkYScsJ1xcXFx1MDM5Qic6J0xhbWJkYScsJ1xcXFx1MDNCQyc6J211JywnXFxcXHhCNSc6J21pY3JvJywnXFxcXHUwMzlDJzonTXUnLCdcXFxcdTAzQkQnOidudScsJ1xcXFx1MDM5RCc6J051JywnXFxcXHUwM0JFJzoneGknLCdcXFxcdTAzOUUnOidYaScsJ1xcXFx1MDNCRic6J29taWNyb24nLCdcXFxcdTAzOUYnOidPbWljcm9uJywnXFxcXHUwM0MwJzoncGknLCdcXFxcdTAzRDYnOidwaXYnLCdcXFxcdTAzQTAnOidQaScsJ1xcXFx1MDNDMSc6J3JobycsJ1xcXFx1MDNGMSc6J3Job3YnLCdcXFxcdTAzQTEnOidSaG8nLCdcXFxcdTAzQzMnOidzaWdtYScsJ1xcXFx1MDNBMyc6J1NpZ21hJywnXFxcXHUwM0MyJzonc2lnbWFmJywnXFxcXHUwM0M0JzondGF1JywnXFxcXHUwM0E0JzonVGF1JywnXFxcXHUwM0M1JzondXBzaScsJ1xcXFx1MDNBNSc6J1Vwc2lsb24nLCdcXFxcdTAzRDInOidVcHNpJywnXFxcXHUwM0M2JzoncGhpJywnXFxcXHUwM0Q1JzoncGhpdicsJ1xcXFx1MDNBNic6J1BoaScsJ1xcXFx1MDNDNyc6J2NoaScsJ1xcXFx1MDNBNyc6J0NoaScsJ1xcXFx1MDNDOCc6J3BzaScsJ1xcXFx1MDNBOCc6J1BzaScsJ1xcXFx1MDNDOSc6J29tZWdhJywnXFxcXHUwM0E5Jzonb2htJywnXFxcXHUwNDMwJzonYWN5JywnXFxcXHUwNDEwJzonQWN5JywnXFxcXHUwNDMxJzonYmN5JywnXFxcXHUwNDExJzonQmN5JywnXFxcXHUwNDMyJzondmN5JywnXFxcXHUwNDEyJzonVmN5JywnXFxcXHUwNDMzJzonZ2N5JywnXFxcXHUwNDEzJzonR2N5JywnXFxcXHUwNDUzJzonZ2pjeScsJ1xcXFx1MDQwMyc6J0dKY3knLCdcXFxcdTA0MzQnOidkY3knLCdcXFxcdTA0MTQnOidEY3knLCdcXFxcdTA0NTInOidkamN5JywnXFxcXHUwNDAyJzonREpjeScsJ1xcXFx1MDQzNSc6J2llY3knLCdcXFxcdTA0MTUnOidJRWN5JywnXFxcXHUwNDUxJzonaW9jeScsJ1xcXFx1MDQwMSc6J0lPY3knLCdcXFxcdTA0NTQnOidqdWtjeScsJ1xcXFx1MDQwNCc6J0p1a2N5JywnXFxcXHUwNDM2JzonemhjeScsJ1xcXFx1MDQxNic6J1pIY3knLCdcXFxcdTA0MzcnOid6Y3knLCdcXFxcdTA0MTcnOidaY3knLCdcXFxcdTA0NTUnOidkc2N5JywnXFxcXHUwNDA1JzonRFNjeScsJ1xcXFx1MDQzOCc6J2ljeScsJ1xcXFx1MDQxOCc6J0ljeScsJ1xcXFx1MDQ1Nic6J2l1a2N5JywnXFxcXHUwNDA2JzonSXVrY3knLCdcXFxcdTA0NTcnOid5aWN5JywnXFxcXHUwNDA3JzonWUljeScsJ1xcXFx1MDQzOSc6J2pjeScsJ1xcXFx1MDQxOSc6J0pjeScsJ1xcXFx1MDQ1OCc6J2pzZXJjeScsJ1xcXFx1MDQwOCc6J0pzZXJjeScsJ1xcXFx1MDQzQSc6J2tjeScsJ1xcXFx1MDQxQSc6J0tjeScsJ1xcXFx1MDQ1Qyc6J2tqY3knLCdcXFxcdTA0MEMnOidLSmN5JywnXFxcXHUwNDNCJzonbGN5JywnXFxcXHUwNDFCJzonTGN5JywnXFxcXHUwNDU5JzonbGpjeScsJ1xcXFx1MDQwOSc6J0xKY3knLCdcXFxcdTA0M0MnOidtY3knLCdcXFxcdTA0MUMnOidNY3knLCdcXFxcdTA0M0QnOiduY3knLCdcXFxcdTA0MUQnOidOY3knLCdcXFxcdTA0NUEnOiduamN5JywnXFxcXHUwNDBBJzonTkpjeScsJ1xcXFx1MDQzRSc6J29jeScsJ1xcXFx1MDQxRSc6J09jeScsJ1xcXFx1MDQzRic6J3BjeScsJ1xcXFx1MDQxRic6J1BjeScsJ1xcXFx1MDQ0MCc6J3JjeScsJ1xcXFx1MDQyMCc6J1JjeScsJ1xcXFx1MDQ0MSc6J3NjeScsJ1xcXFx1MDQyMSc6J1NjeScsJ1xcXFx1MDQ0Mic6J3RjeScsJ1xcXFx1MDQyMic6J1RjeScsJ1xcXFx1MDQ1Qic6J3RzaGN5JywnXFxcXHUwNDBCJzonVFNIY3knLCdcXFxcdTA0NDMnOid1Y3knLCdcXFxcdTA0MjMnOidVY3knLCdcXFxcdTA0NUUnOid1YnJjeScsJ1xcXFx1MDQwRSc6J1VicmN5JywnXFxcXHUwNDQ0JzonZmN5JywnXFxcXHUwNDI0JzonRmN5JywnXFxcXHUwNDQ1Jzona2hjeScsJ1xcXFx1MDQyNSc6J0tIY3knLCdcXFxcdTA0NDYnOid0c2N5JywnXFxcXHUwNDI2JzonVFNjeScsJ1xcXFx1MDQ0Nyc6J2NoY3knLCdcXFxcdTA0MjcnOidDSGN5JywnXFxcXHUwNDVGJzonZHpjeScsJ1xcXFx1MDQwRic6J0RaY3knLCdcXFxcdTA0NDgnOidzaGN5JywnXFxcXHUwNDI4JzonU0hjeScsJ1xcXFx1MDQ0OSc6J3NoY2hjeScsJ1xcXFx1MDQyOSc6J1NIQ0hjeScsJ1xcXFx1MDQ0QSc6J2hhcmRjeScsJ1xcXFx1MDQyQSc6J0hBUkRjeScsJ1xcXFx1MDQ0Qic6J3ljeScsJ1xcXFx1MDQyQic6J1ljeScsJ1xcXFx1MDQ0Qyc6J3NvZnRjeScsJ1xcXFx1MDQyQyc6J1NPRlRjeScsJ1xcXFx1MDQ0RCc6J2VjeScsJ1xcXFx1MDQyRCc6J0VjeScsJ1xcXFx1MDQ0RSc6J3l1Y3knLCdcXFxcdTA0MkUnOidZVWN5JywnXFxcXHUwNDRGJzoneWFjeScsJ1xcXFx1MDQyRic6J1lBY3knLCdcXFxcdTIxMzUnOidhbGVwaCcsJ1xcXFx1MjEzNic6J2JldGgnLCdcXFxcdTIxMzcnOidnaW1lbCcsJ1xcXFx1MjEzOCc6J2RhbGV0aCd9O1xcblxcblxcdHZhciByZWdleEVzY2FwZSA9IC9bXFxcIiYnPD5gXS9nO1xcblxcdHZhciBlc2NhcGVNYXAgPSB7XFxuXFx0XFx0J1xcXCInOiAnJnF1b3Q7JyxcXG5cXHRcXHQnJic6ICcmYW1wOycsXFxuXFx0XFx0J1xcXFwnJzogJyYjeDI3OycsXFxuXFx0XFx0JzwnOiAnJmx0OycsXFxuXFx0XFx0Ly8gU2VlIGh0dHBzOi8vbWF0aGlhc2J5bmVucy5iZS9ub3Rlcy9hbWJpZ3VvdXMtYW1wZXJzYW5kczogaW4gSFRNTCwgdGhlXFxuXFx0XFx0Ly8gZm9sbG93aW5nIGlzIG5vdCBzdHJpY3RseSBuZWNlc3NhcnkgdW5sZXNzIGl04oCZcyBwYXJ0IG9mIGEgdGFnIG9yIGFuXFxuXFx0XFx0Ly8gdW5xdW90ZWQgYXR0cmlidXRlIHZhbHVlLiBXZeKAmXJlIG9ubHkgZXNjYXBpbmcgaXQgdG8gc3VwcG9ydCB0aG9zZVxcblxcdFxcdC8vIHNpdHVhdGlvbnMsIGFuZCBmb3IgWE1MIHN1cHBvcnQuXFxuXFx0XFx0Jz4nOiAnJmd0OycsXFxuXFx0XFx0Ly8gSW4gSW50ZXJuZXQgRXhwbG9yZXIg4omkIDgsIHRoZSBiYWNrdGljayBjaGFyYWN0ZXIgY2FuIGJlIHVzZWRcXG5cXHRcXHQvLyB0byBicmVhayBvdXQgb2YgKHVuKXF1b3RlZCBhdHRyaWJ1dGUgdmFsdWVzIG9yIEhUTUwgY29tbWVudHMuXFxuXFx0XFx0Ly8gU2VlIGh0dHA6Ly9odG1sNXNlYy5vcmcvIzEwMiwgaHR0cDovL2h0bWw1c2VjLm9yZy8jMTA4LCBhbmRcXG5cXHRcXHQvLyBodHRwOi8vaHRtbDVzZWMub3JnLyMxMzMuXFxuXFx0XFx0J2AnOiAnJiN4NjA7J1xcblxcdH07XFxuXFxuXFx0dmFyIHJlZ2V4SW52YWxpZEVudGl0eSA9IC8mIyg/Olt4WF1bXmEtZkEtRjAtOV18W14wLTl4WF0pLztcXG5cXHR2YXIgcmVnZXhJbnZhbGlkUmF3Q29kZVBvaW50ID0gL1tcXFxcMC1cXFxceDA4XFxcXHgwQlxcXFx4MEUtXFxcXHgxRlxcXFx4N0YtXFxcXHg5RlxcXFx1RkREMC1cXFxcdUZERUZcXFxcdUZGRkVcXFxcdUZGRkZdfFtcXFxcdUQ4M0ZcXFxcdUQ4N0ZcXFxcdUQ4QkZcXFxcdUQ4RkZcXFxcdUQ5M0ZcXFxcdUQ5N0ZcXFxcdUQ5QkZcXFxcdUQ5RkZcXFxcdURBM0ZcXFxcdURBN0ZcXFxcdURBQkZcXFxcdURBRkZcXFxcdURCM0ZcXFxcdURCN0ZcXFxcdURCQkZcXFxcdURCRkZdW1xcXFx1REZGRVxcXFx1REZGRl18W1xcXFx1RDgwMC1cXFxcdURCRkZdKD8hW1xcXFx1REMwMC1cXFxcdURGRkZdKXwoPzpbXlxcXFx1RDgwMC1cXFxcdURCRkZdfF4pW1xcXFx1REMwMC1cXFxcdURGRkZdLztcXG5cXHR2YXIgcmVnZXhEZWNvZGUgPSAvJiMoWzAtOV0rKSg7Pyl8JiNbeFhdKFthLWZBLUYwLTldKykoOz8pfCYoWzAtOWEtekEtWl0rKTt8JihBYWN1dGV8QWdyYXZlfEF0aWxkZXxDY2VkaWx8RWFjdXRlfEVncmF2ZXxJYWN1dGV8SWdyYXZlfE50aWxkZXxPYWN1dGV8T2dyYXZlfE9zbGFzaHxPdGlsZGV8VWFjdXRlfFVncmF2ZXxZYWN1dGV8YWFjdXRlfGFncmF2ZXxhdGlsZGV8YnJ2YmFyfGNjZWRpbHxjdXJyZW58ZGl2aWRlfGVhY3V0ZXxlZ3JhdmV8ZnJhYzEyfGZyYWMxNHxmcmFjMzR8aWFjdXRlfGlncmF2ZXxpcXVlc3R8bWlkZG90fG50aWxkZXxvYWN1dGV8b2dyYXZlfG9zbGFzaHxvdGlsZGV8cGx1c21ufHVhY3V0ZXx1Z3JhdmV8eWFjdXRlfEFFbGlnfEFjaXJjfEFyaW5nfEVjaXJjfEljaXJjfE9jaXJjfFRIT1JOfFVjaXJjfGFjaXJjfGFjdXRlfGFlbGlnfGFyaW5nfGNlZGlsfGVjaXJjfGljaXJjfGlleGNsfGxhcXVvfG1pY3JvfG9jaXJjfHBvdW5kfHJhcXVvfHN6bGlnfHRob3JufHRpbWVzfHVjaXJjfEF1bWx8Q09QWXxFdW1sfEl1bWx8T3VtbHxRVU9UfFV1bWx8YXVtbHxjZW50fGNvcHl8ZXVtbHxpdW1sfG1hY3J8bmJzcHxvcmRmfG9yZG18b3VtbHxwYXJhfHF1b3R8c2VjdHxzdXAxfHN1cDJ8c3VwM3x1dW1sfHl1bWx8QU1QfEVUSHxSRUd8YW1wfGRlZ3xldGh8bm90fHJlZ3xzaHl8dW1sfHllbnxHVHxMVHxndHxsdCkoWz1hLXpBLVowLTldKT8vZztcXG5cXHR2YXIgZGVjb2RlTWFwID0geydhYWN1dGUnOidcXFxceEUxJywnQWFjdXRlJzonXFxcXHhDMScsJ2FicmV2ZSc6J1xcXFx1MDEwMycsJ0FicmV2ZSc6J1xcXFx1MDEwMicsJ2FjJzonXFxcXHUyMjNFJywnYWNkJzonXFxcXHUyMjNGJywnYWNFJzonXFxcXHUyMjNFXFxcXHUwMzMzJywnYWNpcmMnOidcXFxceEUyJywnQWNpcmMnOidcXFxceEMyJywnYWN1dGUnOidcXFxceEI0JywnYWN5JzonXFxcXHUwNDMwJywnQWN5JzonXFxcXHUwNDEwJywnYWVsaWcnOidcXFxceEU2JywnQUVsaWcnOidcXFxceEM2JywnYWYnOidcXFxcdTIwNjEnLCdhZnInOidcXFxcdUQ4MzVcXFxcdUREMUUnLCdBZnInOidcXFxcdUQ4MzVcXFxcdUREMDQnLCdhZ3JhdmUnOidcXFxceEUwJywnQWdyYXZlJzonXFxcXHhDMCcsJ2FsZWZzeW0nOidcXFxcdTIxMzUnLCdhbGVwaCc6J1xcXFx1MjEzNScsJ2FscGhhJzonXFxcXHUwM0IxJywnQWxwaGEnOidcXFxcdTAzOTEnLCdhbWFjcic6J1xcXFx1MDEwMScsJ0FtYWNyJzonXFxcXHUwMTAwJywnYW1hbGcnOidcXFxcdTJBM0YnLCdhbXAnOicmJywnQU1QJzonJicsJ2FuZCc6J1xcXFx1MjIyNycsJ0FuZCc6J1xcXFx1MkE1MycsJ2FuZGFuZCc6J1xcXFx1MkE1NScsJ2FuZGQnOidcXFxcdTJBNUMnLCdhbmRzbG9wZSc6J1xcXFx1MkE1OCcsJ2FuZHYnOidcXFxcdTJBNUEnLCdhbmcnOidcXFxcdTIyMjAnLCdhbmdlJzonXFxcXHUyOUE0JywnYW5nbGUnOidcXFxcdTIyMjAnLCdhbmdtc2QnOidcXFxcdTIyMjEnLCdhbmdtc2RhYSc6J1xcXFx1MjlBOCcsJ2FuZ21zZGFiJzonXFxcXHUyOUE5JywnYW5nbXNkYWMnOidcXFxcdTI5QUEnLCdhbmdtc2RhZCc6J1xcXFx1MjlBQicsJ2FuZ21zZGFlJzonXFxcXHUyOUFDJywnYW5nbXNkYWYnOidcXFxcdTI5QUQnLCdhbmdtc2RhZyc6J1xcXFx1MjlBRScsJ2FuZ21zZGFoJzonXFxcXHUyOUFGJywnYW5ncnQnOidcXFxcdTIyMUYnLCdhbmdydHZiJzonXFxcXHUyMkJFJywnYW5ncnR2YmQnOidcXFxcdTI5OUQnLCdhbmdzcGgnOidcXFxcdTIyMjInLCdhbmdzdCc6J1xcXFx4QzUnLCdhbmd6YXJyJzonXFxcXHUyMzdDJywnYW9nb24nOidcXFxcdTAxMDUnLCdBb2dvbic6J1xcXFx1MDEwNCcsJ2FvcGYnOidcXFxcdUQ4MzVcXFxcdURENTInLCdBb3BmJzonXFxcXHVEODM1XFxcXHVERDM4JywnYXAnOidcXFxcdTIyNDgnLCdhcGFjaXInOidcXFxcdTJBNkYnLCdhcGUnOidcXFxcdTIyNEEnLCdhcEUnOidcXFxcdTJBNzAnLCdhcGlkJzonXFxcXHUyMjRCJywnYXBvcyc6J1xcXFwnJywnQXBwbHlGdW5jdGlvbic6J1xcXFx1MjA2MScsJ2FwcHJveCc6J1xcXFx1MjI0OCcsJ2FwcHJveGVxJzonXFxcXHUyMjRBJywnYXJpbmcnOidcXFxceEU1JywnQXJpbmcnOidcXFxceEM1JywnYXNjcic6J1xcXFx1RDgzNVxcXFx1RENCNicsJ0FzY3InOidcXFxcdUQ4MzVcXFxcdURDOUMnLCdBc3NpZ24nOidcXFxcdTIyNTQnLCdhc3QnOicqJywnYXN5bXAnOidcXFxcdTIyNDgnLCdhc3ltcGVxJzonXFxcXHUyMjREJywnYXRpbGRlJzonXFxcXHhFMycsJ0F0aWxkZSc6J1xcXFx4QzMnLCdhdW1sJzonXFxcXHhFNCcsJ0F1bWwnOidcXFxceEM0JywnYXdjb25pbnQnOidcXFxcdTIyMzMnLCdhd2ludCc6J1xcXFx1MkExMScsJ2JhY2tjb25nJzonXFxcXHUyMjRDJywnYmFja2Vwc2lsb24nOidcXFxcdTAzRjYnLCdiYWNrcHJpbWUnOidcXFxcdTIwMzUnLCdiYWNrc2ltJzonXFxcXHUyMjNEJywnYmFja3NpbWVxJzonXFxcXHUyMkNEJywnQmFja3NsYXNoJzonXFxcXHUyMjE2JywnQmFydic6J1xcXFx1MkFFNycsJ2JhcnZlZSc6J1xcXFx1MjJCRCcsJ2JhcndlZCc6J1xcXFx1MjMwNScsJ0JhcndlZCc6J1xcXFx1MjMwNicsJ2JhcndlZGdlJzonXFxcXHUyMzA1JywnYmJyayc6J1xcXFx1MjNCNScsJ2Jicmt0YnJrJzonXFxcXHUyM0I2JywnYmNvbmcnOidcXFxcdTIyNEMnLCdiY3knOidcXFxcdTA0MzEnLCdCY3knOidcXFxcdTA0MTEnLCdiZHF1byc6J1xcXFx1MjAxRScsJ2JlY2F1cyc6J1xcXFx1MjIzNScsJ2JlY2F1c2UnOidcXFxcdTIyMzUnLCdCZWNhdXNlJzonXFxcXHUyMjM1JywnYmVtcHR5dic6J1xcXFx1MjlCMCcsJ2JlcHNpJzonXFxcXHUwM0Y2JywnYmVybm91JzonXFxcXHUyMTJDJywnQmVybm91bGxpcyc6J1xcXFx1MjEyQycsJ2JldGEnOidcXFxcdTAzQjInLCdCZXRhJzonXFxcXHUwMzkyJywnYmV0aCc6J1xcXFx1MjEzNicsJ2JldHdlZW4nOidcXFxcdTIyNkMnLCdiZnInOidcXFxcdUQ4MzVcXFxcdUREMUYnLCdCZnInOidcXFxcdUQ4MzVcXFxcdUREMDUnLCdiaWdjYXAnOidcXFxcdTIyQzInLCdiaWdjaXJjJzonXFxcXHUyNUVGJywnYmlnY3VwJzonXFxcXHUyMkMzJywnYmlnb2RvdCc6J1xcXFx1MkEwMCcsJ2JpZ29wbHVzJzonXFxcXHUyQTAxJywnYmlnb3RpbWVzJzonXFxcXHUyQTAyJywnYmlnc3FjdXAnOidcXFxcdTJBMDYnLCdiaWdzdGFyJzonXFxcXHUyNjA1JywnYmlndHJpYW5nbGVkb3duJzonXFxcXHUyNUJEJywnYmlndHJpYW5nbGV1cCc6J1xcXFx1MjVCMycsJ2JpZ3VwbHVzJzonXFxcXHUyQTA0JywnYmlndmVlJzonXFxcXHUyMkMxJywnYmlnd2VkZ2UnOidcXFxcdTIyQzAnLCdia2Fyb3cnOidcXFxcdTI5MEQnLCdibGFja2xvemVuZ2UnOidcXFxcdTI5RUInLCdibGFja3NxdWFyZSc6J1xcXFx1MjVBQScsJ2JsYWNrdHJpYW5nbGUnOidcXFxcdTI1QjQnLCdibGFja3RyaWFuZ2xlZG93bic6J1xcXFx1MjVCRScsJ2JsYWNrdHJpYW5nbGVsZWZ0JzonXFxcXHUyNUMyJywnYmxhY2t0cmlhbmdsZXJpZ2h0JzonXFxcXHUyNUI4JywnYmxhbmsnOidcXFxcdTI0MjMnLCdibGsxMic6J1xcXFx1MjU5MicsJ2JsazE0JzonXFxcXHUyNTkxJywnYmxrMzQnOidcXFxcdTI1OTMnLCdibG9jayc6J1xcXFx1MjU4OCcsJ2JuZSc6Jz1cXFxcdTIwRTUnLCdibmVxdWl2JzonXFxcXHUyMjYxXFxcXHUyMEU1JywnYm5vdCc6J1xcXFx1MjMxMCcsJ2JOb3QnOidcXFxcdTJBRUQnLCdib3BmJzonXFxcXHVEODM1XFxcXHVERDUzJywnQm9wZic6J1xcXFx1RDgzNVxcXFx1REQzOScsJ2JvdCc6J1xcXFx1MjJBNScsJ2JvdHRvbSc6J1xcXFx1MjJBNScsJ2Jvd3RpZSc6J1xcXFx1MjJDOCcsJ2JveGJveCc6J1xcXFx1MjlDOScsJ2JveGRsJzonXFxcXHUyNTEwJywnYm94ZEwnOidcXFxcdTI1NTUnLCdib3hEbCc6J1xcXFx1MjU1NicsJ2JveERMJzonXFxcXHUyNTU3JywnYm94ZHInOidcXFxcdTI1MEMnLCdib3hkUic6J1xcXFx1MjU1MicsJ2JveERyJzonXFxcXHUyNTUzJywnYm94RFInOidcXFxcdTI1NTQnLCdib3hoJzonXFxcXHUyNTAwJywnYm94SCc6J1xcXFx1MjU1MCcsJ2JveGhkJzonXFxcXHUyNTJDJywnYm94aEQnOidcXFxcdTI1NjUnLCdib3hIZCc6J1xcXFx1MjU2NCcsJ2JveEhEJzonXFxcXHUyNTY2JywnYm94aHUnOidcXFxcdTI1MzQnLCdib3hoVSc6J1xcXFx1MjU2OCcsJ2JveEh1JzonXFxcXHUyNTY3JywnYm94SFUnOidcXFxcdTI1NjknLCdib3htaW51cyc6J1xcXFx1MjI5RicsJ2JveHBsdXMnOidcXFxcdTIyOUUnLCdib3h0aW1lcyc6J1xcXFx1MjJBMCcsJ2JveHVsJzonXFxcXHUyNTE4JywnYm94dUwnOidcXFxcdTI1NUInLCdib3hVbCc6J1xcXFx1MjU1QycsJ2JveFVMJzonXFxcXHUyNTVEJywnYm94dXInOidcXFxcdTI1MTQnLCdib3h1Uic6J1xcXFx1MjU1OCcsJ2JveFVyJzonXFxcXHUyNTU5JywnYm94VVInOidcXFxcdTI1NUEnLCdib3h2JzonXFxcXHUyNTAyJywnYm94Vic6J1xcXFx1MjU1MScsJ2JveHZoJzonXFxcXHUyNTNDJywnYm94dkgnOidcXFxcdTI1NkEnLCdib3hWaCc6J1xcXFx1MjU2QicsJ2JveFZIJzonXFxcXHUyNTZDJywnYm94dmwnOidcXFxcdTI1MjQnLCdib3h2TCc6J1xcXFx1MjU2MScsJ2JveFZsJzonXFxcXHUyNTYyJywnYm94VkwnOidcXFxcdTI1NjMnLCdib3h2cic6J1xcXFx1MjUxQycsJ2JveHZSJzonXFxcXHUyNTVFJywnYm94VnInOidcXFxcdTI1NUYnLCdib3hWUic6J1xcXFx1MjU2MCcsJ2JwcmltZSc6J1xcXFx1MjAzNScsJ2JyZXZlJzonXFxcXHUwMkQ4JywnQnJldmUnOidcXFxcdTAyRDgnLCdicnZiYXInOidcXFxceEE2JywnYnNjcic6J1xcXFx1RDgzNVxcXFx1RENCNycsJ0JzY3InOidcXFxcdTIxMkMnLCdic2VtaSc6J1xcXFx1MjA0RicsJ2JzaW0nOidcXFxcdTIyM0QnLCdic2ltZSc6J1xcXFx1MjJDRCcsJ2Jzb2wnOidcXFxcXFxcXCcsJ2Jzb2xiJzonXFxcXHUyOUM1JywnYnNvbGhzdWInOidcXFxcdTI3QzgnLCdidWxsJzonXFxcXHUyMDIyJywnYnVsbGV0JzonXFxcXHUyMDIyJywnYnVtcCc6J1xcXFx1MjI0RScsJ2J1bXBlJzonXFxcXHUyMjRGJywnYnVtcEUnOidcXFxcdTJBQUUnLCdidW1wZXEnOidcXFxcdTIyNEYnLCdCdW1wZXEnOidcXFxcdTIyNEUnLCdjYWN1dGUnOidcXFxcdTAxMDcnLCdDYWN1dGUnOidcXFxcdTAxMDYnLCdjYXAnOidcXFxcdTIyMjknLCdDYXAnOidcXFxcdTIyRDInLCdjYXBhbmQnOidcXFxcdTJBNDQnLCdjYXBicmN1cCc6J1xcXFx1MkE0OScsJ2NhcGNhcCc6J1xcXFx1MkE0QicsJ2NhcGN1cCc6J1xcXFx1MkE0NycsJ2NhcGRvdCc6J1xcXFx1MkE0MCcsJ0NhcGl0YWxEaWZmZXJlbnRpYWxEJzonXFxcXHUyMTQ1JywnY2Fwcyc6J1xcXFx1MjIyOVxcXFx1RkUwMCcsJ2NhcmV0JzonXFxcXHUyMDQxJywnY2Fyb24nOidcXFxcdTAyQzcnLCdDYXlsZXlzJzonXFxcXHUyMTJEJywnY2NhcHMnOidcXFxcdTJBNEQnLCdjY2Fyb24nOidcXFxcdTAxMEQnLCdDY2Fyb24nOidcXFxcdTAxMEMnLCdjY2VkaWwnOidcXFxceEU3JywnQ2NlZGlsJzonXFxcXHhDNycsJ2NjaXJjJzonXFxcXHUwMTA5JywnQ2NpcmMnOidcXFxcdTAxMDgnLCdDY29uaW50JzonXFxcXHUyMjMwJywnY2N1cHMnOidcXFxcdTJBNEMnLCdjY3Vwc3NtJzonXFxcXHUyQTUwJywnY2RvdCc6J1xcXFx1MDEwQicsJ0Nkb3QnOidcXFxcdTAxMEEnLCdjZWRpbCc6J1xcXFx4QjgnLCdDZWRpbGxhJzonXFxcXHhCOCcsJ2NlbXB0eXYnOidcXFxcdTI5QjInLCdjZW50JzonXFxcXHhBMicsJ2NlbnRlcmRvdCc6J1xcXFx4QjcnLCdDZW50ZXJEb3QnOidcXFxceEI3JywnY2ZyJzonXFxcXHVEODM1XFxcXHVERDIwJywnQ2ZyJzonXFxcXHUyMTJEJywnY2hjeSc6J1xcXFx1MDQ0NycsJ0NIY3knOidcXFxcdTA0MjcnLCdjaGVjayc6J1xcXFx1MjcxMycsJ2NoZWNrbWFyayc6J1xcXFx1MjcxMycsJ2NoaSc6J1xcXFx1MDNDNycsJ0NoaSc6J1xcXFx1MDNBNycsJ2Npcic6J1xcXFx1MjVDQicsJ2NpcmMnOidcXFxcdTAyQzYnLCdjaXJjZXEnOidcXFxcdTIyNTcnLCdjaXJjbGVhcnJvd2xlZnQnOidcXFxcdTIxQkEnLCdjaXJjbGVhcnJvd3JpZ2h0JzonXFxcXHUyMUJCJywnY2lyY2xlZGFzdCc6J1xcXFx1MjI5QicsJ2NpcmNsZWRjaXJjJzonXFxcXHUyMjlBJywnY2lyY2xlZGRhc2gnOidcXFxcdTIyOUQnLCdDaXJjbGVEb3QnOidcXFxcdTIyOTknLCdjaXJjbGVkUic6J1xcXFx4QUUnLCdjaXJjbGVkUyc6J1xcXFx1MjRDOCcsJ0NpcmNsZU1pbnVzJzonXFxcXHUyMjk2JywnQ2lyY2xlUGx1cyc6J1xcXFx1MjI5NScsJ0NpcmNsZVRpbWVzJzonXFxcXHUyMjk3JywnY2lyZSc6J1xcXFx1MjI1NycsJ2NpckUnOidcXFxcdTI5QzMnLCdjaXJmbmludCc6J1xcXFx1MkExMCcsJ2Npcm1pZCc6J1xcXFx1MkFFRicsJ2NpcnNjaXInOidcXFxcdTI5QzInLCdDbG9ja3dpc2VDb250b3VySW50ZWdyYWwnOidcXFxcdTIyMzInLCdDbG9zZUN1cmx5RG91YmxlUXVvdGUnOidcXFxcdTIwMUQnLCdDbG9zZUN1cmx5UXVvdGUnOidcXFxcdTIwMTknLCdjbHVicyc6J1xcXFx1MjY2MycsJ2NsdWJzdWl0JzonXFxcXHUyNjYzJywnY29sb24nOic6JywnQ29sb24nOidcXFxcdTIyMzcnLCdjb2xvbmUnOidcXFxcdTIyNTQnLCdDb2xvbmUnOidcXFxcdTJBNzQnLCdjb2xvbmVxJzonXFxcXHUyMjU0JywnY29tbWEnOicsJywnY29tbWF0JzonQCcsJ2NvbXAnOidcXFxcdTIyMDEnLCdjb21wZm4nOidcXFxcdTIyMTgnLCdjb21wbGVtZW50JzonXFxcXHUyMjAxJywnY29tcGxleGVzJzonXFxcXHUyMTAyJywnY29uZyc6J1xcXFx1MjI0NScsJ2Nvbmdkb3QnOidcXFxcdTJBNkQnLCdDb25ncnVlbnQnOidcXFxcdTIyNjEnLCdjb25pbnQnOidcXFxcdTIyMkUnLCdDb25pbnQnOidcXFxcdTIyMkYnLCdDb250b3VySW50ZWdyYWwnOidcXFxcdTIyMkUnLCdjb3BmJzonXFxcXHVEODM1XFxcXHVERDU0JywnQ29wZic6J1xcXFx1MjEwMicsJ2NvcHJvZCc6J1xcXFx1MjIxMCcsJ0NvcHJvZHVjdCc6J1xcXFx1MjIxMCcsJ2NvcHknOidcXFxceEE5JywnQ09QWSc6J1xcXFx4QTknLCdjb3B5c3InOidcXFxcdTIxMTcnLCdDb3VudGVyQ2xvY2t3aXNlQ29udG91ckludGVncmFsJzonXFxcXHUyMjMzJywnY3JhcnInOidcXFxcdTIxQjUnLCdjcm9zcyc6J1xcXFx1MjcxNycsJ0Nyb3NzJzonXFxcXHUyQTJGJywnY3Njcic6J1xcXFx1RDgzNVxcXFx1RENCOCcsJ0NzY3InOidcXFxcdUQ4MzVcXFxcdURDOUUnLCdjc3ViJzonXFxcXHUyQUNGJywnY3N1YmUnOidcXFxcdTJBRDEnLCdjc3VwJzonXFxcXHUyQUQwJywnY3N1cGUnOidcXFxcdTJBRDInLCdjdGRvdCc6J1xcXFx1MjJFRicsJ2N1ZGFycmwnOidcXFxcdTI5MzgnLCdjdWRhcnJyJzonXFxcXHUyOTM1JywnY3VlcHInOidcXFxcdTIyREUnLCdjdWVzYyc6J1xcXFx1MjJERicsJ2N1bGFycic6J1xcXFx1MjFCNicsJ2N1bGFycnAnOidcXFxcdTI5M0QnLCdjdXAnOidcXFxcdTIyMkEnLCdDdXAnOidcXFxcdTIyRDMnLCdjdXBicmNhcCc6J1xcXFx1MkE0OCcsJ2N1cGNhcCc6J1xcXFx1MkE0NicsJ0N1cENhcCc6J1xcXFx1MjI0RCcsJ2N1cGN1cCc6J1xcXFx1MkE0QScsJ2N1cGRvdCc6J1xcXFx1MjI4RCcsJ2N1cG9yJzonXFxcXHUyQTQ1JywnY3Vwcyc6J1xcXFx1MjIyQVxcXFx1RkUwMCcsJ2N1cmFycic6J1xcXFx1MjFCNycsJ2N1cmFycm0nOidcXFxcdTI5M0MnLCdjdXJseWVxcHJlYyc6J1xcXFx1MjJERScsJ2N1cmx5ZXFzdWNjJzonXFxcXHUyMkRGJywnY3VybHl2ZWUnOidcXFxcdTIyQ0UnLCdjdXJseXdlZGdlJzonXFxcXHUyMkNGJywnY3VycmVuJzonXFxcXHhBNCcsJ2N1cnZlYXJyb3dsZWZ0JzonXFxcXHUyMUI2JywnY3VydmVhcnJvd3JpZ2h0JzonXFxcXHUyMUI3JywnY3V2ZWUnOidcXFxcdTIyQ0UnLCdjdXdlZCc6J1xcXFx1MjJDRicsJ2N3Y29uaW50JzonXFxcXHUyMjMyJywnY3dpbnQnOidcXFxcdTIyMzEnLCdjeWxjdHknOidcXFxcdTIzMkQnLCdkYWdnZXInOidcXFxcdTIwMjAnLCdEYWdnZXInOidcXFxcdTIwMjEnLCdkYWxldGgnOidcXFxcdTIxMzgnLCdkYXJyJzonXFxcXHUyMTkzJywnZEFycic6J1xcXFx1MjFEMycsJ0RhcnInOidcXFxcdTIxQTEnLCdkYXNoJzonXFxcXHUyMDEwJywnZGFzaHYnOidcXFxcdTIyQTMnLCdEYXNodic6J1xcXFx1MkFFNCcsJ2Ria2Fyb3cnOidcXFxcdTI5MEYnLCdkYmxhYyc6J1xcXFx1MDJERCcsJ2RjYXJvbic6J1xcXFx1MDEwRicsJ0RjYXJvbic6J1xcXFx1MDEwRScsJ2RjeSc6J1xcXFx1MDQzNCcsJ0RjeSc6J1xcXFx1MDQxNCcsJ2RkJzonXFxcXHUyMTQ2JywnREQnOidcXFxcdTIxNDUnLCdkZGFnZ2VyJzonXFxcXHUyMDIxJywnZGRhcnInOidcXFxcdTIxQ0EnLCdERG90cmFoZCc6J1xcXFx1MjkxMScsJ2Rkb3RzZXEnOidcXFxcdTJBNzcnLCdkZWcnOidcXFxceEIwJywnRGVsJzonXFxcXHUyMjA3JywnZGVsdGEnOidcXFxcdTAzQjQnLCdEZWx0YSc6J1xcXFx1MDM5NCcsJ2RlbXB0eXYnOidcXFxcdTI5QjEnLCdkZmlzaHQnOidcXFxcdTI5N0YnLCdkZnInOidcXFxcdUQ4MzVcXFxcdUREMjEnLCdEZnInOidcXFxcdUQ4MzVcXFxcdUREMDcnLCdkSGFyJzonXFxcXHUyOTY1JywnZGhhcmwnOidcXFxcdTIxQzMnLCdkaGFycic6J1xcXFx1MjFDMicsJ0RpYWNyaXRpY2FsQWN1dGUnOidcXFxceEI0JywnRGlhY3JpdGljYWxEb3QnOidcXFxcdTAyRDknLCdEaWFjcml0aWNhbERvdWJsZUFjdXRlJzonXFxcXHUwMkREJywnRGlhY3JpdGljYWxHcmF2ZSc6J2AnLCdEaWFjcml0aWNhbFRpbGRlJzonXFxcXHUwMkRDJywnZGlhbSc6J1xcXFx1MjJDNCcsJ2RpYW1vbmQnOidcXFxcdTIyQzQnLCdEaWFtb25kJzonXFxcXHUyMkM0JywnZGlhbW9uZHN1aXQnOidcXFxcdTI2NjYnLCdkaWFtcyc6J1xcXFx1MjY2NicsJ2RpZSc6J1xcXFx4QTgnLCdEaWZmZXJlbnRpYWxEJzonXFxcXHUyMTQ2JywnZGlnYW1tYSc6J1xcXFx1MDNERCcsJ2Rpc2luJzonXFxcXHUyMkYyJywnZGl2JzonXFxcXHhGNycsJ2RpdmlkZSc6J1xcXFx4RjcnLCdkaXZpZGVvbnRpbWVzJzonXFxcXHUyMkM3JywnZGl2b254JzonXFxcXHUyMkM3JywnZGpjeSc6J1xcXFx1MDQ1MicsJ0RKY3knOidcXFxcdTA0MDInLCdkbGNvcm4nOidcXFxcdTIzMUUnLCdkbGNyb3AnOidcXFxcdTIzMEQnLCdkb2xsYXInOickJywnZG9wZic6J1xcXFx1RDgzNVxcXFx1REQ1NScsJ0RvcGYnOidcXFxcdUQ4MzVcXFxcdUREM0InLCdkb3QnOidcXFxcdTAyRDknLCdEb3QnOidcXFxceEE4JywnRG90RG90JzonXFxcXHUyMERDJywnZG90ZXEnOidcXFxcdTIyNTAnLCdkb3RlcWRvdCc6J1xcXFx1MjI1MScsJ0RvdEVxdWFsJzonXFxcXHUyMjUwJywnZG90bWludXMnOidcXFxcdTIyMzgnLCdkb3RwbHVzJzonXFxcXHUyMjE0JywnZG90c3F1YXJlJzonXFxcXHUyMkExJywnZG91YmxlYmFyd2VkZ2UnOidcXFxcdTIzMDYnLCdEb3VibGVDb250b3VySW50ZWdyYWwnOidcXFxcdTIyMkYnLCdEb3VibGVEb3QnOidcXFxceEE4JywnRG91YmxlRG93bkFycm93JzonXFxcXHUyMUQzJywnRG91YmxlTGVmdEFycm93JzonXFxcXHUyMUQwJywnRG91YmxlTGVmdFJpZ2h0QXJyb3cnOidcXFxcdTIxRDQnLCdEb3VibGVMZWZ0VGVlJzonXFxcXHUyQUU0JywnRG91YmxlTG9uZ0xlZnRBcnJvdyc6J1xcXFx1MjdGOCcsJ0RvdWJsZUxvbmdMZWZ0UmlnaHRBcnJvdyc6J1xcXFx1MjdGQScsJ0RvdWJsZUxvbmdSaWdodEFycm93JzonXFxcXHUyN0Y5JywnRG91YmxlUmlnaHRBcnJvdyc6J1xcXFx1MjFEMicsJ0RvdWJsZVJpZ2h0VGVlJzonXFxcXHUyMkE4JywnRG91YmxlVXBBcnJvdyc6J1xcXFx1MjFEMScsJ0RvdWJsZVVwRG93bkFycm93JzonXFxcXHUyMUQ1JywnRG91YmxlVmVydGljYWxCYXInOidcXFxcdTIyMjUnLCdkb3duYXJyb3cnOidcXFxcdTIxOTMnLCdEb3duYXJyb3cnOidcXFxcdTIxRDMnLCdEb3duQXJyb3cnOidcXFxcdTIxOTMnLCdEb3duQXJyb3dCYXInOidcXFxcdTI5MTMnLCdEb3duQXJyb3dVcEFycm93JzonXFxcXHUyMUY1JywnRG93bkJyZXZlJzonXFxcXHUwMzExJywnZG93bmRvd25hcnJvd3MnOidcXFxcdTIxQ0EnLCdkb3duaGFycG9vbmxlZnQnOidcXFxcdTIxQzMnLCdkb3duaGFycG9vbnJpZ2h0JzonXFxcXHUyMUMyJywnRG93bkxlZnRSaWdodFZlY3Rvcic6J1xcXFx1Mjk1MCcsJ0Rvd25MZWZ0VGVlVmVjdG9yJzonXFxcXHUyOTVFJywnRG93bkxlZnRWZWN0b3InOidcXFxcdTIxQkQnLCdEb3duTGVmdFZlY3RvckJhcic6J1xcXFx1Mjk1NicsJ0Rvd25SaWdodFRlZVZlY3Rvcic6J1xcXFx1Mjk1RicsJ0Rvd25SaWdodFZlY3Rvcic6J1xcXFx1MjFDMScsJ0Rvd25SaWdodFZlY3RvckJhcic6J1xcXFx1Mjk1NycsJ0Rvd25UZWUnOidcXFxcdTIyQTQnLCdEb3duVGVlQXJyb3cnOidcXFxcdTIxQTcnLCdkcmJrYXJvdyc6J1xcXFx1MjkxMCcsJ2RyY29ybic6J1xcXFx1MjMxRicsJ2RyY3JvcCc6J1xcXFx1MjMwQycsJ2RzY3InOidcXFxcdUQ4MzVcXFxcdURDQjknLCdEc2NyJzonXFxcXHVEODM1XFxcXHVEQzlGJywnZHNjeSc6J1xcXFx1MDQ1NScsJ0RTY3knOidcXFxcdTA0MDUnLCdkc29sJzonXFxcXHUyOUY2JywnZHN0cm9rJzonXFxcXHUwMTExJywnRHN0cm9rJzonXFxcXHUwMTEwJywnZHRkb3QnOidcXFxcdTIyRjEnLCdkdHJpJzonXFxcXHUyNUJGJywnZHRyaWYnOidcXFxcdTI1QkUnLCdkdWFycic6J1xcXFx1MjFGNScsJ2R1aGFyJzonXFxcXHUyOTZGJywnZHdhbmdsZSc6J1xcXFx1MjlBNicsJ2R6Y3knOidcXFxcdTA0NUYnLCdEWmN5JzonXFxcXHUwNDBGJywnZHppZ3JhcnInOidcXFxcdTI3RkYnLCdlYWN1dGUnOidcXFxceEU5JywnRWFjdXRlJzonXFxcXHhDOScsJ2Vhc3Rlcic6J1xcXFx1MkE2RScsJ2VjYXJvbic6J1xcXFx1MDExQicsJ0VjYXJvbic6J1xcXFx1MDExQScsJ2VjaXInOidcXFxcdTIyNTYnLCdlY2lyYyc6J1xcXFx4RUEnLCdFY2lyYyc6J1xcXFx4Q0EnLCdlY29sb24nOidcXFxcdTIyNTUnLCdlY3knOidcXFxcdTA0NEQnLCdFY3knOidcXFxcdTA0MkQnLCdlRERvdCc6J1xcXFx1MkE3NycsJ2Vkb3QnOidcXFxcdTAxMTcnLCdlRG90JzonXFxcXHUyMjUxJywnRWRvdCc6J1xcXFx1MDExNicsJ2VlJzonXFxcXHUyMTQ3JywnZWZEb3QnOidcXFxcdTIyNTInLCdlZnInOidcXFxcdUQ4MzVcXFxcdUREMjInLCdFZnInOidcXFxcdUQ4MzVcXFxcdUREMDgnLCdlZyc6J1xcXFx1MkE5QScsJ2VncmF2ZSc6J1xcXFx4RTgnLCdFZ3JhdmUnOidcXFxceEM4JywnZWdzJzonXFxcXHUyQTk2JywnZWdzZG90JzonXFxcXHUyQTk4JywnZWwnOidcXFxcdTJBOTknLCdFbGVtZW50JzonXFxcXHUyMjA4JywnZWxpbnRlcnMnOidcXFxcdTIzRTcnLCdlbGwnOidcXFxcdTIxMTMnLCdlbHMnOidcXFxcdTJBOTUnLCdlbHNkb3QnOidcXFxcdTJBOTcnLCdlbWFjcic6J1xcXFx1MDExMycsJ0VtYWNyJzonXFxcXHUwMTEyJywnZW1wdHknOidcXFxcdTIyMDUnLCdlbXB0eXNldCc6J1xcXFx1MjIwNScsJ0VtcHR5U21hbGxTcXVhcmUnOidcXFxcdTI1RkInLCdlbXB0eXYnOidcXFxcdTIyMDUnLCdFbXB0eVZlcnlTbWFsbFNxdWFyZSc6J1xcXFx1MjVBQicsJ2Vtc3AnOidcXFxcdTIwMDMnLCdlbXNwMTMnOidcXFxcdTIwMDQnLCdlbXNwMTQnOidcXFxcdTIwMDUnLCdlbmcnOidcXFxcdTAxNEInLCdFTkcnOidcXFxcdTAxNEEnLCdlbnNwJzonXFxcXHUyMDAyJywnZW9nb24nOidcXFxcdTAxMTknLCdFb2dvbic6J1xcXFx1MDExOCcsJ2VvcGYnOidcXFxcdUQ4MzVcXFxcdURENTYnLCdFb3BmJzonXFxcXHVEODM1XFxcXHVERDNDJywnZXBhcic6J1xcXFx1MjJENScsJ2VwYXJzbCc6J1xcXFx1MjlFMycsJ2VwbHVzJzonXFxcXHUyQTcxJywnZXBzaSc6J1xcXFx1MDNCNScsJ2Vwc2lsb24nOidcXFxcdTAzQjUnLCdFcHNpbG9uJzonXFxcXHUwMzk1JywnZXBzaXYnOidcXFxcdTAzRjUnLCdlcWNpcmMnOidcXFxcdTIyNTYnLCdlcWNvbG9uJzonXFxcXHUyMjU1JywnZXFzaW0nOidcXFxcdTIyNDInLCdlcXNsYW50Z3RyJzonXFxcXHUyQTk2JywnZXFzbGFudGxlc3MnOidcXFxcdTJBOTUnLCdFcXVhbCc6J1xcXFx1MkE3NScsJ2VxdWFscyc6Jz0nLCdFcXVhbFRpbGRlJzonXFxcXHUyMjQyJywnZXF1ZXN0JzonXFxcXHUyMjVGJywnRXF1aWxpYnJpdW0nOidcXFxcdTIxQ0MnLCdlcXVpdic6J1xcXFx1MjI2MScsJ2VxdWl2REQnOidcXFxcdTJBNzgnLCdlcXZwYXJzbCc6J1xcXFx1MjlFNScsJ2VyYXJyJzonXFxcXHUyOTcxJywnZXJEb3QnOidcXFxcdTIyNTMnLCdlc2NyJzonXFxcXHUyMTJGJywnRXNjcic6J1xcXFx1MjEzMCcsJ2VzZG90JzonXFxcXHUyMjUwJywnZXNpbSc6J1xcXFx1MjI0MicsJ0VzaW0nOidcXFxcdTJBNzMnLCdldGEnOidcXFxcdTAzQjcnLCdFdGEnOidcXFxcdTAzOTcnLCdldGgnOidcXFxceEYwJywnRVRIJzonXFxcXHhEMCcsJ2V1bWwnOidcXFxceEVCJywnRXVtbCc6J1xcXFx4Q0InLCdldXJvJzonXFxcXHUyMEFDJywnZXhjbCc6JyEnLCdleGlzdCc6J1xcXFx1MjIwMycsJ0V4aXN0cyc6J1xcXFx1MjIwMycsJ2V4cGVjdGF0aW9uJzonXFxcXHUyMTMwJywnZXhwb25lbnRpYWxlJzonXFxcXHUyMTQ3JywnRXhwb25lbnRpYWxFJzonXFxcXHUyMTQ3JywnZmFsbGluZ2RvdHNlcSc6J1xcXFx1MjI1MicsJ2ZjeSc6J1xcXFx1MDQ0NCcsJ0ZjeSc6J1xcXFx1MDQyNCcsJ2ZlbWFsZSc6J1xcXFx1MjY0MCcsJ2ZmaWxpZyc6J1xcXFx1RkIwMycsJ2ZmbGlnJzonXFxcXHVGQjAwJywnZmZsbGlnJzonXFxcXHVGQjA0JywnZmZyJzonXFxcXHVEODM1XFxcXHVERDIzJywnRmZyJzonXFxcXHVEODM1XFxcXHVERDA5JywnZmlsaWcnOidcXFxcdUZCMDEnLCdGaWxsZWRTbWFsbFNxdWFyZSc6J1xcXFx1MjVGQycsJ0ZpbGxlZFZlcnlTbWFsbFNxdWFyZSc6J1xcXFx1MjVBQScsJ2ZqbGlnJzonZmonLCdmbGF0JzonXFxcXHUyNjZEJywnZmxsaWcnOidcXFxcdUZCMDInLCdmbHRucyc6J1xcXFx1MjVCMScsJ2Zub2YnOidcXFxcdTAxOTInLCdmb3BmJzonXFxcXHVEODM1XFxcXHVERDU3JywnRm9wZic6J1xcXFx1RDgzNVxcXFx1REQzRCcsJ2ZvcmFsbCc6J1xcXFx1MjIwMCcsJ0ZvckFsbCc6J1xcXFx1MjIwMCcsJ2ZvcmsnOidcXFxcdTIyRDQnLCdmb3Jrdic6J1xcXFx1MkFEOScsJ0ZvdXJpZXJ0cmYnOidcXFxcdTIxMzEnLCdmcGFydGludCc6J1xcXFx1MkEwRCcsJ2ZyYWMxMic6J1xcXFx4QkQnLCdmcmFjMTMnOidcXFxcdTIxNTMnLCdmcmFjMTQnOidcXFxceEJDJywnZnJhYzE1JzonXFxcXHUyMTU1JywnZnJhYzE2JzonXFxcXHUyMTU5JywnZnJhYzE4JzonXFxcXHUyMTVCJywnZnJhYzIzJzonXFxcXHUyMTU0JywnZnJhYzI1JzonXFxcXHUyMTU2JywnZnJhYzM0JzonXFxcXHhCRScsJ2ZyYWMzNSc6J1xcXFx1MjE1NycsJ2ZyYWMzOCc6J1xcXFx1MjE1QycsJ2ZyYWM0NSc6J1xcXFx1MjE1OCcsJ2ZyYWM1Nic6J1xcXFx1MjE1QScsJ2ZyYWM1OCc6J1xcXFx1MjE1RCcsJ2ZyYWM3OCc6J1xcXFx1MjE1RScsJ2ZyYXNsJzonXFxcXHUyMDQ0JywnZnJvd24nOidcXFxcdTIzMjInLCdmc2NyJzonXFxcXHVEODM1XFxcXHVEQ0JCJywnRnNjcic6J1xcXFx1MjEzMScsJ2dhY3V0ZSc6J1xcXFx1MDFGNScsJ2dhbW1hJzonXFxcXHUwM0IzJywnR2FtbWEnOidcXFxcdTAzOTMnLCdnYW1tYWQnOidcXFxcdTAzREQnLCdHYW1tYWQnOidcXFxcdTAzREMnLCdnYXAnOidcXFxcdTJBODYnLCdnYnJldmUnOidcXFxcdTAxMUYnLCdHYnJldmUnOidcXFxcdTAxMUUnLCdHY2VkaWwnOidcXFxcdTAxMjInLCdnY2lyYyc6J1xcXFx1MDExRCcsJ0djaXJjJzonXFxcXHUwMTFDJywnZ2N5JzonXFxcXHUwNDMzJywnR2N5JzonXFxcXHUwNDEzJywnZ2RvdCc6J1xcXFx1MDEyMScsJ0dkb3QnOidcXFxcdTAxMjAnLCdnZSc6J1xcXFx1MjI2NScsJ2dFJzonXFxcXHUyMjY3JywnZ2VsJzonXFxcXHUyMkRCJywnZ0VsJzonXFxcXHUyQThDJywnZ2VxJzonXFxcXHUyMjY1JywnZ2VxcSc6J1xcXFx1MjI2NycsJ2dlcXNsYW50JzonXFxcXHUyQTdFJywnZ2VzJzonXFxcXHUyQTdFJywnZ2VzY2MnOidcXFxcdTJBQTknLCdnZXNkb3QnOidcXFxcdTJBODAnLCdnZXNkb3RvJzonXFxcXHUyQTgyJywnZ2VzZG90b2wnOidcXFxcdTJBODQnLCdnZXNsJzonXFxcXHUyMkRCXFxcXHVGRTAwJywnZ2VzbGVzJzonXFxcXHUyQTk0JywnZ2ZyJzonXFxcXHVEODM1XFxcXHVERDI0JywnR2ZyJzonXFxcXHVEODM1XFxcXHVERDBBJywnZ2cnOidcXFxcdTIyNkInLCdHZyc6J1xcXFx1MjJEOScsJ2dnZyc6J1xcXFx1MjJEOScsJ2dpbWVsJzonXFxcXHUyMTM3JywnZ2pjeSc6J1xcXFx1MDQ1MycsJ0dKY3knOidcXFxcdTA0MDMnLCdnbCc6J1xcXFx1MjI3NycsJ2dsYSc6J1xcXFx1MkFBNScsJ2dsRSc6J1xcXFx1MkE5MicsJ2dsaic6J1xcXFx1MkFBNCcsJ2duYXAnOidcXFxcdTJBOEEnLCdnbmFwcHJveCc6J1xcXFx1MkE4QScsJ2duZSc6J1xcXFx1MkE4OCcsJ2duRSc6J1xcXFx1MjI2OScsJ2duZXEnOidcXFxcdTJBODgnLCdnbmVxcSc6J1xcXFx1MjI2OScsJ2duc2ltJzonXFxcXHUyMkU3JywnZ29wZic6J1xcXFx1RDgzNVxcXFx1REQ1OCcsJ0dvcGYnOidcXFxcdUQ4MzVcXFxcdUREM0UnLCdncmF2ZSc6J2AnLCdHcmVhdGVyRXF1YWwnOidcXFxcdTIyNjUnLCdHcmVhdGVyRXF1YWxMZXNzJzonXFxcXHUyMkRCJywnR3JlYXRlckZ1bGxFcXVhbCc6J1xcXFx1MjI2NycsJ0dyZWF0ZXJHcmVhdGVyJzonXFxcXHUyQUEyJywnR3JlYXRlckxlc3MnOidcXFxcdTIyNzcnLCdHcmVhdGVyU2xhbnRFcXVhbCc6J1xcXFx1MkE3RScsJ0dyZWF0ZXJUaWxkZSc6J1xcXFx1MjI3MycsJ2dzY3InOidcXFxcdTIxMEEnLCdHc2NyJzonXFxcXHVEODM1XFxcXHVEQ0EyJywnZ3NpbSc6J1xcXFx1MjI3MycsJ2dzaW1lJzonXFxcXHUyQThFJywnZ3NpbWwnOidcXFxcdTJBOTAnLCdndCc6Jz4nLCdHdCc6J1xcXFx1MjI2QicsJ0dUJzonPicsJ2d0Y2MnOidcXFxcdTJBQTcnLCdndGNpcic6J1xcXFx1MkE3QScsJ2d0ZG90JzonXFxcXHUyMkQ3JywnZ3RsUGFyJzonXFxcXHUyOTk1JywnZ3RxdWVzdCc6J1xcXFx1MkE3QycsJ2d0cmFwcHJveCc6J1xcXFx1MkE4NicsJ2d0cmFycic6J1xcXFx1Mjk3OCcsJ2d0cmRvdCc6J1xcXFx1MjJENycsJ2d0cmVxbGVzcyc6J1xcXFx1MjJEQicsJ2d0cmVxcWxlc3MnOidcXFxcdTJBOEMnLCdndHJsZXNzJzonXFxcXHUyMjc3JywnZ3Ryc2ltJzonXFxcXHUyMjczJywnZ3ZlcnRuZXFxJzonXFxcXHUyMjY5XFxcXHVGRTAwJywnZ3ZuRSc6J1xcXFx1MjI2OVxcXFx1RkUwMCcsJ0hhY2VrJzonXFxcXHUwMkM3JywnaGFpcnNwJzonXFxcXHUyMDBBJywnaGFsZic6J1xcXFx4QkQnLCdoYW1pbHQnOidcXFxcdTIxMEInLCdoYXJkY3knOidcXFxcdTA0NEEnLCdIQVJEY3knOidcXFxcdTA0MkEnLCdoYXJyJzonXFxcXHUyMTk0JywnaEFycic6J1xcXFx1MjFENCcsJ2hhcnJjaXInOidcXFxcdTI5NDgnLCdoYXJydyc6J1xcXFx1MjFBRCcsJ0hhdCc6J14nLCdoYmFyJzonXFxcXHUyMTBGJywnaGNpcmMnOidcXFxcdTAxMjUnLCdIY2lyYyc6J1xcXFx1MDEyNCcsJ2hlYXJ0cyc6J1xcXFx1MjY2NScsJ2hlYXJ0c3VpdCc6J1xcXFx1MjY2NScsJ2hlbGxpcCc6J1xcXFx1MjAyNicsJ2hlcmNvbic6J1xcXFx1MjJCOScsJ2hmcic6J1xcXFx1RDgzNVxcXFx1REQyNScsJ0hmcic6J1xcXFx1MjEwQycsJ0hpbGJlcnRTcGFjZSc6J1xcXFx1MjEwQicsJ2hrc2Vhcm93JzonXFxcXHUyOTI1JywnaGtzd2Fyb3cnOidcXFxcdTI5MjYnLCdob2Fycic6J1xcXFx1MjFGRicsJ2hvbXRodCc6J1xcXFx1MjIzQicsJ2hvb2tsZWZ0YXJyb3cnOidcXFxcdTIxQTknLCdob29rcmlnaHRhcnJvdyc6J1xcXFx1MjFBQScsJ2hvcGYnOidcXFxcdUQ4MzVcXFxcdURENTknLCdIb3BmJzonXFxcXHUyMTBEJywnaG9yYmFyJzonXFxcXHUyMDE1JywnSG9yaXpvbnRhbExpbmUnOidcXFxcdTI1MDAnLCdoc2NyJzonXFxcXHVEODM1XFxcXHVEQ0JEJywnSHNjcic6J1xcXFx1MjEwQicsJ2hzbGFzaCc6J1xcXFx1MjEwRicsJ2hzdHJvayc6J1xcXFx1MDEyNycsJ0hzdHJvayc6J1xcXFx1MDEyNicsJ0h1bXBEb3duSHVtcCc6J1xcXFx1MjI0RScsJ0h1bXBFcXVhbCc6J1xcXFx1MjI0RicsJ2h5YnVsbCc6J1xcXFx1MjA0MycsJ2h5cGhlbic6J1xcXFx1MjAxMCcsJ2lhY3V0ZSc6J1xcXFx4RUQnLCdJYWN1dGUnOidcXFxceENEJywnaWMnOidcXFxcdTIwNjMnLCdpY2lyYyc6J1xcXFx4RUUnLCdJY2lyYyc6J1xcXFx4Q0UnLCdpY3knOidcXFxcdTA0MzgnLCdJY3knOidcXFxcdTA0MTgnLCdJZG90JzonXFxcXHUwMTMwJywnaWVjeSc6J1xcXFx1MDQzNScsJ0lFY3knOidcXFxcdTA0MTUnLCdpZXhjbCc6J1xcXFx4QTEnLCdpZmYnOidcXFxcdTIxRDQnLCdpZnInOidcXFxcdUQ4MzVcXFxcdUREMjYnLCdJZnInOidcXFxcdTIxMTEnLCdpZ3JhdmUnOidcXFxceEVDJywnSWdyYXZlJzonXFxcXHhDQycsJ2lpJzonXFxcXHUyMTQ4JywnaWlpaW50JzonXFxcXHUyQTBDJywnaWlpbnQnOidcXFxcdTIyMkQnLCdpaW5maW4nOidcXFxcdTI5REMnLCdpaW90YSc6J1xcXFx1MjEyOScsJ2lqbGlnJzonXFxcXHUwMTMzJywnSUpsaWcnOidcXFxcdTAxMzInLCdJbSc6J1xcXFx1MjExMScsJ2ltYWNyJzonXFxcXHUwMTJCJywnSW1hY3InOidcXFxcdTAxMkEnLCdpbWFnZSc6J1xcXFx1MjExMScsJ0ltYWdpbmFyeUknOidcXFxcdTIxNDgnLCdpbWFnbGluZSc6J1xcXFx1MjExMCcsJ2ltYWdwYXJ0JzonXFxcXHUyMTExJywnaW1hdGgnOidcXFxcdTAxMzEnLCdpbW9mJzonXFxcXHUyMkI3JywnaW1wZWQnOidcXFxcdTAxQjUnLCdJbXBsaWVzJzonXFxcXHUyMUQyJywnaW4nOidcXFxcdTIyMDgnLCdpbmNhcmUnOidcXFxcdTIxMDUnLCdpbmZpbic6J1xcXFx1MjIxRScsJ2luZmludGllJzonXFxcXHUyOUREJywnaW5vZG90JzonXFxcXHUwMTMxJywnaW50JzonXFxcXHUyMjJCJywnSW50JzonXFxcXHUyMjJDJywnaW50Y2FsJzonXFxcXHUyMkJBJywnaW50ZWdlcnMnOidcXFxcdTIxMjQnLCdJbnRlZ3JhbCc6J1xcXFx1MjIyQicsJ2ludGVyY2FsJzonXFxcXHUyMkJBJywnSW50ZXJzZWN0aW9uJzonXFxcXHUyMkMyJywnaW50bGFyaGsnOidcXFxcdTJBMTcnLCdpbnRwcm9kJzonXFxcXHUyQTNDJywnSW52aXNpYmxlQ29tbWEnOidcXFxcdTIwNjMnLCdJbnZpc2libGVUaW1lcyc6J1xcXFx1MjA2MicsJ2lvY3knOidcXFxcdTA0NTEnLCdJT2N5JzonXFxcXHUwNDAxJywnaW9nb24nOidcXFxcdTAxMkYnLCdJb2dvbic6J1xcXFx1MDEyRScsJ2lvcGYnOidcXFxcdUQ4MzVcXFxcdURENUEnLCdJb3BmJzonXFxcXHVEODM1XFxcXHVERDQwJywnaW90YSc6J1xcXFx1MDNCOScsJ0lvdGEnOidcXFxcdTAzOTknLCdpcHJvZCc6J1xcXFx1MkEzQycsJ2lxdWVzdCc6J1xcXFx4QkYnLCdpc2NyJzonXFxcXHVEODM1XFxcXHVEQ0JFJywnSXNjcic6J1xcXFx1MjExMCcsJ2lzaW4nOidcXFxcdTIyMDgnLCdpc2luZG90JzonXFxcXHUyMkY1JywnaXNpbkUnOidcXFxcdTIyRjknLCdpc2lucyc6J1xcXFx1MjJGNCcsJ2lzaW5zdic6J1xcXFx1MjJGMycsJ2lzaW52JzonXFxcXHUyMjA4JywnaXQnOidcXFxcdTIwNjInLCdpdGlsZGUnOidcXFxcdTAxMjknLCdJdGlsZGUnOidcXFxcdTAxMjgnLCdpdWtjeSc6J1xcXFx1MDQ1NicsJ0l1a2N5JzonXFxcXHUwNDA2JywnaXVtbCc6J1xcXFx4RUYnLCdJdW1sJzonXFxcXHhDRicsJ2pjaXJjJzonXFxcXHUwMTM1JywnSmNpcmMnOidcXFxcdTAxMzQnLCdqY3knOidcXFxcdTA0MzknLCdKY3knOidcXFxcdTA0MTknLCdqZnInOidcXFxcdUQ4MzVcXFxcdUREMjcnLCdKZnInOidcXFxcdUQ4MzVcXFxcdUREMEQnLCdqbWF0aCc6J1xcXFx1MDIzNycsJ2pvcGYnOidcXFxcdUQ4MzVcXFxcdURENUInLCdKb3BmJzonXFxcXHVEODM1XFxcXHVERDQxJywnanNjcic6J1xcXFx1RDgzNVxcXFx1RENCRicsJ0pzY3InOidcXFxcdUQ4MzVcXFxcdURDQTUnLCdqc2VyY3knOidcXFxcdTA0NTgnLCdKc2VyY3knOidcXFxcdTA0MDgnLCdqdWtjeSc6J1xcXFx1MDQ1NCcsJ0p1a2N5JzonXFxcXHUwNDA0Jywna2FwcGEnOidcXFxcdTAzQkEnLCdLYXBwYSc6J1xcXFx1MDM5QScsJ2thcHBhdic6J1xcXFx1MDNGMCcsJ2tjZWRpbCc6J1xcXFx1MDEzNycsJ0tjZWRpbCc6J1xcXFx1MDEzNicsJ2tjeSc6J1xcXFx1MDQzQScsJ0tjeSc6J1xcXFx1MDQxQScsJ2tmcic6J1xcXFx1RDgzNVxcXFx1REQyOCcsJ0tmcic6J1xcXFx1RDgzNVxcXFx1REQwRScsJ2tncmVlbic6J1xcXFx1MDEzOCcsJ2toY3knOidcXFxcdTA0NDUnLCdLSGN5JzonXFxcXHUwNDI1Jywna2pjeSc6J1xcXFx1MDQ1QycsJ0tKY3knOidcXFxcdTA0MEMnLCdrb3BmJzonXFxcXHVEODM1XFxcXHVERDVDJywnS29wZic6J1xcXFx1RDgzNVxcXFx1REQ0MicsJ2tzY3InOidcXFxcdUQ4MzVcXFxcdURDQzAnLCdLc2NyJzonXFxcXHVEODM1XFxcXHVEQ0E2JywnbEFhcnInOidcXFxcdTIxREEnLCdsYWN1dGUnOidcXFxcdTAxM0EnLCdMYWN1dGUnOidcXFxcdTAxMzknLCdsYWVtcHR5dic6J1xcXFx1MjlCNCcsJ2xhZ3Jhbic6J1xcXFx1MjExMicsJ2xhbWJkYSc6J1xcXFx1MDNCQicsJ0xhbWJkYSc6J1xcXFx1MDM5QicsJ2xhbmcnOidcXFxcdTI3RTgnLCdMYW5nJzonXFxcXHUyN0VBJywnbGFuZ2QnOidcXFxcdTI5OTEnLCdsYW5nbGUnOidcXFxcdTI3RTgnLCdsYXAnOidcXFxcdTJBODUnLCdMYXBsYWNldHJmJzonXFxcXHUyMTEyJywnbGFxdW8nOidcXFxceEFCJywnbGFycic6J1xcXFx1MjE5MCcsJ2xBcnInOidcXFxcdTIxRDAnLCdMYXJyJzonXFxcXHUyMTlFJywnbGFycmInOidcXFxcdTIxRTQnLCdsYXJyYmZzJzonXFxcXHUyOTFGJywnbGFycmZzJzonXFxcXHUyOTFEJywnbGFycmhrJzonXFxcXHUyMUE5JywnbGFycmxwJzonXFxcXHUyMUFCJywnbGFycnBsJzonXFxcXHUyOTM5JywnbGFycnNpbSc6J1xcXFx1Mjk3MycsJ2xhcnJ0bCc6J1xcXFx1MjFBMicsJ2xhdCc6J1xcXFx1MkFBQicsJ2xhdGFpbCc6J1xcXFx1MjkxOScsJ2xBdGFpbCc6J1xcXFx1MjkxQicsJ2xhdGUnOidcXFxcdTJBQUQnLCdsYXRlcyc6J1xcXFx1MkFBRFxcXFx1RkUwMCcsJ2xiYXJyJzonXFxcXHUyOTBDJywnbEJhcnInOidcXFxcdTI5MEUnLCdsYmJyayc6J1xcXFx1Mjc3MicsJ2xicmFjZSc6J3snLCdsYnJhY2snOidbJywnbGJya2UnOidcXFxcdTI5OEInLCdsYnJrc2xkJzonXFxcXHUyOThGJywnbGJya3NsdSc6J1xcXFx1Mjk4RCcsJ2xjYXJvbic6J1xcXFx1MDEzRScsJ0xjYXJvbic6J1xcXFx1MDEzRCcsJ2xjZWRpbCc6J1xcXFx1MDEzQycsJ0xjZWRpbCc6J1xcXFx1MDEzQicsJ2xjZWlsJzonXFxcXHUyMzA4JywnbGN1Yic6J3snLCdsY3knOidcXFxcdTA0M0InLCdMY3knOidcXFxcdTA0MUInLCdsZGNhJzonXFxcXHUyOTM2JywnbGRxdW8nOidcXFxcdTIwMUMnLCdsZHF1b3InOidcXFxcdTIwMUUnLCdsZHJkaGFyJzonXFxcXHUyOTY3JywnbGRydXNoYXInOidcXFxcdTI5NEInLCdsZHNoJzonXFxcXHUyMUIyJywnbGUnOidcXFxcdTIyNjQnLCdsRSc6J1xcXFx1MjI2NicsJ0xlZnRBbmdsZUJyYWNrZXQnOidcXFxcdTI3RTgnLCdsZWZ0YXJyb3cnOidcXFxcdTIxOTAnLCdMZWZ0YXJyb3cnOidcXFxcdTIxRDAnLCdMZWZ0QXJyb3cnOidcXFxcdTIxOTAnLCdMZWZ0QXJyb3dCYXInOidcXFxcdTIxRTQnLCdMZWZ0QXJyb3dSaWdodEFycm93JzonXFxcXHUyMUM2JywnbGVmdGFycm93dGFpbCc6J1xcXFx1MjFBMicsJ0xlZnRDZWlsaW5nJzonXFxcXHUyMzA4JywnTGVmdERvdWJsZUJyYWNrZXQnOidcXFxcdTI3RTYnLCdMZWZ0RG93blRlZVZlY3Rvcic6J1xcXFx1Mjk2MScsJ0xlZnREb3duVmVjdG9yJzonXFxcXHUyMUMzJywnTGVmdERvd25WZWN0b3JCYXInOidcXFxcdTI5NTknLCdMZWZ0Rmxvb3InOidcXFxcdTIzMEEnLCdsZWZ0aGFycG9vbmRvd24nOidcXFxcdTIxQkQnLCdsZWZ0aGFycG9vbnVwJzonXFxcXHUyMUJDJywnbGVmdGxlZnRhcnJvd3MnOidcXFxcdTIxQzcnLCdsZWZ0cmlnaHRhcnJvdyc6J1xcXFx1MjE5NCcsJ0xlZnRyaWdodGFycm93JzonXFxcXHUyMUQ0JywnTGVmdFJpZ2h0QXJyb3cnOidcXFxcdTIxOTQnLCdsZWZ0cmlnaHRhcnJvd3MnOidcXFxcdTIxQzYnLCdsZWZ0cmlnaHRoYXJwb29ucyc6J1xcXFx1MjFDQicsJ2xlZnRyaWdodHNxdWlnYXJyb3cnOidcXFxcdTIxQUQnLCdMZWZ0UmlnaHRWZWN0b3InOidcXFxcdTI5NEUnLCdMZWZ0VGVlJzonXFxcXHUyMkEzJywnTGVmdFRlZUFycm93JzonXFxcXHUyMUE0JywnTGVmdFRlZVZlY3Rvcic6J1xcXFx1Mjk1QScsJ2xlZnR0aHJlZXRpbWVzJzonXFxcXHUyMkNCJywnTGVmdFRyaWFuZ2xlJzonXFxcXHUyMkIyJywnTGVmdFRyaWFuZ2xlQmFyJzonXFxcXHUyOUNGJywnTGVmdFRyaWFuZ2xlRXF1YWwnOidcXFxcdTIyQjQnLCdMZWZ0VXBEb3duVmVjdG9yJzonXFxcXHUyOTUxJywnTGVmdFVwVGVlVmVjdG9yJzonXFxcXHUyOTYwJywnTGVmdFVwVmVjdG9yJzonXFxcXHUyMUJGJywnTGVmdFVwVmVjdG9yQmFyJzonXFxcXHUyOTU4JywnTGVmdFZlY3Rvcic6J1xcXFx1MjFCQycsJ0xlZnRWZWN0b3JCYXInOidcXFxcdTI5NTInLCdsZWcnOidcXFxcdTIyREEnLCdsRWcnOidcXFxcdTJBOEInLCdsZXEnOidcXFxcdTIyNjQnLCdsZXFxJzonXFxcXHUyMjY2JywnbGVxc2xhbnQnOidcXFxcdTJBN0QnLCdsZXMnOidcXFxcdTJBN0QnLCdsZXNjYyc6J1xcXFx1MkFBOCcsJ2xlc2RvdCc6J1xcXFx1MkE3RicsJ2xlc2RvdG8nOidcXFxcdTJBODEnLCdsZXNkb3Rvcic6J1xcXFx1MkE4MycsJ2xlc2cnOidcXFxcdTIyREFcXFxcdUZFMDAnLCdsZXNnZXMnOidcXFxcdTJBOTMnLCdsZXNzYXBwcm94JzonXFxcXHUyQTg1JywnbGVzc2RvdCc6J1xcXFx1MjJENicsJ2xlc3NlcWd0cic6J1xcXFx1MjJEQScsJ2xlc3NlcXFndHInOidcXFxcdTJBOEInLCdMZXNzRXF1YWxHcmVhdGVyJzonXFxcXHUyMkRBJywnTGVzc0Z1bGxFcXVhbCc6J1xcXFx1MjI2NicsJ0xlc3NHcmVhdGVyJzonXFxcXHUyMjc2JywnbGVzc2d0cic6J1xcXFx1MjI3NicsJ0xlc3NMZXNzJzonXFxcXHUyQUExJywnbGVzc3NpbSc6J1xcXFx1MjI3MicsJ0xlc3NTbGFudEVxdWFsJzonXFxcXHUyQTdEJywnTGVzc1RpbGRlJzonXFxcXHUyMjcyJywnbGZpc2h0JzonXFxcXHUyOTdDJywnbGZsb29yJzonXFxcXHUyMzBBJywnbGZyJzonXFxcXHVEODM1XFxcXHVERDI5JywnTGZyJzonXFxcXHVEODM1XFxcXHVERDBGJywnbGcnOidcXFxcdTIyNzYnLCdsZ0UnOidcXFxcdTJBOTEnLCdsSGFyJzonXFxcXHUyOTYyJywnbGhhcmQnOidcXFxcdTIxQkQnLCdsaGFydSc6J1xcXFx1MjFCQycsJ2xoYXJ1bCc6J1xcXFx1Mjk2QScsJ2xoYmxrJzonXFxcXHUyNTg0JywnbGpjeSc6J1xcXFx1MDQ1OScsJ0xKY3knOidcXFxcdTA0MDknLCdsbCc6J1xcXFx1MjI2QScsJ0xsJzonXFxcXHUyMkQ4JywnbGxhcnInOidcXFxcdTIxQzcnLCdsbGNvcm5lcic6J1xcXFx1MjMxRScsJ0xsZWZ0YXJyb3cnOidcXFxcdTIxREEnLCdsbGhhcmQnOidcXFxcdTI5NkInLCdsbHRyaSc6J1xcXFx1MjVGQScsJ2xtaWRvdCc6J1xcXFx1MDE0MCcsJ0xtaWRvdCc6J1xcXFx1MDEzRicsJ2xtb3VzdCc6J1xcXFx1MjNCMCcsJ2xtb3VzdGFjaGUnOidcXFxcdTIzQjAnLCdsbmFwJzonXFxcXHUyQTg5JywnbG5hcHByb3gnOidcXFxcdTJBODknLCdsbmUnOidcXFxcdTJBODcnLCdsbkUnOidcXFxcdTIyNjgnLCdsbmVxJzonXFxcXHUyQTg3JywnbG5lcXEnOidcXFxcdTIyNjgnLCdsbnNpbSc6J1xcXFx1MjJFNicsJ2xvYW5nJzonXFxcXHUyN0VDJywnbG9hcnInOidcXFxcdTIxRkQnLCdsb2Jyayc6J1xcXFx1MjdFNicsJ2xvbmdsZWZ0YXJyb3cnOidcXFxcdTI3RjUnLCdMb25nbGVmdGFycm93JzonXFxcXHUyN0Y4JywnTG9uZ0xlZnRBcnJvdyc6J1xcXFx1MjdGNScsJ2xvbmdsZWZ0cmlnaHRhcnJvdyc6J1xcXFx1MjdGNycsJ0xvbmdsZWZ0cmlnaHRhcnJvdyc6J1xcXFx1MjdGQScsJ0xvbmdMZWZ0UmlnaHRBcnJvdyc6J1xcXFx1MjdGNycsJ2xvbmdtYXBzdG8nOidcXFxcdTI3RkMnLCdsb25ncmlnaHRhcnJvdyc6J1xcXFx1MjdGNicsJ0xvbmdyaWdodGFycm93JzonXFxcXHUyN0Y5JywnTG9uZ1JpZ2h0QXJyb3cnOidcXFxcdTI3RjYnLCdsb29wYXJyb3dsZWZ0JzonXFxcXHUyMUFCJywnbG9vcGFycm93cmlnaHQnOidcXFxcdTIxQUMnLCdsb3Bhcic6J1xcXFx1Mjk4NScsJ2xvcGYnOidcXFxcdUQ4MzVcXFxcdURENUQnLCdMb3BmJzonXFxcXHVEODM1XFxcXHVERDQzJywnbG9wbHVzJzonXFxcXHUyQTJEJywnbG90aW1lcyc6J1xcXFx1MkEzNCcsJ2xvd2FzdCc6J1xcXFx1MjIxNycsJ2xvd2Jhcic6J18nLCdMb3dlckxlZnRBcnJvdyc6J1xcXFx1MjE5OScsJ0xvd2VyUmlnaHRBcnJvdyc6J1xcXFx1MjE5OCcsJ2xveic6J1xcXFx1MjVDQScsJ2xvemVuZ2UnOidcXFxcdTI1Q0EnLCdsb3pmJzonXFxcXHUyOUVCJywnbHBhcic6JygnLCdscGFybHQnOidcXFxcdTI5OTMnLCdscmFycic6J1xcXFx1MjFDNicsJ2xyY29ybmVyJzonXFxcXHUyMzFGJywnbHJoYXInOidcXFxcdTIxQ0InLCdscmhhcmQnOidcXFxcdTI5NkQnLCdscm0nOidcXFxcdTIwMEUnLCdscnRyaSc6J1xcXFx1MjJCRicsJ2xzYXF1byc6J1xcXFx1MjAzOScsJ2xzY3InOidcXFxcdUQ4MzVcXFxcdURDQzEnLCdMc2NyJzonXFxcXHUyMTEyJywnbHNoJzonXFxcXHUyMUIwJywnTHNoJzonXFxcXHUyMUIwJywnbHNpbSc6J1xcXFx1MjI3MicsJ2xzaW1lJzonXFxcXHUyQThEJywnbHNpbWcnOidcXFxcdTJBOEYnLCdsc3FiJzonWycsJ2xzcXVvJzonXFxcXHUyMDE4JywnbHNxdW9yJzonXFxcXHUyMDFBJywnbHN0cm9rJzonXFxcXHUwMTQyJywnTHN0cm9rJzonXFxcXHUwMTQxJywnbHQnOic8JywnTHQnOidcXFxcdTIyNkEnLCdMVCc6JzwnLCdsdGNjJzonXFxcXHUyQUE2JywnbHRjaXInOidcXFxcdTJBNzknLCdsdGRvdCc6J1xcXFx1MjJENicsJ2x0aHJlZSc6J1xcXFx1MjJDQicsJ2x0aW1lcyc6J1xcXFx1MjJDOScsJ2x0bGFycic6J1xcXFx1Mjk3NicsJ2x0cXVlc3QnOidcXFxcdTJBN0InLCdsdHJpJzonXFxcXHUyNUMzJywnbHRyaWUnOidcXFxcdTIyQjQnLCdsdHJpZic6J1xcXFx1MjVDMicsJ2x0clBhcic6J1xcXFx1Mjk5NicsJ2x1cmRzaGFyJzonXFxcXHUyOTRBJywnbHVydWhhcic6J1xcXFx1Mjk2NicsJ2x2ZXJ0bmVxcSc6J1xcXFx1MjI2OFxcXFx1RkUwMCcsJ2x2bkUnOidcXFxcdTIyNjhcXFxcdUZFMDAnLCdtYWNyJzonXFxcXHhBRicsJ21hbGUnOidcXFxcdTI2NDInLCdtYWx0JzonXFxcXHUyNzIwJywnbWFsdGVzZSc6J1xcXFx1MjcyMCcsJ21hcCc6J1xcXFx1MjFBNicsJ01hcCc6J1xcXFx1MjkwNScsJ21hcHN0byc6J1xcXFx1MjFBNicsJ21hcHN0b2Rvd24nOidcXFxcdTIxQTcnLCdtYXBzdG9sZWZ0JzonXFxcXHUyMUE0JywnbWFwc3RvdXAnOidcXFxcdTIxQTUnLCdtYXJrZXInOidcXFxcdTI1QUUnLCdtY29tbWEnOidcXFxcdTJBMjknLCdtY3knOidcXFxcdTA0M0MnLCdNY3knOidcXFxcdTA0MUMnLCdtZGFzaCc6J1xcXFx1MjAxNCcsJ21ERG90JzonXFxcXHUyMjNBJywnbWVhc3VyZWRhbmdsZSc6J1xcXFx1MjIyMScsJ01lZGl1bVNwYWNlJzonXFxcXHUyMDVGJywnTWVsbGludHJmJzonXFxcXHUyMTMzJywnbWZyJzonXFxcXHVEODM1XFxcXHVERDJBJywnTWZyJzonXFxcXHVEODM1XFxcXHVERDEwJywnbWhvJzonXFxcXHUyMTI3JywnbWljcm8nOidcXFxceEI1JywnbWlkJzonXFxcXHUyMjIzJywnbWlkYXN0JzonKicsJ21pZGNpcic6J1xcXFx1MkFGMCcsJ21pZGRvdCc6J1xcXFx4QjcnLCdtaW51cyc6J1xcXFx1MjIxMicsJ21pbnVzYic6J1xcXFx1MjI5RicsJ21pbnVzZCc6J1xcXFx1MjIzOCcsJ21pbnVzZHUnOidcXFxcdTJBMkEnLCdNaW51c1BsdXMnOidcXFxcdTIyMTMnLCdtbGNwJzonXFxcXHUyQURCJywnbWxkcic6J1xcXFx1MjAyNicsJ21ucGx1cyc6J1xcXFx1MjIxMycsJ21vZGVscyc6J1xcXFx1MjJBNycsJ21vcGYnOidcXFxcdUQ4MzVcXFxcdURENUUnLCdNb3BmJzonXFxcXHVEODM1XFxcXHVERDQ0JywnbXAnOidcXFxcdTIyMTMnLCdtc2NyJzonXFxcXHVEODM1XFxcXHVEQ0MyJywnTXNjcic6J1xcXFx1MjEzMycsJ21zdHBvcyc6J1xcXFx1MjIzRScsJ211JzonXFxcXHUwM0JDJywnTXUnOidcXFxcdTAzOUMnLCdtdWx0aW1hcCc6J1xcXFx1MjJCOCcsJ211bWFwJzonXFxcXHUyMkI4JywnbmFibGEnOidcXFxcdTIyMDcnLCduYWN1dGUnOidcXFxcdTAxNDQnLCdOYWN1dGUnOidcXFxcdTAxNDMnLCduYW5nJzonXFxcXHUyMjIwXFxcXHUyMEQyJywnbmFwJzonXFxcXHUyMjQ5JywnbmFwRSc6J1xcXFx1MkE3MFxcXFx1MDMzOCcsJ25hcGlkJzonXFxcXHUyMjRCXFxcXHUwMzM4JywnbmFwb3MnOidcXFxcdTAxNDknLCduYXBwcm94JzonXFxcXHUyMjQ5JywnbmF0dXInOidcXFxcdTI2NkUnLCduYXR1cmFsJzonXFxcXHUyNjZFJywnbmF0dXJhbHMnOidcXFxcdTIxMTUnLCduYnNwJzonXFxcXHhBMCcsJ25idW1wJzonXFxcXHUyMjRFXFxcXHUwMzM4JywnbmJ1bXBlJzonXFxcXHUyMjRGXFxcXHUwMzM4JywnbmNhcCc6J1xcXFx1MkE0MycsJ25jYXJvbic6J1xcXFx1MDE0OCcsJ05jYXJvbic6J1xcXFx1MDE0NycsJ25jZWRpbCc6J1xcXFx1MDE0NicsJ05jZWRpbCc6J1xcXFx1MDE0NScsJ25jb25nJzonXFxcXHUyMjQ3JywnbmNvbmdkb3QnOidcXFxcdTJBNkRcXFxcdTAzMzgnLCduY3VwJzonXFxcXHUyQTQyJywnbmN5JzonXFxcXHUwNDNEJywnTmN5JzonXFxcXHUwNDFEJywnbmRhc2gnOidcXFxcdTIwMTMnLCduZSc6J1xcXFx1MjI2MCcsJ25lYXJoayc6J1xcXFx1MjkyNCcsJ25lYXJyJzonXFxcXHUyMTk3JywnbmVBcnInOidcXFxcdTIxRDcnLCduZWFycm93JzonXFxcXHUyMTk3JywnbmVkb3QnOidcXFxcdTIyNTBcXFxcdTAzMzgnLCdOZWdhdGl2ZU1lZGl1bVNwYWNlJzonXFxcXHUyMDBCJywnTmVnYXRpdmVUaGlja1NwYWNlJzonXFxcXHUyMDBCJywnTmVnYXRpdmVUaGluU3BhY2UnOidcXFxcdTIwMEInLCdOZWdhdGl2ZVZlcnlUaGluU3BhY2UnOidcXFxcdTIwMEInLCduZXF1aXYnOidcXFxcdTIyNjInLCduZXNlYXInOidcXFxcdTI5MjgnLCduZXNpbSc6J1xcXFx1MjI0MlxcXFx1MDMzOCcsJ05lc3RlZEdyZWF0ZXJHcmVhdGVyJzonXFxcXHUyMjZCJywnTmVzdGVkTGVzc0xlc3MnOidcXFxcdTIyNkEnLCdOZXdMaW5lJzonXFxcXG4nLCduZXhpc3QnOidcXFxcdTIyMDQnLCduZXhpc3RzJzonXFxcXHUyMjA0JywnbmZyJzonXFxcXHVEODM1XFxcXHVERDJCJywnTmZyJzonXFxcXHVEODM1XFxcXHVERDExJywnbmdlJzonXFxcXHUyMjcxJywnbmdFJzonXFxcXHUyMjY3XFxcXHUwMzM4JywnbmdlcSc6J1xcXFx1MjI3MScsJ25nZXFxJzonXFxcXHUyMjY3XFxcXHUwMzM4JywnbmdlcXNsYW50JzonXFxcXHUyQTdFXFxcXHUwMzM4Jywnbmdlcyc6J1xcXFx1MkE3RVxcXFx1MDMzOCcsJ25HZyc6J1xcXFx1MjJEOVxcXFx1MDMzOCcsJ25nc2ltJzonXFxcXHUyMjc1Jywnbmd0JzonXFxcXHUyMjZGJywnbkd0JzonXFxcXHUyMjZCXFxcXHUyMEQyJywnbmd0cic6J1xcXFx1MjI2RicsJ25HdHYnOidcXFxcdTIyNkJcXFxcdTAzMzgnLCduaGFycic6J1xcXFx1MjFBRScsJ25oQXJyJzonXFxcXHUyMUNFJywnbmhwYXInOidcXFxcdTJBRjInLCduaSc6J1xcXFx1MjIwQicsJ25pcyc6J1xcXFx1MjJGQycsJ25pc2QnOidcXFxcdTIyRkEnLCduaXYnOidcXFxcdTIyMEInLCduamN5JzonXFxcXHUwNDVBJywnTkpjeSc6J1xcXFx1MDQwQScsJ25sYXJyJzonXFxcXHUyMTlBJywnbmxBcnInOidcXFxcdTIxQ0QnLCdubGRyJzonXFxcXHUyMDI1JywnbmxlJzonXFxcXHUyMjcwJywnbmxFJzonXFxcXHUyMjY2XFxcXHUwMzM4JywnbmxlZnRhcnJvdyc6J1xcXFx1MjE5QScsJ25MZWZ0YXJyb3cnOidcXFxcdTIxQ0QnLCdubGVmdHJpZ2h0YXJyb3cnOidcXFxcdTIxQUUnLCduTGVmdHJpZ2h0YXJyb3cnOidcXFxcdTIxQ0UnLCdubGVxJzonXFxcXHUyMjcwJywnbmxlcXEnOidcXFxcdTIyNjZcXFxcdTAzMzgnLCdubGVxc2xhbnQnOidcXFxcdTJBN0RcXFxcdTAzMzgnLCdubGVzJzonXFxcXHUyQTdEXFxcXHUwMzM4Jywnbmxlc3MnOidcXFxcdTIyNkUnLCduTGwnOidcXFxcdTIyRDhcXFxcdTAzMzgnLCdubHNpbSc6J1xcXFx1MjI3NCcsJ25sdCc6J1xcXFx1MjI2RScsJ25MdCc6J1xcXFx1MjI2QVxcXFx1MjBEMicsJ25sdHJpJzonXFxcXHUyMkVBJywnbmx0cmllJzonXFxcXHUyMkVDJywnbkx0dic6J1xcXFx1MjI2QVxcXFx1MDMzOCcsJ25taWQnOidcXFxcdTIyMjQnLCdOb0JyZWFrJzonXFxcXHUyMDYwJywnTm9uQnJlYWtpbmdTcGFjZSc6J1xcXFx4QTAnLCdub3BmJzonXFxcXHVEODM1XFxcXHVERDVGJywnTm9wZic6J1xcXFx1MjExNScsJ25vdCc6J1xcXFx4QUMnLCdOb3QnOidcXFxcdTJBRUMnLCdOb3RDb25ncnVlbnQnOidcXFxcdTIyNjInLCdOb3RDdXBDYXAnOidcXFxcdTIyNkQnLCdOb3REb3VibGVWZXJ0aWNhbEJhcic6J1xcXFx1MjIyNicsJ05vdEVsZW1lbnQnOidcXFxcdTIyMDknLCdOb3RFcXVhbCc6J1xcXFx1MjI2MCcsJ05vdEVxdWFsVGlsZGUnOidcXFxcdTIyNDJcXFxcdTAzMzgnLCdOb3RFeGlzdHMnOidcXFxcdTIyMDQnLCdOb3RHcmVhdGVyJzonXFxcXHUyMjZGJywnTm90R3JlYXRlckVxdWFsJzonXFxcXHUyMjcxJywnTm90R3JlYXRlckZ1bGxFcXVhbCc6J1xcXFx1MjI2N1xcXFx1MDMzOCcsJ05vdEdyZWF0ZXJHcmVhdGVyJzonXFxcXHUyMjZCXFxcXHUwMzM4JywnTm90R3JlYXRlckxlc3MnOidcXFxcdTIyNzknLCdOb3RHcmVhdGVyU2xhbnRFcXVhbCc6J1xcXFx1MkE3RVxcXFx1MDMzOCcsJ05vdEdyZWF0ZXJUaWxkZSc6J1xcXFx1MjI3NScsJ05vdEh1bXBEb3duSHVtcCc6J1xcXFx1MjI0RVxcXFx1MDMzOCcsJ05vdEh1bXBFcXVhbCc6J1xcXFx1MjI0RlxcXFx1MDMzOCcsJ25vdGluJzonXFxcXHUyMjA5Jywnbm90aW5kb3QnOidcXFxcdTIyRjVcXFxcdTAzMzgnLCdub3RpbkUnOidcXFxcdTIyRjlcXFxcdTAzMzgnLCdub3RpbnZhJzonXFxcXHUyMjA5Jywnbm90aW52Yic6J1xcXFx1MjJGNycsJ25vdGludmMnOidcXFxcdTIyRjYnLCdOb3RMZWZ0VHJpYW5nbGUnOidcXFxcdTIyRUEnLCdOb3RMZWZ0VHJpYW5nbGVCYXInOidcXFxcdTI5Q0ZcXFxcdTAzMzgnLCdOb3RMZWZ0VHJpYW5nbGVFcXVhbCc6J1xcXFx1MjJFQycsJ05vdExlc3MnOidcXFxcdTIyNkUnLCdOb3RMZXNzRXF1YWwnOidcXFxcdTIyNzAnLCdOb3RMZXNzR3JlYXRlcic6J1xcXFx1MjI3OCcsJ05vdExlc3NMZXNzJzonXFxcXHUyMjZBXFxcXHUwMzM4JywnTm90TGVzc1NsYW50RXF1YWwnOidcXFxcdTJBN0RcXFxcdTAzMzgnLCdOb3RMZXNzVGlsZGUnOidcXFxcdTIyNzQnLCdOb3ROZXN0ZWRHcmVhdGVyR3JlYXRlcic6J1xcXFx1MkFBMlxcXFx1MDMzOCcsJ05vdE5lc3RlZExlc3NMZXNzJzonXFxcXHUyQUExXFxcXHUwMzM4Jywnbm90bmknOidcXFxcdTIyMEMnLCdub3RuaXZhJzonXFxcXHUyMjBDJywnbm90bml2Yic6J1xcXFx1MjJGRScsJ25vdG5pdmMnOidcXFxcdTIyRkQnLCdOb3RQcmVjZWRlcyc6J1xcXFx1MjI4MCcsJ05vdFByZWNlZGVzRXF1YWwnOidcXFxcdTJBQUZcXFxcdTAzMzgnLCdOb3RQcmVjZWRlc1NsYW50RXF1YWwnOidcXFxcdTIyRTAnLCdOb3RSZXZlcnNlRWxlbWVudCc6J1xcXFx1MjIwQycsJ05vdFJpZ2h0VHJpYW5nbGUnOidcXFxcdTIyRUInLCdOb3RSaWdodFRyaWFuZ2xlQmFyJzonXFxcXHUyOUQwXFxcXHUwMzM4JywnTm90UmlnaHRUcmlhbmdsZUVxdWFsJzonXFxcXHUyMkVEJywnTm90U3F1YXJlU3Vic2V0JzonXFxcXHUyMjhGXFxcXHUwMzM4JywnTm90U3F1YXJlU3Vic2V0RXF1YWwnOidcXFxcdTIyRTInLCdOb3RTcXVhcmVTdXBlcnNldCc6J1xcXFx1MjI5MFxcXFx1MDMzOCcsJ05vdFNxdWFyZVN1cGVyc2V0RXF1YWwnOidcXFxcdTIyRTMnLCdOb3RTdWJzZXQnOidcXFxcdTIyODJcXFxcdTIwRDInLCdOb3RTdWJzZXRFcXVhbCc6J1xcXFx1MjI4OCcsJ05vdFN1Y2NlZWRzJzonXFxcXHUyMjgxJywnTm90U3VjY2VlZHNFcXVhbCc6J1xcXFx1MkFCMFxcXFx1MDMzOCcsJ05vdFN1Y2NlZWRzU2xhbnRFcXVhbCc6J1xcXFx1MjJFMScsJ05vdFN1Y2NlZWRzVGlsZGUnOidcXFxcdTIyN0ZcXFxcdTAzMzgnLCdOb3RTdXBlcnNldCc6J1xcXFx1MjI4M1xcXFx1MjBEMicsJ05vdFN1cGVyc2V0RXF1YWwnOidcXFxcdTIyODknLCdOb3RUaWxkZSc6J1xcXFx1MjI0MScsJ05vdFRpbGRlRXF1YWwnOidcXFxcdTIyNDQnLCdOb3RUaWxkZUZ1bGxFcXVhbCc6J1xcXFx1MjI0NycsJ05vdFRpbGRlVGlsZGUnOidcXFxcdTIyNDknLCdOb3RWZXJ0aWNhbEJhcic6J1xcXFx1MjIyNCcsJ25wYXInOidcXFxcdTIyMjYnLCducGFyYWxsZWwnOidcXFxcdTIyMjYnLCducGFyc2wnOidcXFxcdTJBRkRcXFxcdTIwRTUnLCducGFydCc6J1xcXFx1MjIwMlxcXFx1MDMzOCcsJ25wb2xpbnQnOidcXFxcdTJBMTQnLCducHInOidcXFxcdTIyODAnLCducHJjdWUnOidcXFxcdTIyRTAnLCducHJlJzonXFxcXHUyQUFGXFxcXHUwMzM4JywnbnByZWMnOidcXFxcdTIyODAnLCducHJlY2VxJzonXFxcXHUyQUFGXFxcXHUwMzM4JywnbnJhcnInOidcXFxcdTIxOUInLCduckFycic6J1xcXFx1MjFDRicsJ25yYXJyYyc6J1xcXFx1MjkzM1xcXFx1MDMzOCcsJ25yYXJydyc6J1xcXFx1MjE5RFxcXFx1MDMzOCcsJ25yaWdodGFycm93JzonXFxcXHUyMTlCJywnblJpZ2h0YXJyb3cnOidcXFxcdTIxQ0YnLCducnRyaSc6J1xcXFx1MjJFQicsJ25ydHJpZSc6J1xcXFx1MjJFRCcsJ25zYyc6J1xcXFx1MjI4MScsJ25zY2N1ZSc6J1xcXFx1MjJFMScsJ25zY2UnOidcXFxcdTJBQjBcXFxcdTAzMzgnLCduc2NyJzonXFxcXHVEODM1XFxcXHVEQ0MzJywnTnNjcic6J1xcXFx1RDgzNVxcXFx1RENBOScsJ25zaG9ydG1pZCc6J1xcXFx1MjIyNCcsJ25zaG9ydHBhcmFsbGVsJzonXFxcXHUyMjI2JywnbnNpbSc6J1xcXFx1MjI0MScsJ25zaW1lJzonXFxcXHUyMjQ0JywnbnNpbWVxJzonXFxcXHUyMjQ0JywnbnNtaWQnOidcXFxcdTIyMjQnLCduc3Bhcic6J1xcXFx1MjIyNicsJ25zcXN1YmUnOidcXFxcdTIyRTInLCduc3FzdXBlJzonXFxcXHUyMkUzJywnbnN1Yic6J1xcXFx1MjI4NCcsJ25zdWJlJzonXFxcXHUyMjg4JywnbnN1YkUnOidcXFxcdTJBQzVcXFxcdTAzMzgnLCduc3Vic2V0JzonXFxcXHUyMjgyXFxcXHUyMEQyJywnbnN1YnNldGVxJzonXFxcXHUyMjg4JywnbnN1YnNldGVxcSc6J1xcXFx1MkFDNVxcXFx1MDMzOCcsJ25zdWNjJzonXFxcXHUyMjgxJywnbnN1Y2NlcSc6J1xcXFx1MkFCMFxcXFx1MDMzOCcsJ25zdXAnOidcXFxcdTIyODUnLCduc3VwZSc6J1xcXFx1MjI4OScsJ25zdXBFJzonXFxcXHUyQUM2XFxcXHUwMzM4JywnbnN1cHNldCc6J1xcXFx1MjI4M1xcXFx1MjBEMicsJ25zdXBzZXRlcSc6J1xcXFx1MjI4OScsJ25zdXBzZXRlcXEnOidcXFxcdTJBQzZcXFxcdTAzMzgnLCdudGdsJzonXFxcXHUyMjc5JywnbnRpbGRlJzonXFxcXHhGMScsJ050aWxkZSc6J1xcXFx4RDEnLCdudGxnJzonXFxcXHUyMjc4JywnbnRyaWFuZ2xlbGVmdCc6J1xcXFx1MjJFQScsJ250cmlhbmdsZWxlZnRlcSc6J1xcXFx1MjJFQycsJ250cmlhbmdsZXJpZ2h0JzonXFxcXHUyMkVCJywnbnRyaWFuZ2xlcmlnaHRlcSc6J1xcXFx1MjJFRCcsJ251JzonXFxcXHUwM0JEJywnTnUnOidcXFxcdTAzOUQnLCdudW0nOicjJywnbnVtZXJvJzonXFxcXHUyMTE2JywnbnVtc3AnOidcXFxcdTIwMDcnLCdudmFwJzonXFxcXHUyMjREXFxcXHUyMEQyJywnbnZkYXNoJzonXFxcXHUyMkFDJywnbnZEYXNoJzonXFxcXHUyMkFEJywnblZkYXNoJzonXFxcXHUyMkFFJywnblZEYXNoJzonXFxcXHUyMkFGJywnbnZnZSc6J1xcXFx1MjI2NVxcXFx1MjBEMicsJ252Z3QnOic+XFxcXHUyMEQyJywnbnZIYXJyJzonXFxcXHUyOTA0JywnbnZpbmZpbic6J1xcXFx1MjlERScsJ252bEFycic6J1xcXFx1MjkwMicsJ252bGUnOidcXFxcdTIyNjRcXFxcdTIwRDInLCdudmx0JzonPFxcXFx1MjBEMicsJ252bHRyaWUnOidcXFxcdTIyQjRcXFxcdTIwRDInLCdudnJBcnInOidcXFxcdTI5MDMnLCdudnJ0cmllJzonXFxcXHUyMkI1XFxcXHUyMEQyJywnbnZzaW0nOidcXFxcdTIyM0NcXFxcdTIwRDInLCdud2FyaGsnOidcXFxcdTI5MjMnLCdud2Fycic6J1xcXFx1MjE5NicsJ253QXJyJzonXFxcXHUyMUQ2JywnbndhcnJvdyc6J1xcXFx1MjE5NicsJ253bmVhcic6J1xcXFx1MjkyNycsJ29hY3V0ZSc6J1xcXFx4RjMnLCdPYWN1dGUnOidcXFxceEQzJywnb2FzdCc6J1xcXFx1MjI5QicsJ29jaXInOidcXFxcdTIyOUEnLCdvY2lyYyc6J1xcXFx4RjQnLCdPY2lyYyc6J1xcXFx4RDQnLCdvY3knOidcXFxcdTA0M0UnLCdPY3knOidcXFxcdTA0MUUnLCdvZGFzaCc6J1xcXFx1MjI5RCcsJ29kYmxhYyc6J1xcXFx1MDE1MScsJ09kYmxhYyc6J1xcXFx1MDE1MCcsJ29kaXYnOidcXFxcdTJBMzgnLCdvZG90JzonXFxcXHUyMjk5Jywnb2Rzb2xkJzonXFxcXHUyOUJDJywnb2VsaWcnOidcXFxcdTAxNTMnLCdPRWxpZyc6J1xcXFx1MDE1MicsJ29mY2lyJzonXFxcXHUyOUJGJywnb2ZyJzonXFxcXHVEODM1XFxcXHVERDJDJywnT2ZyJzonXFxcXHVEODM1XFxcXHVERDEyJywnb2dvbic6J1xcXFx1MDJEQicsJ29ncmF2ZSc6J1xcXFx4RjInLCdPZ3JhdmUnOidcXFxceEQyJywnb2d0JzonXFxcXHUyOUMxJywnb2hiYXInOidcXFxcdTI5QjUnLCdvaG0nOidcXFxcdTAzQTknLCdvaW50JzonXFxcXHUyMjJFJywnb2xhcnInOidcXFxcdTIxQkEnLCdvbGNpcic6J1xcXFx1MjlCRScsJ29sY3Jvc3MnOidcXFxcdTI5QkInLCdvbGluZSc6J1xcXFx1MjAzRScsJ29sdCc6J1xcXFx1MjlDMCcsJ29tYWNyJzonXFxcXHUwMTREJywnT21hY3InOidcXFxcdTAxNEMnLCdvbWVnYSc6J1xcXFx1MDNDOScsJ09tZWdhJzonXFxcXHUwM0E5Jywnb21pY3Jvbic6J1xcXFx1MDNCRicsJ09taWNyb24nOidcXFxcdTAzOUYnLCdvbWlkJzonXFxcXHUyOUI2Jywnb21pbnVzJzonXFxcXHUyMjk2Jywnb29wZic6J1xcXFx1RDgzNVxcXFx1REQ2MCcsJ09vcGYnOidcXFxcdUQ4MzVcXFxcdURENDYnLCdvcGFyJzonXFxcXHUyOUI3JywnT3BlbkN1cmx5RG91YmxlUXVvdGUnOidcXFxcdTIwMUMnLCdPcGVuQ3VybHlRdW90ZSc6J1xcXFx1MjAxOCcsJ29wZXJwJzonXFxcXHUyOUI5Jywnb3BsdXMnOidcXFxcdTIyOTUnLCdvcic6J1xcXFx1MjIyOCcsJ09yJzonXFxcXHUyQTU0Jywnb3JhcnInOidcXFxcdTIxQkInLCdvcmQnOidcXFxcdTJBNUQnLCdvcmRlcic6J1xcXFx1MjEzNCcsJ29yZGVyb2YnOidcXFxcdTIxMzQnLCdvcmRmJzonXFxcXHhBQScsJ29yZG0nOidcXFxceEJBJywnb3JpZ29mJzonXFxcXHUyMkI2Jywnb3Jvcic6J1xcXFx1MkE1NicsJ29yc2xvcGUnOidcXFxcdTJBNTcnLCdvcnYnOidcXFxcdTJBNUInLCdvUyc6J1xcXFx1MjRDOCcsJ29zY3InOidcXFxcdTIxMzQnLCdPc2NyJzonXFxcXHVEODM1XFxcXHVEQ0FBJywnb3NsYXNoJzonXFxcXHhGOCcsJ09zbGFzaCc6J1xcXFx4RDgnLCdvc29sJzonXFxcXHUyMjk4Jywnb3RpbGRlJzonXFxcXHhGNScsJ090aWxkZSc6J1xcXFx4RDUnLCdvdGltZXMnOidcXFxcdTIyOTcnLCdPdGltZXMnOidcXFxcdTJBMzcnLCdvdGltZXNhcyc6J1xcXFx1MkEzNicsJ291bWwnOidcXFxceEY2JywnT3VtbCc6J1xcXFx4RDYnLCdvdmJhcic6J1xcXFx1MjMzRCcsJ092ZXJCYXInOidcXFxcdTIwM0UnLCdPdmVyQnJhY2UnOidcXFxcdTIzREUnLCdPdmVyQnJhY2tldCc6J1xcXFx1MjNCNCcsJ092ZXJQYXJlbnRoZXNpcyc6J1xcXFx1MjNEQycsJ3Bhcic6J1xcXFx1MjIyNScsJ3BhcmEnOidcXFxceEI2JywncGFyYWxsZWwnOidcXFxcdTIyMjUnLCdwYXJzaW0nOidcXFxcdTJBRjMnLCdwYXJzbCc6J1xcXFx1MkFGRCcsJ3BhcnQnOidcXFxcdTIyMDInLCdQYXJ0aWFsRCc6J1xcXFx1MjIwMicsJ3BjeSc6J1xcXFx1MDQzRicsJ1BjeSc6J1xcXFx1MDQxRicsJ3BlcmNudCc6JyUnLCdwZXJpb2QnOicuJywncGVybWlsJzonXFxcXHUyMDMwJywncGVycCc6J1xcXFx1MjJBNScsJ3BlcnRlbmsnOidcXFxcdTIwMzEnLCdwZnInOidcXFxcdUQ4MzVcXFxcdUREMkQnLCdQZnInOidcXFxcdUQ4MzVcXFxcdUREMTMnLCdwaGknOidcXFxcdTAzQzYnLCdQaGknOidcXFxcdTAzQTYnLCdwaGl2JzonXFxcXHUwM0Q1JywncGhtbWF0JzonXFxcXHUyMTMzJywncGhvbmUnOidcXFxcdTI2MEUnLCdwaSc6J1xcXFx1MDNDMCcsJ1BpJzonXFxcXHUwM0EwJywncGl0Y2hmb3JrJzonXFxcXHUyMkQ0JywncGl2JzonXFxcXHUwM0Q2JywncGxhbmNrJzonXFxcXHUyMTBGJywncGxhbmNraCc6J1xcXFx1MjEwRScsJ3BsYW5rdic6J1xcXFx1MjEwRicsJ3BsdXMnOicrJywncGx1c2FjaXInOidcXFxcdTJBMjMnLCdwbHVzYic6J1xcXFx1MjI5RScsJ3BsdXNjaXInOidcXFxcdTJBMjInLCdwbHVzZG8nOidcXFxcdTIyMTQnLCdwbHVzZHUnOidcXFxcdTJBMjUnLCdwbHVzZSc6J1xcXFx1MkE3MicsJ1BsdXNNaW51cyc6J1xcXFx4QjEnLCdwbHVzbW4nOidcXFxceEIxJywncGx1c3NpbSc6J1xcXFx1MkEyNicsJ3BsdXN0d28nOidcXFxcdTJBMjcnLCdwbSc6J1xcXFx4QjEnLCdQb2luY2FyZXBsYW5lJzonXFxcXHUyMTBDJywncG9pbnRpbnQnOidcXFxcdTJBMTUnLCdwb3BmJzonXFxcXHVEODM1XFxcXHVERDYxJywnUG9wZic6J1xcXFx1MjExOScsJ3BvdW5kJzonXFxcXHhBMycsJ3ByJzonXFxcXHUyMjdBJywnUHInOidcXFxcdTJBQkInLCdwcmFwJzonXFxcXHUyQUI3JywncHJjdWUnOidcXFxcdTIyN0MnLCdwcmUnOidcXFxcdTJBQUYnLCdwckUnOidcXFxcdTJBQjMnLCdwcmVjJzonXFxcXHUyMjdBJywncHJlY2FwcHJveCc6J1xcXFx1MkFCNycsJ3ByZWNjdXJseWVxJzonXFxcXHUyMjdDJywnUHJlY2VkZXMnOidcXFxcdTIyN0EnLCdQcmVjZWRlc0VxdWFsJzonXFxcXHUyQUFGJywnUHJlY2VkZXNTbGFudEVxdWFsJzonXFxcXHUyMjdDJywnUHJlY2VkZXNUaWxkZSc6J1xcXFx1MjI3RScsJ3ByZWNlcSc6J1xcXFx1MkFBRicsJ3ByZWNuYXBwcm94JzonXFxcXHUyQUI5JywncHJlY25lcXEnOidcXFxcdTJBQjUnLCdwcmVjbnNpbSc6J1xcXFx1MjJFOCcsJ3ByZWNzaW0nOidcXFxcdTIyN0UnLCdwcmltZSc6J1xcXFx1MjAzMicsJ1ByaW1lJzonXFxcXHUyMDMzJywncHJpbWVzJzonXFxcXHUyMTE5JywncHJuYXAnOidcXFxcdTJBQjknLCdwcm5FJzonXFxcXHUyQUI1JywncHJuc2ltJzonXFxcXHUyMkU4JywncHJvZCc6J1xcXFx1MjIwRicsJ1Byb2R1Y3QnOidcXFxcdTIyMEYnLCdwcm9mYWxhcic6J1xcXFx1MjMyRScsJ3Byb2ZsaW5lJzonXFxcXHUyMzEyJywncHJvZnN1cmYnOidcXFxcdTIzMTMnLCdwcm9wJzonXFxcXHUyMjFEJywnUHJvcG9ydGlvbic6J1xcXFx1MjIzNycsJ1Byb3BvcnRpb25hbCc6J1xcXFx1MjIxRCcsJ3Byb3B0byc6J1xcXFx1MjIxRCcsJ3Byc2ltJzonXFxcXHUyMjdFJywncHJ1cmVsJzonXFxcXHUyMkIwJywncHNjcic6J1xcXFx1RDgzNVxcXFx1RENDNScsJ1BzY3InOidcXFxcdUQ4MzVcXFxcdURDQUInLCdwc2knOidcXFxcdTAzQzgnLCdQc2knOidcXFxcdTAzQTgnLCdwdW5jc3AnOidcXFxcdTIwMDgnLCdxZnInOidcXFxcdUQ4MzVcXFxcdUREMkUnLCdRZnInOidcXFxcdUQ4MzVcXFxcdUREMTQnLCdxaW50JzonXFxcXHUyQTBDJywncW9wZic6J1xcXFx1RDgzNVxcXFx1REQ2MicsJ1FvcGYnOidcXFxcdTIxMUEnLCdxcHJpbWUnOidcXFxcdTIwNTcnLCdxc2NyJzonXFxcXHVEODM1XFxcXHVEQ0M2JywnUXNjcic6J1xcXFx1RDgzNVxcXFx1RENBQycsJ3F1YXRlcm5pb25zJzonXFxcXHUyMTBEJywncXVhdGludCc6J1xcXFx1MkExNicsJ3F1ZXN0JzonPycsJ3F1ZXN0ZXEnOidcXFxcdTIyNUYnLCdxdW90JzonXFxcIicsJ1FVT1QnOidcXFwiJywnckFhcnInOidcXFxcdTIxREInLCdyYWNlJzonXFxcXHUyMjNEXFxcXHUwMzMxJywncmFjdXRlJzonXFxcXHUwMTU1JywnUmFjdXRlJzonXFxcXHUwMTU0JywncmFkaWMnOidcXFxcdTIyMUEnLCdyYWVtcHR5dic6J1xcXFx1MjlCMycsJ3JhbmcnOidcXFxcdTI3RTknLCdSYW5nJzonXFxcXHUyN0VCJywncmFuZ2QnOidcXFxcdTI5OTInLCdyYW5nZSc6J1xcXFx1MjlBNScsJ3JhbmdsZSc6J1xcXFx1MjdFOScsJ3JhcXVvJzonXFxcXHhCQicsJ3JhcnInOidcXFxcdTIxOTInLCdyQXJyJzonXFxcXHUyMUQyJywnUmFycic6J1xcXFx1MjFBMCcsJ3JhcnJhcCc6J1xcXFx1Mjk3NScsJ3JhcnJiJzonXFxcXHUyMUU1JywncmFycmJmcyc6J1xcXFx1MjkyMCcsJ3JhcnJjJzonXFxcXHUyOTMzJywncmFycmZzJzonXFxcXHUyOTFFJywncmFycmhrJzonXFxcXHUyMUFBJywncmFycmxwJzonXFxcXHUyMUFDJywncmFycnBsJzonXFxcXHUyOTQ1JywncmFycnNpbSc6J1xcXFx1Mjk3NCcsJ3JhcnJ0bCc6J1xcXFx1MjFBMycsJ1JhcnJ0bCc6J1xcXFx1MjkxNicsJ3JhcnJ3JzonXFxcXHUyMTlEJywncmF0YWlsJzonXFxcXHUyOTFBJywnckF0YWlsJzonXFxcXHUyOTFDJywncmF0aW8nOidcXFxcdTIyMzYnLCdyYXRpb25hbHMnOidcXFxcdTIxMUEnLCdyYmFycic6J1xcXFx1MjkwRCcsJ3JCYXJyJzonXFxcXHUyOTBGJywnUkJhcnInOidcXFxcdTI5MTAnLCdyYmJyayc6J1xcXFx1Mjc3MycsJ3JicmFjZSc6J30nLCdyYnJhY2snOiddJywncmJya2UnOidcXFxcdTI5OEMnLCdyYnJrc2xkJzonXFxcXHUyOThFJywncmJya3NsdSc6J1xcXFx1Mjk5MCcsJ3JjYXJvbic6J1xcXFx1MDE1OScsJ1JjYXJvbic6J1xcXFx1MDE1OCcsJ3JjZWRpbCc6J1xcXFx1MDE1NycsJ1JjZWRpbCc6J1xcXFx1MDE1NicsJ3JjZWlsJzonXFxcXHUyMzA5JywncmN1Yic6J30nLCdyY3knOidcXFxcdTA0NDAnLCdSY3knOidcXFxcdTA0MjAnLCdyZGNhJzonXFxcXHUyOTM3JywncmRsZGhhcic6J1xcXFx1Mjk2OScsJ3JkcXVvJzonXFxcXHUyMDFEJywncmRxdW9yJzonXFxcXHUyMDFEJywncmRzaCc6J1xcXFx1MjFCMycsJ1JlJzonXFxcXHUyMTFDJywncmVhbCc6J1xcXFx1MjExQycsJ3JlYWxpbmUnOidcXFxcdTIxMUInLCdyZWFscGFydCc6J1xcXFx1MjExQycsJ3JlYWxzJzonXFxcXHUyMTFEJywncmVjdCc6J1xcXFx1MjVBRCcsJ3JlZyc6J1xcXFx4QUUnLCdSRUcnOidcXFxceEFFJywnUmV2ZXJzZUVsZW1lbnQnOidcXFxcdTIyMEInLCdSZXZlcnNlRXF1aWxpYnJpdW0nOidcXFxcdTIxQ0InLCdSZXZlcnNlVXBFcXVpbGlicml1bSc6J1xcXFx1Mjk2RicsJ3JmaXNodCc6J1xcXFx1Mjk3RCcsJ3JmbG9vcic6J1xcXFx1MjMwQicsJ3Jmcic6J1xcXFx1RDgzNVxcXFx1REQyRicsJ1Jmcic6J1xcXFx1MjExQycsJ3JIYXInOidcXFxcdTI5NjQnLCdyaGFyZCc6J1xcXFx1MjFDMScsJ3JoYXJ1JzonXFxcXHUyMUMwJywncmhhcnVsJzonXFxcXHUyOTZDJywncmhvJzonXFxcXHUwM0MxJywnUmhvJzonXFxcXHUwM0ExJywncmhvdic6J1xcXFx1MDNGMScsJ1JpZ2h0QW5nbGVCcmFja2V0JzonXFxcXHUyN0U5JywncmlnaHRhcnJvdyc6J1xcXFx1MjE5MicsJ1JpZ2h0YXJyb3cnOidcXFxcdTIxRDInLCdSaWdodEFycm93JzonXFxcXHUyMTkyJywnUmlnaHRBcnJvd0Jhcic6J1xcXFx1MjFFNScsJ1JpZ2h0QXJyb3dMZWZ0QXJyb3cnOidcXFxcdTIxQzQnLCdyaWdodGFycm93dGFpbCc6J1xcXFx1MjFBMycsJ1JpZ2h0Q2VpbGluZyc6J1xcXFx1MjMwOScsJ1JpZ2h0RG91YmxlQnJhY2tldCc6J1xcXFx1MjdFNycsJ1JpZ2h0RG93blRlZVZlY3Rvcic6J1xcXFx1Mjk1RCcsJ1JpZ2h0RG93blZlY3Rvcic6J1xcXFx1MjFDMicsJ1JpZ2h0RG93blZlY3RvckJhcic6J1xcXFx1Mjk1NScsJ1JpZ2h0Rmxvb3InOidcXFxcdTIzMEInLCdyaWdodGhhcnBvb25kb3duJzonXFxcXHUyMUMxJywncmlnaHRoYXJwb29udXAnOidcXFxcdTIxQzAnLCdyaWdodGxlZnRhcnJvd3MnOidcXFxcdTIxQzQnLCdyaWdodGxlZnRoYXJwb29ucyc6J1xcXFx1MjFDQycsJ3JpZ2h0cmlnaHRhcnJvd3MnOidcXFxcdTIxQzknLCdyaWdodHNxdWlnYXJyb3cnOidcXFxcdTIxOUQnLCdSaWdodFRlZSc6J1xcXFx1MjJBMicsJ1JpZ2h0VGVlQXJyb3cnOidcXFxcdTIxQTYnLCdSaWdodFRlZVZlY3Rvcic6J1xcXFx1Mjk1QicsJ3JpZ2h0dGhyZWV0aW1lcyc6J1xcXFx1MjJDQycsJ1JpZ2h0VHJpYW5nbGUnOidcXFxcdTIyQjMnLCdSaWdodFRyaWFuZ2xlQmFyJzonXFxcXHUyOUQwJywnUmlnaHRUcmlhbmdsZUVxdWFsJzonXFxcXHUyMkI1JywnUmlnaHRVcERvd25WZWN0b3InOidcXFxcdTI5NEYnLCdSaWdodFVwVGVlVmVjdG9yJzonXFxcXHUyOTVDJywnUmlnaHRVcFZlY3Rvcic6J1xcXFx1MjFCRScsJ1JpZ2h0VXBWZWN0b3JCYXInOidcXFxcdTI5NTQnLCdSaWdodFZlY3Rvcic6J1xcXFx1MjFDMCcsJ1JpZ2h0VmVjdG9yQmFyJzonXFxcXHUyOTUzJywncmluZyc6J1xcXFx1MDJEQScsJ3Jpc2luZ2RvdHNlcSc6J1xcXFx1MjI1MycsJ3JsYXJyJzonXFxcXHUyMUM0JywncmxoYXInOidcXFxcdTIxQ0MnLCdybG0nOidcXFxcdTIwMEYnLCdybW91c3QnOidcXFxcdTIzQjEnLCdybW91c3RhY2hlJzonXFxcXHUyM0IxJywncm5taWQnOidcXFxcdTJBRUUnLCdyb2FuZyc6J1xcXFx1MjdFRCcsJ3JvYXJyJzonXFxcXHUyMUZFJywncm9icmsnOidcXFxcdTI3RTcnLCdyb3Bhcic6J1xcXFx1Mjk4NicsJ3JvcGYnOidcXFxcdUQ4MzVcXFxcdURENjMnLCdSb3BmJzonXFxcXHUyMTFEJywncm9wbHVzJzonXFxcXHUyQTJFJywncm90aW1lcyc6J1xcXFx1MkEzNScsJ1JvdW5kSW1wbGllcyc6J1xcXFx1Mjk3MCcsJ3JwYXInOicpJywncnBhcmd0JzonXFxcXHUyOTk0JywncnBwb2xpbnQnOidcXFxcdTJBMTInLCdycmFycic6J1xcXFx1MjFDOScsJ1JyaWdodGFycm93JzonXFxcXHUyMURCJywncnNhcXVvJzonXFxcXHUyMDNBJywncnNjcic6J1xcXFx1RDgzNVxcXFx1RENDNycsJ1JzY3InOidcXFxcdTIxMUInLCdyc2gnOidcXFxcdTIxQjEnLCdSc2gnOidcXFxcdTIxQjEnLCdyc3FiJzonXScsJ3JzcXVvJzonXFxcXHUyMDE5JywncnNxdW9yJzonXFxcXHUyMDE5JywncnRocmVlJzonXFxcXHUyMkNDJywncnRpbWVzJzonXFxcXHUyMkNBJywncnRyaSc6J1xcXFx1MjVCOScsJ3J0cmllJzonXFxcXHUyMkI1JywncnRyaWYnOidcXFxcdTI1QjgnLCdydHJpbHRyaSc6J1xcXFx1MjlDRScsJ1J1bGVEZWxheWVkJzonXFxcXHUyOUY0JywncnVsdWhhcic6J1xcXFx1Mjk2OCcsJ3J4JzonXFxcXHUyMTFFJywnc2FjdXRlJzonXFxcXHUwMTVCJywnU2FjdXRlJzonXFxcXHUwMTVBJywnc2JxdW8nOidcXFxcdTIwMUEnLCdzYyc6J1xcXFx1MjI3QicsJ1NjJzonXFxcXHUyQUJDJywnc2NhcCc6J1xcXFx1MkFCOCcsJ3NjYXJvbic6J1xcXFx1MDE2MScsJ1NjYXJvbic6J1xcXFx1MDE2MCcsJ3NjY3VlJzonXFxcXHUyMjdEJywnc2NlJzonXFxcXHUyQUIwJywnc2NFJzonXFxcXHUyQUI0Jywnc2NlZGlsJzonXFxcXHUwMTVGJywnU2NlZGlsJzonXFxcXHUwMTVFJywnc2NpcmMnOidcXFxcdTAxNUQnLCdTY2lyYyc6J1xcXFx1MDE1QycsJ3NjbmFwJzonXFxcXHUyQUJBJywnc2NuRSc6J1xcXFx1MkFCNicsJ3NjbnNpbSc6J1xcXFx1MjJFOScsJ3NjcG9saW50JzonXFxcXHUyQTEzJywnc2NzaW0nOidcXFxcdTIyN0YnLCdzY3knOidcXFxcdTA0NDEnLCdTY3knOidcXFxcdTA0MjEnLCdzZG90JzonXFxcXHUyMkM1Jywnc2RvdGInOidcXFxcdTIyQTEnLCdzZG90ZSc6J1xcXFx1MkE2NicsJ3NlYXJoayc6J1xcXFx1MjkyNScsJ3NlYXJyJzonXFxcXHUyMTk4Jywnc2VBcnInOidcXFxcdTIxRDgnLCdzZWFycm93JzonXFxcXHUyMTk4Jywnc2VjdCc6J1xcXFx4QTcnLCdzZW1pJzonOycsJ3Nlc3dhcic6J1xcXFx1MjkyOScsJ3NldG1pbnVzJzonXFxcXHUyMjE2Jywnc2V0bW4nOidcXFxcdTIyMTYnLCdzZXh0JzonXFxcXHUyNzM2Jywnc2ZyJzonXFxcXHVEODM1XFxcXHVERDMwJywnU2ZyJzonXFxcXHVEODM1XFxcXHVERDE2Jywnc2Zyb3duJzonXFxcXHUyMzIyJywnc2hhcnAnOidcXFxcdTI2NkYnLCdzaGNoY3knOidcXFxcdTA0NDknLCdTSENIY3knOidcXFxcdTA0MjknLCdzaGN5JzonXFxcXHUwNDQ4JywnU0hjeSc6J1xcXFx1MDQyOCcsJ1Nob3J0RG93bkFycm93JzonXFxcXHUyMTkzJywnU2hvcnRMZWZ0QXJyb3cnOidcXFxcdTIxOTAnLCdzaG9ydG1pZCc6J1xcXFx1MjIyMycsJ3Nob3J0cGFyYWxsZWwnOidcXFxcdTIyMjUnLCdTaG9ydFJpZ2h0QXJyb3cnOidcXFxcdTIxOTInLCdTaG9ydFVwQXJyb3cnOidcXFxcdTIxOTEnLCdzaHknOidcXFxceEFEJywnc2lnbWEnOidcXFxcdTAzQzMnLCdTaWdtYSc6J1xcXFx1MDNBMycsJ3NpZ21hZic6J1xcXFx1MDNDMicsJ3NpZ21hdic6J1xcXFx1MDNDMicsJ3NpbSc6J1xcXFx1MjIzQycsJ3NpbWRvdCc6J1xcXFx1MkE2QScsJ3NpbWUnOidcXFxcdTIyNDMnLCdzaW1lcSc6J1xcXFx1MjI0MycsJ3NpbWcnOidcXFxcdTJBOUUnLCdzaW1nRSc6J1xcXFx1MkFBMCcsJ3NpbWwnOidcXFxcdTJBOUQnLCdzaW1sRSc6J1xcXFx1MkE5RicsJ3NpbW5lJzonXFxcXHUyMjQ2Jywnc2ltcGx1cyc6J1xcXFx1MkEyNCcsJ3NpbXJhcnInOidcXFxcdTI5NzInLCdzbGFycic6J1xcXFx1MjE5MCcsJ1NtYWxsQ2lyY2xlJzonXFxcXHUyMjE4Jywnc21hbGxzZXRtaW51cyc6J1xcXFx1MjIxNicsJ3NtYXNocCc6J1xcXFx1MkEzMycsJ3NtZXBhcnNsJzonXFxcXHUyOUU0Jywnc21pZCc6J1xcXFx1MjIyMycsJ3NtaWxlJzonXFxcXHUyMzIzJywnc210JzonXFxcXHUyQUFBJywnc210ZSc6J1xcXFx1MkFBQycsJ3NtdGVzJzonXFxcXHUyQUFDXFxcXHVGRTAwJywnc29mdGN5JzonXFxcXHUwNDRDJywnU09GVGN5JzonXFxcXHUwNDJDJywnc29sJzonLycsJ3NvbGInOidcXFxcdTI5QzQnLCdzb2xiYXInOidcXFxcdTIzM0YnLCdzb3BmJzonXFxcXHVEODM1XFxcXHVERDY0JywnU29wZic6J1xcXFx1RDgzNVxcXFx1REQ0QScsJ3NwYWRlcyc6J1xcXFx1MjY2MCcsJ3NwYWRlc3VpdCc6J1xcXFx1MjY2MCcsJ3NwYXInOidcXFxcdTIyMjUnLCdzcWNhcCc6J1xcXFx1MjI5MycsJ3NxY2Fwcyc6J1xcXFx1MjI5M1xcXFx1RkUwMCcsJ3NxY3VwJzonXFxcXHUyMjk0Jywnc3FjdXBzJzonXFxcXHUyMjk0XFxcXHVGRTAwJywnU3FydCc6J1xcXFx1MjIxQScsJ3Nxc3ViJzonXFxcXHUyMjhGJywnc3FzdWJlJzonXFxcXHUyMjkxJywnc3FzdWJzZXQnOidcXFxcdTIyOEYnLCdzcXN1YnNldGVxJzonXFxcXHUyMjkxJywnc3FzdXAnOidcXFxcdTIyOTAnLCdzcXN1cGUnOidcXFxcdTIyOTInLCdzcXN1cHNldCc6J1xcXFx1MjI5MCcsJ3Nxc3Vwc2V0ZXEnOidcXFxcdTIyOTInLCdzcXUnOidcXFxcdTI1QTEnLCdzcXVhcmUnOidcXFxcdTI1QTEnLCdTcXVhcmUnOidcXFxcdTI1QTEnLCdTcXVhcmVJbnRlcnNlY3Rpb24nOidcXFxcdTIyOTMnLCdTcXVhcmVTdWJzZXQnOidcXFxcdTIyOEYnLCdTcXVhcmVTdWJzZXRFcXVhbCc6J1xcXFx1MjI5MScsJ1NxdWFyZVN1cGVyc2V0JzonXFxcXHUyMjkwJywnU3F1YXJlU3VwZXJzZXRFcXVhbCc6J1xcXFx1MjI5MicsJ1NxdWFyZVVuaW9uJzonXFxcXHUyMjk0Jywnc3F1YXJmJzonXFxcXHUyNUFBJywnc3F1Zic6J1xcXFx1MjVBQScsJ3NyYXJyJzonXFxcXHUyMTkyJywnc3Njcic6J1xcXFx1RDgzNVxcXFx1RENDOCcsJ1NzY3InOidcXFxcdUQ4MzVcXFxcdURDQUUnLCdzc2V0bW4nOidcXFxcdTIyMTYnLCdzc21pbGUnOidcXFxcdTIzMjMnLCdzc3RhcmYnOidcXFxcdTIyQzYnLCdzdGFyJzonXFxcXHUyNjA2JywnU3Rhcic6J1xcXFx1MjJDNicsJ3N0YXJmJzonXFxcXHUyNjA1Jywnc3RyYWlnaHRlcHNpbG9uJzonXFxcXHUwM0Y1Jywnc3RyYWlnaHRwaGknOidcXFxcdTAzRDUnLCdzdHJucyc6J1xcXFx4QUYnLCdzdWInOidcXFxcdTIyODInLCdTdWInOidcXFxcdTIyRDAnLCdzdWJkb3QnOidcXFxcdTJBQkQnLCdzdWJlJzonXFxcXHUyMjg2Jywnc3ViRSc6J1xcXFx1MkFDNScsJ3N1YmVkb3QnOidcXFxcdTJBQzMnLCdzdWJtdWx0JzonXFxcXHUyQUMxJywnc3VibmUnOidcXFxcdTIyOEEnLCdzdWJuRSc6J1xcXFx1MkFDQicsJ3N1YnBsdXMnOidcXFxcdTJBQkYnLCdzdWJyYXJyJzonXFxcXHUyOTc5Jywnc3Vic2V0JzonXFxcXHUyMjgyJywnU3Vic2V0JzonXFxcXHUyMkQwJywnc3Vic2V0ZXEnOidcXFxcdTIyODYnLCdzdWJzZXRlcXEnOidcXFxcdTJBQzUnLCdTdWJzZXRFcXVhbCc6J1xcXFx1MjI4NicsJ3N1YnNldG5lcSc6J1xcXFx1MjI4QScsJ3N1YnNldG5lcXEnOidcXFxcdTJBQ0InLCdzdWJzaW0nOidcXFxcdTJBQzcnLCdzdWJzdWInOidcXFxcdTJBRDUnLCdzdWJzdXAnOidcXFxcdTJBRDMnLCdzdWNjJzonXFxcXHUyMjdCJywnc3VjY2FwcHJveCc6J1xcXFx1MkFCOCcsJ3N1Y2NjdXJseWVxJzonXFxcXHUyMjdEJywnU3VjY2VlZHMnOidcXFxcdTIyN0InLCdTdWNjZWVkc0VxdWFsJzonXFxcXHUyQUIwJywnU3VjY2VlZHNTbGFudEVxdWFsJzonXFxcXHUyMjdEJywnU3VjY2VlZHNUaWxkZSc6J1xcXFx1MjI3RicsJ3N1Y2NlcSc6J1xcXFx1MkFCMCcsJ3N1Y2NuYXBwcm94JzonXFxcXHUyQUJBJywnc3VjY25lcXEnOidcXFxcdTJBQjYnLCdzdWNjbnNpbSc6J1xcXFx1MjJFOScsJ3N1Y2NzaW0nOidcXFxcdTIyN0YnLCdTdWNoVGhhdCc6J1xcXFx1MjIwQicsJ3N1bSc6J1xcXFx1MjIxMScsJ1N1bSc6J1xcXFx1MjIxMScsJ3N1bmcnOidcXFxcdTI2NkEnLCdzdXAnOidcXFxcdTIyODMnLCdTdXAnOidcXFxcdTIyRDEnLCdzdXAxJzonXFxcXHhCOScsJ3N1cDInOidcXFxceEIyJywnc3VwMyc6J1xcXFx4QjMnLCdzdXBkb3QnOidcXFxcdTJBQkUnLCdzdXBkc3ViJzonXFxcXHUyQUQ4Jywnc3VwZSc6J1xcXFx1MjI4NycsJ3N1cEUnOidcXFxcdTJBQzYnLCdzdXBlZG90JzonXFxcXHUyQUM0JywnU3VwZXJzZXQnOidcXFxcdTIyODMnLCdTdXBlcnNldEVxdWFsJzonXFxcXHUyMjg3Jywnc3VwaHNvbCc6J1xcXFx1MjdDOScsJ3N1cGhzdWInOidcXFxcdTJBRDcnLCdzdXBsYXJyJzonXFxcXHUyOTdCJywnc3VwbXVsdCc6J1xcXFx1MkFDMicsJ3N1cG5lJzonXFxcXHUyMjhCJywnc3VwbkUnOidcXFxcdTJBQ0MnLCdzdXBwbHVzJzonXFxcXHUyQUMwJywnc3Vwc2V0JzonXFxcXHUyMjgzJywnU3Vwc2V0JzonXFxcXHUyMkQxJywnc3Vwc2V0ZXEnOidcXFxcdTIyODcnLCdzdXBzZXRlcXEnOidcXFxcdTJBQzYnLCdzdXBzZXRuZXEnOidcXFxcdTIyOEInLCdzdXBzZXRuZXFxJzonXFxcXHUyQUNDJywnc3Vwc2ltJzonXFxcXHUyQUM4Jywnc3Vwc3ViJzonXFxcXHUyQUQ0Jywnc3Vwc3VwJzonXFxcXHUyQUQ2Jywnc3dhcmhrJzonXFxcXHUyOTI2Jywnc3dhcnInOidcXFxcdTIxOTknLCdzd0Fycic6J1xcXFx1MjFEOScsJ3N3YXJyb3cnOidcXFxcdTIxOTknLCdzd253YXInOidcXFxcdTI5MkEnLCdzemxpZyc6J1xcXFx4REYnLCdUYWInOidcXFxcdCcsJ3RhcmdldCc6J1xcXFx1MjMxNicsJ3RhdSc6J1xcXFx1MDNDNCcsJ1RhdSc6J1xcXFx1MDNBNCcsJ3RicmsnOidcXFxcdTIzQjQnLCd0Y2Fyb24nOidcXFxcdTAxNjUnLCdUY2Fyb24nOidcXFxcdTAxNjQnLCd0Y2VkaWwnOidcXFxcdTAxNjMnLCdUY2VkaWwnOidcXFxcdTAxNjInLCd0Y3knOidcXFxcdTA0NDInLCdUY3knOidcXFxcdTA0MjInLCd0ZG90JzonXFxcXHUyMERCJywndGVscmVjJzonXFxcXHUyMzE1JywndGZyJzonXFxcXHVEODM1XFxcXHVERDMxJywnVGZyJzonXFxcXHVEODM1XFxcXHVERDE3JywndGhlcmU0JzonXFxcXHUyMjM0JywndGhlcmVmb3JlJzonXFxcXHUyMjM0JywnVGhlcmVmb3JlJzonXFxcXHUyMjM0JywndGhldGEnOidcXFxcdTAzQjgnLCdUaGV0YSc6J1xcXFx1MDM5OCcsJ3RoZXRhc3ltJzonXFxcXHUwM0QxJywndGhldGF2JzonXFxcXHUwM0QxJywndGhpY2thcHByb3gnOidcXFxcdTIyNDgnLCd0aGlja3NpbSc6J1xcXFx1MjIzQycsJ1RoaWNrU3BhY2UnOidcXFxcdTIwNUZcXFxcdTIwMEEnLCd0aGluc3AnOidcXFxcdTIwMDknLCdUaGluU3BhY2UnOidcXFxcdTIwMDknLCd0aGthcCc6J1xcXFx1MjI0OCcsJ3Roa3NpbSc6J1xcXFx1MjIzQycsJ3Rob3JuJzonXFxcXHhGRScsJ1RIT1JOJzonXFxcXHhERScsJ3RpbGRlJzonXFxcXHUwMkRDJywnVGlsZGUnOidcXFxcdTIyM0MnLCdUaWxkZUVxdWFsJzonXFxcXHUyMjQzJywnVGlsZGVGdWxsRXF1YWwnOidcXFxcdTIyNDUnLCdUaWxkZVRpbGRlJzonXFxcXHUyMjQ4JywndGltZXMnOidcXFxceEQ3JywndGltZXNiJzonXFxcXHUyMkEwJywndGltZXNiYXInOidcXFxcdTJBMzEnLCd0aW1lc2QnOidcXFxcdTJBMzAnLCd0aW50JzonXFxcXHUyMjJEJywndG9lYSc6J1xcXFx1MjkyOCcsJ3RvcCc6J1xcXFx1MjJBNCcsJ3RvcGJvdCc6J1xcXFx1MjMzNicsJ3RvcGNpcic6J1xcXFx1MkFGMScsJ3RvcGYnOidcXFxcdUQ4MzVcXFxcdURENjUnLCdUb3BmJzonXFxcXHVEODM1XFxcXHVERDRCJywndG9wZm9yayc6J1xcXFx1MkFEQScsJ3Rvc2EnOidcXFxcdTI5MjknLCd0cHJpbWUnOidcXFxcdTIwMzQnLCd0cmFkZSc6J1xcXFx1MjEyMicsJ1RSQURFJzonXFxcXHUyMTIyJywndHJpYW5nbGUnOidcXFxcdTI1QjUnLCd0cmlhbmdsZWRvd24nOidcXFxcdTI1QkYnLCd0cmlhbmdsZWxlZnQnOidcXFxcdTI1QzMnLCd0cmlhbmdsZWxlZnRlcSc6J1xcXFx1MjJCNCcsJ3RyaWFuZ2xlcSc6J1xcXFx1MjI1QycsJ3RyaWFuZ2xlcmlnaHQnOidcXFxcdTI1QjknLCd0cmlhbmdsZXJpZ2h0ZXEnOidcXFxcdTIyQjUnLCd0cmlkb3QnOidcXFxcdTI1RUMnLCd0cmllJzonXFxcXHUyMjVDJywndHJpbWludXMnOidcXFxcdTJBM0EnLCdUcmlwbGVEb3QnOidcXFxcdTIwREInLCd0cmlwbHVzJzonXFxcXHUyQTM5JywndHJpc2InOidcXFxcdTI5Q0QnLCd0cml0aW1lJzonXFxcXHUyQTNCJywndHJwZXppdW0nOidcXFxcdTIzRTInLCd0c2NyJzonXFxcXHVEODM1XFxcXHVEQ0M5JywnVHNjcic6J1xcXFx1RDgzNVxcXFx1RENBRicsJ3RzY3knOidcXFxcdTA0NDYnLCdUU2N5JzonXFxcXHUwNDI2JywndHNoY3knOidcXFxcdTA0NUInLCdUU0hjeSc6J1xcXFx1MDQwQicsJ3RzdHJvayc6J1xcXFx1MDE2NycsJ1RzdHJvayc6J1xcXFx1MDE2NicsJ3R3aXh0JzonXFxcXHUyMjZDJywndHdvaGVhZGxlZnRhcnJvdyc6J1xcXFx1MjE5RScsJ3R3b2hlYWRyaWdodGFycm93JzonXFxcXHUyMUEwJywndWFjdXRlJzonXFxcXHhGQScsJ1VhY3V0ZSc6J1xcXFx4REEnLCd1YXJyJzonXFxcXHUyMTkxJywndUFycic6J1xcXFx1MjFEMScsJ1VhcnInOidcXFxcdTIxOUYnLCdVYXJyb2Npcic6J1xcXFx1Mjk0OScsJ3VicmN5JzonXFxcXHUwNDVFJywnVWJyY3knOidcXFxcdTA0MEUnLCd1YnJldmUnOidcXFxcdTAxNkQnLCdVYnJldmUnOidcXFxcdTAxNkMnLCd1Y2lyYyc6J1xcXFx4RkInLCdVY2lyYyc6J1xcXFx4REInLCd1Y3knOidcXFxcdTA0NDMnLCdVY3knOidcXFxcdTA0MjMnLCd1ZGFycic6J1xcXFx1MjFDNScsJ3VkYmxhYyc6J1xcXFx1MDE3MScsJ1VkYmxhYyc6J1xcXFx1MDE3MCcsJ3VkaGFyJzonXFxcXHUyOTZFJywndWZpc2h0JzonXFxcXHUyOTdFJywndWZyJzonXFxcXHVEODM1XFxcXHVERDMyJywnVWZyJzonXFxcXHVEODM1XFxcXHVERDE4JywndWdyYXZlJzonXFxcXHhGOScsJ1VncmF2ZSc6J1xcXFx4RDknLCd1SGFyJzonXFxcXHUyOTYzJywndWhhcmwnOidcXFxcdTIxQkYnLCd1aGFycic6J1xcXFx1MjFCRScsJ3VoYmxrJzonXFxcXHUyNTgwJywndWxjb3JuJzonXFxcXHUyMzFDJywndWxjb3JuZXInOidcXFxcdTIzMUMnLCd1bGNyb3AnOidcXFxcdTIzMEYnLCd1bHRyaSc6J1xcXFx1MjVGOCcsJ3VtYWNyJzonXFxcXHUwMTZCJywnVW1hY3InOidcXFxcdTAxNkEnLCd1bWwnOidcXFxceEE4JywnVW5kZXJCYXInOidfJywnVW5kZXJCcmFjZSc6J1xcXFx1MjNERicsJ1VuZGVyQnJhY2tldCc6J1xcXFx1MjNCNScsJ1VuZGVyUGFyZW50aGVzaXMnOidcXFxcdTIzREQnLCdVbmlvbic6J1xcXFx1MjJDMycsJ1VuaW9uUGx1cyc6J1xcXFx1MjI4RScsJ3VvZ29uJzonXFxcXHUwMTczJywnVW9nb24nOidcXFxcdTAxNzInLCd1b3BmJzonXFxcXHVEODM1XFxcXHVERDY2JywnVW9wZic6J1xcXFx1RDgzNVxcXFx1REQ0QycsJ3VwYXJyb3cnOidcXFxcdTIxOTEnLCdVcGFycm93JzonXFxcXHUyMUQxJywnVXBBcnJvdyc6J1xcXFx1MjE5MScsJ1VwQXJyb3dCYXInOidcXFxcdTI5MTInLCdVcEFycm93RG93bkFycm93JzonXFxcXHUyMUM1JywndXBkb3duYXJyb3cnOidcXFxcdTIxOTUnLCdVcGRvd25hcnJvdyc6J1xcXFx1MjFENScsJ1VwRG93bkFycm93JzonXFxcXHUyMTk1JywnVXBFcXVpbGlicml1bSc6J1xcXFx1Mjk2RScsJ3VwaGFycG9vbmxlZnQnOidcXFxcdTIxQkYnLCd1cGhhcnBvb25yaWdodCc6J1xcXFx1MjFCRScsJ3VwbHVzJzonXFxcXHUyMjhFJywnVXBwZXJMZWZ0QXJyb3cnOidcXFxcdTIxOTYnLCdVcHBlclJpZ2h0QXJyb3cnOidcXFxcdTIxOTcnLCd1cHNpJzonXFxcXHUwM0M1JywnVXBzaSc6J1xcXFx1MDNEMicsJ3Vwc2loJzonXFxcXHUwM0QyJywndXBzaWxvbic6J1xcXFx1MDNDNScsJ1Vwc2lsb24nOidcXFxcdTAzQTUnLCdVcFRlZSc6J1xcXFx1MjJBNScsJ1VwVGVlQXJyb3cnOidcXFxcdTIxQTUnLCd1cHVwYXJyb3dzJzonXFxcXHUyMUM4JywndXJjb3JuJzonXFxcXHUyMzFEJywndXJjb3JuZXInOidcXFxcdTIzMUQnLCd1cmNyb3AnOidcXFxcdTIzMEUnLCd1cmluZyc6J1xcXFx1MDE2RicsJ1VyaW5nJzonXFxcXHUwMTZFJywndXJ0cmknOidcXFxcdTI1RjknLCd1c2NyJzonXFxcXHVEODM1XFxcXHVEQ0NBJywnVXNjcic6J1xcXFx1RDgzNVxcXFx1RENCMCcsJ3V0ZG90JzonXFxcXHUyMkYwJywndXRpbGRlJzonXFxcXHUwMTY5JywnVXRpbGRlJzonXFxcXHUwMTY4JywndXRyaSc6J1xcXFx1MjVCNScsJ3V0cmlmJzonXFxcXHUyNUI0JywndXVhcnInOidcXFxcdTIxQzgnLCd1dW1sJzonXFxcXHhGQycsJ1V1bWwnOidcXFxceERDJywndXdhbmdsZSc6J1xcXFx1MjlBNycsJ3ZhbmdydCc6J1xcXFx1Mjk5QycsJ3ZhcmVwc2lsb24nOidcXFxcdTAzRjUnLCd2YXJrYXBwYSc6J1xcXFx1MDNGMCcsJ3Zhcm5vdGhpbmcnOidcXFxcdTIyMDUnLCd2YXJwaGknOidcXFxcdTAzRDUnLCd2YXJwaSc6J1xcXFx1MDNENicsJ3ZhcnByb3B0byc6J1xcXFx1MjIxRCcsJ3ZhcnInOidcXFxcdTIxOTUnLCd2QXJyJzonXFxcXHUyMUQ1JywndmFycmhvJzonXFxcXHUwM0YxJywndmFyc2lnbWEnOidcXFxcdTAzQzInLCd2YXJzdWJzZXRuZXEnOidcXFxcdTIyOEFcXFxcdUZFMDAnLCd2YXJzdWJzZXRuZXFxJzonXFxcXHUyQUNCXFxcXHVGRTAwJywndmFyc3Vwc2V0bmVxJzonXFxcXHUyMjhCXFxcXHVGRTAwJywndmFyc3Vwc2V0bmVxcSc6J1xcXFx1MkFDQ1xcXFx1RkUwMCcsJ3ZhcnRoZXRhJzonXFxcXHUwM0QxJywndmFydHJpYW5nbGVsZWZ0JzonXFxcXHUyMkIyJywndmFydHJpYW5nbGVyaWdodCc6J1xcXFx1MjJCMycsJ3ZCYXInOidcXFxcdTJBRTgnLCdWYmFyJzonXFxcXHUyQUVCJywndkJhcnYnOidcXFxcdTJBRTknLCd2Y3knOidcXFxcdTA0MzInLCdWY3knOidcXFxcdTA0MTInLCd2ZGFzaCc6J1xcXFx1MjJBMicsJ3ZEYXNoJzonXFxcXHUyMkE4JywnVmRhc2gnOidcXFxcdTIyQTknLCdWRGFzaCc6J1xcXFx1MjJBQicsJ1ZkYXNobCc6J1xcXFx1MkFFNicsJ3ZlZSc6J1xcXFx1MjIyOCcsJ1ZlZSc6J1xcXFx1MjJDMScsJ3ZlZWJhcic6J1xcXFx1MjJCQicsJ3ZlZWVxJzonXFxcXHUyMjVBJywndmVsbGlwJzonXFxcXHUyMkVFJywndmVyYmFyJzonfCcsJ1ZlcmJhcic6J1xcXFx1MjAxNicsJ3ZlcnQnOid8JywnVmVydCc6J1xcXFx1MjAxNicsJ1ZlcnRpY2FsQmFyJzonXFxcXHUyMjIzJywnVmVydGljYWxMaW5lJzonfCcsJ1ZlcnRpY2FsU2VwYXJhdG9yJzonXFxcXHUyNzU4JywnVmVydGljYWxUaWxkZSc6J1xcXFx1MjI0MCcsJ1ZlcnlUaGluU3BhY2UnOidcXFxcdTIwMEEnLCd2ZnInOidcXFxcdUQ4MzVcXFxcdUREMzMnLCdWZnInOidcXFxcdUQ4MzVcXFxcdUREMTknLCd2bHRyaSc6J1xcXFx1MjJCMicsJ3Zuc3ViJzonXFxcXHUyMjgyXFxcXHUyMEQyJywndm5zdXAnOidcXFxcdTIyODNcXFxcdTIwRDInLCd2b3BmJzonXFxcXHVEODM1XFxcXHVERDY3JywnVm9wZic6J1xcXFx1RDgzNVxcXFx1REQ0RCcsJ3Zwcm9wJzonXFxcXHUyMjFEJywndnJ0cmknOidcXFxcdTIyQjMnLCd2c2NyJzonXFxcXHVEODM1XFxcXHVEQ0NCJywnVnNjcic6J1xcXFx1RDgzNVxcXFx1RENCMScsJ3ZzdWJuZSc6J1xcXFx1MjI4QVxcXFx1RkUwMCcsJ3ZzdWJuRSc6J1xcXFx1MkFDQlxcXFx1RkUwMCcsJ3ZzdXBuZSc6J1xcXFx1MjI4QlxcXFx1RkUwMCcsJ3ZzdXBuRSc6J1xcXFx1MkFDQ1xcXFx1RkUwMCcsJ1Z2ZGFzaCc6J1xcXFx1MjJBQScsJ3Z6aWd6YWcnOidcXFxcdTI5OUEnLCd3Y2lyYyc6J1xcXFx1MDE3NScsJ1djaXJjJzonXFxcXHUwMTc0Jywnd2VkYmFyJzonXFxcXHUyQTVGJywnd2VkZ2UnOidcXFxcdTIyMjcnLCdXZWRnZSc6J1xcXFx1MjJDMCcsJ3dlZGdlcSc6J1xcXFx1MjI1OScsJ3dlaWVycCc6J1xcXFx1MjExOCcsJ3dmcic6J1xcXFx1RDgzNVxcXFx1REQzNCcsJ1dmcic6J1xcXFx1RDgzNVxcXFx1REQxQScsJ3dvcGYnOidcXFxcdUQ4MzVcXFxcdURENjgnLCdXb3BmJzonXFxcXHVEODM1XFxcXHVERDRFJywnd3AnOidcXFxcdTIxMTgnLCd3cic6J1xcXFx1MjI0MCcsJ3dyZWF0aCc6J1xcXFx1MjI0MCcsJ3dzY3InOidcXFxcdUQ4MzVcXFxcdURDQ0MnLCdXc2NyJzonXFxcXHVEODM1XFxcXHVEQ0IyJywneGNhcCc6J1xcXFx1MjJDMicsJ3hjaXJjJzonXFxcXHUyNUVGJywneGN1cCc6J1xcXFx1MjJDMycsJ3hkdHJpJzonXFxcXHUyNUJEJywneGZyJzonXFxcXHVEODM1XFxcXHVERDM1JywnWGZyJzonXFxcXHVEODM1XFxcXHVERDFCJywneGhhcnInOidcXFxcdTI3RjcnLCd4aEFycic6J1xcXFx1MjdGQScsJ3hpJzonXFxcXHUwM0JFJywnWGknOidcXFxcdTAzOUUnLCd4bGFycic6J1xcXFx1MjdGNScsJ3hsQXJyJzonXFxcXHUyN0Y4JywneG1hcCc6J1xcXFx1MjdGQycsJ3huaXMnOidcXFxcdTIyRkInLCd4b2RvdCc6J1xcXFx1MkEwMCcsJ3hvcGYnOidcXFxcdUQ4MzVcXFxcdURENjknLCdYb3BmJzonXFxcXHVEODM1XFxcXHVERDRGJywneG9wbHVzJzonXFxcXHUyQTAxJywneG90aW1lJzonXFxcXHUyQTAyJywneHJhcnInOidcXFxcdTI3RjYnLCd4ckFycic6J1xcXFx1MjdGOScsJ3hzY3InOidcXFxcdUQ4MzVcXFxcdURDQ0QnLCdYc2NyJzonXFxcXHVEODM1XFxcXHVEQ0IzJywneHNxY3VwJzonXFxcXHUyQTA2JywneHVwbHVzJzonXFxcXHUyQTA0JywneHV0cmknOidcXFxcdTI1QjMnLCd4dmVlJzonXFxcXHUyMkMxJywneHdlZGdlJzonXFxcXHUyMkMwJywneWFjdXRlJzonXFxcXHhGRCcsJ1lhY3V0ZSc6J1xcXFx4REQnLCd5YWN5JzonXFxcXHUwNDRGJywnWUFjeSc6J1xcXFx1MDQyRicsJ3ljaXJjJzonXFxcXHUwMTc3JywnWWNpcmMnOidcXFxcdTAxNzYnLCd5Y3knOidcXFxcdTA0NEInLCdZY3knOidcXFxcdTA0MkInLCd5ZW4nOidcXFxceEE1JywneWZyJzonXFxcXHVEODM1XFxcXHVERDM2JywnWWZyJzonXFxcXHVEODM1XFxcXHVERDFDJywneWljeSc6J1xcXFx1MDQ1NycsJ1lJY3knOidcXFxcdTA0MDcnLCd5b3BmJzonXFxcXHVEODM1XFxcXHVERDZBJywnWW9wZic6J1xcXFx1RDgzNVxcXFx1REQ1MCcsJ3lzY3InOidcXFxcdUQ4MzVcXFxcdURDQ0UnLCdZc2NyJzonXFxcXHVEODM1XFxcXHVEQ0I0JywneXVjeSc6J1xcXFx1MDQ0RScsJ1lVY3knOidcXFxcdTA0MkUnLCd5dW1sJzonXFxcXHhGRicsJ1l1bWwnOidcXFxcdTAxNzgnLCd6YWN1dGUnOidcXFxcdTAxN0EnLCdaYWN1dGUnOidcXFxcdTAxNzknLCd6Y2Fyb24nOidcXFxcdTAxN0UnLCdaY2Fyb24nOidcXFxcdTAxN0QnLCd6Y3knOidcXFxcdTA0MzcnLCdaY3knOidcXFxcdTA0MTcnLCd6ZG90JzonXFxcXHUwMTdDJywnWmRvdCc6J1xcXFx1MDE3QicsJ3plZXRyZic6J1xcXFx1MjEyOCcsJ1plcm9XaWR0aFNwYWNlJzonXFxcXHUyMDBCJywnemV0YSc6J1xcXFx1MDNCNicsJ1pldGEnOidcXFxcdTAzOTYnLCd6ZnInOidcXFxcdUQ4MzVcXFxcdUREMzcnLCdaZnInOidcXFxcdTIxMjgnLCd6aGN5JzonXFxcXHUwNDM2JywnWkhjeSc6J1xcXFx1MDQxNicsJ3ppZ3JhcnInOidcXFxcdTIxREQnLCd6b3BmJzonXFxcXHVEODM1XFxcXHVERDZCJywnWm9wZic6J1xcXFx1MjEyNCcsJ3pzY3InOidcXFxcdUQ4MzVcXFxcdURDQ0YnLCdac2NyJzonXFxcXHVEODM1XFxcXHVEQ0I1JywnendqJzonXFxcXHUyMDBEJywnenduaic6J1xcXFx1MjAwQyd9O1xcblxcdHZhciBkZWNvZGVNYXBMZWdhY3kgPSB7J2FhY3V0ZSc6J1xcXFx4RTEnLCdBYWN1dGUnOidcXFxceEMxJywnYWNpcmMnOidcXFxceEUyJywnQWNpcmMnOidcXFxceEMyJywnYWN1dGUnOidcXFxceEI0JywnYWVsaWcnOidcXFxceEU2JywnQUVsaWcnOidcXFxceEM2JywnYWdyYXZlJzonXFxcXHhFMCcsJ0FncmF2ZSc6J1xcXFx4QzAnLCdhbXAnOicmJywnQU1QJzonJicsJ2FyaW5nJzonXFxcXHhFNScsJ0FyaW5nJzonXFxcXHhDNScsJ2F0aWxkZSc6J1xcXFx4RTMnLCdBdGlsZGUnOidcXFxceEMzJywnYXVtbCc6J1xcXFx4RTQnLCdBdW1sJzonXFxcXHhDNCcsJ2JydmJhcic6J1xcXFx4QTYnLCdjY2VkaWwnOidcXFxceEU3JywnQ2NlZGlsJzonXFxcXHhDNycsJ2NlZGlsJzonXFxcXHhCOCcsJ2NlbnQnOidcXFxceEEyJywnY29weSc6J1xcXFx4QTknLCdDT1BZJzonXFxcXHhBOScsJ2N1cnJlbic6J1xcXFx4QTQnLCdkZWcnOidcXFxceEIwJywnZGl2aWRlJzonXFxcXHhGNycsJ2VhY3V0ZSc6J1xcXFx4RTknLCdFYWN1dGUnOidcXFxceEM5JywnZWNpcmMnOidcXFxceEVBJywnRWNpcmMnOidcXFxceENBJywnZWdyYXZlJzonXFxcXHhFOCcsJ0VncmF2ZSc6J1xcXFx4QzgnLCdldGgnOidcXFxceEYwJywnRVRIJzonXFxcXHhEMCcsJ2V1bWwnOidcXFxceEVCJywnRXVtbCc6J1xcXFx4Q0InLCdmcmFjMTInOidcXFxceEJEJywnZnJhYzE0JzonXFxcXHhCQycsJ2ZyYWMzNCc6J1xcXFx4QkUnLCdndCc6Jz4nLCdHVCc6Jz4nLCdpYWN1dGUnOidcXFxceEVEJywnSWFjdXRlJzonXFxcXHhDRCcsJ2ljaXJjJzonXFxcXHhFRScsJ0ljaXJjJzonXFxcXHhDRScsJ2lleGNsJzonXFxcXHhBMScsJ2lncmF2ZSc6J1xcXFx4RUMnLCdJZ3JhdmUnOidcXFxceENDJywnaXF1ZXN0JzonXFxcXHhCRicsJ2l1bWwnOidcXFxceEVGJywnSXVtbCc6J1xcXFx4Q0YnLCdsYXF1byc6J1xcXFx4QUInLCdsdCc6JzwnLCdMVCc6JzwnLCdtYWNyJzonXFxcXHhBRicsJ21pY3JvJzonXFxcXHhCNScsJ21pZGRvdCc6J1xcXFx4QjcnLCduYnNwJzonXFxcXHhBMCcsJ25vdCc6J1xcXFx4QUMnLCdudGlsZGUnOidcXFxceEYxJywnTnRpbGRlJzonXFxcXHhEMScsJ29hY3V0ZSc6J1xcXFx4RjMnLCdPYWN1dGUnOidcXFxceEQzJywnb2NpcmMnOidcXFxceEY0JywnT2NpcmMnOidcXFxceEQ0Jywnb2dyYXZlJzonXFxcXHhGMicsJ09ncmF2ZSc6J1xcXFx4RDInLCdvcmRmJzonXFxcXHhBQScsJ29yZG0nOidcXFxceEJBJywnb3NsYXNoJzonXFxcXHhGOCcsJ09zbGFzaCc6J1xcXFx4RDgnLCdvdGlsZGUnOidcXFxceEY1JywnT3RpbGRlJzonXFxcXHhENScsJ291bWwnOidcXFxceEY2JywnT3VtbCc6J1xcXFx4RDYnLCdwYXJhJzonXFxcXHhCNicsJ3BsdXNtbic6J1xcXFx4QjEnLCdwb3VuZCc6J1xcXFx4QTMnLCdxdW90JzonXFxcIicsJ1FVT1QnOidcXFwiJywncmFxdW8nOidcXFxceEJCJywncmVnJzonXFxcXHhBRScsJ1JFRyc6J1xcXFx4QUUnLCdzZWN0JzonXFxcXHhBNycsJ3NoeSc6J1xcXFx4QUQnLCdzdXAxJzonXFxcXHhCOScsJ3N1cDInOidcXFxceEIyJywnc3VwMyc6J1xcXFx4QjMnLCdzemxpZyc6J1xcXFx4REYnLCd0aG9ybic6J1xcXFx4RkUnLCdUSE9STic6J1xcXFx4REUnLCd0aW1lcyc6J1xcXFx4RDcnLCd1YWN1dGUnOidcXFxceEZBJywnVWFjdXRlJzonXFxcXHhEQScsJ3VjaXJjJzonXFxcXHhGQicsJ1VjaXJjJzonXFxcXHhEQicsJ3VncmF2ZSc6J1xcXFx4RjknLCdVZ3JhdmUnOidcXFxceEQ5JywndW1sJzonXFxcXHhBOCcsJ3V1bWwnOidcXFxceEZDJywnVXVtbCc6J1xcXFx4REMnLCd5YWN1dGUnOidcXFxceEZEJywnWWFjdXRlJzonXFxcXHhERCcsJ3llbic6J1xcXFx4QTUnLCd5dW1sJzonXFxcXHhGRid9O1xcblxcdHZhciBkZWNvZGVNYXBOdW1lcmljID0geycwJzonXFxcXHVGRkZEJywnMTI4JzonXFxcXHUyMEFDJywnMTMwJzonXFxcXHUyMDFBJywnMTMxJzonXFxcXHUwMTkyJywnMTMyJzonXFxcXHUyMDFFJywnMTMzJzonXFxcXHUyMDI2JywnMTM0JzonXFxcXHUyMDIwJywnMTM1JzonXFxcXHUyMDIxJywnMTM2JzonXFxcXHUwMkM2JywnMTM3JzonXFxcXHUyMDMwJywnMTM4JzonXFxcXHUwMTYwJywnMTM5JzonXFxcXHUyMDM5JywnMTQwJzonXFxcXHUwMTUyJywnMTQyJzonXFxcXHUwMTdEJywnMTQ1JzonXFxcXHUyMDE4JywnMTQ2JzonXFxcXHUyMDE5JywnMTQ3JzonXFxcXHUyMDFDJywnMTQ4JzonXFxcXHUyMDFEJywnMTQ5JzonXFxcXHUyMDIyJywnMTUwJzonXFxcXHUyMDEzJywnMTUxJzonXFxcXHUyMDE0JywnMTUyJzonXFxcXHUwMkRDJywnMTUzJzonXFxcXHUyMTIyJywnMTU0JzonXFxcXHUwMTYxJywnMTU1JzonXFxcXHUyMDNBJywnMTU2JzonXFxcXHUwMTUzJywnMTU4JzonXFxcXHUwMTdFJywnMTU5JzonXFxcXHUwMTc4J307XFxuXFx0dmFyIGludmFsaWRSZWZlcmVuY2VDb2RlUG9pbnRzID0gWzEsMiwzLDQsNSw2LDcsOCwxMSwxMywxNCwxNSwxNiwxNywxOCwxOSwyMCwyMSwyMiwyMywyNCwyNSwyNiwyNywyOCwyOSwzMCwzMSwxMjcsMTI4LDEyOSwxMzAsMTMxLDEzMiwxMzMsMTM0LDEzNSwxMzYsMTM3LDEzOCwxMzksMTQwLDE0MSwxNDIsMTQzLDE0NCwxNDUsMTQ2LDE0NywxNDgsMTQ5LDE1MCwxNTEsMTUyLDE1MywxNTQsMTU1LDE1NiwxNTcsMTU4LDE1OSw2NDk3Niw2NDk3Nyw2NDk3OCw2NDk3OSw2NDk4MCw2NDk4MSw2NDk4Miw2NDk4Myw2NDk4NCw2NDk4NSw2NDk4Niw2NDk4Nyw2NDk4OCw2NDk4OSw2NDk5MCw2NDk5MSw2NDk5Miw2NDk5Myw2NDk5NCw2NDk5NSw2NDk5Niw2NDk5Nyw2NDk5OCw2NDk5OSw2NTAwMCw2NTAwMSw2NTAwMiw2NTAwMyw2NTAwNCw2NTAwNSw2NTAwNiw2NTAwNyw2NTUzNCw2NTUzNSwxMzEwNzAsMTMxMDcxLDE5NjYwNiwxOTY2MDcsMjYyMTQyLDI2MjE0MywzMjc2NzgsMzI3Njc5LDM5MzIxNCwzOTMyMTUsNDU4NzUwLDQ1ODc1MSw1MjQyODYsNTI0Mjg3LDU4OTgyMiw1ODk4MjMsNjU1MzU4LDY1NTM1OSw3MjA4OTQsNzIwODk1LDc4NjQzMCw3ODY0MzEsODUxOTY2LDg1MTk2Nyw5MTc1MDIsOTE3NTAzLDk4MzAzOCw5ODMwMzksMTA0ODU3NCwxMDQ4NTc1LDExMTQxMTAsMTExNDExMV07XFxuXFxuXFx0LyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXFxuXFxuXFx0dmFyIHN0cmluZ0Zyb21DaGFyQ29kZSA9IFN0cmluZy5mcm9tQ2hhckNvZGU7XFxuXFxuXFx0dmFyIG9iamVjdCA9IHt9O1xcblxcdHZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdC5oYXNPd25Qcm9wZXJ0eTtcXG5cXHR2YXIgaGFzID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eU5hbWUpIHtcXG5cXHRcXHRyZXR1cm4gaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5TmFtZSk7XFxuXFx0fTtcXG5cXG5cXHR2YXIgY29udGFpbnMgPSBmdW5jdGlvbihhcnJheSwgdmFsdWUpIHtcXG5cXHRcXHR2YXIgaW5kZXggPSAtMTtcXG5cXHRcXHR2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xcblxcdFxcdHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XFxuXFx0XFx0XFx0aWYgKGFycmF5W2luZGV4XSA9PSB2YWx1ZSkge1xcblxcdFxcdFxcdFxcdHJldHVybiB0cnVlO1xcblxcdFxcdFxcdH1cXG5cXHRcXHR9XFxuXFx0XFx0cmV0dXJuIGZhbHNlO1xcblxcdH07XFxuXFxuXFx0dmFyIG1lcmdlID0gZnVuY3Rpb24ob3B0aW9ucywgZGVmYXVsdHMpIHtcXG5cXHRcXHRpZiAoIW9wdGlvbnMpIHtcXG5cXHRcXHRcXHRyZXR1cm4gZGVmYXVsdHM7XFxuXFx0XFx0fVxcblxcdFxcdHZhciByZXN1bHQgPSB7fTtcXG5cXHRcXHR2YXIga2V5O1xcblxcdFxcdGZvciAoa2V5IGluIGRlZmF1bHRzKSB7XFxuXFx0XFx0XFx0Ly8gQSBgaGFzT3duUHJvcGVydHlgIGNoZWNrIGlzIG5vdCBuZWVkZWQgaGVyZSwgc2luY2Ugb25seSByZWNvZ25pemVkXFxuXFx0XFx0XFx0Ly8gb3B0aW9uIG5hbWVzIGFyZSB1c2VkIGFueXdheS4gQW55IG90aGVycyBhcmUgaWdub3JlZC5cXG5cXHRcXHRcXHRyZXN1bHRba2V5XSA9IGhhcyhvcHRpb25zLCBrZXkpID8gb3B0aW9uc1trZXldIDogZGVmYXVsdHNba2V5XTtcXG5cXHRcXHR9XFxuXFx0XFx0cmV0dXJuIHJlc3VsdDtcXG5cXHR9O1xcblxcblxcdC8vIE1vZGlmaWVkIHZlcnNpb24gb2YgYHVjczJlbmNvZGVgOyBzZWUgaHR0cHM6Ly9tdGhzLmJlL3B1bnljb2RlLlxcblxcdHZhciBjb2RlUG9pbnRUb1N5bWJvbCA9IGZ1bmN0aW9uKGNvZGVQb2ludCwgc3RyaWN0KSB7XFxuXFx0XFx0dmFyIG91dHB1dCA9ICcnO1xcblxcdFxcdGlmICgoY29kZVBvaW50ID49IDB4RDgwMCAmJiBjb2RlUG9pbnQgPD0gMHhERkZGKSB8fCBjb2RlUG9pbnQgPiAweDEwRkZGRikge1xcblxcdFxcdFxcdC8vIFNlZSBpc3N1ZSAjNDpcXG5cXHRcXHRcXHQvLyDigJxPdGhlcndpc2UsIGlmIHRoZSBudW1iZXIgaXMgaW4gdGhlIHJhbmdlIDB4RDgwMCB0byAweERGRkYgb3IgaXNcXG5cXHRcXHRcXHQvLyBncmVhdGVyIHRoYW4gMHgxMEZGRkYsIHRoZW4gdGhpcyBpcyBhIHBhcnNlIGVycm9yLiBSZXR1cm4gYSBVK0ZGRkRcXG5cXHRcXHRcXHQvLyBSRVBMQUNFTUVOVCBDSEFSQUNURVIu4oCdXFxuXFx0XFx0XFx0aWYgKHN0cmljdCkge1xcblxcdFxcdFxcdFxcdHBhcnNlRXJyb3IoJ2NoYXJhY3RlciByZWZlcmVuY2Ugb3V0c2lkZSB0aGUgcGVybWlzc2libGUgVW5pY29kZSByYW5nZScpO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRyZXR1cm4gJ1xcXFx1RkZGRCc7XFxuXFx0XFx0fVxcblxcdFxcdGlmIChoYXMoZGVjb2RlTWFwTnVtZXJpYywgY29kZVBvaW50KSkge1xcblxcdFxcdFxcdGlmIChzdHJpY3QpIHtcXG5cXHRcXHRcXHRcXHRwYXJzZUVycm9yKCdkaXNhbGxvd2VkIGNoYXJhY3RlciByZWZlcmVuY2UnKTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0cmV0dXJuIGRlY29kZU1hcE51bWVyaWNbY29kZVBvaW50XTtcXG5cXHRcXHR9XFxuXFx0XFx0aWYgKHN0cmljdCAmJiBjb250YWlucyhpbnZhbGlkUmVmZXJlbmNlQ29kZVBvaW50cywgY29kZVBvaW50KSkge1xcblxcdFxcdFxcdHBhcnNlRXJyb3IoJ2Rpc2FsbG93ZWQgY2hhcmFjdGVyIHJlZmVyZW5jZScpO1xcblxcdFxcdH1cXG5cXHRcXHRpZiAoY29kZVBvaW50ID4gMHhGRkZGKSB7XFxuXFx0XFx0XFx0Y29kZVBvaW50IC09IDB4MTAwMDA7XFxuXFx0XFx0XFx0b3V0cHV0ICs9IHN0cmluZ0Zyb21DaGFyQ29kZShjb2RlUG9pbnQgPj4+IDEwICYgMHgzRkYgfCAweEQ4MDApO1xcblxcdFxcdFxcdGNvZGVQb2ludCA9IDB4REMwMCB8IGNvZGVQb2ludCAmIDB4M0ZGO1xcblxcdFxcdH1cXG5cXHRcXHRvdXRwdXQgKz0gc3RyaW5nRnJvbUNoYXJDb2RlKGNvZGVQb2ludCk7XFxuXFx0XFx0cmV0dXJuIG91dHB1dDtcXG5cXHR9O1xcblxcblxcdHZhciBoZXhFc2NhcGUgPSBmdW5jdGlvbihjb2RlUG9pbnQpIHtcXG5cXHRcXHRyZXR1cm4gJyYjeCcgKyBjb2RlUG9pbnQudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCkgKyAnOyc7XFxuXFx0fTtcXG5cXG5cXHR2YXIgZGVjRXNjYXBlID0gZnVuY3Rpb24oY29kZVBvaW50KSB7XFxuXFx0XFx0cmV0dXJuICcmIycgKyBjb2RlUG9pbnQgKyAnOyc7XFxuXFx0fTtcXG5cXG5cXHR2YXIgcGFyc2VFcnJvciA9IGZ1bmN0aW9uKG1lc3NhZ2UpIHtcXG5cXHRcXHR0aHJvdyBFcnJvcignUGFyc2UgZXJyb3I6ICcgKyBtZXNzYWdlKTtcXG5cXHR9O1xcblxcblxcdC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xcblxcblxcdHZhciBlbmNvZGUgPSBmdW5jdGlvbihzdHJpbmcsIG9wdGlvbnMpIHtcXG5cXHRcXHRvcHRpb25zID0gbWVyZ2Uob3B0aW9ucywgZW5jb2RlLm9wdGlvbnMpO1xcblxcdFxcdHZhciBzdHJpY3QgPSBvcHRpb25zLnN0cmljdDtcXG5cXHRcXHRpZiAoc3RyaWN0ICYmIHJlZ2V4SW52YWxpZFJhd0NvZGVQb2ludC50ZXN0KHN0cmluZykpIHtcXG5cXHRcXHRcXHRwYXJzZUVycm9yKCdmb3JiaWRkZW4gY29kZSBwb2ludCcpO1xcblxcdFxcdH1cXG5cXHRcXHR2YXIgZW5jb2RlRXZlcnl0aGluZyA9IG9wdGlvbnMuZW5jb2RlRXZlcnl0aGluZztcXG5cXHRcXHR2YXIgdXNlTmFtZWRSZWZlcmVuY2VzID0gb3B0aW9ucy51c2VOYW1lZFJlZmVyZW5jZXM7XFxuXFx0XFx0dmFyIGFsbG93VW5zYWZlU3ltYm9scyA9IG9wdGlvbnMuYWxsb3dVbnNhZmVTeW1ib2xzO1xcblxcdFxcdHZhciBlc2NhcGVDb2RlUG9pbnQgPSBvcHRpb25zLmRlY2ltYWwgPyBkZWNFc2NhcGUgOiBoZXhFc2NhcGU7XFxuXFxuXFx0XFx0dmFyIGVzY2FwZUJtcFN5bWJvbCA9IGZ1bmN0aW9uKHN5bWJvbCkge1xcblxcdFxcdFxcdHJldHVybiBlc2NhcGVDb2RlUG9pbnQoc3ltYm9sLmNoYXJDb2RlQXQoMCkpO1xcblxcdFxcdH07XFxuXFxuXFx0XFx0aWYgKGVuY29kZUV2ZXJ5dGhpbmcpIHtcXG5cXHRcXHRcXHQvLyBFbmNvZGUgQVNDSUkgc3ltYm9scy5cXG5cXHRcXHRcXHRzdHJpbmcgPSBzdHJpbmcucmVwbGFjZShyZWdleEFzY2lpV2hpdGVsaXN0LCBmdW5jdGlvbihzeW1ib2wpIHtcXG5cXHRcXHRcXHRcXHQvLyBVc2UgbmFtZWQgcmVmZXJlbmNlcyBpZiByZXF1ZXN0ZWQgJiBwb3NzaWJsZS5cXG5cXHRcXHRcXHRcXHRpZiAodXNlTmFtZWRSZWZlcmVuY2VzICYmIGhhcyhlbmNvZGVNYXAsIHN5bWJvbCkpIHtcXG5cXHRcXHRcXHRcXHRcXHRyZXR1cm4gJyYnICsgZW5jb2RlTWFwW3N5bWJvbF0gKyAnOyc7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdHJldHVybiBlc2NhcGVCbXBTeW1ib2woc3ltYm9sKTtcXG5cXHRcXHRcXHR9KTtcXG5cXHRcXHRcXHQvLyBTaG9ydGVuIGEgZmV3IGVzY2FwZXMgdGhhdCByZXByZXNlbnQgdHdvIHN5bWJvbHMsIG9mIHdoaWNoIGF0IGxlYXN0IG9uZVxcblxcdFxcdFxcdC8vIGlzIHdpdGhpbiB0aGUgQVNDSUkgcmFuZ2UuXFxuXFx0XFx0XFx0aWYgKHVzZU5hbWVkUmVmZXJlbmNlcykge1xcblxcdFxcdFxcdFxcdHN0cmluZyA9IHN0cmluZ1xcblxcdFxcdFxcdFxcdFxcdC5yZXBsYWNlKC8mZ3Q7XFxcXHUyMEQyL2csICcmbnZndDsnKVxcblxcdFxcdFxcdFxcdFxcdC5yZXBsYWNlKC8mbHQ7XFxcXHUyMEQyL2csICcmbnZsdDsnKVxcblxcdFxcdFxcdFxcdFxcdC5yZXBsYWNlKC8mI3g2NjsmI3g2QTsvZywgJyZmamxpZzsnKTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0Ly8gRW5jb2RlIG5vbi1BU0NJSSBzeW1ib2xzLlxcblxcdFxcdFxcdGlmICh1c2VOYW1lZFJlZmVyZW5jZXMpIHtcXG5cXHRcXHRcXHRcXHQvLyBFbmNvZGUgbm9uLUFTQ0lJIHN5bWJvbHMgdGhhdCBjYW4gYmUgcmVwbGFjZWQgd2l0aCBhIG5hbWVkIHJlZmVyZW5jZS5cXG5cXHRcXHRcXHRcXHRzdHJpbmcgPSBzdHJpbmcucmVwbGFjZShyZWdleEVuY29kZU5vbkFzY2lpLCBmdW5jdGlvbihzdHJpbmcpIHtcXG5cXHRcXHRcXHRcXHRcXHQvLyBOb3RlOiB0aGVyZSBpcyBubyBuZWVkIHRvIGNoZWNrIGBoYXMoZW5jb2RlTWFwLCBzdHJpbmcpYCBoZXJlLlxcblxcdFxcdFxcdFxcdFxcdHJldHVybiAnJicgKyBlbmNvZGVNYXBbc3RyaW5nXSArICc7JztcXG5cXHRcXHRcXHRcXHR9KTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0Ly8gTm90ZTogYW55IHJlbWFpbmluZyBub24tQVNDSUkgc3ltYm9scyBhcmUgaGFuZGxlZCBvdXRzaWRlIG9mIHRoZSBgaWZgLlxcblxcdFxcdH0gZWxzZSBpZiAodXNlTmFtZWRSZWZlcmVuY2VzKSB7XFxuXFx0XFx0XFx0Ly8gQXBwbHkgbmFtZWQgY2hhcmFjdGVyIHJlZmVyZW5jZXMuXFxuXFx0XFx0XFx0Ly8gRW5jb2RlIGA8PlxcXCInJmAgdXNpbmcgbmFtZWQgY2hhcmFjdGVyIHJlZmVyZW5jZXMuXFxuXFx0XFx0XFx0aWYgKCFhbGxvd1Vuc2FmZVN5bWJvbHMpIHtcXG5cXHRcXHRcXHRcXHRzdHJpbmcgPSBzdHJpbmcucmVwbGFjZShyZWdleEVzY2FwZSwgZnVuY3Rpb24oc3RyaW5nKSB7XFxuXFx0XFx0XFx0XFx0XFx0cmV0dXJuICcmJyArIGVuY29kZU1hcFtzdHJpbmddICsgJzsnOyAvLyBubyBuZWVkIHRvIGNoZWNrIGBoYXMoKWAgaGVyZVxcblxcdFxcdFxcdFxcdH0pO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHQvLyBTaG9ydGVuIGVzY2FwZXMgdGhhdCByZXByZXNlbnQgdHdvIHN5bWJvbHMsIG9mIHdoaWNoIGF0IGxlYXN0IG9uZSBpc1xcblxcdFxcdFxcdC8vIGA8PlxcXCInJmAuXFxuXFx0XFx0XFx0c3RyaW5nID0gc3RyaW5nXFxuXFx0XFx0XFx0XFx0LnJlcGxhY2UoLyZndDtcXFxcdTIwRDIvZywgJyZudmd0OycpXFxuXFx0XFx0XFx0XFx0LnJlcGxhY2UoLyZsdDtcXFxcdTIwRDIvZywgJyZudmx0OycpO1xcblxcdFxcdFxcdC8vIEVuY29kZSBub24tQVNDSUkgc3ltYm9scyB0aGF0IGNhbiBiZSByZXBsYWNlZCB3aXRoIGEgbmFtZWQgcmVmZXJlbmNlLlxcblxcdFxcdFxcdHN0cmluZyA9IHN0cmluZy5yZXBsYWNlKHJlZ2V4RW5jb2RlTm9uQXNjaWksIGZ1bmN0aW9uKHN0cmluZykge1xcblxcdFxcdFxcdFxcdC8vIE5vdGU6IHRoZXJlIGlzIG5vIG5lZWQgdG8gY2hlY2sgYGhhcyhlbmNvZGVNYXAsIHN0cmluZylgIGhlcmUuXFxuXFx0XFx0XFx0XFx0cmV0dXJuICcmJyArIGVuY29kZU1hcFtzdHJpbmddICsgJzsnO1xcblxcdFxcdFxcdH0pO1xcblxcdFxcdH0gZWxzZSBpZiAoIWFsbG93VW5zYWZlU3ltYm9scykge1xcblxcdFxcdFxcdC8vIEVuY29kZSBgPD5cXFwiJyZgIHVzaW5nIGhleGFkZWNpbWFsIGVzY2FwZXMsIG5vdyB0aGF0IHRoZXnigJlyZSBub3QgaGFuZGxlZFxcblxcdFxcdFxcdC8vIHVzaW5nIG5hbWVkIGNoYXJhY3RlciByZWZlcmVuY2VzLlxcblxcdFxcdFxcdHN0cmluZyA9IHN0cmluZy5yZXBsYWNlKHJlZ2V4RXNjYXBlLCBlc2NhcGVCbXBTeW1ib2wpO1xcblxcdFxcdH1cXG5cXHRcXHRyZXR1cm4gc3RyaW5nXFxuXFx0XFx0XFx0Ly8gRW5jb2RlIGFzdHJhbCBzeW1ib2xzLlxcblxcdFxcdFxcdC5yZXBsYWNlKHJlZ2V4QXN0cmFsU3ltYm9scywgZnVuY3Rpb24oJDApIHtcXG5cXHRcXHRcXHRcXHQvLyBodHRwczovL21hdGhpYXNieW5lbnMuYmUvbm90ZXMvamF2YXNjcmlwdC1lbmNvZGluZyNzdXJyb2dhdGUtZm9ybXVsYWVcXG5cXHRcXHRcXHRcXHR2YXIgaGlnaCA9ICQwLmNoYXJDb2RlQXQoMCk7XFxuXFx0XFx0XFx0XFx0dmFyIGxvdyA9ICQwLmNoYXJDb2RlQXQoMSk7XFxuXFx0XFx0XFx0XFx0dmFyIGNvZGVQb2ludCA9IChoaWdoIC0gMHhEODAwKSAqIDB4NDAwICsgbG93IC0gMHhEQzAwICsgMHgxMDAwMDtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gZXNjYXBlQ29kZVBvaW50KGNvZGVQb2ludCk7XFxuXFx0XFx0XFx0fSlcXG5cXHRcXHRcXHQvLyBFbmNvZGUgYW55IHJlbWFpbmluZyBCTVAgc3ltYm9scyB0aGF0IGFyZSBub3QgcHJpbnRhYmxlIEFTQ0lJIHN5bWJvbHNcXG5cXHRcXHRcXHQvLyB1c2luZyBhIGhleGFkZWNpbWFsIGVzY2FwZS5cXG5cXHRcXHRcXHQucmVwbGFjZShyZWdleEJtcFdoaXRlbGlzdCwgZXNjYXBlQm1wU3ltYm9sKTtcXG5cXHR9O1xcblxcdC8vIEV4cG9zZSBkZWZhdWx0IG9wdGlvbnMgKHNvIHRoZXkgY2FuIGJlIG92ZXJyaWRkZW4gZ2xvYmFsbHkpLlxcblxcdGVuY29kZS5vcHRpb25zID0ge1xcblxcdFxcdCdhbGxvd1Vuc2FmZVN5bWJvbHMnOiBmYWxzZSxcXG5cXHRcXHQnZW5jb2RlRXZlcnl0aGluZyc6IGZhbHNlLFxcblxcdFxcdCdzdHJpY3QnOiBmYWxzZSxcXG5cXHRcXHQndXNlTmFtZWRSZWZlcmVuY2VzJzogZmFsc2UsXFxuXFx0XFx0J2RlY2ltYWwnIDogZmFsc2VcXG5cXHR9O1xcblxcblxcdHZhciBkZWNvZGUgPSBmdW5jdGlvbihodG1sLCBvcHRpb25zKSB7XFxuXFx0XFx0b3B0aW9ucyA9IG1lcmdlKG9wdGlvbnMsIGRlY29kZS5vcHRpb25zKTtcXG5cXHRcXHR2YXIgc3RyaWN0ID0gb3B0aW9ucy5zdHJpY3Q7XFxuXFx0XFx0aWYgKHN0cmljdCAmJiByZWdleEludmFsaWRFbnRpdHkudGVzdChodG1sKSkge1xcblxcdFxcdFxcdHBhcnNlRXJyb3IoJ21hbGZvcm1lZCBjaGFyYWN0ZXIgcmVmZXJlbmNlJyk7XFxuXFx0XFx0fVxcblxcdFxcdHJldHVybiBodG1sLnJlcGxhY2UocmVnZXhEZWNvZGUsIGZ1bmN0aW9uKCQwLCAkMSwgJDIsICQzLCAkNCwgJDUsICQ2LCAkNykge1xcblxcdFxcdFxcdHZhciBjb2RlUG9pbnQ7XFxuXFx0XFx0XFx0dmFyIHNlbWljb2xvbjtcXG5cXHRcXHRcXHR2YXIgZGVjRGlnaXRzO1xcblxcdFxcdFxcdHZhciBoZXhEaWdpdHM7XFxuXFx0XFx0XFx0dmFyIHJlZmVyZW5jZTtcXG5cXHRcXHRcXHR2YXIgbmV4dDtcXG5cXHRcXHRcXHRpZiAoJDEpIHtcXG5cXHRcXHRcXHRcXHQvLyBEZWNvZGUgZGVjaW1hbCBlc2NhcGVzLCBlLmcuIGAmIzExOTU1ODtgLlxcblxcdFxcdFxcdFxcdGRlY0RpZ2l0cyA9ICQxO1xcblxcdFxcdFxcdFxcdHNlbWljb2xvbiA9ICQyO1xcblxcdFxcdFxcdFxcdGlmIChzdHJpY3QgJiYgIXNlbWljb2xvbikge1xcblxcdFxcdFxcdFxcdFxcdHBhcnNlRXJyb3IoJ2NoYXJhY3RlciByZWZlcmVuY2Ugd2FzIG5vdCB0ZXJtaW5hdGVkIGJ5IGEgc2VtaWNvbG9uJyk7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdGNvZGVQb2ludCA9IHBhcnNlSW50KGRlY0RpZ2l0cywgMTApO1xcblxcdFxcdFxcdFxcdHJldHVybiBjb2RlUG9pbnRUb1N5bWJvbChjb2RlUG9pbnQsIHN0cmljdCk7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdGlmICgkMykge1xcblxcdFxcdFxcdFxcdC8vIERlY29kZSBoZXhhZGVjaW1hbCBlc2NhcGVzLCBlLmcuIGAmI3gxRDMwNjtgLlxcblxcdFxcdFxcdFxcdGhleERpZ2l0cyA9ICQzO1xcblxcdFxcdFxcdFxcdHNlbWljb2xvbiA9ICQ0O1xcblxcdFxcdFxcdFxcdGlmIChzdHJpY3QgJiYgIXNlbWljb2xvbikge1xcblxcdFxcdFxcdFxcdFxcdHBhcnNlRXJyb3IoJ2NoYXJhY3RlciByZWZlcmVuY2Ugd2FzIG5vdCB0ZXJtaW5hdGVkIGJ5IGEgc2VtaWNvbG9uJyk7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdGNvZGVQb2ludCA9IHBhcnNlSW50KGhleERpZ2l0cywgMTYpO1xcblxcdFxcdFxcdFxcdHJldHVybiBjb2RlUG9pbnRUb1N5bWJvbChjb2RlUG9pbnQsIHN0cmljdCk7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdGlmICgkNSkge1xcblxcdFxcdFxcdFxcdC8vIERlY29kZSBuYW1lZCBjaGFyYWN0ZXIgcmVmZXJlbmNlcyB3aXRoIHRyYWlsaW5nIGA7YCwgZS5nLiBgJmNvcHk7YC5cXG5cXHRcXHRcXHRcXHRyZWZlcmVuY2UgPSAkNTtcXG5cXHRcXHRcXHRcXHRpZiAoaGFzKGRlY29kZU1hcCwgcmVmZXJlbmNlKSkge1xcblxcdFxcdFxcdFxcdFxcdHJldHVybiBkZWNvZGVNYXBbcmVmZXJlbmNlXTtcXG5cXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdFxcdC8vIEFtYmlndW91cyBhbXBlcnNhbmQuIGh0dHBzOi8vbXRocy5iZS9ub3Rlcy9hbWJpZ3VvdXMtYW1wZXJzYW5kc1xcblxcdFxcdFxcdFxcdFxcdGlmIChzdHJpY3QpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRwYXJzZUVycm9yKFxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdCduYW1lZCBjaGFyYWN0ZXIgcmVmZXJlbmNlIHdhcyBub3QgdGVybWluYXRlZCBieSBhIHNlbWljb2xvbidcXG5cXHRcXHRcXHRcXHRcXHRcXHQpO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRyZXR1cm4gJDA7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHQvLyBJZiB3ZeKAmXJlIHN0aWxsIGhlcmUsIGl04oCZcyBhIGxlZ2FjeSByZWZlcmVuY2UgZm9yIHN1cmUuIE5vIG5lZWQgZm9yIGFuXFxuXFx0XFx0XFx0Ly8gZXh0cmEgYGlmYCBjaGVjay5cXG5cXHRcXHRcXHQvLyBEZWNvZGUgbmFtZWQgY2hhcmFjdGVyIHJlZmVyZW5jZXMgd2l0aG91dCB0cmFpbGluZyBgO2AsIGUuZy4gYCZhbXBgXFxuXFx0XFx0XFx0Ly8gVGhpcyBpcyBvbmx5IGEgcGFyc2UgZXJyb3IgaWYgaXQgZ2V0cyBjb252ZXJ0ZWQgdG8gYCZgLCBvciBpZiBpdCBpc1xcblxcdFxcdFxcdC8vIGZvbGxvd2VkIGJ5IGA9YCBpbiBhbiBhdHRyaWJ1dGUgY29udGV4dC5cXG5cXHRcXHRcXHRyZWZlcmVuY2UgPSAkNjtcXG5cXHRcXHRcXHRuZXh0ID0gJDc7XFxuXFx0XFx0XFx0aWYgKG5leHQgJiYgb3B0aW9ucy5pc0F0dHJpYnV0ZVZhbHVlKSB7XFxuXFx0XFx0XFx0XFx0aWYgKHN0cmljdCAmJiBuZXh0ID09ICc9Jykge1xcblxcdFxcdFxcdFxcdFxcdHBhcnNlRXJyb3IoJ2AmYCBkaWQgbm90IHN0YXJ0IGEgY2hhcmFjdGVyIHJlZmVyZW5jZScpO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRyZXR1cm4gJDA7XFxuXFx0XFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRcXHRpZiAoc3RyaWN0KSB7XFxuXFx0XFx0XFx0XFx0XFx0cGFyc2VFcnJvcihcXG5cXHRcXHRcXHRcXHRcXHRcXHQnbmFtZWQgY2hhcmFjdGVyIHJlZmVyZW5jZSB3YXMgbm90IHRlcm1pbmF0ZWQgYnkgYSBzZW1pY29sb24nXFxuXFx0XFx0XFx0XFx0XFx0KTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0Ly8gTm90ZTogdGhlcmUgaXMgbm8gbmVlZCB0byBjaGVjayBgaGFzKGRlY29kZU1hcExlZ2FjeSwgcmVmZXJlbmNlKWAuXFxuXFx0XFx0XFx0XFx0cmV0dXJuIGRlY29kZU1hcExlZ2FjeVtyZWZlcmVuY2VdICsgKG5leHQgfHwgJycpO1xcblxcdFxcdFxcdH1cXG5cXHRcXHR9KTtcXG5cXHR9O1xcblxcdC8vIEV4cG9zZSBkZWZhdWx0IG9wdGlvbnMgKHNvIHRoZXkgY2FuIGJlIG92ZXJyaWRkZW4gZ2xvYmFsbHkpLlxcblxcdGRlY29kZS5vcHRpb25zID0ge1xcblxcdFxcdCdpc0F0dHJpYnV0ZVZhbHVlJzogZmFsc2UsXFxuXFx0XFx0J3N0cmljdCc6IGZhbHNlXFxuXFx0fTtcXG5cXG5cXHR2YXIgZXNjYXBlID0gZnVuY3Rpb24oc3RyaW5nKSB7XFxuXFx0XFx0cmV0dXJuIHN0cmluZy5yZXBsYWNlKHJlZ2V4RXNjYXBlLCBmdW5jdGlvbigkMCkge1xcblxcdFxcdFxcdC8vIE5vdGU6IHRoZXJlIGlzIG5vIG5lZWQgdG8gY2hlY2sgYGhhcyhlc2NhcGVNYXAsICQwKWAgaGVyZS5cXG5cXHRcXHRcXHRyZXR1cm4gZXNjYXBlTWFwWyQwXTtcXG5cXHRcXHR9KTtcXG5cXHR9O1xcblxcblxcdC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xcblxcblxcdHZhciBoZSA9IHtcXG5cXHRcXHQndmVyc2lvbic6ICcxLjEuMScsXFxuXFx0XFx0J2VuY29kZSc6IGVuY29kZSxcXG5cXHRcXHQnZGVjb2RlJzogZGVjb2RlLFxcblxcdFxcdCdlc2NhcGUnOiBlc2NhcGUsXFxuXFx0XFx0J3VuZXNjYXBlJzogZGVjb2RlXFxuXFx0fTtcXG5cXG5cXHQvLyBTb21lIEFNRCBidWlsZCBvcHRpbWl6ZXJzLCBsaWtlIHIuanMsIGNoZWNrIGZvciBzcGVjaWZpYyBjb25kaXRpb24gcGF0dGVybnNcXG5cXHQvLyBsaWtlIHRoZSBmb2xsb3dpbmc6XFxuXFx0aWYgKFxcblxcdFxcdGZhbHNlXFxuXFx0KSB7XFxuXFx0XFx0ZGVmaW5lKGZ1bmN0aW9uKCkge1xcblxcdFxcdFxcdHJldHVybiBoZTtcXG5cXHRcXHR9KTtcXG5cXHR9XFx0ZWxzZSBpZiAoZnJlZUV4cG9ydHMgJiYgIWZyZWVFeHBvcnRzLm5vZGVUeXBlKSB7XFxuXFx0XFx0aWYgKGZyZWVNb2R1bGUpIHsgLy8gaW4gTm9kZS5qcywgaW8uanMsIG9yIFJpbmdvSlMgdjAuOC4wK1xcblxcdFxcdFxcdGZyZWVNb2R1bGUuZXhwb3J0cyA9IGhlO1xcblxcdFxcdH0gZWxzZSB7IC8vIGluIE5hcndoYWwgb3IgUmluZ29KUyB2MC43LjAtXFxuXFx0XFx0XFx0Zm9yICh2YXIga2V5IGluIGhlKSB7XFxuXFx0XFx0XFx0XFx0aGFzKGhlLCBrZXkpICYmIChmcmVlRXhwb3J0c1trZXldID0gaGVba2V5XSk7XFxuXFx0XFx0XFx0fVxcblxcdFxcdH1cXG5cXHR9IGVsc2UgeyAvLyBpbiBSaGlubyBvciBhIHdlYiBicm93c2VyXFxuXFx0XFx0cm9vdC5oZSA9IGhlO1xcblxcdH1cXG5cXG59KHRoaXMpKTtcXG5cXG59KS5jYWxsKHRoaXMsdHlwZW9mIGdsb2JhbCAhPT0gXFxcInVuZGVmaW5lZFxcXCIgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gXFxcInVuZGVmaW5lZFxcXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXFxcInVuZGVmaW5lZFxcXCIgPyB3aW5kb3cgOiB7fSlcXG59LHt9XSw2NTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XFxuZXhwb3J0cy5yZWFkID0gZnVuY3Rpb24gKGJ1ZmZlciwgb2Zmc2V0LCBpc0xFLCBtTGVuLCBuQnl0ZXMpIHtcXG4gIHZhciBlLCBtXFxuICB2YXIgZUxlbiA9IG5CeXRlcyAqIDggLSBtTGVuIC0gMVxcbiAgdmFyIGVNYXggPSAoMSA8PCBlTGVuKSAtIDFcXG4gIHZhciBlQmlhcyA9IGVNYXggPj4gMVxcbiAgdmFyIG5CaXRzID0gLTdcXG4gIHZhciBpID0gaXNMRSA/IChuQnl0ZXMgLSAxKSA6IDBcXG4gIHZhciBkID0gaXNMRSA/IC0xIDogMVxcbiAgdmFyIHMgPSBidWZmZXJbb2Zmc2V0ICsgaV1cXG5cXG4gIGkgKz0gZFxcblxcbiAgZSA9IHMgJiAoKDEgPDwgKC1uQml0cykpIC0gMSlcXG4gIHMgPj49ICgtbkJpdHMpXFxuICBuQml0cyArPSBlTGVuXFxuICBmb3IgKDsgbkJpdHMgPiAwOyBlID0gZSAqIDI1NiArIGJ1ZmZlcltvZmZzZXQgKyBpXSwgaSArPSBkLCBuQml0cyAtPSA4KSB7fVxcblxcbiAgbSA9IGUgJiAoKDEgPDwgKC1uQml0cykpIC0gMSlcXG4gIGUgPj49ICgtbkJpdHMpXFxuICBuQml0cyArPSBtTGVuXFxuICBmb3IgKDsgbkJpdHMgPiAwOyBtID0gbSAqIDI1NiArIGJ1ZmZlcltvZmZzZXQgKyBpXSwgaSArPSBkLCBuQml0cyAtPSA4KSB7fVxcblxcbiAgaWYgKGUgPT09IDApIHtcXG4gICAgZSA9IDEgLSBlQmlhc1xcbiAgfSBlbHNlIGlmIChlID09PSBlTWF4KSB7XFxuICAgIHJldHVybiBtID8gTmFOIDogKChzID8gLTEgOiAxKSAqIEluZmluaXR5KVxcbiAgfSBlbHNlIHtcXG4gICAgbSA9IG0gKyBNYXRoLnBvdygyLCBtTGVuKVxcbiAgICBlID0gZSAtIGVCaWFzXFxuICB9XFxuICByZXR1cm4gKHMgPyAtMSA6IDEpICogbSAqIE1hdGgucG93KDIsIGUgLSBtTGVuKVxcbn1cXG5cXG5leHBvcnRzLndyaXRlID0gZnVuY3Rpb24gKGJ1ZmZlciwgdmFsdWUsIG9mZnNldCwgaXNMRSwgbUxlbiwgbkJ5dGVzKSB7XFxuICB2YXIgZSwgbSwgY1xcbiAgdmFyIGVMZW4gPSBuQnl0ZXMgKiA4IC0gbUxlbiAtIDFcXG4gIHZhciBlTWF4ID0gKDEgPDwgZUxlbikgLSAxXFxuICB2YXIgZUJpYXMgPSBlTWF4ID4+IDFcXG4gIHZhciBydCA9IChtTGVuID09PSAyMyA/IE1hdGgucG93KDIsIC0yNCkgLSBNYXRoLnBvdygyLCAtNzcpIDogMClcXG4gIHZhciBpID0gaXNMRSA/IDAgOiAobkJ5dGVzIC0gMSlcXG4gIHZhciBkID0gaXNMRSA/IDEgOiAtMVxcbiAgdmFyIHMgPSB2YWx1ZSA8IDAgfHwgKHZhbHVlID09PSAwICYmIDEgLyB2YWx1ZSA8IDApID8gMSA6IDBcXG5cXG4gIHZhbHVlID0gTWF0aC5hYnModmFsdWUpXFxuXFxuICBpZiAoaXNOYU4odmFsdWUpIHx8IHZhbHVlID09PSBJbmZpbml0eSkge1xcbiAgICBtID0gaXNOYU4odmFsdWUpID8gMSA6IDBcXG4gICAgZSA9IGVNYXhcXG4gIH0gZWxzZSB7XFxuICAgIGUgPSBNYXRoLmZsb29yKE1hdGgubG9nKHZhbHVlKSAvIE1hdGguTE4yKVxcbiAgICBpZiAodmFsdWUgKiAoYyA9IE1hdGgucG93KDIsIC1lKSkgPCAxKSB7XFxuICAgICAgZS0tXFxuICAgICAgYyAqPSAyXFxuICAgIH1cXG4gICAgaWYgKGUgKyBlQmlhcyA+PSAxKSB7XFxuICAgICAgdmFsdWUgKz0gcnQgLyBjXFxuICAgIH0gZWxzZSB7XFxuICAgICAgdmFsdWUgKz0gcnQgKiBNYXRoLnBvdygyLCAxIC0gZUJpYXMpXFxuICAgIH1cXG4gICAgaWYgKHZhbHVlICogYyA+PSAyKSB7XFxuICAgICAgZSsrXFxuICAgICAgYyAvPSAyXFxuICAgIH1cXG5cXG4gICAgaWYgKGUgKyBlQmlhcyA+PSBlTWF4KSB7XFxuICAgICAgbSA9IDBcXG4gICAgICBlID0gZU1heFxcbiAgICB9IGVsc2UgaWYgKGUgKyBlQmlhcyA+PSAxKSB7XFxuICAgICAgbSA9ICh2YWx1ZSAqIGMgLSAxKSAqIE1hdGgucG93KDIsIG1MZW4pXFxuICAgICAgZSA9IGUgKyBlQmlhc1xcbiAgICB9IGVsc2Uge1xcbiAgICAgIG0gPSB2YWx1ZSAqIE1hdGgucG93KDIsIGVCaWFzIC0gMSkgKiBNYXRoLnBvdygyLCBtTGVuKVxcbiAgICAgIGUgPSAwXFxuICAgIH1cXG4gIH1cXG5cXG4gIGZvciAoOyBtTGVuID49IDg7IGJ1ZmZlcltvZmZzZXQgKyBpXSA9IG0gJiAweGZmLCBpICs9IGQsIG0gLz0gMjU2LCBtTGVuIC09IDgpIHt9XFxuXFxuICBlID0gKGUgPDwgbUxlbikgfCBtXFxuICBlTGVuICs9IG1MZW5cXG4gIGZvciAoOyBlTGVuID4gMDsgYnVmZmVyW29mZnNldCArIGldID0gZSAmIDB4ZmYsIGkgKz0gZCwgZSAvPSAyNTYsIGVMZW4gLT0gOCkge31cXG5cXG4gIGJ1ZmZlcltvZmZzZXQgKyBpIC0gZF0gfD0gcyAqIDEyOFxcbn1cXG5cXG59LHt9XSw2NjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XFxuaWYgKHR5cGVvZiBPYmplY3QuY3JlYXRlID09PSAnZnVuY3Rpb24nKSB7XFxuICAvLyBpbXBsZW1lbnRhdGlvbiBmcm9tIHN0YW5kYXJkIG5vZGUuanMgJ3V0aWwnIG1vZHVsZVxcbiAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpbmhlcml0cyhjdG9yLCBzdXBlckN0b3IpIHtcXG4gICAgY3Rvci5zdXBlcl8gPSBzdXBlckN0b3JcXG4gICAgY3Rvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ3Rvci5wcm90b3R5cGUsIHtcXG4gICAgICBjb25zdHJ1Y3Rvcjoge1xcbiAgICAgICAgdmFsdWU6IGN0b3IsXFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlLFxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXFxuICAgICAgfVxcbiAgICB9KTtcXG4gIH07XFxufSBlbHNlIHtcXG4gIC8vIG9sZCBzY2hvb2wgc2hpbSBmb3Igb2xkIGJyb3dzZXJzXFxuICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGluaGVyaXRzKGN0b3IsIHN1cGVyQ3Rvcikge1xcbiAgICBjdG9yLnN1cGVyXyA9IHN1cGVyQ3RvclxcbiAgICB2YXIgVGVtcEN0b3IgPSBmdW5jdGlvbiAoKSB7fVxcbiAgICBUZW1wQ3Rvci5wcm90b3R5cGUgPSBzdXBlckN0b3IucHJvdG90eXBlXFxuICAgIGN0b3IucHJvdG90eXBlID0gbmV3IFRlbXBDdG9yKClcXG4gICAgY3Rvci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBjdG9yXFxuICB9XFxufVxcblxcbn0se31dLDY3OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcXG4vKiFcXG4gKiBEZXRlcm1pbmUgaWYgYW4gb2JqZWN0IGlzIGEgQnVmZmVyXFxuICpcXG4gKiBAYXV0aG9yICAgRmVyb3NzIEFib3VraGFkaWplaCA8ZmVyb3NzQGZlcm9zcy5vcmc+IDxodHRwOi8vZmVyb3NzLm9yZz5cXG4gKiBAbGljZW5zZSAgTUlUXFxuICovXFxuXFxuLy8gVGhlIF9pc0J1ZmZlciBjaGVjayBpcyBmb3IgU2FmYXJpIDUtNyBzdXBwb3J0LCBiZWNhdXNlIGl0J3MgbWlzc2luZ1xcbi8vIE9iamVjdC5wcm90b3R5cGUuY29uc3RydWN0b3IuIFJlbW92ZSB0aGlzIGV2ZW50dWFsbHlcXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChvYmopIHtcXG4gIHJldHVybiBvYmogIT0gbnVsbCAmJiAoaXNCdWZmZXIob2JqKSB8fCBpc1Nsb3dCdWZmZXIob2JqKSB8fCAhIW9iai5faXNCdWZmZXIpXFxufVxcblxcbmZ1bmN0aW9uIGlzQnVmZmVyIChvYmopIHtcXG4gIHJldHVybiAhIW9iai5jb25zdHJ1Y3RvciAmJiB0eXBlb2Ygb2JqLmNvbnN0cnVjdG9yLmlzQnVmZmVyID09PSAnZnVuY3Rpb24nICYmIG9iai5jb25zdHJ1Y3Rvci5pc0J1ZmZlcihvYmopXFxufVxcblxcbi8vIEZvciBOb2RlIHYwLjEwIHN1cHBvcnQuIFJlbW92ZSB0aGlzIGV2ZW50dWFsbHkuXFxuZnVuY3Rpb24gaXNTbG93QnVmZmVyIChvYmopIHtcXG4gIHJldHVybiB0eXBlb2Ygb2JqLnJlYWRGbG9hdExFID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBvYmouc2xpY2UgPT09ICdmdW5jdGlvbicgJiYgaXNCdWZmZXIob2JqLnNsaWNlKDAsIDApKVxcbn1cXG5cXG59LHt9XSw2ODpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XFxudmFyIHRvU3RyaW5nID0ge30udG9TdHJpbmc7XFxuXFxubW9kdWxlLmV4cG9ydHMgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uIChhcnIpIHtcXG4gIHJldHVybiB0b1N0cmluZy5jYWxsKGFycikgPT0gJ1tvYmplY3QgQXJyYXldJztcXG59O1xcblxcbn0se31dLDY5OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcXG4oZnVuY3Rpb24gKGdsb2JhbCl7XFxuLyohIEpTT04gdjMuMy4yIHwgaHR0cDovL2Jlc3RpZWpzLmdpdGh1Yi5pby9qc29uMyB8IENvcHlyaWdodCAyMDEyLTIwMTQsIEtpdCBDYW1icmlkZ2UgfCBodHRwOi8va2l0Lm1pdC1saWNlbnNlLm9yZyAqL1xcbjsoZnVuY3Rpb24gKCkge1xcbiAgLy8gRGV0ZWN0IHRoZSBgZGVmaW5lYCBmdW5jdGlvbiBleHBvc2VkIGJ5IGFzeW5jaHJvbm91cyBtb2R1bGUgbG9hZGVycy4gVGhlXFxuICAvLyBzdHJpY3QgYGRlZmluZWAgY2hlY2sgaXMgbmVjZXNzYXJ5IGZvciBjb21wYXRpYmlsaXR5IHdpdGggYHIuanNgLlxcbiAgdmFyIGlzTG9hZGVyID0gZmFsc2U7XFxuXFxuICAvLyBBIHNldCBvZiB0eXBlcyB1c2VkIHRvIGRpc3Rpbmd1aXNoIG9iamVjdHMgZnJvbSBwcmltaXRpdmVzLlxcbiAgdmFyIG9iamVjdFR5cGVzID0ge1xcbiAgICBcXFwiZnVuY3Rpb25cXFwiOiB0cnVlLFxcbiAgICBcXFwib2JqZWN0XFxcIjogdHJ1ZVxcbiAgfTtcXG5cXG4gIC8vIERldGVjdCB0aGUgYGV4cG9ydHNgIG9iamVjdCBleHBvc2VkIGJ5IENvbW1vbkpTIGltcGxlbWVudGF0aW9ucy5cXG4gIHZhciBmcmVlRXhwb3J0cyA9IG9iamVjdFR5cGVzW3R5cGVvZiBleHBvcnRzXSAmJiBleHBvcnRzICYmICFleHBvcnRzLm5vZGVUeXBlICYmIGV4cG9ydHM7XFxuXFxuICAvLyBVc2UgdGhlIGBnbG9iYWxgIG9iamVjdCBleHBvc2VkIGJ5IE5vZGUgKGluY2x1ZGluZyBCcm93c2VyaWZ5IHZpYVxcbiAgLy8gYGluc2VydC1tb2R1bGUtZ2xvYmFsc2ApLCBOYXJ3aGFsLCBhbmQgUmluZ28gYXMgdGhlIGRlZmF1bHQgY29udGV4dCxcXG4gIC8vIGFuZCB0aGUgYHdpbmRvd2Agb2JqZWN0IGluIGJyb3dzZXJzLiBSaGlubyBleHBvcnRzIGEgYGdsb2JhbGAgZnVuY3Rpb25cXG4gIC8vIGluc3RlYWQuXFxuICB2YXIgcm9vdCA9IG9iamVjdFR5cGVzW3R5cGVvZiB3aW5kb3ddICYmIHdpbmRvdyB8fCB0aGlzLFxcbiAgICAgIGZyZWVHbG9iYWwgPSBmcmVlRXhwb3J0cyAmJiBvYmplY3RUeXBlc1t0eXBlb2YgbW9kdWxlXSAmJiBtb2R1bGUgJiYgIW1vZHVsZS5ub2RlVHlwZSAmJiB0eXBlb2YgZ2xvYmFsID09IFxcXCJvYmplY3RcXFwiICYmIGdsb2JhbDtcXG5cXG4gIGlmIChmcmVlR2xvYmFsICYmIChmcmVlR2xvYmFsW1xcXCJnbG9iYWxcXFwiXSA9PT0gZnJlZUdsb2JhbCB8fCBmcmVlR2xvYmFsW1xcXCJ3aW5kb3dcXFwiXSA9PT0gZnJlZUdsb2JhbCB8fCBmcmVlR2xvYmFsW1xcXCJzZWxmXFxcIl0gPT09IGZyZWVHbG9iYWwpKSB7XFxuICAgIHJvb3QgPSBmcmVlR2xvYmFsO1xcbiAgfVxcblxcbiAgLy8gUHVibGljOiBJbml0aWFsaXplcyBKU09OIDMgdXNpbmcgdGhlIGdpdmVuIGBjb250ZXh0YCBvYmplY3QsIGF0dGFjaGluZyB0aGVcXG4gIC8vIGBzdHJpbmdpZnlgIGFuZCBgcGFyc2VgIGZ1bmN0aW9ucyB0byB0aGUgc3BlY2lmaWVkIGBleHBvcnRzYCBvYmplY3QuXFxuICBmdW5jdGlvbiBydW5JbkNvbnRleHQoY29udGV4dCwgZXhwb3J0cykge1xcbiAgICBjb250ZXh0IHx8IChjb250ZXh0ID0gcm9vdFtcXFwiT2JqZWN0XFxcIl0oKSk7XFxuICAgIGV4cG9ydHMgfHwgKGV4cG9ydHMgPSByb290W1xcXCJPYmplY3RcXFwiXSgpKTtcXG5cXG4gICAgLy8gTmF0aXZlIGNvbnN0cnVjdG9yIGFsaWFzZXMuXFxuICAgIHZhciBOdW1iZXIgPSBjb250ZXh0W1xcXCJOdW1iZXJcXFwiXSB8fCByb290W1xcXCJOdW1iZXJcXFwiXSxcXG4gICAgICAgIFN0cmluZyA9IGNvbnRleHRbXFxcIlN0cmluZ1xcXCJdIHx8IHJvb3RbXFxcIlN0cmluZ1xcXCJdLFxcbiAgICAgICAgT2JqZWN0ID0gY29udGV4dFtcXFwiT2JqZWN0XFxcIl0gfHwgcm9vdFtcXFwiT2JqZWN0XFxcIl0sXFxuICAgICAgICBEYXRlID0gY29udGV4dFtcXFwiRGF0ZVxcXCJdIHx8IHJvb3RbXFxcIkRhdGVcXFwiXSxcXG4gICAgICAgIFN5bnRheEVycm9yID0gY29udGV4dFtcXFwiU3ludGF4RXJyb3JcXFwiXSB8fCByb290W1xcXCJTeW50YXhFcnJvclxcXCJdLFxcbiAgICAgICAgVHlwZUVycm9yID0gY29udGV4dFtcXFwiVHlwZUVycm9yXFxcIl0gfHwgcm9vdFtcXFwiVHlwZUVycm9yXFxcIl0sXFxuICAgICAgICBNYXRoID0gY29udGV4dFtcXFwiTWF0aFxcXCJdIHx8IHJvb3RbXFxcIk1hdGhcXFwiXSxcXG4gICAgICAgIG5hdGl2ZUpTT04gPSBjb250ZXh0W1xcXCJKU09OXFxcIl0gfHwgcm9vdFtcXFwiSlNPTlxcXCJdO1xcblxcbiAgICAvLyBEZWxlZ2F0ZSB0byB0aGUgbmF0aXZlIGBzdHJpbmdpZnlgIGFuZCBgcGFyc2VgIGltcGxlbWVudGF0aW9ucy5cXG4gICAgaWYgKHR5cGVvZiBuYXRpdmVKU09OID09IFxcXCJvYmplY3RcXFwiICYmIG5hdGl2ZUpTT04pIHtcXG4gICAgICBleHBvcnRzLnN0cmluZ2lmeSA9IG5hdGl2ZUpTT04uc3RyaW5naWZ5O1xcbiAgICAgIGV4cG9ydHMucGFyc2UgPSBuYXRpdmVKU09OLnBhcnNlO1xcbiAgICB9XFxuXFxuICAgIC8vIENvbnZlbmllbmNlIGFsaWFzZXMuXFxuICAgIHZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGUsXFxuICAgICAgICBnZXRDbGFzcyA9IG9iamVjdFByb3RvLnRvU3RyaW5nLFxcbiAgICAgICAgaXNQcm9wZXJ0eSwgZm9yRWFjaCwgdW5kZWY7XFxuXFxuICAgIC8vIFRlc3QgdGhlIGBEYXRlI2dldFVUQypgIG1ldGhvZHMuIEJhc2VkIG9uIHdvcmsgYnkgQFlhZmZsZS5cXG4gICAgdmFyIGlzRXh0ZW5kZWQgPSBuZXcgRGF0ZSgtMzUwOTgyNzMzNDU3MzI5Mik7XFxuICAgIHRyeSB7XFxuICAgICAgLy8gVGhlIGBnZXRVVENGdWxsWWVhcmAsIGBNb250aGAsIGFuZCBgRGF0ZWAgbWV0aG9kcyByZXR1cm4gbm9uc2Vuc2ljYWxcXG4gICAgICAvLyByZXN1bHRzIGZvciBjZXJ0YWluIGRhdGVzIGluIE9wZXJhID49IDEwLjUzLlxcbiAgICAgIGlzRXh0ZW5kZWQgPSBpc0V4dGVuZGVkLmdldFVUQ0Z1bGxZZWFyKCkgPT0gLTEwOTI1MiAmJiBpc0V4dGVuZGVkLmdldFVUQ01vbnRoKCkgPT09IDAgJiYgaXNFeHRlbmRlZC5nZXRVVENEYXRlKCkgPT09IDEgJiZcXG4gICAgICAgIC8vIFNhZmFyaSA8IDIuMC4yIHN0b3JlcyB0aGUgaW50ZXJuYWwgbWlsbGlzZWNvbmQgdGltZSB2YWx1ZSBjb3JyZWN0bHksXFxuICAgICAgICAvLyBidXQgY2xpcHMgdGhlIHZhbHVlcyByZXR1cm5lZCBieSB0aGUgZGF0ZSBtZXRob2RzIHRvIHRoZSByYW5nZSBvZlxcbiAgICAgICAgLy8gc2lnbmVkIDMyLWJpdCBpbnRlZ2VycyAoWy0yICoqIDMxLCAyICoqIDMxIC0gMV0pLlxcbiAgICAgICAgaXNFeHRlbmRlZC5nZXRVVENIb3VycygpID09IDEwICYmIGlzRXh0ZW5kZWQuZ2V0VVRDTWludXRlcygpID09IDM3ICYmIGlzRXh0ZW5kZWQuZ2V0VVRDU2Vjb25kcygpID09IDYgJiYgaXNFeHRlbmRlZC5nZXRVVENNaWxsaXNlY29uZHMoKSA9PSA3MDg7XFxuICAgIH0gY2F0Y2ggKGV4Y2VwdGlvbikge31cXG5cXG4gICAgLy8gSW50ZXJuYWw6IERldGVybWluZXMgd2hldGhlciB0aGUgbmF0aXZlIGBKU09OLnN0cmluZ2lmeWAgYW5kIGBwYXJzZWBcXG4gICAgLy8gaW1wbGVtZW50YXRpb25zIGFyZSBzcGVjLWNvbXBsaWFudC4gQmFzZWQgb24gd29yayBieSBLZW4gU255ZGVyLlxcbiAgICBmdW5jdGlvbiBoYXMobmFtZSkge1xcbiAgICAgIGlmIChoYXNbbmFtZV0gIT09IHVuZGVmKSB7XFxuICAgICAgICAvLyBSZXR1cm4gY2FjaGVkIGZlYXR1cmUgdGVzdCByZXN1bHQuXFxuICAgICAgICByZXR1cm4gaGFzW25hbWVdO1xcbiAgICAgIH1cXG4gICAgICB2YXIgaXNTdXBwb3J0ZWQ7XFxuICAgICAgaWYgKG5hbWUgPT0gXFxcImJ1Zy1zdHJpbmctY2hhci1pbmRleFxcXCIpIHtcXG4gICAgICAgIC8vIElFIDw9IDcgZG9lc24ndCBzdXBwb3J0IGFjY2Vzc2luZyBzdHJpbmcgY2hhcmFjdGVycyB1c2luZyBzcXVhcmVcXG4gICAgICAgIC8vIGJyYWNrZXQgbm90YXRpb24uIElFIDggb25seSBzdXBwb3J0cyB0aGlzIGZvciBwcmltaXRpdmVzLlxcbiAgICAgICAgaXNTdXBwb3J0ZWQgPSBcXFwiYVxcXCJbMF0gIT0gXFxcImFcXFwiO1xcbiAgICAgIH0gZWxzZSBpZiAobmFtZSA9PSBcXFwianNvblxcXCIpIHtcXG4gICAgICAgIC8vIEluZGljYXRlcyB3aGV0aGVyIGJvdGggYEpTT04uc3RyaW5naWZ5YCBhbmQgYEpTT04ucGFyc2VgIGFyZVxcbiAgICAgICAgLy8gc3VwcG9ydGVkLlxcbiAgICAgICAgaXNTdXBwb3J0ZWQgPSBoYXMoXFxcImpzb24tc3RyaW5naWZ5XFxcIikgJiYgaGFzKFxcXCJqc29uLXBhcnNlXFxcIik7XFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIHZhciB2YWx1ZSwgc2VyaWFsaXplZCA9ICd7XFxcImFcXFwiOlsxLHRydWUsZmFsc2UsbnVsbCxcXFwiXFxcXFxcXFx1MDAwMFxcXFxcXFxcYlxcXFxcXFxcblxcXFxcXFxcZlxcXFxcXFxcclxcXFxcXFxcdFxcXCJdfSc7XFxuICAgICAgICAvLyBUZXN0IGBKU09OLnN0cmluZ2lmeWAuXFxuICAgICAgICBpZiAobmFtZSA9PSBcXFwianNvbi1zdHJpbmdpZnlcXFwiKSB7XFxuICAgICAgICAgIHZhciBzdHJpbmdpZnkgPSBleHBvcnRzLnN0cmluZ2lmeSwgc3RyaW5naWZ5U3VwcG9ydGVkID0gdHlwZW9mIHN0cmluZ2lmeSA9PSBcXFwiZnVuY3Rpb25cXFwiICYmIGlzRXh0ZW5kZWQ7XFxuICAgICAgICAgIGlmIChzdHJpbmdpZnlTdXBwb3J0ZWQpIHtcXG4gICAgICAgICAgICAvLyBBIHRlc3QgZnVuY3Rpb24gb2JqZWN0IHdpdGggYSBjdXN0b20gYHRvSlNPTmAgbWV0aG9kLlxcbiAgICAgICAgICAgICh2YWx1ZSA9IGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgICAgIHJldHVybiAxO1xcbiAgICAgICAgICAgIH0pLnRvSlNPTiA9IHZhbHVlO1xcbiAgICAgICAgICAgIHRyeSB7XFxuICAgICAgICAgICAgICBzdHJpbmdpZnlTdXBwb3J0ZWQgPVxcbiAgICAgICAgICAgICAgICAvLyBGaXJlZm94IDMuMWIxIGFuZCBiMiBzZXJpYWxpemUgc3RyaW5nLCBudW1iZXIsIGFuZCBib29sZWFuXFxuICAgICAgICAgICAgICAgIC8vIHByaW1pdGl2ZXMgYXMgb2JqZWN0IGxpdGVyYWxzLlxcbiAgICAgICAgICAgICAgICBzdHJpbmdpZnkoMCkgPT09IFxcXCIwXFxcIiAmJlxcbiAgICAgICAgICAgICAgICAvLyBGRiAzLjFiMSwgYjIsIGFuZCBKU09OIDIgc2VyaWFsaXplIHdyYXBwZWQgcHJpbWl0aXZlcyBhcyBvYmplY3RcXG4gICAgICAgICAgICAgICAgLy8gbGl0ZXJhbHMuXFxuICAgICAgICAgICAgICAgIHN0cmluZ2lmeShuZXcgTnVtYmVyKCkpID09PSBcXFwiMFxcXCIgJiZcXG4gICAgICAgICAgICAgICAgc3RyaW5naWZ5KG5ldyBTdHJpbmcoKSkgPT0gJ1xcXCJcXFwiJyAmJlxcbiAgICAgICAgICAgICAgICAvLyBGRiAzLjFiMSwgMiB0aHJvdyBhbiBlcnJvciBpZiB0aGUgdmFsdWUgaXMgYG51bGxgLCBgdW5kZWZpbmVkYCwgb3JcXG4gICAgICAgICAgICAgICAgLy8gZG9lcyBub3QgZGVmaW5lIGEgY2Fub25pY2FsIEpTT04gcmVwcmVzZW50YXRpb24gKHRoaXMgYXBwbGllcyB0b1xcbiAgICAgICAgICAgICAgICAvLyBvYmplY3RzIHdpdGggYHRvSlNPTmAgcHJvcGVydGllcyBhcyB3ZWxsLCAqdW5sZXNzKiB0aGV5IGFyZSBuZXN0ZWRcXG4gICAgICAgICAgICAgICAgLy8gd2l0aGluIGFuIG9iamVjdCBvciBhcnJheSkuXFxuICAgICAgICAgICAgICAgIHN0cmluZ2lmeShnZXRDbGFzcykgPT09IHVuZGVmICYmXFxuICAgICAgICAgICAgICAgIC8vIElFIDggc2VyaWFsaXplcyBgdW5kZWZpbmVkYCBhcyBgXFxcInVuZGVmaW5lZFxcXCJgLiBTYWZhcmkgPD0gNS4xLjcgYW5kXFxuICAgICAgICAgICAgICAgIC8vIEZGIDMuMWIzIHBhc3MgdGhpcyB0ZXN0LlxcbiAgICAgICAgICAgICAgICBzdHJpbmdpZnkodW5kZWYpID09PSB1bmRlZiAmJlxcbiAgICAgICAgICAgICAgICAvLyBTYWZhcmkgPD0gNS4xLjcgYW5kIEZGIDMuMWIzIHRocm93IGBFcnJvcmBzIGFuZCBgVHlwZUVycm9yYHMsXFxuICAgICAgICAgICAgICAgIC8vIHJlc3BlY3RpdmVseSwgaWYgdGhlIHZhbHVlIGlzIG9taXR0ZWQgZW50aXJlbHkuXFxuICAgICAgICAgICAgICAgIHN0cmluZ2lmeSgpID09PSB1bmRlZiAmJlxcbiAgICAgICAgICAgICAgICAvLyBGRiAzLjFiMSwgMiB0aHJvdyBhbiBlcnJvciBpZiB0aGUgZ2l2ZW4gdmFsdWUgaXMgbm90IGEgbnVtYmVyLFxcbiAgICAgICAgICAgICAgICAvLyBzdHJpbmcsIGFycmF5LCBvYmplY3QsIEJvb2xlYW4sIG9yIGBudWxsYCBsaXRlcmFsLiBUaGlzIGFwcGxpZXMgdG9cXG4gICAgICAgICAgICAgICAgLy8gb2JqZWN0cyB3aXRoIGN1c3RvbSBgdG9KU09OYCBtZXRob2RzIGFzIHdlbGwsIHVubGVzcyB0aGV5IGFyZSBuZXN0ZWRcXG4gICAgICAgICAgICAgICAgLy8gaW5zaWRlIG9iamVjdCBvciBhcnJheSBsaXRlcmFscy4gWVVJIDMuMC4wYjEgaWdub3JlcyBjdXN0b20gYHRvSlNPTmBcXG4gICAgICAgICAgICAgICAgLy8gbWV0aG9kcyBlbnRpcmVseS5cXG4gICAgICAgICAgICAgICAgc3RyaW5naWZ5KHZhbHVlKSA9PT0gXFxcIjFcXFwiICYmXFxuICAgICAgICAgICAgICAgIHN0cmluZ2lmeShbdmFsdWVdKSA9PSBcXFwiWzFdXFxcIiAmJlxcbiAgICAgICAgICAgICAgICAvLyBQcm90b3R5cGUgPD0gMS42LjEgc2VyaWFsaXplcyBgW3VuZGVmaW5lZF1gIGFzIGBcXFwiW11cXFwiYCBpbnN0ZWFkIG9mXFxuICAgICAgICAgICAgICAgIC8vIGBcXFwiW251bGxdXFxcImAuXFxuICAgICAgICAgICAgICAgIHN0cmluZ2lmeShbdW5kZWZdKSA9PSBcXFwiW251bGxdXFxcIiAmJlxcbiAgICAgICAgICAgICAgICAvLyBZVUkgMy4wLjBiMSBmYWlscyB0byBzZXJpYWxpemUgYG51bGxgIGxpdGVyYWxzLlxcbiAgICAgICAgICAgICAgICBzdHJpbmdpZnkobnVsbCkgPT0gXFxcIm51bGxcXFwiICYmXFxuICAgICAgICAgICAgICAgIC8vIEZGIDMuMWIxLCAyIGhhbHRzIHNlcmlhbGl6YXRpb24gaWYgYW4gYXJyYXkgY29udGFpbnMgYSBmdW5jdGlvbjpcXG4gICAgICAgICAgICAgICAgLy8gYFsxLCB0cnVlLCBnZXRDbGFzcywgMV1gIHNlcmlhbGl6ZXMgYXMgXFxcIlsxLHRydWUsXSxcXFwiLiBGRiAzLjFiM1xcbiAgICAgICAgICAgICAgICAvLyBlbGlkZXMgbm9uLUpTT04gdmFsdWVzIGZyb20gb2JqZWN0cyBhbmQgYXJyYXlzLCB1bmxlc3MgdGhleVxcbiAgICAgICAgICAgICAgICAvLyBkZWZpbmUgY3VzdG9tIGB0b0pTT05gIG1ldGhvZHMuXFxuICAgICAgICAgICAgICAgIHN0cmluZ2lmeShbdW5kZWYsIGdldENsYXNzLCBudWxsXSkgPT0gXFxcIltudWxsLG51bGwsbnVsbF1cXFwiICYmXFxuICAgICAgICAgICAgICAgIC8vIFNpbXBsZSBzZXJpYWxpemF0aW9uIHRlc3QuIEZGIDMuMWIxIHVzZXMgVW5pY29kZSBlc2NhcGUgc2VxdWVuY2VzXFxuICAgICAgICAgICAgICAgIC8vIHdoZXJlIGNoYXJhY3RlciBlc2NhcGUgY29kZXMgYXJlIGV4cGVjdGVkIChlLmcuLCBgXFxcXGJgID0+IGBcXFxcdTAwMDhgKS5cXG4gICAgICAgICAgICAgICAgc3RyaW5naWZ5KHsgXFxcImFcXFwiOiBbdmFsdWUsIHRydWUsIGZhbHNlLCBudWxsLCBcXFwiXFxcXHgwMFxcXFxiXFxcXG5cXFxcZlxcXFxyXFxcXHRcXFwiXSB9KSA9PSBzZXJpYWxpemVkICYmXFxuICAgICAgICAgICAgICAgIC8vIEZGIDMuMWIxIGFuZCBiMiBpZ25vcmUgdGhlIGBmaWx0ZXJgIGFuZCBgd2lkdGhgIGFyZ3VtZW50cy5cXG4gICAgICAgICAgICAgICAgc3RyaW5naWZ5KG51bGwsIHZhbHVlKSA9PT0gXFxcIjFcXFwiICYmXFxuICAgICAgICAgICAgICAgIHN0cmluZ2lmeShbMSwgMl0sIG51bGwsIDEpID09IFxcXCJbXFxcXG4gMSxcXFxcbiAyXFxcXG5dXFxcIiAmJlxcbiAgICAgICAgICAgICAgICAvLyBKU09OIDIsIFByb3RvdHlwZSA8PSAxLjcsIGFuZCBvbGRlciBXZWJLaXQgYnVpbGRzIGluY29ycmVjdGx5XFxuICAgICAgICAgICAgICAgIC8vIHNlcmlhbGl6ZSBleHRlbmRlZCB5ZWFycy5cXG4gICAgICAgICAgICAgICAgc3RyaW5naWZ5KG5ldyBEYXRlKC04LjY0ZTE1KSkgPT0gJ1xcXCItMjcxODIxLTA0LTIwVDAwOjAwOjAwLjAwMFpcXFwiJyAmJlxcbiAgICAgICAgICAgICAgICAvLyBUaGUgbWlsbGlzZWNvbmRzIGFyZSBvcHRpb25hbCBpbiBFUyA1LCBidXQgcmVxdWlyZWQgaW4gNS4xLlxcbiAgICAgICAgICAgICAgICBzdHJpbmdpZnkobmV3IERhdGUoOC42NGUxNSkpID09ICdcXFwiKzI3NTc2MC0wOS0xM1QwMDowMDowMC4wMDBaXFxcIicgJiZcXG4gICAgICAgICAgICAgICAgLy8gRmlyZWZveCA8PSAxMS4wIGluY29ycmVjdGx5IHNlcmlhbGl6ZXMgeWVhcnMgcHJpb3IgdG8gMCBhcyBuZWdhdGl2ZVxcbiAgICAgICAgICAgICAgICAvLyBmb3VyLWRpZ2l0IHllYXJzIGluc3RlYWQgb2Ygc2l4LWRpZ2l0IHllYXJzLiBDcmVkaXRzOiBAWWFmZmxlLlxcbiAgICAgICAgICAgICAgICBzdHJpbmdpZnkobmV3IERhdGUoLTYyMTk4NzU1MmU1KSkgPT0gJ1xcXCItMDAwMDAxLTAxLTAxVDAwOjAwOjAwLjAwMFpcXFwiJyAmJlxcbiAgICAgICAgICAgICAgICAvLyBTYWZhcmkgPD0gNS4xLjUgYW5kIE9wZXJhID49IDEwLjUzIGluY29ycmVjdGx5IHNlcmlhbGl6ZSBtaWxsaXNlY29uZFxcbiAgICAgICAgICAgICAgICAvLyB2YWx1ZXMgbGVzcyB0aGFuIDEwMDAuIENyZWRpdHM6IEBZYWZmbGUuXFxuICAgICAgICAgICAgICAgIHN0cmluZ2lmeShuZXcgRGF0ZSgtMSkpID09ICdcXFwiMTk2OS0xMi0zMVQyMzo1OTo1OS45OTlaXFxcIic7XFxuICAgICAgICAgICAgfSBjYXRjaCAoZXhjZXB0aW9uKSB7XFxuICAgICAgICAgICAgICBzdHJpbmdpZnlTdXBwb3J0ZWQgPSBmYWxzZTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgIH1cXG4gICAgICAgICAgaXNTdXBwb3J0ZWQgPSBzdHJpbmdpZnlTdXBwb3J0ZWQ7XFxuICAgICAgICB9XFxuICAgICAgICAvLyBUZXN0IGBKU09OLnBhcnNlYC5cXG4gICAgICAgIGlmIChuYW1lID09IFxcXCJqc29uLXBhcnNlXFxcIikge1xcbiAgICAgICAgICB2YXIgcGFyc2UgPSBleHBvcnRzLnBhcnNlO1xcbiAgICAgICAgICBpZiAodHlwZW9mIHBhcnNlID09IFxcXCJmdW5jdGlvblxcXCIpIHtcXG4gICAgICAgICAgICB0cnkge1xcbiAgICAgICAgICAgICAgLy8gRkYgMy4xYjEsIGIyIHdpbGwgdGhyb3cgYW4gZXhjZXB0aW9uIGlmIGEgYmFyZSBsaXRlcmFsIGlzIHByb3ZpZGVkLlxcbiAgICAgICAgICAgICAgLy8gQ29uZm9ybWluZyBpbXBsZW1lbnRhdGlvbnMgc2hvdWxkIGFsc28gY29lcmNlIHRoZSBpbml0aWFsIGFyZ3VtZW50IHRvXFxuICAgICAgICAgICAgICAvLyBhIHN0cmluZyBwcmlvciB0byBwYXJzaW5nLlxcbiAgICAgICAgICAgICAgaWYgKHBhcnNlKFxcXCIwXFxcIikgPT09IDAgJiYgIXBhcnNlKGZhbHNlKSkge1xcbiAgICAgICAgICAgICAgICAvLyBTaW1wbGUgcGFyc2luZyB0ZXN0LlxcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHBhcnNlKHNlcmlhbGl6ZWQpO1xcbiAgICAgICAgICAgICAgICB2YXIgcGFyc2VTdXBwb3J0ZWQgPSB2YWx1ZVtcXFwiYVxcXCJdLmxlbmd0aCA9PSA1ICYmIHZhbHVlW1xcXCJhXFxcIl1bMF0gPT09IDE7XFxuICAgICAgICAgICAgICAgIGlmIChwYXJzZVN1cHBvcnRlZCkge1xcbiAgICAgICAgICAgICAgICAgIHRyeSB7XFxuICAgICAgICAgICAgICAgICAgICAvLyBTYWZhcmkgPD0gNS4xLjIgYW5kIEZGIDMuMWIxIGFsbG93IHVuZXNjYXBlZCB0YWJzIGluIHN0cmluZ3MuXFxuICAgICAgICAgICAgICAgICAgICBwYXJzZVN1cHBvcnRlZCA9ICFwYXJzZSgnXFxcIlxcXFx0XFxcIicpO1xcbiAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGV4Y2VwdGlvbikge31cXG4gICAgICAgICAgICAgICAgICBpZiAocGFyc2VTdXBwb3J0ZWQpIHtcXG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XFxuICAgICAgICAgICAgICAgICAgICAgIC8vIEZGIDQuMCBhbmQgNC4wLjEgYWxsb3cgbGVhZGluZyBgK2Agc2lnbnMgYW5kIGxlYWRpbmdcXG4gICAgICAgICAgICAgICAgICAgICAgLy8gZGVjaW1hbCBwb2ludHMuIEZGIDQuMCwgNC4wLjEsIGFuZCBJRSA5LTEwIGFsc28gYWxsb3dcXG4gICAgICAgICAgICAgICAgICAgICAgLy8gY2VydGFpbiBvY3RhbCBsaXRlcmFscy5cXG4gICAgICAgICAgICAgICAgICAgICAgcGFyc2VTdXBwb3J0ZWQgPSBwYXJzZShcXFwiMDFcXFwiKSAhPT0gMTtcXG4gICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGV4Y2VwdGlvbikge31cXG4gICAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgICAgaWYgKHBhcnNlU3VwcG9ydGVkKSB7XFxuICAgICAgICAgICAgICAgICAgICB0cnkge1xcbiAgICAgICAgICAgICAgICAgICAgICAvLyBGRiA0LjAsIDQuMC4xLCBhbmQgUmhpbm8gMS43UjMtUjQgYWxsb3cgdHJhaWxpbmcgZGVjaW1hbFxcbiAgICAgICAgICAgICAgICAgICAgICAvLyBwb2ludHMuIFRoZXNlIGVudmlyb25tZW50cywgYWxvbmcgd2l0aCBGRiAzLjFiMSBhbmQgMixcXG4gICAgICAgICAgICAgICAgICAgICAgLy8gYWxzbyBhbGxvdyB0cmFpbGluZyBjb21tYXMgaW4gSlNPTiBvYmplY3RzIGFuZCBhcnJheXMuXFxuICAgICAgICAgICAgICAgICAgICAgIHBhcnNlU3VwcG9ydGVkID0gcGFyc2UoXFxcIjEuXFxcIikgIT09IDE7XFxuICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChleGNlcHRpb24pIHt9XFxuICAgICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfSBjYXRjaCAoZXhjZXB0aW9uKSB7XFxuICAgICAgICAgICAgICBwYXJzZVN1cHBvcnRlZCA9IGZhbHNlO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgfVxcbiAgICAgICAgICBpc1N1cHBvcnRlZCA9IHBhcnNlU3VwcG9ydGVkO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG4gICAgICByZXR1cm4gaGFzW25hbWVdID0gISFpc1N1cHBvcnRlZDtcXG4gICAgfVxcblxcbiAgICBpZiAoIWhhcyhcXFwianNvblxcXCIpKSB7XFxuICAgICAgLy8gQ29tbW9uIGBbW0NsYXNzXV1gIG5hbWUgYWxpYXNlcy5cXG4gICAgICB2YXIgZnVuY3Rpb25DbGFzcyA9IFxcXCJbb2JqZWN0IEZ1bmN0aW9uXVxcXCIsXFxuICAgICAgICAgIGRhdGVDbGFzcyA9IFxcXCJbb2JqZWN0IERhdGVdXFxcIixcXG4gICAgICAgICAgbnVtYmVyQ2xhc3MgPSBcXFwiW29iamVjdCBOdW1iZXJdXFxcIixcXG4gICAgICAgICAgc3RyaW5nQ2xhc3MgPSBcXFwiW29iamVjdCBTdHJpbmddXFxcIixcXG4gICAgICAgICAgYXJyYXlDbGFzcyA9IFxcXCJbb2JqZWN0IEFycmF5XVxcXCIsXFxuICAgICAgICAgIGJvb2xlYW5DbGFzcyA9IFxcXCJbb2JqZWN0IEJvb2xlYW5dXFxcIjtcXG5cXG4gICAgICAvLyBEZXRlY3QgaW5jb21wbGV0ZSBzdXBwb3J0IGZvciBhY2Nlc3Npbmcgc3RyaW5nIGNoYXJhY3RlcnMgYnkgaW5kZXguXFxuICAgICAgdmFyIGNoYXJJbmRleEJ1Z2d5ID0gaGFzKFxcXCJidWctc3RyaW5nLWNoYXItaW5kZXhcXFwiKTtcXG5cXG4gICAgICAvLyBEZWZpbmUgYWRkaXRpb25hbCB1dGlsaXR5IG1ldGhvZHMgaWYgdGhlIGBEYXRlYCBtZXRob2RzIGFyZSBidWdneS5cXG4gICAgICBpZiAoIWlzRXh0ZW5kZWQpIHtcXG4gICAgICAgIHZhciBmbG9vciA9IE1hdGguZmxvb3I7XFxuICAgICAgICAvLyBBIG1hcHBpbmcgYmV0d2VlbiB0aGUgbW9udGhzIG9mIHRoZSB5ZWFyIGFuZCB0aGUgbnVtYmVyIG9mIGRheXMgYmV0d2VlblxcbiAgICAgICAgLy8gSmFudWFyeSAxc3QgYW5kIHRoZSBmaXJzdCBvZiB0aGUgcmVzcGVjdGl2ZSBtb250aC5cXG4gICAgICAgIHZhciBNb250aHMgPSBbMCwgMzEsIDU5LCA5MCwgMTIwLCAxNTEsIDE4MSwgMjEyLCAyNDMsIDI3MywgMzA0LCAzMzRdO1xcbiAgICAgICAgLy8gSW50ZXJuYWw6IENhbGN1bGF0ZXMgdGhlIG51bWJlciBvZiBkYXlzIGJldHdlZW4gdGhlIFVuaXggZXBvY2ggYW5kIHRoZVxcbiAgICAgICAgLy8gZmlyc3QgZGF5IG9mIHRoZSBnaXZlbiBtb250aC5cXG4gICAgICAgIHZhciBnZXREYXkgPSBmdW5jdGlvbiAoeWVhciwgbW9udGgpIHtcXG4gICAgICAgICAgcmV0dXJuIE1vbnRoc1ttb250aF0gKyAzNjUgKiAoeWVhciAtIDE5NzApICsgZmxvb3IoKHllYXIgLSAxOTY5ICsgKG1vbnRoID0gKyhtb250aCA+IDEpKSkgLyA0KSAtIGZsb29yKCh5ZWFyIC0gMTkwMSArIG1vbnRoKSAvIDEwMCkgKyBmbG9vcigoeWVhciAtIDE2MDEgKyBtb250aCkgLyA0MDApO1xcbiAgICAgICAgfTtcXG4gICAgICB9XFxuXFxuICAgICAgLy8gSW50ZXJuYWw6IERldGVybWluZXMgaWYgYSBwcm9wZXJ0eSBpcyBhIGRpcmVjdCBwcm9wZXJ0eSBvZiB0aGUgZ2l2ZW5cXG4gICAgICAvLyBvYmplY3QuIERlbGVnYXRlcyB0byB0aGUgbmF0aXZlIGBPYmplY3QjaGFzT3duUHJvcGVydHlgIG1ldGhvZC5cXG4gICAgICBpZiAoIShpc1Byb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHkpKSB7XFxuICAgICAgICBpc1Byb3BlcnR5ID0gZnVuY3Rpb24gKHByb3BlcnR5KSB7XFxuICAgICAgICAgIHZhciBtZW1iZXJzID0ge30sIGNvbnN0cnVjdG9yO1xcbiAgICAgICAgICBpZiAoKG1lbWJlcnMuX19wcm90b19fID0gbnVsbCwgbWVtYmVycy5fX3Byb3RvX18gPSB7XFxuICAgICAgICAgICAgLy8gVGhlICpwcm90byogcHJvcGVydHkgY2Fubm90IGJlIHNldCBtdWx0aXBsZSB0aW1lcyBpbiByZWNlbnRcXG4gICAgICAgICAgICAvLyB2ZXJzaW9ucyBvZiBGaXJlZm94IGFuZCBTZWFNb25rZXkuXFxuICAgICAgICAgICAgXFxcInRvU3RyaW5nXFxcIjogMVxcbiAgICAgICAgICB9LCBtZW1iZXJzKS50b1N0cmluZyAhPSBnZXRDbGFzcykge1xcbiAgICAgICAgICAgIC8vIFNhZmFyaSA8PSAyLjAuMyBkb2Vzbid0IGltcGxlbWVudCBgT2JqZWN0I2hhc093blByb3BlcnR5YCwgYnV0XFxuICAgICAgICAgICAgLy8gc3VwcG9ydHMgdGhlIG11dGFibGUgKnByb3RvKiBwcm9wZXJ0eS5cXG4gICAgICAgICAgICBpc1Byb3BlcnR5ID0gZnVuY3Rpb24gKHByb3BlcnR5KSB7XFxuICAgICAgICAgICAgICAvLyBDYXB0dXJlIGFuZCBicmVhayB0aGUgb2JqZWN0J3MgcHJvdG90eXBlIGNoYWluIChzZWUgc2VjdGlvbiA4LjYuMlxcbiAgICAgICAgICAgICAgLy8gb2YgdGhlIEVTIDUuMSBzcGVjKS4gVGhlIHBhcmVudGhlc2l6ZWQgZXhwcmVzc2lvbiBwcmV2ZW50cyBhblxcbiAgICAgICAgICAgICAgLy8gdW5zYWZlIHRyYW5zZm9ybWF0aW9uIGJ5IHRoZSBDbG9zdXJlIENvbXBpbGVyLlxcbiAgICAgICAgICAgICAgdmFyIG9yaWdpbmFsID0gdGhpcy5fX3Byb3RvX18sIHJlc3VsdCA9IHByb3BlcnR5IGluICh0aGlzLl9fcHJvdG9fXyA9IG51bGwsIHRoaXMpO1xcbiAgICAgICAgICAgICAgLy8gUmVzdG9yZSB0aGUgb3JpZ2luYWwgcHJvdG90eXBlIGNoYWluLlxcbiAgICAgICAgICAgICAgdGhpcy5fX3Byb3RvX18gPSBvcmlnaW5hbDtcXG4gICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XFxuICAgICAgICAgICAgfTtcXG4gICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICAvLyBDYXB0dXJlIGEgcmVmZXJlbmNlIHRvIHRoZSB0b3AtbGV2ZWwgYE9iamVjdGAgY29uc3RydWN0b3IuXFxuICAgICAgICAgICAgY29uc3RydWN0b3IgPSBtZW1iZXJzLmNvbnN0cnVjdG9yO1xcbiAgICAgICAgICAgIC8vIFVzZSB0aGUgYGNvbnN0cnVjdG9yYCBwcm9wZXJ0eSB0byBzaW11bGF0ZSBgT2JqZWN0I2hhc093blByb3BlcnR5YCBpblxcbiAgICAgICAgICAgIC8vIG90aGVyIGVudmlyb25tZW50cy5cXG4gICAgICAgICAgICBpc1Byb3BlcnR5ID0gZnVuY3Rpb24gKHByb3BlcnR5KSB7XFxuICAgICAgICAgICAgICB2YXIgcGFyZW50ID0gKHRoaXMuY29uc3RydWN0b3IgfHwgY29uc3RydWN0b3IpLnByb3RvdHlwZTtcXG4gICAgICAgICAgICAgIHJldHVybiBwcm9wZXJ0eSBpbiB0aGlzICYmICEocHJvcGVydHkgaW4gcGFyZW50ICYmIHRoaXNbcHJvcGVydHldID09PSBwYXJlbnRbcHJvcGVydHldKTtcXG4gICAgICAgICAgICB9O1xcbiAgICAgICAgICB9XFxuICAgICAgICAgIG1lbWJlcnMgPSBudWxsO1xcbiAgICAgICAgICByZXR1cm4gaXNQcm9wZXJ0eS5jYWxsKHRoaXMsIHByb3BlcnR5KTtcXG4gICAgICAgIH07XFxuICAgICAgfVxcblxcbiAgICAgIC8vIEludGVybmFsOiBOb3JtYWxpemVzIHRoZSBgZm9yLi4uaW5gIGl0ZXJhdGlvbiBhbGdvcml0aG0gYWNyb3NzXFxuICAgICAgLy8gZW52aXJvbm1lbnRzLiBFYWNoIGVudW1lcmF0ZWQga2V5IGlzIHlpZWxkZWQgdG8gYSBgY2FsbGJhY2tgIGZ1bmN0aW9uLlxcbiAgICAgIGZvckVhY2ggPSBmdW5jdGlvbiAob2JqZWN0LCBjYWxsYmFjaykge1xcbiAgICAgICAgdmFyIHNpemUgPSAwLCBQcm9wZXJ0aWVzLCBtZW1iZXJzLCBwcm9wZXJ0eTtcXG5cXG4gICAgICAgIC8vIFRlc3RzIGZvciBidWdzIGluIHRoZSBjdXJyZW50IGVudmlyb25tZW50J3MgYGZvci4uLmluYCBhbGdvcml0aG0uIFRoZVxcbiAgICAgICAgLy8gYHZhbHVlT2ZgIHByb3BlcnR5IGluaGVyaXRzIHRoZSBub24tZW51bWVyYWJsZSBmbGFnIGZyb21cXG4gICAgICAgIC8vIGBPYmplY3QucHJvdG90eXBlYCBpbiBvbGRlciB2ZXJzaW9ucyBvZiBJRSwgTmV0c2NhcGUsIGFuZCBNb3ppbGxhLlxcbiAgICAgICAgKFByb3BlcnRpZXMgPSBmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgIHRoaXMudmFsdWVPZiA9IDA7XFxuICAgICAgICB9KS5wcm90b3R5cGUudmFsdWVPZiA9IDA7XFxuXFxuICAgICAgICAvLyBJdGVyYXRlIG92ZXIgYSBuZXcgaW5zdGFuY2Ugb2YgdGhlIGBQcm9wZXJ0aWVzYCBjbGFzcy5cXG4gICAgICAgIG1lbWJlcnMgPSBuZXcgUHJvcGVydGllcygpO1xcbiAgICAgICAgZm9yIChwcm9wZXJ0eSBpbiBtZW1iZXJzKSB7XFxuICAgICAgICAgIC8vIElnbm9yZSBhbGwgcHJvcGVydGllcyBpbmhlcml0ZWQgZnJvbSBgT2JqZWN0LnByb3RvdHlwZWAuXFxuICAgICAgICAgIGlmIChpc1Byb3BlcnR5LmNhbGwobWVtYmVycywgcHJvcGVydHkpKSB7XFxuICAgICAgICAgICAgc2l6ZSsrO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgICBQcm9wZXJ0aWVzID0gbWVtYmVycyA9IG51bGw7XFxuXFxuICAgICAgICAvLyBOb3JtYWxpemUgdGhlIGl0ZXJhdGlvbiBhbGdvcml0aG0uXFxuICAgICAgICBpZiAoIXNpemUpIHtcXG4gICAgICAgICAgLy8gQSBsaXN0IG9mIG5vbi1lbnVtZXJhYmxlIHByb3BlcnRpZXMgaW5oZXJpdGVkIGZyb20gYE9iamVjdC5wcm90b3R5cGVgLlxcbiAgICAgICAgICBtZW1iZXJzID0gW1xcXCJ2YWx1ZU9mXFxcIiwgXFxcInRvU3RyaW5nXFxcIiwgXFxcInRvTG9jYWxlU3RyaW5nXFxcIiwgXFxcInByb3BlcnR5SXNFbnVtZXJhYmxlXFxcIiwgXFxcImlzUHJvdG90eXBlT2ZcXFwiLCBcXFwiaGFzT3duUHJvcGVydHlcXFwiLCBcXFwiY29uc3RydWN0b3JcXFwiXTtcXG4gICAgICAgICAgLy8gSUUgPD0gOCwgTW96aWxsYSAxLjAsIGFuZCBOZXRzY2FwZSA2LjIgaWdub3JlIHNoYWRvd2VkIG5vbi1lbnVtZXJhYmxlXFxuICAgICAgICAgIC8vIHByb3BlcnRpZXMuXFxuICAgICAgICAgIGZvckVhY2ggPSBmdW5jdGlvbiAob2JqZWN0LCBjYWxsYmFjaykge1xcbiAgICAgICAgICAgIHZhciBpc0Z1bmN0aW9uID0gZ2V0Q2xhc3MuY2FsbChvYmplY3QpID09IGZ1bmN0aW9uQ2xhc3MsIHByb3BlcnR5LCBsZW5ndGg7XFxuICAgICAgICAgICAgdmFyIGhhc1Byb3BlcnR5ID0gIWlzRnVuY3Rpb24gJiYgdHlwZW9mIG9iamVjdC5jb25zdHJ1Y3RvciAhPSBcXFwiZnVuY3Rpb25cXFwiICYmIG9iamVjdFR5cGVzW3R5cGVvZiBvYmplY3QuaGFzT3duUHJvcGVydHldICYmIG9iamVjdC5oYXNPd25Qcm9wZXJ0eSB8fCBpc1Byb3BlcnR5O1xcbiAgICAgICAgICAgIGZvciAocHJvcGVydHkgaW4gb2JqZWN0KSB7XFxuICAgICAgICAgICAgICAvLyBHZWNrbyA8PSAxLjAgZW51bWVyYXRlcyB0aGUgYHByb3RvdHlwZWAgcHJvcGVydHkgb2YgZnVuY3Rpb25zIHVuZGVyXFxuICAgICAgICAgICAgICAvLyBjZXJ0YWluIGNvbmRpdGlvbnM7IElFIGRvZXMgbm90LlxcbiAgICAgICAgICAgICAgaWYgKCEoaXNGdW5jdGlvbiAmJiBwcm9wZXJ0eSA9PSBcXFwicHJvdG90eXBlXFxcIikgJiYgaGFzUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KSkge1xcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhwcm9wZXJ0eSk7XFxuICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIC8vIE1hbnVhbGx5IGludm9rZSB0aGUgY2FsbGJhY2sgZm9yIGVhY2ggbm9uLWVudW1lcmFibGUgcHJvcGVydHkuXFxuICAgICAgICAgICAgZm9yIChsZW5ndGggPSBtZW1iZXJzLmxlbmd0aDsgcHJvcGVydHkgPSBtZW1iZXJzWy0tbGVuZ3RoXTsgaGFzUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KSAmJiBjYWxsYmFjayhwcm9wZXJ0eSkpO1xcbiAgICAgICAgICB9O1xcbiAgICAgICAgfSBlbHNlIGlmIChzaXplID09IDIpIHtcXG4gICAgICAgICAgLy8gU2FmYXJpIDw9IDIuMC40IGVudW1lcmF0ZXMgc2hhZG93ZWQgcHJvcGVydGllcyB0d2ljZS5cXG4gICAgICAgICAgZm9yRWFjaCA9IGZ1bmN0aW9uIChvYmplY3QsIGNhbGxiYWNrKSB7XFxuICAgICAgICAgICAgLy8gQ3JlYXRlIGEgc2V0IG9mIGl0ZXJhdGVkIHByb3BlcnRpZXMuXFxuICAgICAgICAgICAgdmFyIG1lbWJlcnMgPSB7fSwgaXNGdW5jdGlvbiA9IGdldENsYXNzLmNhbGwob2JqZWN0KSA9PSBmdW5jdGlvbkNsYXNzLCBwcm9wZXJ0eTtcXG4gICAgICAgICAgICBmb3IgKHByb3BlcnR5IGluIG9iamVjdCkge1xcbiAgICAgICAgICAgICAgLy8gU3RvcmUgZWFjaCBwcm9wZXJ0eSBuYW1lIHRvIHByZXZlbnQgZG91YmxlIGVudW1lcmF0aW9uLiBUaGVcXG4gICAgICAgICAgICAgIC8vIGBwcm90b3R5cGVgIHByb3BlcnR5IG9mIGZ1bmN0aW9ucyBpcyBub3QgZW51bWVyYXRlZCBkdWUgdG8gY3Jvc3MtXFxuICAgICAgICAgICAgICAvLyBlbnZpcm9ubWVudCBpbmNvbnNpc3RlbmNpZXMuXFxuICAgICAgICAgICAgICBpZiAoIShpc0Z1bmN0aW9uICYmIHByb3BlcnR5ID09IFxcXCJwcm90b3R5cGVcXFwiKSAmJiAhaXNQcm9wZXJ0eS5jYWxsKG1lbWJlcnMsIHByb3BlcnR5KSAmJiAobWVtYmVyc1twcm9wZXJ0eV0gPSAxKSAmJiBpc1Byb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSkpIHtcXG4gICAgICAgICAgICAgICAgY2FsbGJhY2socHJvcGVydHkpO1xcbiAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgfTtcXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgIC8vIE5vIGJ1Z3MgZGV0ZWN0ZWQ7IHVzZSB0aGUgc3RhbmRhcmQgYGZvci4uLmluYCBhbGdvcml0aG0uXFxuICAgICAgICAgIGZvckVhY2ggPSBmdW5jdGlvbiAob2JqZWN0LCBjYWxsYmFjaykge1xcbiAgICAgICAgICAgIHZhciBpc0Z1bmN0aW9uID0gZ2V0Q2xhc3MuY2FsbChvYmplY3QpID09IGZ1bmN0aW9uQ2xhc3MsIHByb3BlcnR5LCBpc0NvbnN0cnVjdG9yO1xcbiAgICAgICAgICAgIGZvciAocHJvcGVydHkgaW4gb2JqZWN0KSB7XFxuICAgICAgICAgICAgICBpZiAoIShpc0Z1bmN0aW9uICYmIHByb3BlcnR5ID09IFxcXCJwcm90b3R5cGVcXFwiKSAmJiBpc1Byb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSkgJiYgIShpc0NvbnN0cnVjdG9yID0gcHJvcGVydHkgPT09IFxcXCJjb25zdHJ1Y3RvclxcXCIpKSB7XFxuICAgICAgICAgICAgICAgIGNhbGxiYWNrKHByb3BlcnR5KTtcXG4gICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgLy8gTWFudWFsbHkgaW52b2tlIHRoZSBjYWxsYmFjayBmb3IgdGhlIGBjb25zdHJ1Y3RvcmAgcHJvcGVydHkgZHVlIHRvXFxuICAgICAgICAgICAgLy8gY3Jvc3MtZW52aXJvbm1lbnQgaW5jb25zaXN0ZW5jaWVzLlxcbiAgICAgICAgICAgIGlmIChpc0NvbnN0cnVjdG9yIHx8IGlzUHJvcGVydHkuY2FsbChvYmplY3QsIChwcm9wZXJ0eSA9IFxcXCJjb25zdHJ1Y3RvclxcXCIpKSkge1xcbiAgICAgICAgICAgICAgY2FsbGJhY2socHJvcGVydHkpO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgfTtcXG4gICAgICAgIH1cXG4gICAgICAgIHJldHVybiBmb3JFYWNoKG9iamVjdCwgY2FsbGJhY2spO1xcbiAgICAgIH07XFxuXFxuICAgICAgLy8gUHVibGljOiBTZXJpYWxpemVzIGEgSmF2YVNjcmlwdCBgdmFsdWVgIGFzIGEgSlNPTiBzdHJpbmcuIFRoZSBvcHRpb25hbFxcbiAgICAgIC8vIGBmaWx0ZXJgIGFyZ3VtZW50IG1heSBzcGVjaWZ5IGVpdGhlciBhIGZ1bmN0aW9uIHRoYXQgYWx0ZXJzIGhvdyBvYmplY3QgYW5kXFxuICAgICAgLy8gYXJyYXkgbWVtYmVycyBhcmUgc2VyaWFsaXplZCwgb3IgYW4gYXJyYXkgb2Ygc3RyaW5ncyBhbmQgbnVtYmVycyB0aGF0XFxuICAgICAgLy8gaW5kaWNhdGVzIHdoaWNoIHByb3BlcnRpZXMgc2hvdWxkIGJlIHNlcmlhbGl6ZWQuIFRoZSBvcHRpb25hbCBgd2lkdGhgXFxuICAgICAgLy8gYXJndW1lbnQgbWF5IGJlIGVpdGhlciBhIHN0cmluZyBvciBudW1iZXIgdGhhdCBzcGVjaWZpZXMgdGhlIGluZGVudGF0aW9uXFxuICAgICAgLy8gbGV2ZWwgb2YgdGhlIG91dHB1dC5cXG4gICAgICBpZiAoIWhhcyhcXFwianNvbi1zdHJpbmdpZnlcXFwiKSkge1xcbiAgICAgICAgLy8gSW50ZXJuYWw6IEEgbWFwIG9mIGNvbnRyb2wgY2hhcmFjdGVycyBhbmQgdGhlaXIgZXNjYXBlZCBlcXVpdmFsZW50cy5cXG4gICAgICAgIHZhciBFc2NhcGVzID0ge1xcbiAgICAgICAgICA5MjogXFxcIlxcXFxcXFxcXFxcXFxcXFxcXFwiLFxcbiAgICAgICAgICAzNDogJ1xcXFxcXFxcXFxcIicsXFxuICAgICAgICAgIDg6IFxcXCJcXFxcXFxcXGJcXFwiLFxcbiAgICAgICAgICAxMjogXFxcIlxcXFxcXFxcZlxcXCIsXFxuICAgICAgICAgIDEwOiBcXFwiXFxcXFxcXFxuXFxcIixcXG4gICAgICAgICAgMTM6IFxcXCJcXFxcXFxcXHJcXFwiLFxcbiAgICAgICAgICA5OiBcXFwiXFxcXFxcXFx0XFxcIlxcbiAgICAgICAgfTtcXG5cXG4gICAgICAgIC8vIEludGVybmFsOiBDb252ZXJ0cyBgdmFsdWVgIGludG8gYSB6ZXJvLXBhZGRlZCBzdHJpbmcgc3VjaCB0aGF0IGl0c1xcbiAgICAgICAgLy8gbGVuZ3RoIGlzIGF0IGxlYXN0IGVxdWFsIHRvIGB3aWR0aGAuIFRoZSBgd2lkdGhgIG11c3QgYmUgPD0gNi5cXG4gICAgICAgIHZhciBsZWFkaW5nWmVyb2VzID0gXFxcIjAwMDAwMFxcXCI7XFxuICAgICAgICB2YXIgdG9QYWRkZWRTdHJpbmcgPSBmdW5jdGlvbiAod2lkdGgsIHZhbHVlKSB7XFxuICAgICAgICAgIC8vIFRoZSBgfHwgMGAgZXhwcmVzc2lvbiBpcyBuZWNlc3NhcnkgdG8gd29yayBhcm91bmQgYSBidWcgaW5cXG4gICAgICAgICAgLy8gT3BlcmEgPD0gNy41NHUyIHdoZXJlIGAwID09IC0wYCwgYnV0IGBTdHJpbmcoLTApICE9PSBcXFwiMFxcXCJgLlxcbiAgICAgICAgICByZXR1cm4gKGxlYWRpbmdaZXJvZXMgKyAodmFsdWUgfHwgMCkpLnNsaWNlKC13aWR0aCk7XFxuICAgICAgICB9O1xcblxcbiAgICAgICAgLy8gSW50ZXJuYWw6IERvdWJsZS1xdW90ZXMgYSBzdHJpbmcgYHZhbHVlYCwgcmVwbGFjaW5nIGFsbCBBU0NJSSBjb250cm9sXFxuICAgICAgICAvLyBjaGFyYWN0ZXJzIChjaGFyYWN0ZXJzIHdpdGggY29kZSB1bml0IHZhbHVlcyBiZXR3ZWVuIDAgYW5kIDMxKSB3aXRoXFxuICAgICAgICAvLyB0aGVpciBlc2NhcGVkIGVxdWl2YWxlbnRzLiBUaGlzIGlzIGFuIGltcGxlbWVudGF0aW9uIG9mIHRoZVxcbiAgICAgICAgLy8gYFF1b3RlKHZhbHVlKWAgb3BlcmF0aW9uIGRlZmluZWQgaW4gRVMgNS4xIHNlY3Rpb24gMTUuMTIuMy5cXG4gICAgICAgIHZhciB1bmljb2RlUHJlZml4ID0gXFxcIlxcXFxcXFxcdTAwXFxcIjtcXG4gICAgICAgIHZhciBxdW90ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xcbiAgICAgICAgICB2YXIgcmVzdWx0ID0gJ1xcXCInLCBpbmRleCA9IDAsIGxlbmd0aCA9IHZhbHVlLmxlbmd0aCwgdXNlQ2hhckluZGV4ID0gIWNoYXJJbmRleEJ1Z2d5IHx8IGxlbmd0aCA+IDEwO1xcbiAgICAgICAgICB2YXIgc3ltYm9scyA9IHVzZUNoYXJJbmRleCAmJiAoY2hhckluZGV4QnVnZ3kgPyB2YWx1ZS5zcGxpdChcXFwiXFxcIikgOiB2YWx1ZSk7XFxuICAgICAgICAgIGZvciAoOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xcbiAgICAgICAgICAgIHZhciBjaGFyQ29kZSA9IHZhbHVlLmNoYXJDb2RlQXQoaW5kZXgpO1xcbiAgICAgICAgICAgIC8vIElmIHRoZSBjaGFyYWN0ZXIgaXMgYSBjb250cm9sIGNoYXJhY3RlciwgYXBwZW5kIGl0cyBVbmljb2RlIG9yXFxuICAgICAgICAgICAgLy8gc2hvcnRoYW5kIGVzY2FwZSBzZXF1ZW5jZTsgb3RoZXJ3aXNlLCBhcHBlbmQgdGhlIGNoYXJhY3RlciBhcy1pcy5cXG4gICAgICAgICAgICBzd2l0Y2ggKGNoYXJDb2RlKSB7XFxuICAgICAgICAgICAgICBjYXNlIDg6IGNhc2UgOTogY2FzZSAxMDogY2FzZSAxMjogY2FzZSAxMzogY2FzZSAzNDogY2FzZSA5MjpcXG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9IEVzY2FwZXNbY2hhckNvZGVdO1xcbiAgICAgICAgICAgICAgICBicmVhaztcXG4gICAgICAgICAgICAgIGRlZmF1bHQ6XFxuICAgICAgICAgICAgICAgIGlmIChjaGFyQ29kZSA8IDMyKSB7XFxuICAgICAgICAgICAgICAgICAgcmVzdWx0ICs9IHVuaWNvZGVQcmVmaXggKyB0b1BhZGRlZFN0cmluZygyLCBjaGFyQ29kZS50b1N0cmluZygxNikpO1xcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgIHJlc3VsdCArPSB1c2VDaGFySW5kZXggPyBzeW1ib2xzW2luZGV4XSA6IHZhbHVlLmNoYXJBdChpbmRleCk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICB9XFxuICAgICAgICAgIHJldHVybiByZXN1bHQgKyAnXFxcIic7XFxuICAgICAgICB9O1xcblxcbiAgICAgICAgLy8gSW50ZXJuYWw6IFJlY3Vyc2l2ZWx5IHNlcmlhbGl6ZXMgYW4gb2JqZWN0LiBJbXBsZW1lbnRzIHRoZVxcbiAgICAgICAgLy8gYFN0cihrZXksIGhvbGRlcilgLCBgSk8odmFsdWUpYCwgYW5kIGBKQSh2YWx1ZSlgIG9wZXJhdGlvbnMuXFxuICAgICAgICB2YXIgc2VyaWFsaXplID0gZnVuY3Rpb24gKHByb3BlcnR5LCBvYmplY3QsIGNhbGxiYWNrLCBwcm9wZXJ0aWVzLCB3aGl0ZXNwYWNlLCBpbmRlbnRhdGlvbiwgc3RhY2spIHtcXG4gICAgICAgICAgdmFyIHZhbHVlLCBjbGFzc05hbWUsIHllYXIsIG1vbnRoLCBkYXRlLCB0aW1lLCBob3VycywgbWludXRlcywgc2Vjb25kcywgbWlsbGlzZWNvbmRzLCByZXN1bHRzLCBlbGVtZW50LCBpbmRleCwgbGVuZ3RoLCBwcmVmaXgsIHJlc3VsdDtcXG4gICAgICAgICAgdHJ5IHtcXG4gICAgICAgICAgICAvLyBOZWNlc3NhcnkgZm9yIGhvc3Qgb2JqZWN0IHN1cHBvcnQuXFxuICAgICAgICAgICAgdmFsdWUgPSBvYmplY3RbcHJvcGVydHldO1xcbiAgICAgICAgICB9IGNhdGNoIChleGNlcHRpb24pIHt9XFxuICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT0gXFxcIm9iamVjdFxcXCIgJiYgdmFsdWUpIHtcXG4gICAgICAgICAgICBjbGFzc05hbWUgPSBnZXRDbGFzcy5jYWxsKHZhbHVlKTtcXG4gICAgICAgICAgICBpZiAoY2xhc3NOYW1lID09IGRhdGVDbGFzcyAmJiAhaXNQcm9wZXJ0eS5jYWxsKHZhbHVlLCBcXFwidG9KU09OXFxcIikpIHtcXG4gICAgICAgICAgICAgIGlmICh2YWx1ZSA+IC0xIC8gMCAmJiB2YWx1ZSA8IDEgLyAwKSB7XFxuICAgICAgICAgICAgICAgIC8vIERhdGVzIGFyZSBzZXJpYWxpemVkIGFjY29yZGluZyB0byB0aGUgYERhdGUjdG9KU09OYCBtZXRob2RcXG4gICAgICAgICAgICAgICAgLy8gc3BlY2lmaWVkIGluIEVTIDUuMSBzZWN0aW9uIDE1LjkuNS40NC4gU2VlIHNlY3Rpb24gMTUuOS4xLjE1XFxuICAgICAgICAgICAgICAgIC8vIGZvciB0aGUgSVNPIDg2MDEgZGF0ZSB0aW1lIHN0cmluZyBmb3JtYXQuXFxuICAgICAgICAgICAgICAgIGlmIChnZXREYXkpIHtcXG4gICAgICAgICAgICAgICAgICAvLyBNYW51YWxseSBjb21wdXRlIHRoZSB5ZWFyLCBtb250aCwgZGF0ZSwgaG91cnMsIG1pbnV0ZXMsXFxuICAgICAgICAgICAgICAgICAgLy8gc2Vjb25kcywgYW5kIG1pbGxpc2Vjb25kcyBpZiB0aGUgYGdldFVUQypgIG1ldGhvZHMgYXJlXFxuICAgICAgICAgICAgICAgICAgLy8gYnVnZ3kuIEFkYXB0ZWQgZnJvbSBAWWFmZmxlJ3MgYGRhdGUtc2hpbWAgcHJvamVjdC5cXG4gICAgICAgICAgICAgICAgICBkYXRlID0gZmxvb3IodmFsdWUgLyA4NjRlNSk7XFxuICAgICAgICAgICAgICAgICAgZm9yICh5ZWFyID0gZmxvb3IoZGF0ZSAvIDM2NS4yNDI1KSArIDE5NzAgLSAxOyBnZXREYXkoeWVhciArIDEsIDApIDw9IGRhdGU7IHllYXIrKyk7XFxuICAgICAgICAgICAgICAgICAgZm9yIChtb250aCA9IGZsb29yKChkYXRlIC0gZ2V0RGF5KHllYXIsIDApKSAvIDMwLjQyKTsgZ2V0RGF5KHllYXIsIG1vbnRoICsgMSkgPD0gZGF0ZTsgbW9udGgrKyk7XFxuICAgICAgICAgICAgICAgICAgZGF0ZSA9IDEgKyBkYXRlIC0gZ2V0RGF5KHllYXIsIG1vbnRoKTtcXG4gICAgICAgICAgICAgICAgICAvLyBUaGUgYHRpbWVgIHZhbHVlIHNwZWNpZmllcyB0aGUgdGltZSB3aXRoaW4gdGhlIGRheSAoc2VlIEVTXFxuICAgICAgICAgICAgICAgICAgLy8gNS4xIHNlY3Rpb24gMTUuOS4xLjIpLiBUaGUgZm9ybXVsYSBgKEEgJSBCICsgQikgJSBCYCBpcyB1c2VkXFxuICAgICAgICAgICAgICAgICAgLy8gdG8gY29tcHV0ZSBgQSBtb2R1bG8gQmAsIGFzIHRoZSBgJWAgb3BlcmF0b3IgZG9lcyBub3RcXG4gICAgICAgICAgICAgICAgICAvLyBjb3JyZXNwb25kIHRvIHRoZSBgbW9kdWxvYCBvcGVyYXRpb24gZm9yIG5lZ2F0aXZlIG51bWJlcnMuXFxuICAgICAgICAgICAgICAgICAgdGltZSA9ICh2YWx1ZSAlIDg2NGU1ICsgODY0ZTUpICUgODY0ZTU7XFxuICAgICAgICAgICAgICAgICAgLy8gVGhlIGhvdXJzLCBtaW51dGVzLCBzZWNvbmRzLCBhbmQgbWlsbGlzZWNvbmRzIGFyZSBvYnRhaW5lZCBieVxcbiAgICAgICAgICAgICAgICAgIC8vIGRlY29tcG9zaW5nIHRoZSB0aW1lIHdpdGhpbiB0aGUgZGF5LiBTZWUgc2VjdGlvbiAxNS45LjEuMTAuXFxuICAgICAgICAgICAgICAgICAgaG91cnMgPSBmbG9vcih0aW1lIC8gMzZlNSkgJSAyNDtcXG4gICAgICAgICAgICAgICAgICBtaW51dGVzID0gZmxvb3IodGltZSAvIDZlNCkgJSA2MDtcXG4gICAgICAgICAgICAgICAgICBzZWNvbmRzID0gZmxvb3IodGltZSAvIDFlMykgJSA2MDtcXG4gICAgICAgICAgICAgICAgICBtaWxsaXNlY29uZHMgPSB0aW1lICUgMWUzO1xcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgICAgICAgIHllYXIgPSB2YWx1ZS5nZXRVVENGdWxsWWVhcigpO1xcbiAgICAgICAgICAgICAgICAgIG1vbnRoID0gdmFsdWUuZ2V0VVRDTW9udGgoKTtcXG4gICAgICAgICAgICAgICAgICBkYXRlID0gdmFsdWUuZ2V0VVRDRGF0ZSgpO1xcbiAgICAgICAgICAgICAgICAgIGhvdXJzID0gdmFsdWUuZ2V0VVRDSG91cnMoKTtcXG4gICAgICAgICAgICAgICAgICBtaW51dGVzID0gdmFsdWUuZ2V0VVRDTWludXRlcygpO1xcbiAgICAgICAgICAgICAgICAgIHNlY29uZHMgPSB2YWx1ZS5nZXRVVENTZWNvbmRzKCk7XFxuICAgICAgICAgICAgICAgICAgbWlsbGlzZWNvbmRzID0gdmFsdWUuZ2V0VVRDTWlsbGlzZWNvbmRzKCk7XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgLy8gU2VyaWFsaXplIGV4dGVuZGVkIHllYXJzIGNvcnJlY3RseS5cXG4gICAgICAgICAgICAgICAgdmFsdWUgPSAoeWVhciA8PSAwIHx8IHllYXIgPj0gMWU0ID8gKHllYXIgPCAwID8gXFxcIi1cXFwiIDogXFxcIitcXFwiKSArIHRvUGFkZGVkU3RyaW5nKDYsIHllYXIgPCAwID8gLXllYXIgOiB5ZWFyKSA6IHRvUGFkZGVkU3RyaW5nKDQsIHllYXIpKSArXFxuICAgICAgICAgICAgICAgICAgXFxcIi1cXFwiICsgdG9QYWRkZWRTdHJpbmcoMiwgbW9udGggKyAxKSArIFxcXCItXFxcIiArIHRvUGFkZGVkU3RyaW5nKDIsIGRhdGUpICtcXG4gICAgICAgICAgICAgICAgICAvLyBNb250aHMsIGRhdGVzLCBob3VycywgbWludXRlcywgYW5kIHNlY29uZHMgc2hvdWxkIGhhdmUgdHdvXFxuICAgICAgICAgICAgICAgICAgLy8gZGlnaXRzOyBtaWxsaXNlY29uZHMgc2hvdWxkIGhhdmUgdGhyZWUuXFxuICAgICAgICAgICAgICAgICAgXFxcIlRcXFwiICsgdG9QYWRkZWRTdHJpbmcoMiwgaG91cnMpICsgXFxcIjpcXFwiICsgdG9QYWRkZWRTdHJpbmcoMiwgbWludXRlcykgKyBcXFwiOlxcXCIgKyB0b1BhZGRlZFN0cmluZygyLCBzZWNvbmRzKSArXFxuICAgICAgICAgICAgICAgICAgLy8gTWlsbGlzZWNvbmRzIGFyZSBvcHRpb25hbCBpbiBFUyA1LjAsIGJ1dCByZXF1aXJlZCBpbiA1LjEuXFxuICAgICAgICAgICAgICAgICAgXFxcIi5cXFwiICsgdG9QYWRkZWRTdHJpbmcoMywgbWlsbGlzZWNvbmRzKSArIFxcXCJaXFxcIjtcXG4gICAgICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgICAgIHZhbHVlID0gbnVsbDtcXG4gICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZS50b0pTT04gPT0gXFxcImZ1bmN0aW9uXFxcIiAmJiAoKGNsYXNzTmFtZSAhPSBudW1iZXJDbGFzcyAmJiBjbGFzc05hbWUgIT0gc3RyaW5nQ2xhc3MgJiYgY2xhc3NOYW1lICE9IGFycmF5Q2xhc3MpIHx8IGlzUHJvcGVydHkuY2FsbCh2YWx1ZSwgXFxcInRvSlNPTlxcXCIpKSkge1xcbiAgICAgICAgICAgICAgLy8gUHJvdG90eXBlIDw9IDEuNi4xIGFkZHMgbm9uLXN0YW5kYXJkIGB0b0pTT05gIG1ldGhvZHMgdG8gdGhlXFxuICAgICAgICAgICAgICAvLyBgTnVtYmVyYCwgYFN0cmluZ2AsIGBEYXRlYCwgYW5kIGBBcnJheWAgcHJvdG90eXBlcy4gSlNPTiAzXFxuICAgICAgICAgICAgICAvLyBpZ25vcmVzIGFsbCBgdG9KU09OYCBtZXRob2RzIG9uIHRoZXNlIG9iamVjdHMgdW5sZXNzIHRoZXkgYXJlXFxuICAgICAgICAgICAgICAvLyBkZWZpbmVkIGRpcmVjdGx5IG9uIGFuIGluc3RhbmNlLlxcbiAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS50b0pTT04ocHJvcGVydHkpO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgfVxcbiAgICAgICAgICBpZiAoY2FsbGJhY2spIHtcXG4gICAgICAgICAgICAvLyBJZiBhIHJlcGxhY2VtZW50IGZ1bmN0aW9uIHdhcyBwcm92aWRlZCwgY2FsbCBpdCB0byBvYnRhaW4gdGhlIHZhbHVlXFxuICAgICAgICAgICAgLy8gZm9yIHNlcmlhbGl6YXRpb24uXFxuICAgICAgICAgICAgdmFsdWUgPSBjYWxsYmFjay5jYWxsKG9iamVjdCwgcHJvcGVydHksIHZhbHVlKTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgICBpZiAodmFsdWUgPT09IG51bGwpIHtcXG4gICAgICAgICAgICByZXR1cm4gXFxcIm51bGxcXFwiO1xcbiAgICAgICAgICB9XFxuICAgICAgICAgIGNsYXNzTmFtZSA9IGdldENsYXNzLmNhbGwodmFsdWUpO1xcbiAgICAgICAgICBpZiAoY2xhc3NOYW1lID09IGJvb2xlYW5DbGFzcykge1xcbiAgICAgICAgICAgIC8vIEJvb2xlYW5zIGFyZSByZXByZXNlbnRlZCBsaXRlcmFsbHkuXFxuICAgICAgICAgICAgcmV0dXJuIFxcXCJcXFwiICsgdmFsdWU7XFxuICAgICAgICAgIH0gZWxzZSBpZiAoY2xhc3NOYW1lID09IG51bWJlckNsYXNzKSB7XFxuICAgICAgICAgICAgLy8gSlNPTiBudW1iZXJzIG11c3QgYmUgZmluaXRlLiBgSW5maW5pdHlgIGFuZCBgTmFOYCBhcmUgc2VyaWFsaXplZCBhc1xcbiAgICAgICAgICAgIC8vIGBcXFwibnVsbFxcXCJgLlxcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZSA+IC0xIC8gMCAmJiB2YWx1ZSA8IDEgLyAwID8gXFxcIlxcXCIgKyB2YWx1ZSA6IFxcXCJudWxsXFxcIjtcXG4gICAgICAgICAgfSBlbHNlIGlmIChjbGFzc05hbWUgPT0gc3RyaW5nQ2xhc3MpIHtcXG4gICAgICAgICAgICAvLyBTdHJpbmdzIGFyZSBkb3VibGUtcXVvdGVkIGFuZCBlc2NhcGVkLlxcbiAgICAgICAgICAgIHJldHVybiBxdW90ZShcXFwiXFxcIiArIHZhbHVlKTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgICAvLyBSZWN1cnNpdmVseSBzZXJpYWxpemUgb2JqZWN0cyBhbmQgYXJyYXlzLlxcbiAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09IFxcXCJvYmplY3RcXFwiKSB7XFxuICAgICAgICAgICAgLy8gQ2hlY2sgZm9yIGN5Y2xpYyBzdHJ1Y3R1cmVzLiBUaGlzIGlzIGEgbGluZWFyIHNlYXJjaDsgcGVyZm9ybWFuY2VcXG4gICAgICAgICAgICAvLyBpcyBpbnZlcnNlbHkgcHJvcG9ydGlvbmFsIHRvIHRoZSBudW1iZXIgb2YgdW5pcXVlIG5lc3RlZCBvYmplY3RzLlxcbiAgICAgICAgICAgIGZvciAobGVuZ3RoID0gc3RhY2subGVuZ3RoOyBsZW5ndGgtLTspIHtcXG4gICAgICAgICAgICAgIGlmIChzdGFja1tsZW5ndGhdID09PSB2YWx1ZSkge1xcbiAgICAgICAgICAgICAgICAvLyBDeWNsaWMgc3RydWN0dXJlcyBjYW5ub3QgYmUgc2VyaWFsaXplZCBieSBgSlNPTi5zdHJpbmdpZnlgLlxcbiAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoKTtcXG4gICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgLy8gQWRkIHRoZSBvYmplY3QgdG8gdGhlIHN0YWNrIG9mIHRyYXZlcnNlZCBvYmplY3RzLlxcbiAgICAgICAgICAgIHN0YWNrLnB1c2godmFsdWUpO1xcbiAgICAgICAgICAgIHJlc3VsdHMgPSBbXTtcXG4gICAgICAgICAgICAvLyBTYXZlIHRoZSBjdXJyZW50IGluZGVudGF0aW9uIGxldmVsIGFuZCBpbmRlbnQgb25lIGFkZGl0aW9uYWwgbGV2ZWwuXFxuICAgICAgICAgICAgcHJlZml4ID0gaW5kZW50YXRpb247XFxuICAgICAgICAgICAgaW5kZW50YXRpb24gKz0gd2hpdGVzcGFjZTtcXG4gICAgICAgICAgICBpZiAoY2xhc3NOYW1lID09IGFycmF5Q2xhc3MpIHtcXG4gICAgICAgICAgICAgIC8vIFJlY3Vyc2l2ZWx5IHNlcmlhbGl6ZSBhcnJheSBlbGVtZW50cy5cXG4gICAgICAgICAgICAgIGZvciAoaW5kZXggPSAwLCBsZW5ndGggPSB2YWx1ZS5sZW5ndGg7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrKSB7XFxuICAgICAgICAgICAgICAgIGVsZW1lbnQgPSBzZXJpYWxpemUoaW5kZXgsIHZhbHVlLCBjYWxsYmFjaywgcHJvcGVydGllcywgd2hpdGVzcGFjZSwgaW5kZW50YXRpb24sIHN0YWNrKTtcXG4gICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKGVsZW1lbnQgPT09IHVuZGVmID8gXFxcIm51bGxcXFwiIDogZWxlbWVudCk7XFxuICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICByZXN1bHQgPSByZXN1bHRzLmxlbmd0aCA/ICh3aGl0ZXNwYWNlID8gXFxcIltcXFxcblxcXCIgKyBpbmRlbnRhdGlvbiArIHJlc3VsdHMuam9pbihcXFwiLFxcXFxuXFxcIiArIGluZGVudGF0aW9uKSArIFxcXCJcXFxcblxcXCIgKyBwcmVmaXggKyBcXFwiXVxcXCIgOiAoXFxcIltcXFwiICsgcmVzdWx0cy5qb2luKFxcXCIsXFxcIikgKyBcXFwiXVxcXCIpKSA6IFxcXCJbXVxcXCI7XFxuICAgICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICAgIC8vIFJlY3Vyc2l2ZWx5IHNlcmlhbGl6ZSBvYmplY3QgbWVtYmVycy4gTWVtYmVycyBhcmUgc2VsZWN0ZWQgZnJvbVxcbiAgICAgICAgICAgICAgLy8gZWl0aGVyIGEgdXNlci1zcGVjaWZpZWQgbGlzdCBvZiBwcm9wZXJ0eSBuYW1lcywgb3IgdGhlIG9iamVjdFxcbiAgICAgICAgICAgICAgLy8gaXRzZWxmLlxcbiAgICAgICAgICAgICAgZm9yRWFjaChwcm9wZXJ0aWVzIHx8IHZhbHVlLCBmdW5jdGlvbiAocHJvcGVydHkpIHtcXG4gICAgICAgICAgICAgICAgdmFyIGVsZW1lbnQgPSBzZXJpYWxpemUocHJvcGVydHksIHZhbHVlLCBjYWxsYmFjaywgcHJvcGVydGllcywgd2hpdGVzcGFjZSwgaW5kZW50YXRpb24sIHN0YWNrKTtcXG4gICAgICAgICAgICAgICAgaWYgKGVsZW1lbnQgIT09IHVuZGVmKSB7XFxuICAgICAgICAgICAgICAgICAgLy8gQWNjb3JkaW5nIHRvIEVTIDUuMSBzZWN0aW9uIDE1LjEyLjM6IFxcXCJJZiBgZ2FwYCB7d2hpdGVzcGFjZX1cXG4gICAgICAgICAgICAgICAgICAvLyBpcyBub3QgdGhlIGVtcHR5IHN0cmluZywgbGV0IGBtZW1iZXJgIHtxdW90ZShwcm9wZXJ0eSkgKyBcXFwiOlxcXCJ9XFxuICAgICAgICAgICAgICAgICAgLy8gYmUgdGhlIGNvbmNhdGVuYXRpb24gb2YgYG1lbWJlcmAgYW5kIHRoZSBgc3BhY2VgIGNoYXJhY3Rlci5cXFwiXFxuICAgICAgICAgICAgICAgICAgLy8gVGhlIFxcXCJgc3BhY2VgIGNoYXJhY3RlclxcXCIgcmVmZXJzIHRvIHRoZSBsaXRlcmFsIHNwYWNlXFxuICAgICAgICAgICAgICAgICAgLy8gY2hhcmFjdGVyLCBub3QgdGhlIGBzcGFjZWAge3dpZHRofSBhcmd1bWVudCBwcm92aWRlZCB0b1xcbiAgICAgICAgICAgICAgICAgIC8vIGBKU09OLnN0cmluZ2lmeWAuXFxuICAgICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKHF1b3RlKHByb3BlcnR5KSArIFxcXCI6XFxcIiArICh3aGl0ZXNwYWNlID8gXFxcIiBcXFwiIDogXFxcIlxcXCIpICsgZWxlbWVudCk7XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgIH0pO1xcbiAgICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0cy5sZW5ndGggPyAod2hpdGVzcGFjZSA/IFxcXCJ7XFxcXG5cXFwiICsgaW5kZW50YXRpb24gKyByZXN1bHRzLmpvaW4oXFxcIixcXFxcblxcXCIgKyBpbmRlbnRhdGlvbikgKyBcXFwiXFxcXG5cXFwiICsgcHJlZml4ICsgXFxcIn1cXFwiIDogKFxcXCJ7XFxcIiArIHJlc3VsdHMuam9pbihcXFwiLFxcXCIpICsgXFxcIn1cXFwiKSkgOiBcXFwie31cXFwiO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAvLyBSZW1vdmUgdGhlIG9iamVjdCBmcm9tIHRoZSB0cmF2ZXJzZWQgb2JqZWN0IHN0YWNrLlxcbiAgICAgICAgICAgIHN0YWNrLnBvcCgpO1xcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH07XFxuXFxuICAgICAgICAvLyBQdWJsaWM6IGBKU09OLnN0cmluZ2lmeWAuIFNlZSBFUyA1LjEgc2VjdGlvbiAxNS4xMi4zLlxcbiAgICAgICAgZXhwb3J0cy5zdHJpbmdpZnkgPSBmdW5jdGlvbiAoc291cmNlLCBmaWx0ZXIsIHdpZHRoKSB7XFxuICAgICAgICAgIHZhciB3aGl0ZXNwYWNlLCBjYWxsYmFjaywgcHJvcGVydGllcywgY2xhc3NOYW1lO1xcbiAgICAgICAgICBpZiAob2JqZWN0VHlwZXNbdHlwZW9mIGZpbHRlcl0gJiYgZmlsdGVyKSB7XFxuICAgICAgICAgICAgaWYgKChjbGFzc05hbWUgPSBnZXRDbGFzcy5jYWxsKGZpbHRlcikpID09IGZ1bmN0aW9uQ2xhc3MpIHtcXG4gICAgICAgICAgICAgIGNhbGxiYWNrID0gZmlsdGVyO1xcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY2xhc3NOYW1lID09IGFycmF5Q2xhc3MpIHtcXG4gICAgICAgICAgICAgIC8vIENvbnZlcnQgdGhlIHByb3BlcnR5IG5hbWVzIGFycmF5IGludG8gYSBtYWtlc2hpZnQgc2V0LlxcbiAgICAgICAgICAgICAgcHJvcGVydGllcyA9IHt9O1xcbiAgICAgICAgICAgICAgZm9yICh2YXIgaW5kZXggPSAwLCBsZW5ndGggPSBmaWx0ZXIubGVuZ3RoLCB2YWx1ZTsgaW5kZXggPCBsZW5ndGg7IHZhbHVlID0gZmlsdGVyW2luZGV4KytdLCAoKGNsYXNzTmFtZSA9IGdldENsYXNzLmNhbGwodmFsdWUpKSwgY2xhc3NOYW1lID09IHN0cmluZ0NsYXNzIHx8IGNsYXNzTmFtZSA9PSBudW1iZXJDbGFzcykgJiYgKHByb3BlcnRpZXNbdmFsdWVdID0gMSkpO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgfVxcbiAgICAgICAgICBpZiAod2lkdGgpIHtcXG4gICAgICAgICAgICBpZiAoKGNsYXNzTmFtZSA9IGdldENsYXNzLmNhbGwod2lkdGgpKSA9PSBudW1iZXJDbGFzcykge1xcbiAgICAgICAgICAgICAgLy8gQ29udmVydCB0aGUgYHdpZHRoYCB0byBhbiBpbnRlZ2VyIGFuZCBjcmVhdGUgYSBzdHJpbmcgY29udGFpbmluZ1xcbiAgICAgICAgICAgICAgLy8gYHdpZHRoYCBudW1iZXIgb2Ygc3BhY2UgY2hhcmFjdGVycy5cXG4gICAgICAgICAgICAgIGlmICgod2lkdGggLT0gd2lkdGggJSAxKSA+IDApIHtcXG4gICAgICAgICAgICAgICAgZm9yICh3aGl0ZXNwYWNlID0gXFxcIlxcXCIsIHdpZHRoID4gMTAgJiYgKHdpZHRoID0gMTApOyB3aGl0ZXNwYWNlLmxlbmd0aCA8IHdpZHRoOyB3aGl0ZXNwYWNlICs9IFxcXCIgXFxcIik7XFxuICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfSBlbHNlIGlmIChjbGFzc05hbWUgPT0gc3RyaW5nQ2xhc3MpIHtcXG4gICAgICAgICAgICAgIHdoaXRlc3BhY2UgPSB3aWR0aC5sZW5ndGggPD0gMTAgPyB3aWR0aCA6IHdpZHRoLnNsaWNlKDAsIDEwKTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgIH1cXG4gICAgICAgICAgLy8gT3BlcmEgPD0gNy41NHUyIGRpc2NhcmRzIHRoZSB2YWx1ZXMgYXNzb2NpYXRlZCB3aXRoIGVtcHR5IHN0cmluZyBrZXlzXFxuICAgICAgICAgIC8vIChgXFxcIlxcXCJgKSBvbmx5IGlmIHRoZXkgYXJlIHVzZWQgZGlyZWN0bHkgd2l0aGluIGFuIG9iamVjdCBtZW1iZXIgbGlzdFxcbiAgICAgICAgICAvLyAoZS5nLiwgYCEoXFxcIlxcXCIgaW4geyBcXFwiXFxcIjogMX0pYCkuXFxuICAgICAgICAgIHJldHVybiBzZXJpYWxpemUoXFxcIlxcXCIsICh2YWx1ZSA9IHt9LCB2YWx1ZVtcXFwiXFxcIl0gPSBzb3VyY2UsIHZhbHVlKSwgY2FsbGJhY2ssIHByb3BlcnRpZXMsIHdoaXRlc3BhY2UsIFxcXCJcXFwiLCBbXSk7XFxuICAgICAgICB9O1xcbiAgICAgIH1cXG5cXG4gICAgICAvLyBQdWJsaWM6IFBhcnNlcyBhIEpTT04gc291cmNlIHN0cmluZy5cXG4gICAgICBpZiAoIWhhcyhcXFwianNvbi1wYXJzZVxcXCIpKSB7XFxuICAgICAgICB2YXIgZnJvbUNoYXJDb2RlID0gU3RyaW5nLmZyb21DaGFyQ29kZTtcXG5cXG4gICAgICAgIC8vIEludGVybmFsOiBBIG1hcCBvZiBlc2NhcGVkIGNvbnRyb2wgY2hhcmFjdGVycyBhbmQgdGhlaXIgdW5lc2NhcGVkXFxuICAgICAgICAvLyBlcXVpdmFsZW50cy5cXG4gICAgICAgIHZhciBVbmVzY2FwZXMgPSB7XFxuICAgICAgICAgIDkyOiBcXFwiXFxcXFxcXFxcXFwiLFxcbiAgICAgICAgICAzNDogJ1xcXCInLFxcbiAgICAgICAgICA0NzogXFxcIi9cXFwiLFxcbiAgICAgICAgICA5ODogXFxcIlxcXFxiXFxcIixcXG4gICAgICAgICAgMTE2OiBcXFwiXFxcXHRcXFwiLFxcbiAgICAgICAgICAxMTA6IFxcXCJcXFxcblxcXCIsXFxuICAgICAgICAgIDEwMjogXFxcIlxcXFxmXFxcIixcXG4gICAgICAgICAgMTE0OiBcXFwiXFxcXHJcXFwiXFxuICAgICAgICB9O1xcblxcbiAgICAgICAgLy8gSW50ZXJuYWw6IFN0b3JlcyB0aGUgcGFyc2VyIHN0YXRlLlxcbiAgICAgICAgdmFyIEluZGV4LCBTb3VyY2U7XFxuXFxuICAgICAgICAvLyBJbnRlcm5hbDogUmVzZXRzIHRoZSBwYXJzZXIgc3RhdGUgYW5kIHRocm93cyBhIGBTeW50YXhFcnJvcmAuXFxuICAgICAgICB2YXIgYWJvcnQgPSBmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgIEluZGV4ID0gU291cmNlID0gbnVsbDtcXG4gICAgICAgICAgdGhyb3cgU3ludGF4RXJyb3IoKTtcXG4gICAgICAgIH07XFxuXFxuICAgICAgICAvLyBJbnRlcm5hbDogUmV0dXJucyB0aGUgbmV4dCB0b2tlbiwgb3IgYFxcXCIkXFxcImAgaWYgdGhlIHBhcnNlciBoYXMgcmVhY2hlZFxcbiAgICAgICAgLy8gdGhlIGVuZCBvZiB0aGUgc291cmNlIHN0cmluZy4gQSB0b2tlbiBtYXkgYmUgYSBzdHJpbmcsIG51bWJlciwgYG51bGxgXFxuICAgICAgICAvLyBsaXRlcmFsLCBvciBCb29sZWFuIGxpdGVyYWwuXFxuICAgICAgICB2YXIgbGV4ID0gZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICB2YXIgc291cmNlID0gU291cmNlLCBsZW5ndGggPSBzb3VyY2UubGVuZ3RoLCB2YWx1ZSwgYmVnaW4sIHBvc2l0aW9uLCBpc1NpZ25lZCwgY2hhckNvZGU7XFxuICAgICAgICAgIHdoaWxlIChJbmRleCA8IGxlbmd0aCkge1xcbiAgICAgICAgICAgIGNoYXJDb2RlID0gc291cmNlLmNoYXJDb2RlQXQoSW5kZXgpO1xcbiAgICAgICAgICAgIHN3aXRjaCAoY2hhckNvZGUpIHtcXG4gICAgICAgICAgICAgIGNhc2UgOTogY2FzZSAxMDogY2FzZSAxMzogY2FzZSAzMjpcXG4gICAgICAgICAgICAgICAgLy8gU2tpcCB3aGl0ZXNwYWNlIHRva2VucywgaW5jbHVkaW5nIHRhYnMsIGNhcnJpYWdlIHJldHVybnMsIGxpbmVcXG4gICAgICAgICAgICAgICAgLy8gZmVlZHMsIGFuZCBzcGFjZSBjaGFyYWN0ZXJzLlxcbiAgICAgICAgICAgICAgICBJbmRleCsrO1xcbiAgICAgICAgICAgICAgICBicmVhaztcXG4gICAgICAgICAgICAgIGNhc2UgMTIzOiBjYXNlIDEyNTogY2FzZSA5MTogY2FzZSA5MzogY2FzZSA1ODogY2FzZSA0NDpcXG4gICAgICAgICAgICAgICAgLy8gUGFyc2UgYSBwdW5jdHVhdG9yIHRva2VuIChge2AsIGB9YCwgYFtgLCBgXWAsIGA6YCwgb3IgYCxgKSBhdFxcbiAgICAgICAgICAgICAgICAvLyB0aGUgY3VycmVudCBwb3NpdGlvbi5cXG4gICAgICAgICAgICAgICAgdmFsdWUgPSBjaGFySW5kZXhCdWdneSA/IHNvdXJjZS5jaGFyQXQoSW5kZXgpIDogc291cmNlW0luZGV4XTtcXG4gICAgICAgICAgICAgICAgSW5kZXgrKztcXG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xcbiAgICAgICAgICAgICAgY2FzZSAzNDpcXG4gICAgICAgICAgICAgICAgLy8gYFxcXCJgIGRlbGltaXRzIGEgSlNPTiBzdHJpbmc7IGFkdmFuY2UgdG8gdGhlIG5leHQgY2hhcmFjdGVyIGFuZFxcbiAgICAgICAgICAgICAgICAvLyBiZWdpbiBwYXJzaW5nIHRoZSBzdHJpbmcuIFN0cmluZyB0b2tlbnMgYXJlIHByZWZpeGVkIHdpdGggdGhlXFxuICAgICAgICAgICAgICAgIC8vIHNlbnRpbmVsIGBAYCBjaGFyYWN0ZXIgdG8gZGlzdGluZ3Vpc2ggdGhlbSBmcm9tIHB1bmN0dWF0b3JzIGFuZFxcbiAgICAgICAgICAgICAgICAvLyBlbmQtb2Ytc3RyaW5nIHRva2Vucy5cXG4gICAgICAgICAgICAgICAgZm9yICh2YWx1ZSA9IFxcXCJAXFxcIiwgSW5kZXgrKzsgSW5kZXggPCBsZW5ndGg7KSB7XFxuICAgICAgICAgICAgICAgICAgY2hhckNvZGUgPSBzb3VyY2UuY2hhckNvZGVBdChJbmRleCk7XFxuICAgICAgICAgICAgICAgICAgaWYgKGNoYXJDb2RlIDwgMzIpIHtcXG4gICAgICAgICAgICAgICAgICAgIC8vIFVuZXNjYXBlZCBBU0NJSSBjb250cm9sIGNoYXJhY3RlcnMgKHRob3NlIHdpdGggYSBjb2RlIHVuaXRcXG4gICAgICAgICAgICAgICAgICAgIC8vIGxlc3MgdGhhbiB0aGUgc3BhY2UgY2hhcmFjdGVyKSBhcmUgbm90IHBlcm1pdHRlZC5cXG4gICAgICAgICAgICAgICAgICAgIGFib3J0KCk7XFxuICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjaGFyQ29kZSA9PSA5Mikge1xcbiAgICAgICAgICAgICAgICAgICAgLy8gQSByZXZlcnNlIHNvbGlkdXMgKGBcXFxcYCkgbWFya3MgdGhlIGJlZ2lubmluZyBvZiBhbiBlc2NhcGVkXFxuICAgICAgICAgICAgICAgICAgICAvLyBjb250cm9sIGNoYXJhY3RlciAoaW5jbHVkaW5nIGBcXFwiYCwgYFxcXFxgLCBhbmQgYC9gKSBvciBVbmljb2RlXFxuICAgICAgICAgICAgICAgICAgICAvLyBlc2NhcGUgc2VxdWVuY2UuXFxuICAgICAgICAgICAgICAgICAgICBjaGFyQ29kZSA9IHNvdXJjZS5jaGFyQ29kZUF0KCsrSW5kZXgpO1xcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChjaGFyQ29kZSkge1xcbiAgICAgICAgICAgICAgICAgICAgICBjYXNlIDkyOiBjYXNlIDM0OiBjYXNlIDQ3OiBjYXNlIDk4OiBjYXNlIDExNjogY2FzZSAxMTA6IGNhc2UgMTAyOiBjYXNlIDExNDpcXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBSZXZpdmUgZXNjYXBlZCBjb250cm9sIGNoYXJhY3RlcnMuXFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgKz0gVW5lc2NhcGVzW2NoYXJDb2RlXTtcXG4gICAgICAgICAgICAgICAgICAgICAgICBJbmRleCsrO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xcbiAgICAgICAgICAgICAgICAgICAgICBjYXNlIDExNzpcXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBgXFxcXHVgIG1hcmtzIHRoZSBiZWdpbm5pbmcgb2YgYSBVbmljb2RlIGVzY2FwZSBzZXF1ZW5jZS5cXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBBZHZhbmNlIHRvIHRoZSBmaXJzdCBjaGFyYWN0ZXIgYW5kIHZhbGlkYXRlIHRoZVxcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGZvdXItZGlnaXQgY29kZSBwb2ludC5cXG4gICAgICAgICAgICAgICAgICAgICAgICBiZWdpbiA9ICsrSW5kZXg7XFxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChwb3NpdGlvbiA9IEluZGV4ICsgNDsgSW5kZXggPCBwb3NpdGlvbjsgSW5kZXgrKykge1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgY2hhckNvZGUgPSBzb3VyY2UuY2hhckNvZGVBdChJbmRleCk7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBBIHZhbGlkIHNlcXVlbmNlIGNvbXByaXNlcyBmb3VyIGhleGRpZ2l0cyAoY2FzZS1cXG4gICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGluc2Vuc2l0aXZlKSB0aGF0IGZvcm0gYSBzaW5nbGUgaGV4YWRlY2ltYWwgdmFsdWUuXFxuICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShjaGFyQ29kZSA+PSA0OCAmJiBjaGFyQ29kZSA8PSA1NyB8fCBjaGFyQ29kZSA+PSA5NyAmJiBjaGFyQ29kZSA8PSAxMDIgfHwgY2hhckNvZGUgPj0gNjUgJiYgY2hhckNvZGUgPD0gNzApKSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEludmFsaWQgVW5pY29kZSBlc2NhcGUgc2VxdWVuY2UuXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFib3J0KCk7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJldml2ZSB0aGUgZXNjYXBlZCBjaGFyYWN0ZXIuXFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgKz0gZnJvbUNoYXJDb2RlKFxcXCIweFxcXCIgKyBzb3VyY2Uuc2xpY2UoYmVnaW4sIEluZGV4KSk7XFxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XFxuICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSW52YWxpZCBlc2NhcGUgc2VxdWVuY2UuXFxuICAgICAgICAgICAgICAgICAgICAgICAgYWJvcnQoKTtcXG4gICAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoYXJDb2RlID09IDM0KSB7XFxuICAgICAgICAgICAgICAgICAgICAgIC8vIEFuIHVuZXNjYXBlZCBkb3VibGUtcXVvdGUgY2hhcmFjdGVyIG1hcmtzIHRoZSBlbmQgb2YgdGhlXFxuICAgICAgICAgICAgICAgICAgICAgIC8vIHN0cmluZy5cXG4gICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XFxuICAgICAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgICAgICBjaGFyQ29kZSA9IHNvdXJjZS5jaGFyQ29kZUF0KEluZGV4KTtcXG4gICAgICAgICAgICAgICAgICAgIGJlZ2luID0gSW5kZXg7XFxuICAgICAgICAgICAgICAgICAgICAvLyBPcHRpbWl6ZSBmb3IgdGhlIGNvbW1vbiBjYXNlIHdoZXJlIGEgc3RyaW5nIGlzIHZhbGlkLlxcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGNoYXJDb2RlID49IDMyICYmIGNoYXJDb2RlICE9IDkyICYmIGNoYXJDb2RlICE9IDM0KSB7XFxuICAgICAgICAgICAgICAgICAgICAgIGNoYXJDb2RlID0gc291cmNlLmNoYXJDb2RlQXQoKytJbmRleCk7XFxuICAgICAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgICAgICAvLyBBcHBlbmQgdGhlIHN0cmluZyBhcy1pcy5cXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlICs9IHNvdXJjZS5zbGljZShiZWdpbiwgSW5kZXgpO1xcbiAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICBpZiAoc291cmNlLmNoYXJDb2RlQXQoSW5kZXgpID09IDM0KSB7XFxuICAgICAgICAgICAgICAgICAgLy8gQWR2YW5jZSB0byB0aGUgbmV4dCBjaGFyYWN0ZXIgYW5kIHJldHVybiB0aGUgcmV2aXZlZCBzdHJpbmcuXFxuICAgICAgICAgICAgICAgICAgSW5kZXgrKztcXG4gICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgLy8gVW50ZXJtaW5hdGVkIHN0cmluZy5cXG4gICAgICAgICAgICAgICAgYWJvcnQoKTtcXG4gICAgICAgICAgICAgIGRlZmF1bHQ6XFxuICAgICAgICAgICAgICAgIC8vIFBhcnNlIG51bWJlcnMgYW5kIGxpdGVyYWxzLlxcbiAgICAgICAgICAgICAgICBiZWdpbiA9IEluZGV4O1xcbiAgICAgICAgICAgICAgICAvLyBBZHZhbmNlIHBhc3QgdGhlIG5lZ2F0aXZlIHNpZ24sIGlmIG9uZSBpcyBzcGVjaWZpZWQuXFxuICAgICAgICAgICAgICAgIGlmIChjaGFyQ29kZSA9PSA0NSkge1xcbiAgICAgICAgICAgICAgICAgIGlzU2lnbmVkID0gdHJ1ZTtcXG4gICAgICAgICAgICAgICAgICBjaGFyQ29kZSA9IHNvdXJjZS5jaGFyQ29kZUF0KCsrSW5kZXgpO1xcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgIC8vIFBhcnNlIGFuIGludGVnZXIgb3IgZmxvYXRpbmctcG9pbnQgdmFsdWUuXFxuICAgICAgICAgICAgICAgIGlmIChjaGFyQ29kZSA+PSA0OCAmJiBjaGFyQ29kZSA8PSA1Nykge1xcbiAgICAgICAgICAgICAgICAgIC8vIExlYWRpbmcgemVyb2VzIGFyZSBpbnRlcnByZXRlZCBhcyBvY3RhbCBsaXRlcmFscy5cXG4gICAgICAgICAgICAgICAgICBpZiAoY2hhckNvZGUgPT0gNDggJiYgKChjaGFyQ29kZSA9IHNvdXJjZS5jaGFyQ29kZUF0KEluZGV4ICsgMSkpLCBjaGFyQ29kZSA+PSA0OCAmJiBjaGFyQ29kZSA8PSA1NykpIHtcXG4gICAgICAgICAgICAgICAgICAgIC8vIElsbGVnYWwgb2N0YWwgbGl0ZXJhbC5cXG4gICAgICAgICAgICAgICAgICAgIGFib3J0KCk7XFxuICAgICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICAgIGlzU2lnbmVkID0gZmFsc2U7XFxuICAgICAgICAgICAgICAgICAgLy8gUGFyc2UgdGhlIGludGVnZXIgY29tcG9uZW50LlxcbiAgICAgICAgICAgICAgICAgIGZvciAoOyBJbmRleCA8IGxlbmd0aCAmJiAoKGNoYXJDb2RlID0gc291cmNlLmNoYXJDb2RlQXQoSW5kZXgpKSwgY2hhckNvZGUgPj0gNDggJiYgY2hhckNvZGUgPD0gNTcpOyBJbmRleCsrKTtcXG4gICAgICAgICAgICAgICAgICAvLyBGbG9hdHMgY2Fubm90IGNvbnRhaW4gYSBsZWFkaW5nIGRlY2ltYWwgcG9pbnQ7IGhvd2V2ZXIsIHRoaXNcXG4gICAgICAgICAgICAgICAgICAvLyBjYXNlIGlzIGFscmVhZHkgYWNjb3VudGVkIGZvciBieSB0aGUgcGFyc2VyLlxcbiAgICAgICAgICAgICAgICAgIGlmIChzb3VyY2UuY2hhckNvZGVBdChJbmRleCkgPT0gNDYpIHtcXG4gICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uID0gKytJbmRleDtcXG4gICAgICAgICAgICAgICAgICAgIC8vIFBhcnNlIHRoZSBkZWNpbWFsIGNvbXBvbmVudC5cXG4gICAgICAgICAgICAgICAgICAgIGZvciAoOyBwb3NpdGlvbiA8IGxlbmd0aCAmJiAoKGNoYXJDb2RlID0gc291cmNlLmNoYXJDb2RlQXQocG9zaXRpb24pKSwgY2hhckNvZGUgPj0gNDggJiYgY2hhckNvZGUgPD0gNTcpOyBwb3NpdGlvbisrKTtcXG4gICAgICAgICAgICAgICAgICAgIGlmIChwb3NpdGlvbiA9PSBJbmRleCkge1xcbiAgICAgICAgICAgICAgICAgICAgICAvLyBJbGxlZ2FsIHRyYWlsaW5nIGRlY2ltYWwuXFxuICAgICAgICAgICAgICAgICAgICAgIGFib3J0KCk7XFxuICAgICAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgICAgICBJbmRleCA9IHBvc2l0aW9uO1xcbiAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgICAvLyBQYXJzZSBleHBvbmVudHMuIFRoZSBgZWAgZGVub3RpbmcgdGhlIGV4cG9uZW50IGlzXFxuICAgICAgICAgICAgICAgICAgLy8gY2FzZS1pbnNlbnNpdGl2ZS5cXG4gICAgICAgICAgICAgICAgICBjaGFyQ29kZSA9IHNvdXJjZS5jaGFyQ29kZUF0KEluZGV4KTtcXG4gICAgICAgICAgICAgICAgICBpZiAoY2hhckNvZGUgPT0gMTAxIHx8IGNoYXJDb2RlID09IDY5KSB7XFxuICAgICAgICAgICAgICAgICAgICBjaGFyQ29kZSA9IHNvdXJjZS5jaGFyQ29kZUF0KCsrSW5kZXgpO1xcbiAgICAgICAgICAgICAgICAgICAgLy8gU2tpcCBwYXN0IHRoZSBzaWduIGZvbGxvd2luZyB0aGUgZXhwb25lbnQsIGlmIG9uZSBpc1xcbiAgICAgICAgICAgICAgICAgICAgLy8gc3BlY2lmaWVkLlxcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoYXJDb2RlID09IDQzIHx8IGNoYXJDb2RlID09IDQ1KSB7XFxuICAgICAgICAgICAgICAgICAgICAgIEluZGV4Kys7XFxuICAgICAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgICAgICAvLyBQYXJzZSB0aGUgZXhwb25lbnRpYWwgY29tcG9uZW50LlxcbiAgICAgICAgICAgICAgICAgICAgZm9yIChwb3NpdGlvbiA9IEluZGV4OyBwb3NpdGlvbiA8IGxlbmd0aCAmJiAoKGNoYXJDb2RlID0gc291cmNlLmNoYXJDb2RlQXQocG9zaXRpb24pKSwgY2hhckNvZGUgPj0gNDggJiYgY2hhckNvZGUgPD0gNTcpOyBwb3NpdGlvbisrKTtcXG4gICAgICAgICAgICAgICAgICAgIGlmIChwb3NpdGlvbiA9PSBJbmRleCkge1xcbiAgICAgICAgICAgICAgICAgICAgICAvLyBJbGxlZ2FsIGVtcHR5IGV4cG9uZW50LlxcbiAgICAgICAgICAgICAgICAgICAgICBhYm9ydCgpO1xcbiAgICAgICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICAgICAgSW5kZXggPSBwb3NpdGlvbjtcXG4gICAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgICAgLy8gQ29lcmNlIHRoZSBwYXJzZWQgdmFsdWUgdG8gYSBKYXZhU2NyaXB0IG51bWJlci5cXG4gICAgICAgICAgICAgICAgICByZXR1cm4gK3NvdXJjZS5zbGljZShiZWdpbiwgSW5kZXgpO1xcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgIC8vIEEgbmVnYXRpdmUgc2lnbiBtYXkgb25seSBwcmVjZWRlIG51bWJlcnMuXFxuICAgICAgICAgICAgICAgIGlmIChpc1NpZ25lZCkge1xcbiAgICAgICAgICAgICAgICAgIGFib3J0KCk7XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgLy8gYHRydWVgLCBgZmFsc2VgLCBhbmQgYG51bGxgIGxpdGVyYWxzLlxcbiAgICAgICAgICAgICAgICBpZiAoc291cmNlLnNsaWNlKEluZGV4LCBJbmRleCArIDQpID09IFxcXCJ0cnVlXFxcIikge1xcbiAgICAgICAgICAgICAgICAgIEluZGV4ICs9IDQ7XFxuICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XFxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoc291cmNlLnNsaWNlKEluZGV4LCBJbmRleCArIDUpID09IFxcXCJmYWxzZVxcXCIpIHtcXG4gICAgICAgICAgICAgICAgICBJbmRleCArPSA1O1xcbiAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChzb3VyY2Uuc2xpY2UoSW5kZXgsIEluZGV4ICsgNCkgPT0gXFxcIm51bGxcXFwiKSB7XFxuICAgICAgICAgICAgICAgICAgSW5kZXggKz0gNDtcXG4gICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICAvLyBVbnJlY29nbml6ZWQgdG9rZW4uXFxuICAgICAgICAgICAgICAgIGFib3J0KCk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICB9XFxuICAgICAgICAgIC8vIFJldHVybiB0aGUgc2VudGluZWwgYCRgIGNoYXJhY3RlciBpZiB0aGUgcGFyc2VyIGhhcyByZWFjaGVkIHRoZSBlbmRcXG4gICAgICAgICAgLy8gb2YgdGhlIHNvdXJjZSBzdHJpbmcuXFxuICAgICAgICAgIHJldHVybiBcXFwiJFxcXCI7XFxuICAgICAgICB9O1xcblxcbiAgICAgICAgLy8gSW50ZXJuYWw6IFBhcnNlcyBhIEpTT04gYHZhbHVlYCB0b2tlbi5cXG4gICAgICAgIHZhciBnZXQgPSBmdW5jdGlvbiAodmFsdWUpIHtcXG4gICAgICAgICAgdmFyIHJlc3VsdHMsIGhhc01lbWJlcnM7XFxuICAgICAgICAgIGlmICh2YWx1ZSA9PSBcXFwiJFxcXCIpIHtcXG4gICAgICAgICAgICAvLyBVbmV4cGVjdGVkIGVuZCBvZiBpbnB1dC5cXG4gICAgICAgICAgICBhYm9ydCgpO1xcbiAgICAgICAgICB9XFxuICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT0gXFxcInN0cmluZ1xcXCIpIHtcXG4gICAgICAgICAgICBpZiAoKGNoYXJJbmRleEJ1Z2d5ID8gdmFsdWUuY2hhckF0KDApIDogdmFsdWVbMF0pID09IFxcXCJAXFxcIikge1xcbiAgICAgICAgICAgICAgLy8gUmVtb3ZlIHRoZSBzZW50aW5lbCBgQGAgY2hhcmFjdGVyLlxcbiAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlLnNsaWNlKDEpO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAvLyBQYXJzZSBvYmplY3QgYW5kIGFycmF5IGxpdGVyYWxzLlxcbiAgICAgICAgICAgIGlmICh2YWx1ZSA9PSBcXFwiW1xcXCIpIHtcXG4gICAgICAgICAgICAgIC8vIFBhcnNlcyBhIEpTT04gYXJyYXksIHJldHVybmluZyBhIG5ldyBKYXZhU2NyaXB0IGFycmF5LlxcbiAgICAgICAgICAgICAgcmVzdWx0cyA9IFtdO1xcbiAgICAgICAgICAgICAgZm9yICg7OyBoYXNNZW1iZXJzIHx8IChoYXNNZW1iZXJzID0gdHJ1ZSkpIHtcXG4gICAgICAgICAgICAgICAgdmFsdWUgPSBsZXgoKTtcXG4gICAgICAgICAgICAgICAgLy8gQSBjbG9zaW5nIHNxdWFyZSBicmFja2V0IG1hcmtzIHRoZSBlbmQgb2YgdGhlIGFycmF5IGxpdGVyYWwuXFxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PSBcXFwiXVxcXCIpIHtcXG4gICAgICAgICAgICAgICAgICBicmVhaztcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICAvLyBJZiB0aGUgYXJyYXkgbGl0ZXJhbCBjb250YWlucyBlbGVtZW50cywgdGhlIGN1cnJlbnQgdG9rZW5cXG4gICAgICAgICAgICAgICAgLy8gc2hvdWxkIGJlIGEgY29tbWEgc2VwYXJhdGluZyB0aGUgcHJldmlvdXMgZWxlbWVudCBmcm9tIHRoZVxcbiAgICAgICAgICAgICAgICAvLyBuZXh0LlxcbiAgICAgICAgICAgICAgICBpZiAoaGFzTWVtYmVycykge1xcbiAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PSBcXFwiLFxcXCIpIHtcXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gbGV4KCk7XFxuICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT0gXFxcIl1cXFwiKSB7XFxuICAgICAgICAgICAgICAgICAgICAgIC8vIFVuZXhwZWN0ZWQgdHJhaWxpbmcgYCxgIGluIGFycmF5IGxpdGVyYWwuXFxuICAgICAgICAgICAgICAgICAgICAgIGFib3J0KCk7XFxuICAgICAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICAgICAgICAgIC8vIEEgYCxgIG11c3Qgc2VwYXJhdGUgZWFjaCBhcnJheSBlbGVtZW50LlxcbiAgICAgICAgICAgICAgICAgICAgYWJvcnQoKTtcXG4gICAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgLy8gRWxpc2lvbnMgYW5kIGxlYWRpbmcgY29tbWFzIGFyZSBub3QgcGVybWl0dGVkLlxcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT0gXFxcIixcXFwiKSB7XFxuICAgICAgICAgICAgICAgICAgYWJvcnQoKTtcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2goZ2V0KHZhbHVlKSk7XFxuICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0cztcXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHZhbHVlID09IFxcXCJ7XFxcIikge1xcbiAgICAgICAgICAgICAgLy8gUGFyc2VzIGEgSlNPTiBvYmplY3QsIHJldHVybmluZyBhIG5ldyBKYXZhU2NyaXB0IG9iamVjdC5cXG4gICAgICAgICAgICAgIHJlc3VsdHMgPSB7fTtcXG4gICAgICAgICAgICAgIGZvciAoOzsgaGFzTWVtYmVycyB8fCAoaGFzTWVtYmVycyA9IHRydWUpKSB7XFxuICAgICAgICAgICAgICAgIHZhbHVlID0gbGV4KCk7XFxuICAgICAgICAgICAgICAgIC8vIEEgY2xvc2luZyBjdXJseSBicmFjZSBtYXJrcyB0aGUgZW5kIG9mIHRoZSBvYmplY3QgbGl0ZXJhbC5cXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlID09IFxcXCJ9XFxcIikge1xcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgIC8vIElmIHRoZSBvYmplY3QgbGl0ZXJhbCBjb250YWlucyBtZW1iZXJzLCB0aGUgY3VycmVudCB0b2tlblxcbiAgICAgICAgICAgICAgICAvLyBzaG91bGQgYmUgYSBjb21tYSBzZXBhcmF0b3IuXFxuICAgICAgICAgICAgICAgIGlmIChoYXNNZW1iZXJzKSB7XFxuICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlID09IFxcXCIsXFxcIikge1xcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBsZXgoKTtcXG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PSBcXFwifVxcXCIpIHtcXG4gICAgICAgICAgICAgICAgICAgICAgLy8gVW5leHBlY3RlZCB0cmFpbGluZyBgLGAgaW4gb2JqZWN0IGxpdGVyYWwuXFxuICAgICAgICAgICAgICAgICAgICAgIGFib3J0KCk7XFxuICAgICAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICAgICAgICAgIC8vIEEgYCxgIG11c3Qgc2VwYXJhdGUgZWFjaCBvYmplY3QgbWVtYmVyLlxcbiAgICAgICAgICAgICAgICAgICAgYWJvcnQoKTtcXG4gICAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgLy8gTGVhZGluZyBjb21tYXMgYXJlIG5vdCBwZXJtaXR0ZWQsIG9iamVjdCBwcm9wZXJ0eSBuYW1lcyBtdXN0IGJlXFxuICAgICAgICAgICAgICAgIC8vIGRvdWJsZS1xdW90ZWQgc3RyaW5ncywgYW5kIGEgYDpgIG11c3Qgc2VwYXJhdGUgZWFjaCBwcm9wZXJ0eVxcbiAgICAgICAgICAgICAgICAvLyBuYW1lIGFuZCB2YWx1ZS5cXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlID09IFxcXCIsXFxcIiB8fCB0eXBlb2YgdmFsdWUgIT0gXFxcInN0cmluZ1xcXCIgfHwgKGNoYXJJbmRleEJ1Z2d5ID8gdmFsdWUuY2hhckF0KDApIDogdmFsdWVbMF0pICE9IFxcXCJAXFxcIiB8fCBsZXgoKSAhPSBcXFwiOlxcXCIpIHtcXG4gICAgICAgICAgICAgICAgICBhYm9ydCgpO1xcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgIHJlc3VsdHNbdmFsdWUuc2xpY2UoMSldID0gZ2V0KGxleCgpKTtcXG4gICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgIHJldHVybiByZXN1bHRzO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAvLyBVbmV4cGVjdGVkIHRva2VuIGVuY291bnRlcmVkLlxcbiAgICAgICAgICAgIGFib3J0KCk7XFxuICAgICAgICAgIH1cXG4gICAgICAgICAgcmV0dXJuIHZhbHVlO1xcbiAgICAgICAgfTtcXG5cXG4gICAgICAgIC8vIEludGVybmFsOiBVcGRhdGVzIGEgdHJhdmVyc2VkIG9iamVjdCBtZW1iZXIuXFxuICAgICAgICB2YXIgdXBkYXRlID0gZnVuY3Rpb24gKHNvdXJjZSwgcHJvcGVydHksIGNhbGxiYWNrKSB7XFxuICAgICAgICAgIHZhciBlbGVtZW50ID0gd2Fsayhzb3VyY2UsIHByb3BlcnR5LCBjYWxsYmFjayk7XFxuICAgICAgICAgIGlmIChlbGVtZW50ID09PSB1bmRlZikge1xcbiAgICAgICAgICAgIGRlbGV0ZSBzb3VyY2VbcHJvcGVydHldO1xcbiAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgIHNvdXJjZVtwcm9wZXJ0eV0gPSBlbGVtZW50O1xcbiAgICAgICAgICB9XFxuICAgICAgICB9O1xcblxcbiAgICAgICAgLy8gSW50ZXJuYWw6IFJlY3Vyc2l2ZWx5IHRyYXZlcnNlcyBhIHBhcnNlZCBKU09OIG9iamVjdCwgaW52b2tpbmcgdGhlXFxuICAgICAgICAvLyBgY2FsbGJhY2tgIGZ1bmN0aW9uIGZvciBlYWNoIHZhbHVlLiBUaGlzIGlzIGFuIGltcGxlbWVudGF0aW9uIG9mIHRoZVxcbiAgICAgICAgLy8gYFdhbGsoaG9sZGVyLCBuYW1lKWAgb3BlcmF0aW9uIGRlZmluZWQgaW4gRVMgNS4xIHNlY3Rpb24gMTUuMTIuMi5cXG4gICAgICAgIHZhciB3YWxrID0gZnVuY3Rpb24gKHNvdXJjZSwgcHJvcGVydHksIGNhbGxiYWNrKSB7XFxuICAgICAgICAgIHZhciB2YWx1ZSA9IHNvdXJjZVtwcm9wZXJ0eV0sIGxlbmd0aDtcXG4gICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PSBcXFwib2JqZWN0XFxcIiAmJiB2YWx1ZSkge1xcbiAgICAgICAgICAgIC8vIGBmb3JFYWNoYCBjYW4ndCBiZSB1c2VkIHRvIHRyYXZlcnNlIGFuIGFycmF5IGluIE9wZXJhIDw9IDguNTRcXG4gICAgICAgICAgICAvLyBiZWNhdXNlIGl0cyBgT2JqZWN0I2hhc093blByb3BlcnR5YCBpbXBsZW1lbnRhdGlvbiByZXR1cm5zIGBmYWxzZWBcXG4gICAgICAgICAgICAvLyBmb3IgYXJyYXkgaW5kaWNlcyAoZS5nLiwgYCFbMSwgMiwgM10uaGFzT3duUHJvcGVydHkoXFxcIjBcXFwiKWApLlxcbiAgICAgICAgICAgIGlmIChnZXRDbGFzcy5jYWxsKHZhbHVlKSA9PSBhcnJheUNsYXNzKSB7XFxuICAgICAgICAgICAgICBmb3IgKGxlbmd0aCA9IHZhbHVlLmxlbmd0aDsgbGVuZ3RoLS07KSB7XFxuICAgICAgICAgICAgICAgIHVwZGF0ZSh2YWx1ZSwgbGVuZ3RoLCBjYWxsYmFjayk7XFxuICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICAgIGZvckVhY2godmFsdWUsIGZ1bmN0aW9uIChwcm9wZXJ0eSkge1xcbiAgICAgICAgICAgICAgICB1cGRhdGUodmFsdWUsIHByb3BlcnR5LCBjYWxsYmFjayk7XFxuICAgICAgICAgICAgICB9KTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgIH1cXG4gICAgICAgICAgcmV0dXJuIGNhbGxiYWNrLmNhbGwoc291cmNlLCBwcm9wZXJ0eSwgdmFsdWUpO1xcbiAgICAgICAgfTtcXG5cXG4gICAgICAgIC8vIFB1YmxpYzogYEpTT04ucGFyc2VgLiBTZWUgRVMgNS4xIHNlY3Rpb24gMTUuMTIuMi5cXG4gICAgICAgIGV4cG9ydHMucGFyc2UgPSBmdW5jdGlvbiAoc291cmNlLCBjYWxsYmFjaykge1xcbiAgICAgICAgICB2YXIgcmVzdWx0LCB2YWx1ZTtcXG4gICAgICAgICAgSW5kZXggPSAwO1xcbiAgICAgICAgICBTb3VyY2UgPSBcXFwiXFxcIiArIHNvdXJjZTtcXG4gICAgICAgICAgcmVzdWx0ID0gZ2V0KGxleCgpKTtcXG4gICAgICAgICAgLy8gSWYgYSBKU09OIHN0cmluZyBjb250YWlucyBtdWx0aXBsZSB0b2tlbnMsIGl0IGlzIGludmFsaWQuXFxuICAgICAgICAgIGlmIChsZXgoKSAhPSBcXFwiJFxcXCIpIHtcXG4gICAgICAgICAgICBhYm9ydCgpO1xcbiAgICAgICAgICB9XFxuICAgICAgICAgIC8vIFJlc2V0IHRoZSBwYXJzZXIgc3RhdGUuXFxuICAgICAgICAgIEluZGV4ID0gU291cmNlID0gbnVsbDtcXG4gICAgICAgICAgcmV0dXJuIGNhbGxiYWNrICYmIGdldENsYXNzLmNhbGwoY2FsbGJhY2spID09IGZ1bmN0aW9uQ2xhc3MgPyB3YWxrKCh2YWx1ZSA9IHt9LCB2YWx1ZVtcXFwiXFxcIl0gPSByZXN1bHQsIHZhbHVlKSwgXFxcIlxcXCIsIGNhbGxiYWNrKSA6IHJlc3VsdDtcXG4gICAgICAgIH07XFxuICAgICAgfVxcbiAgICB9XFxuXFxuICAgIGV4cG9ydHNbXFxcInJ1bkluQ29udGV4dFxcXCJdID0gcnVuSW5Db250ZXh0O1xcbiAgICByZXR1cm4gZXhwb3J0cztcXG4gIH1cXG5cXG4gIGlmIChmcmVlRXhwb3J0cyAmJiAhaXNMb2FkZXIpIHtcXG4gICAgLy8gRXhwb3J0IGZvciBDb21tb25KUyBlbnZpcm9ubWVudHMuXFxuICAgIHJ1bkluQ29udGV4dChyb290LCBmcmVlRXhwb3J0cyk7XFxuICB9IGVsc2Uge1xcbiAgICAvLyBFeHBvcnQgZm9yIHdlYiBicm93c2VycyBhbmQgSmF2YVNjcmlwdCBlbmdpbmVzLlxcbiAgICB2YXIgbmF0aXZlSlNPTiA9IHJvb3QuSlNPTixcXG4gICAgICAgIHByZXZpb3VzSlNPTiA9IHJvb3RbXFxcIkpTT04zXFxcIl0sXFxuICAgICAgICBpc1Jlc3RvcmVkID0gZmFsc2U7XFxuXFxuICAgIHZhciBKU09OMyA9IHJ1bkluQ29udGV4dChyb290LCAocm9vdFtcXFwiSlNPTjNcXFwiXSA9IHtcXG4gICAgICAvLyBQdWJsaWM6IFJlc3RvcmVzIHRoZSBvcmlnaW5hbCB2YWx1ZSBvZiB0aGUgZ2xvYmFsIGBKU09OYCBvYmplY3QgYW5kXFxuICAgICAgLy8gcmV0dXJucyBhIHJlZmVyZW5jZSB0byB0aGUgYEpTT04zYCBvYmplY3QuXFxuICAgICAgXFxcIm5vQ29uZmxpY3RcXFwiOiBmdW5jdGlvbiAoKSB7XFxuICAgICAgICBpZiAoIWlzUmVzdG9yZWQpIHtcXG4gICAgICAgICAgaXNSZXN0b3JlZCA9IHRydWU7XFxuICAgICAgICAgIHJvb3QuSlNPTiA9IG5hdGl2ZUpTT047XFxuICAgICAgICAgIHJvb3RbXFxcIkpTT04zXFxcIl0gPSBwcmV2aW91c0pTT047XFxuICAgICAgICAgIG5hdGl2ZUpTT04gPSBwcmV2aW91c0pTT04gPSBudWxsO1xcbiAgICAgICAgfVxcbiAgICAgICAgcmV0dXJuIEpTT04zO1xcbiAgICAgIH1cXG4gICAgfSkpO1xcblxcbiAgICByb290LkpTT04gPSB7XFxuICAgICAgXFxcInBhcnNlXFxcIjogSlNPTjMucGFyc2UsXFxuICAgICAgXFxcInN0cmluZ2lmeVxcXCI6IEpTT04zLnN0cmluZ2lmeVxcbiAgICB9O1xcbiAgfVxcblxcbiAgLy8gRXhwb3J0IGZvciBhc3luY2hyb25vdXMgbW9kdWxlIGxvYWRlcnMuXFxuICBpZiAoaXNMb2FkZXIpIHtcXG4gICAgZGVmaW5lKGZ1bmN0aW9uICgpIHtcXG4gICAgICByZXR1cm4gSlNPTjM7XFxuICAgIH0pO1xcbiAgfVxcbn0pLmNhbGwodGhpcyk7XFxuXFxufSkuY2FsbCh0aGlzLHR5cGVvZiBnbG9iYWwgIT09IFxcXCJ1bmRlZmluZWRcXFwiID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09IFxcXCJ1bmRlZmluZWRcXFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFxcXCJ1bmRlZmluZWRcXFwiID8gd2luZG93IDoge30pXFxufSx7fV0sNzA6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xcbi8qKlxcbiAqIGxvZGFzaCAzLjIuMCAoQ3VzdG9tIEJ1aWxkKSA8aHR0cHM6Ly9sb2Rhc2guY29tLz5cXG4gKiBCdWlsZDogYGxvZGFzaCBtb2Rlcm4gbW9kdWxhcml6ZSBleHBvcnRzPVxcXCJucG1cXFwiIC1vIC4vYFxcbiAqIENvcHlyaWdodCAyMDEyLTIwMTUgVGhlIERvam8gRm91bmRhdGlvbiA8aHR0cDovL2Rvam9mb3VuZGF0aW9uLm9yZy8+XFxuICogQmFzZWQgb24gVW5kZXJzY29yZS5qcyAxLjguMyA8aHR0cDovL3VuZGVyc2NvcmVqcy5vcmcvTElDRU5TRT5cXG4gKiBDb3B5cmlnaHQgMjAwOS0yMDE1IEplcmVteSBBc2hrZW5hcywgRG9jdW1lbnRDbG91ZCBhbmQgSW52ZXN0aWdhdGl2ZSBSZXBvcnRlcnMgJiBFZGl0b3JzXFxuICogQXZhaWxhYmxlIHVuZGVyIE1JVCBsaWNlbnNlIDxodHRwczovL2xvZGFzaC5jb20vbGljZW5zZT5cXG4gKi9cXG52YXIgYmFzZUNvcHkgPSByZXF1aXJlKCdsb2Rhc2guX2Jhc2Vjb3B5JyksXFxuICAgIGtleXMgPSByZXF1aXJlKCdsb2Rhc2gua2V5cycpO1xcblxcbi8qKlxcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmFzc2lnbmAgd2l0aG91dCBzdXBwb3J0IGZvciBhcmd1bWVudCBqdWdnbGluZyxcXG4gKiBtdWx0aXBsZSBzb3VyY2VzLCBhbmQgYGN1c3RvbWl6ZXJgIGZ1bmN0aW9ucy5cXG4gKlxcbiAqIEBwcml2YXRlXFxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxcbiAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIHNvdXJjZSBvYmplY3QuXFxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cXG4gKi9cXG5mdW5jdGlvbiBiYXNlQXNzaWduKG9iamVjdCwgc291cmNlKSB7XFxuICByZXR1cm4gc291cmNlID09IG51bGxcXG4gICAgPyBvYmplY3RcXG4gICAgOiBiYXNlQ29weShzb3VyY2UsIGtleXMoc291cmNlKSwgb2JqZWN0KTtcXG59XFxuXFxubW9kdWxlLmV4cG9ydHMgPSBiYXNlQXNzaWduO1xcblxcbn0se1xcXCJsb2Rhc2guX2Jhc2Vjb3B5XFxcIjo3MSxcXFwibG9kYXNoLmtleXNcXFwiOjc4fV0sNzE6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xcbi8qKlxcbiAqIGxvZGFzaCAzLjAuMSAoQ3VzdG9tIEJ1aWxkKSA8aHR0cHM6Ly9sb2Rhc2guY29tLz5cXG4gKiBCdWlsZDogYGxvZGFzaCBtb2Rlcm4gbW9kdWxhcml6ZSBleHBvcnRzPVxcXCJucG1cXFwiIC1vIC4vYFxcbiAqIENvcHlyaWdodCAyMDEyLTIwMTUgVGhlIERvam8gRm91bmRhdGlvbiA8aHR0cDovL2Rvam9mb3VuZGF0aW9uLm9yZy8+XFxuICogQmFzZWQgb24gVW5kZXJzY29yZS5qcyAxLjguMyA8aHR0cDovL3VuZGVyc2NvcmVqcy5vcmcvTElDRU5TRT5cXG4gKiBDb3B5cmlnaHQgMjAwOS0yMDE1IEplcmVteSBBc2hrZW5hcywgRG9jdW1lbnRDbG91ZCBhbmQgSW52ZXN0aWdhdGl2ZSBSZXBvcnRlcnMgJiBFZGl0b3JzXFxuICogQXZhaWxhYmxlIHVuZGVyIE1JVCBsaWNlbnNlIDxodHRwczovL2xvZGFzaC5jb20vbGljZW5zZT5cXG4gKi9cXG5cXG4vKipcXG4gKiBDb3BpZXMgcHJvcGVydGllcyBvZiBgc291cmNlYCB0byBgb2JqZWN0YC5cXG4gKlxcbiAqIEBwcml2YXRlXFxuICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgb2JqZWN0IHRvIGNvcHkgcHJvcGVydGllcyBmcm9tLlxcbiAqIEBwYXJhbSB7QXJyYXl9IHByb3BzIFRoZSBwcm9wZXJ0eSBuYW1lcyB0byBjb3B5LlxcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0PXt9XSBUaGUgb2JqZWN0IHRvIGNvcHkgcHJvcGVydGllcyB0by5cXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxcbiAqL1xcbmZ1bmN0aW9uIGJhc2VDb3B5KHNvdXJjZSwgcHJvcHMsIG9iamVjdCkge1xcbiAgb2JqZWN0IHx8IChvYmplY3QgPSB7fSk7XFxuXFxuICB2YXIgaW5kZXggPSAtMSxcXG4gICAgICBsZW5ndGggPSBwcm9wcy5sZW5ndGg7XFxuXFxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xcbiAgICB2YXIga2V5ID0gcHJvcHNbaW5kZXhdO1xcbiAgICBvYmplY3Rba2V5XSA9IHNvdXJjZVtrZXldO1xcbiAgfVxcbiAgcmV0dXJuIG9iamVjdDtcXG59XFxuXFxubW9kdWxlLmV4cG9ydHMgPSBiYXNlQ29weTtcXG5cXG59LHt9XSw3MjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XFxuLyoqXFxuICogbG9kYXNoIDMuMC4zIChDdXN0b20gQnVpbGQpIDxodHRwczovL2xvZGFzaC5jb20vPlxcbiAqIEJ1aWxkOiBgbG9kYXNoIG1vZGVybiBtb2R1bGFyaXplIGV4cG9ydHM9XFxcIm5wbVxcXCIgLW8gLi9gXFxuICogQ29weXJpZ2h0IDIwMTItMjAxNSBUaGUgRG9qbyBGb3VuZGF0aW9uIDxodHRwOi8vZG9qb2ZvdW5kYXRpb24ub3JnLz5cXG4gKiBCYXNlZCBvbiBVbmRlcnNjb3JlLmpzIDEuOC4zIDxodHRwOi8vdW5kZXJzY29yZWpzLm9yZy9MSUNFTlNFPlxcbiAqIENvcHlyaWdodCAyMDA5LTIwMTUgSmVyZW15IEFzaGtlbmFzLCBEb2N1bWVudENsb3VkIGFuZCBJbnZlc3RpZ2F0aXZlIFJlcG9ydGVycyAmIEVkaXRvcnNcXG4gKiBBdmFpbGFibGUgdW5kZXIgTUlUIGxpY2Vuc2UgPGh0dHBzOi8vbG9kYXNoLmNvbS9saWNlbnNlPlxcbiAqL1xcblxcbi8qKlxcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmNyZWF0ZWAgd2l0aG91dCBzdXBwb3J0IGZvciBhc3NpZ25pbmdcXG4gKiBwcm9wZXJ0aWVzIHRvIHRoZSBjcmVhdGVkIG9iamVjdC5cXG4gKlxcbiAqIEBwcml2YXRlXFxuICogQHBhcmFtIHtPYmplY3R9IHByb3RvdHlwZSBUaGUgb2JqZWN0IHRvIGluaGVyaXQgZnJvbS5cXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgb2JqZWN0LlxcbiAqL1xcbnZhciBiYXNlQ3JlYXRlID0gKGZ1bmN0aW9uKCkge1xcbiAgZnVuY3Rpb24gb2JqZWN0KCkge31cXG4gIHJldHVybiBmdW5jdGlvbihwcm90b3R5cGUpIHtcXG4gICAgaWYgKGlzT2JqZWN0KHByb3RvdHlwZSkpIHtcXG4gICAgICBvYmplY3QucHJvdG90eXBlID0gcHJvdG90eXBlO1xcbiAgICAgIHZhciByZXN1bHQgPSBuZXcgb2JqZWN0O1xcbiAgICAgIG9iamVjdC5wcm90b3R5cGUgPSB1bmRlZmluZWQ7XFxuICAgIH1cXG4gICAgcmV0dXJuIHJlc3VsdCB8fCB7fTtcXG4gIH07XFxufSgpKTtcXG5cXG4vKipcXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyB0aGUgW2xhbmd1YWdlIHR5cGVdKGh0dHBzOi8vZXM1LmdpdGh1Yi5pby8jeDgpIG9mIGBPYmplY3RgLlxcbiAqIChlLmcuIGFycmF5cywgZnVuY3Rpb25zLCBvYmplY3RzLCByZWdleGVzLCBgbmV3IE51bWJlcigwKWAsIGFuZCBgbmV3IFN0cmluZygnJylgKVxcbiAqXFxuICogQHN0YXRpY1xcbiAqIEBtZW1iZXJPZiBfXFxuICogQGNhdGVnb3J5IExhbmdcXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cXG4gKiBAZXhhbXBsZVxcbiAqXFxuICogXy5pc09iamVjdCh7fSk7XFxuICogLy8gPT4gdHJ1ZVxcbiAqXFxuICogXy5pc09iamVjdChbMSwgMiwgM10pO1xcbiAqIC8vID0+IHRydWVcXG4gKlxcbiAqIF8uaXNPYmplY3QoMSk7XFxuICogLy8gPT4gZmFsc2VcXG4gKi9cXG5mdW5jdGlvbiBpc09iamVjdCh2YWx1ZSkge1xcbiAgLy8gQXZvaWQgYSBWOCBKSVQgYnVnIGluIENocm9tZSAxOS0yMC5cXG4gIC8vIFNlZSBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9MjI5MSBmb3IgbW9yZSBkZXRhaWxzLlxcbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XFxuICByZXR1cm4gISF2YWx1ZSAmJiAodHlwZSA9PSAnb2JqZWN0JyB8fCB0eXBlID09ICdmdW5jdGlvbicpO1xcbn1cXG5cXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VDcmVhdGU7XFxuXFxufSx7fV0sNzM6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xcbi8qKlxcbiAqIGxvZGFzaCAzLjkuMSAoQ3VzdG9tIEJ1aWxkKSA8aHR0cHM6Ly9sb2Rhc2guY29tLz5cXG4gKiBCdWlsZDogYGxvZGFzaCBtb2Rlcm4gbW9kdWxhcml6ZSBleHBvcnRzPVxcXCJucG1cXFwiIC1vIC4vYFxcbiAqIENvcHlyaWdodCAyMDEyLTIwMTUgVGhlIERvam8gRm91bmRhdGlvbiA8aHR0cDovL2Rvam9mb3VuZGF0aW9uLm9yZy8+XFxuICogQmFzZWQgb24gVW5kZXJzY29yZS5qcyAxLjguMyA8aHR0cDovL3VuZGVyc2NvcmVqcy5vcmcvTElDRU5TRT5cXG4gKiBDb3B5cmlnaHQgMjAwOS0yMDE1IEplcmVteSBBc2hrZW5hcywgRG9jdW1lbnRDbG91ZCBhbmQgSW52ZXN0aWdhdGl2ZSBSZXBvcnRlcnMgJiBFZGl0b3JzXFxuICogQXZhaWxhYmxlIHVuZGVyIE1JVCBsaWNlbnNlIDxodHRwczovL2xvZGFzaC5jb20vbGljZW5zZT5cXG4gKi9cXG5cXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXFxudmFyIGZ1bmNUYWcgPSAnW29iamVjdCBGdW5jdGlvbl0nO1xcblxcbi8qKiBVc2VkIHRvIGRldGVjdCBob3N0IGNvbnN0cnVjdG9ycyAoU2FmYXJpID4gNSkuICovXFxudmFyIHJlSXNIb3N0Q3RvciA9IC9eXFxcXFtvYmplY3QgLis/Q29uc3RydWN0b3JcXFxcXSQvO1xcblxcbi8qKlxcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLlxcbiAqXFxuICogQHByaXZhdGVcXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBvYmplY3QtbGlrZSwgZWxzZSBgZmFsc2VgLlxcbiAqL1xcbmZ1bmN0aW9uIGlzT2JqZWN0TGlrZSh2YWx1ZSkge1xcbiAgcmV0dXJuICEhdmFsdWUgJiYgdHlwZW9mIHZhbHVlID09ICdvYmplY3QnO1xcbn1cXG5cXG4vKiogVXNlZCBmb3IgbmF0aXZlIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xcbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XFxuXFxuLyoqIFVzZWQgdG8gcmVzb2x2ZSB0aGUgZGVjb21waWxlZCBzb3VyY2Ugb2YgZnVuY3Rpb25zLiAqL1xcbnZhciBmblRvU3RyaW5nID0gRnVuY3Rpb24ucHJvdG90eXBlLnRvU3RyaW5nO1xcblxcbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xcbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xcblxcbi8qKlxcbiAqIFVzZWQgdG8gcmVzb2x2ZSB0aGUgW2B0b1N0cmluZ1RhZ2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzYuMC8jc2VjLW9iamVjdC5wcm90b3R5cGUudG9zdHJpbmcpXFxuICogb2YgdmFsdWVzLlxcbiAqL1xcbnZhciBvYmpUb1N0cmluZyA9IG9iamVjdFByb3RvLnRvU3RyaW5nO1xcblxcbi8qKiBVc2VkIHRvIGRldGVjdCBpZiBhIG1ldGhvZCBpcyBuYXRpdmUuICovXFxudmFyIHJlSXNOYXRpdmUgPSBSZWdFeHAoJ14nICtcXG4gIGZuVG9TdHJpbmcuY2FsbChoYXNPd25Qcm9wZXJ0eSkucmVwbGFjZSgvW1xcXFxcXFxcXiQuKis/KClbXFxcXF17fXxdL2csICdcXFxcXFxcXCQmJylcXG4gIC5yZXBsYWNlKC9oYXNPd25Qcm9wZXJ0eXwoZnVuY3Rpb24pLio/KD89XFxcXFxcXFxcXFxcKCl8IGZvciAuKz8oPz1cXFxcXFxcXFxcXFxdKS9nLCAnJDEuKj8nKSArICckJ1xcbik7XFxuXFxuLyoqXFxuICogR2V0cyB0aGUgbmF0aXZlIGZ1bmN0aW9uIGF0IGBrZXlgIG9mIGBvYmplY3RgLlxcbiAqXFxuICogQHByaXZhdGVcXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXFxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBtZXRob2QgdG8gZ2V0LlxcbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBmdW5jdGlvbiBpZiBpdCdzIG5hdGl2ZSwgZWxzZSBgdW5kZWZpbmVkYC5cXG4gKi9cXG5mdW5jdGlvbiBnZXROYXRpdmUob2JqZWN0LCBrZXkpIHtcXG4gIHZhciB2YWx1ZSA9IG9iamVjdCA9PSBudWxsID8gdW5kZWZpbmVkIDogb2JqZWN0W2tleV07XFxuICByZXR1cm4gaXNOYXRpdmUodmFsdWUpID8gdmFsdWUgOiB1bmRlZmluZWQ7XFxufVxcblxcbi8qKlxcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgRnVuY3Rpb25gIG9iamVjdC5cXG4gKlxcbiAqIEBzdGF0aWNcXG4gKiBAbWVtYmVyT2YgX1xcbiAqIEBjYXRlZ29yeSBMYW5nXFxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXFxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgY29ycmVjdGx5IGNsYXNzaWZpZWQsIGVsc2UgYGZhbHNlYC5cXG4gKiBAZXhhbXBsZVxcbiAqXFxuICogXy5pc0Z1bmN0aW9uKF8pO1xcbiAqIC8vID0+IHRydWVcXG4gKlxcbiAqIF8uaXNGdW5jdGlvbigvYWJjLyk7XFxuICogLy8gPT4gZmFsc2VcXG4gKi9cXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKHZhbHVlKSB7XFxuICAvLyBUaGUgdXNlIG9mIGBPYmplY3QjdG9TdHJpbmdgIGF2b2lkcyBpc3N1ZXMgd2l0aCB0aGUgYHR5cGVvZmAgb3BlcmF0b3JcXG4gIC8vIGluIG9sZGVyIHZlcnNpb25zIG9mIENocm9tZSBhbmQgU2FmYXJpIHdoaWNoIHJldHVybiAnZnVuY3Rpb24nIGZvciByZWdleGVzXFxuICAvLyBhbmQgU2FmYXJpIDggZXF1aXZhbGVudHMgd2hpY2ggcmV0dXJuICdvYmplY3QnIGZvciB0eXBlZCBhcnJheSBjb25zdHJ1Y3RvcnMuXFxuICByZXR1cm4gaXNPYmplY3QodmFsdWUpICYmIG9ialRvU3RyaW5nLmNhbGwodmFsdWUpID09IGZ1bmNUYWc7XFxufVxcblxcbi8qKlxcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIHRoZSBbbGFuZ3VhZ2UgdHlwZV0oaHR0cHM6Ly9lczUuZ2l0aHViLmlvLyN4OCkgb2YgYE9iamVjdGAuXFxuICogKGUuZy4gYXJyYXlzLCBmdW5jdGlvbnMsIG9iamVjdHMsIHJlZ2V4ZXMsIGBuZXcgTnVtYmVyKDApYCwgYW5kIGBuZXcgU3RyaW5nKCcnKWApXFxuICpcXG4gKiBAc3RhdGljXFxuICogQG1lbWJlck9mIF9cXG4gKiBAY2F0ZWdvcnkgTGFuZ1xcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxcbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxcbiAqIEBleGFtcGxlXFxuICpcXG4gKiBfLmlzT2JqZWN0KHt9KTtcXG4gKiAvLyA9PiB0cnVlXFxuICpcXG4gKiBfLmlzT2JqZWN0KFsxLCAyLCAzXSk7XFxuICogLy8gPT4gdHJ1ZVxcbiAqXFxuICogXy5pc09iamVjdCgxKTtcXG4gKiAvLyA9PiBmYWxzZVxcbiAqL1xcbmZ1bmN0aW9uIGlzT2JqZWN0KHZhbHVlKSB7XFxuICAvLyBBdm9pZCBhIFY4IEpJVCBidWcgaW4gQ2hyb21lIDE5LTIwLlxcbiAgLy8gU2VlIGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvdjgvaXNzdWVzL2RldGFpbD9pZD0yMjkxIGZvciBtb3JlIGRldGFpbHMuXFxuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcXG4gIHJldHVybiAhIXZhbHVlICYmICh0eXBlID09ICdvYmplY3QnIHx8IHR5cGUgPT0gJ2Z1bmN0aW9uJyk7XFxufVxcblxcbi8qKlxcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgbmF0aXZlIGZ1bmN0aW9uLlxcbiAqXFxuICogQHN0YXRpY1xcbiAqIEBtZW1iZXJPZiBfXFxuICogQGNhdGVnb3J5IExhbmdcXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIG5hdGl2ZSBmdW5jdGlvbiwgZWxzZSBgZmFsc2VgLlxcbiAqIEBleGFtcGxlXFxuICpcXG4gKiBfLmlzTmF0aXZlKEFycmF5LnByb3RvdHlwZS5wdXNoKTtcXG4gKiAvLyA9PiB0cnVlXFxuICpcXG4gKiBfLmlzTmF0aXZlKF8pO1xcbiAqIC8vID0+IGZhbHNlXFxuICovXFxuZnVuY3Rpb24gaXNOYXRpdmUodmFsdWUpIHtcXG4gIGlmICh2YWx1ZSA9PSBudWxsKSB7XFxuICAgIHJldHVybiBmYWxzZTtcXG4gIH1cXG4gIGlmIChpc0Z1bmN0aW9uKHZhbHVlKSkge1xcbiAgICByZXR1cm4gcmVJc05hdGl2ZS50ZXN0KGZuVG9TdHJpbmcuY2FsbCh2YWx1ZSkpO1xcbiAgfVxcbiAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgcmVJc0hvc3RDdG9yLnRlc3QodmFsdWUpO1xcbn1cXG5cXG5tb2R1bGUuZXhwb3J0cyA9IGdldE5hdGl2ZTtcXG5cXG59LHt9XSw3NDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XFxuLyoqXFxuICogbG9kYXNoIDMuMC45IChDdXN0b20gQnVpbGQpIDxodHRwczovL2xvZGFzaC5jb20vPlxcbiAqIEJ1aWxkOiBgbG9kYXNoIG1vZGVybiBtb2R1bGFyaXplIGV4cG9ydHM9XFxcIm5wbVxcXCIgLW8gLi9gXFxuICogQ29weXJpZ2h0IDIwMTItMjAxNSBUaGUgRG9qbyBGb3VuZGF0aW9uIDxodHRwOi8vZG9qb2ZvdW5kYXRpb24ub3JnLz5cXG4gKiBCYXNlZCBvbiBVbmRlcnNjb3JlLmpzIDEuOC4zIDxodHRwOi8vdW5kZXJzY29yZWpzLm9yZy9MSUNFTlNFPlxcbiAqIENvcHlyaWdodCAyMDA5LTIwMTUgSmVyZW15IEFzaGtlbmFzLCBEb2N1bWVudENsb3VkIGFuZCBJbnZlc3RpZ2F0aXZlIFJlcG9ydGVycyAmIEVkaXRvcnNcXG4gKiBBdmFpbGFibGUgdW5kZXIgTUlUIGxpY2Vuc2UgPGh0dHBzOi8vbG9kYXNoLmNvbS9saWNlbnNlPlxcbiAqL1xcblxcbi8qKiBVc2VkIHRvIGRldGVjdCB1bnNpZ25lZCBpbnRlZ2VyIHZhbHVlcy4gKi9cXG52YXIgcmVJc1VpbnQgPSAvXlxcXFxkKyQvO1xcblxcbi8qKlxcbiAqIFVzZWQgYXMgdGhlIFttYXhpbXVtIGxlbmd0aF0oaHR0cHM6Ly9wZW9wbGUubW96aWxsYS5vcmcvfmpvcmVuZG9yZmYvZXM2LWRyYWZ0Lmh0bWwjc2VjLW51bWJlci5tYXhfc2FmZV9pbnRlZ2VyKVxcbiAqIG9mIGFuIGFycmF5LWxpa2UgdmFsdWUuXFxuICovXFxudmFyIE1BWF9TQUZFX0lOVEVHRVIgPSA5MDA3MTk5MjU0NzQwOTkxO1xcblxcbi8qKlxcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnByb3BlcnR5YCB3aXRob3V0IHN1cHBvcnQgZm9yIGRlZXAgcGF0aHMuXFxuICpcXG4gKiBAcHJpdmF0ZVxcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxcbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxcbiAqL1xcbmZ1bmN0aW9uIGJhc2VQcm9wZXJ0eShrZXkpIHtcXG4gIHJldHVybiBmdW5jdGlvbihvYmplY3QpIHtcXG4gICAgcmV0dXJuIG9iamVjdCA9PSBudWxsID8gdW5kZWZpbmVkIDogb2JqZWN0W2tleV07XFxuICB9O1xcbn1cXG5cXG4vKipcXG4gKiBHZXRzIHRoZSBcXFwibGVuZ3RoXFxcIiBwcm9wZXJ0eSB2YWx1ZSBvZiBgb2JqZWN0YC5cXG4gKlxcbiAqICoqTm90ZToqKiBUaGlzIGZ1bmN0aW9uIGlzIHVzZWQgdG8gYXZvaWQgYSBbSklUIGJ1Z10oaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTE0Mjc5MilcXG4gKiB0aGF0IGFmZmVjdHMgU2FmYXJpIG9uIGF0IGxlYXN0IGlPUyA4LjEtOC4zIEFSTTY0LlxcbiAqXFxuICogQHByaXZhdGVcXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXFxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIFxcXCJsZW5ndGhcXFwiIHZhbHVlLlxcbiAqL1xcbnZhciBnZXRMZW5ndGggPSBiYXNlUHJvcGVydHkoJ2xlbmd0aCcpO1xcblxcbi8qKlxcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGFycmF5LWxpa2UuXFxuICpcXG4gKiBAcHJpdmF0ZVxcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxcbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFycmF5LWxpa2UsIGVsc2UgYGZhbHNlYC5cXG4gKi9cXG5mdW5jdGlvbiBpc0FycmF5TGlrZSh2YWx1ZSkge1xcbiAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgaXNMZW5ndGgoZ2V0TGVuZ3RoKHZhbHVlKSk7XFxufVxcblxcbi8qKlxcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgYXJyYXktbGlrZSBpbmRleC5cXG4gKlxcbiAqIEBwcml2YXRlXFxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXFxuICogQHBhcmFtIHtudW1iZXJ9IFtsZW5ndGg9TUFYX1NBRkVfSU5URUdFUl0gVGhlIHVwcGVyIGJvdW5kcyBvZiBhIHZhbGlkIGluZGV4LlxcbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgaW5kZXgsIGVsc2UgYGZhbHNlYC5cXG4gKi9cXG5mdW5jdGlvbiBpc0luZGV4KHZhbHVlLCBsZW5ndGgpIHtcXG4gIHZhbHVlID0gKHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJyB8fCByZUlzVWludC50ZXN0KHZhbHVlKSkgPyArdmFsdWUgOiAtMTtcXG4gIGxlbmd0aCA9IGxlbmd0aCA9PSBudWxsID8gTUFYX1NBRkVfSU5URUdFUiA6IGxlbmd0aDtcXG4gIHJldHVybiB2YWx1ZSA+IC0xICYmIHZhbHVlICUgMSA9PSAwICYmIHZhbHVlIDwgbGVuZ3RoO1xcbn1cXG5cXG4vKipcXG4gKiBDaGVja3MgaWYgdGhlIHByb3ZpZGVkIGFyZ3VtZW50cyBhcmUgZnJvbSBhbiBpdGVyYXRlZSBjYWxsLlxcbiAqXFxuICogQHByaXZhdGVcXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSBwb3RlbnRpYWwgaXRlcmF0ZWUgdmFsdWUgYXJndW1lbnQuXFxuICogQHBhcmFtIHsqfSBpbmRleCBUaGUgcG90ZW50aWFsIGl0ZXJhdGVlIGluZGV4IG9yIGtleSBhcmd1bWVudC5cXG4gKiBAcGFyYW0geyp9IG9iamVjdCBUaGUgcG90ZW50aWFsIGl0ZXJhdGVlIG9iamVjdCBhcmd1bWVudC5cXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGFyZ3VtZW50cyBhcmUgZnJvbSBhbiBpdGVyYXRlZSBjYWxsLCBlbHNlIGBmYWxzZWAuXFxuICovXFxuZnVuY3Rpb24gaXNJdGVyYXRlZUNhbGwodmFsdWUsIGluZGV4LCBvYmplY3QpIHtcXG4gIGlmICghaXNPYmplY3Qob2JqZWN0KSkge1xcbiAgICByZXR1cm4gZmFsc2U7XFxuICB9XFxuICB2YXIgdHlwZSA9IHR5cGVvZiBpbmRleDtcXG4gIGlmICh0eXBlID09ICdudW1iZXInXFxuICAgICAgPyAoaXNBcnJheUxpa2Uob2JqZWN0KSAmJiBpc0luZGV4KGluZGV4LCBvYmplY3QubGVuZ3RoKSlcXG4gICAgICA6ICh0eXBlID09ICdzdHJpbmcnICYmIGluZGV4IGluIG9iamVjdCkpIHtcXG4gICAgdmFyIG90aGVyID0gb2JqZWN0W2luZGV4XTtcXG4gICAgcmV0dXJuIHZhbHVlID09PSB2YWx1ZSA/ICh2YWx1ZSA9PT0gb3RoZXIpIDogKG90aGVyICE9PSBvdGhlcik7XFxuICB9XFxuICByZXR1cm4gZmFsc2U7XFxufVxcblxcbi8qKlxcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgYXJyYXktbGlrZSBsZW5ndGguXFxuICpcXG4gKiAqKk5vdGU6KiogVGhpcyBmdW5jdGlvbiBpcyBiYXNlZCBvbiBbYFRvTGVuZ3RoYF0oaHR0cHM6Ly9wZW9wbGUubW96aWxsYS5vcmcvfmpvcmVuZG9yZmYvZXM2LWRyYWZ0Lmh0bWwjc2VjLXRvbGVuZ3RoKS5cXG4gKlxcbiAqIEBwcml2YXRlXFxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXFxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBsZW5ndGgsIGVsc2UgYGZhbHNlYC5cXG4gKi9cXG5mdW5jdGlvbiBpc0xlbmd0aCh2YWx1ZSkge1xcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJyAmJiB2YWx1ZSA+IC0xICYmIHZhbHVlICUgMSA9PSAwICYmIHZhbHVlIDw9IE1BWF9TQUZFX0lOVEVHRVI7XFxufVxcblxcbi8qKlxcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIHRoZSBbbGFuZ3VhZ2UgdHlwZV0oaHR0cHM6Ly9lczUuZ2l0aHViLmlvLyN4OCkgb2YgYE9iamVjdGAuXFxuICogKGUuZy4gYXJyYXlzLCBmdW5jdGlvbnMsIG9iamVjdHMsIHJlZ2V4ZXMsIGBuZXcgTnVtYmVyKDApYCwgYW5kIGBuZXcgU3RyaW5nKCcnKWApXFxuICpcXG4gKiBAc3RhdGljXFxuICogQG1lbWJlck9mIF9cXG4gKiBAY2F0ZWdvcnkgTGFuZ1xcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxcbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxcbiAqIEBleGFtcGxlXFxuICpcXG4gKiBfLmlzT2JqZWN0KHt9KTtcXG4gKiAvLyA9PiB0cnVlXFxuICpcXG4gKiBfLmlzT2JqZWN0KFsxLCAyLCAzXSk7XFxuICogLy8gPT4gdHJ1ZVxcbiAqXFxuICogXy5pc09iamVjdCgxKTtcXG4gKiAvLyA9PiBmYWxzZVxcbiAqL1xcbmZ1bmN0aW9uIGlzT2JqZWN0KHZhbHVlKSB7XFxuICAvLyBBdm9pZCBhIFY4IEpJVCBidWcgaW4gQ2hyb21lIDE5LTIwLlxcbiAgLy8gU2VlIGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvdjgvaXNzdWVzL2RldGFpbD9pZD0yMjkxIGZvciBtb3JlIGRldGFpbHMuXFxuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcXG4gIHJldHVybiAhIXZhbHVlICYmICh0eXBlID09ICdvYmplY3QnIHx8IHR5cGUgPT0gJ2Z1bmN0aW9uJyk7XFxufVxcblxcbm1vZHVsZS5leHBvcnRzID0gaXNJdGVyYXRlZUNhbGw7XFxuXFxufSx7fV0sNzU6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xcbi8qKlxcbiAqIGxvZGFzaCAzLjEuMSAoQ3VzdG9tIEJ1aWxkKSA8aHR0cHM6Ly9sb2Rhc2guY29tLz5cXG4gKiBCdWlsZDogYGxvZGFzaCBtb2Rlcm4gbW9kdWxhcml6ZSBleHBvcnRzPVxcXCJucG1cXFwiIC1vIC4vYFxcbiAqIENvcHlyaWdodCAyMDEyLTIwMTUgVGhlIERvam8gRm91bmRhdGlvbiA8aHR0cDovL2Rvam9mb3VuZGF0aW9uLm9yZy8+XFxuICogQmFzZWQgb24gVW5kZXJzY29yZS5qcyAxLjguMyA8aHR0cDovL3VuZGVyc2NvcmVqcy5vcmcvTElDRU5TRT5cXG4gKiBDb3B5cmlnaHQgMjAwOS0yMDE1IEplcmVteSBBc2hrZW5hcywgRG9jdW1lbnRDbG91ZCBhbmQgSW52ZXN0aWdhdGl2ZSBSZXBvcnRlcnMgJiBFZGl0b3JzXFxuICogQXZhaWxhYmxlIHVuZGVyIE1JVCBsaWNlbnNlIDxodHRwczovL2xvZGFzaC5jb20vbGljZW5zZT5cXG4gKi9cXG52YXIgYmFzZUFzc2lnbiA9IHJlcXVpcmUoJ2xvZGFzaC5fYmFzZWFzc2lnbicpLFxcbiAgICBiYXNlQ3JlYXRlID0gcmVxdWlyZSgnbG9kYXNoLl9iYXNlY3JlYXRlJyksXFxuICAgIGlzSXRlcmF0ZWVDYWxsID0gcmVxdWlyZSgnbG9kYXNoLl9pc2l0ZXJhdGVlY2FsbCcpO1xcblxcbi8qKlxcbiAqIENyZWF0ZXMgYW4gb2JqZWN0IHRoYXQgaW5oZXJpdHMgZnJvbSB0aGUgZ2l2ZW4gYHByb3RvdHlwZWAgb2JqZWN0LiBJZiBhXFxuICogYHByb3BlcnRpZXNgIG9iamVjdCBpcyBwcm92aWRlZCBpdHMgb3duIGVudW1lcmFibGUgcHJvcGVydGllcyBhcmUgYXNzaWduZWRcXG4gKiB0byB0aGUgY3JlYXRlZCBvYmplY3QuXFxuICpcXG4gKiBAc3RhdGljXFxuICogQG1lbWJlck9mIF9cXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XFxuICogQHBhcmFtIHtPYmplY3R9IHByb3RvdHlwZSBUaGUgb2JqZWN0IHRvIGluaGVyaXQgZnJvbS5cXG4gKiBAcGFyYW0ge09iamVjdH0gW3Byb3BlcnRpZXNdIFRoZSBwcm9wZXJ0aWVzIHRvIGFzc2lnbiB0byB0aGUgb2JqZWN0LlxcbiAqIEBwYXJhbS0ge09iamVjdH0gW2d1YXJkXSBFbmFibGVzIHVzZSBhcyBhIGNhbGxiYWNrIGZvciBmdW5jdGlvbnMgbGlrZSBgXy5tYXBgLlxcbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBvYmplY3QuXFxuICogQGV4YW1wbGVcXG4gKlxcbiAqIGZ1bmN0aW9uIFNoYXBlKCkge1xcbiAqICAgdGhpcy54ID0gMDtcXG4gKiAgIHRoaXMueSA9IDA7XFxuICogfVxcbiAqXFxuICogZnVuY3Rpb24gQ2lyY2xlKCkge1xcbiAqICAgU2hhcGUuY2FsbCh0aGlzKTtcXG4gKiB9XFxuICpcXG4gKiBDaXJjbGUucHJvdG90eXBlID0gXy5jcmVhdGUoU2hhcGUucHJvdG90eXBlLCB7XFxuICogICAnY29uc3RydWN0b3InOiBDaXJjbGVcXG4gKiB9KTtcXG4gKlxcbiAqIHZhciBjaXJjbGUgPSBuZXcgQ2lyY2xlO1xcbiAqIGNpcmNsZSBpbnN0YW5jZW9mIENpcmNsZTtcXG4gKiAvLyA9PiB0cnVlXFxuICpcXG4gKiBjaXJjbGUgaW5zdGFuY2VvZiBTaGFwZTtcXG4gKiAvLyA9PiB0cnVlXFxuICovXFxuZnVuY3Rpb24gY3JlYXRlKHByb3RvdHlwZSwgcHJvcGVydGllcywgZ3VhcmQpIHtcXG4gIHZhciByZXN1bHQgPSBiYXNlQ3JlYXRlKHByb3RvdHlwZSk7XFxuICBpZiAoZ3VhcmQgJiYgaXNJdGVyYXRlZUNhbGwocHJvdG90eXBlLCBwcm9wZXJ0aWVzLCBndWFyZCkpIHtcXG4gICAgcHJvcGVydGllcyA9IHVuZGVmaW5lZDtcXG4gIH1cXG4gIHJldHVybiBwcm9wZXJ0aWVzID8gYmFzZUFzc2lnbihyZXN1bHQsIHByb3BlcnRpZXMpIDogcmVzdWx0O1xcbn1cXG5cXG5tb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZTtcXG5cXG59LHtcXFwibG9kYXNoLl9iYXNlYXNzaWduXFxcIjo3MCxcXFwibG9kYXNoLl9iYXNlY3JlYXRlXFxcIjo3MixcXFwibG9kYXNoLl9pc2l0ZXJhdGVlY2FsbFxcXCI6NzR9XSw3NjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XFxuLyoqXFxuICogbG9kYXNoIChDdXN0b20gQnVpbGQpIDxodHRwczovL2xvZGFzaC5jb20vPlxcbiAqIEJ1aWxkOiBgbG9kYXNoIG1vZHVsYXJpemUgZXhwb3J0cz1cXFwibnBtXFxcIiAtbyAuL2BcXG4gKiBDb3B5cmlnaHQgalF1ZXJ5IEZvdW5kYXRpb24gYW5kIG90aGVyIGNvbnRyaWJ1dG9ycyA8aHR0cHM6Ly9qcXVlcnkub3JnLz5cXG4gKiBSZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZSA8aHR0cHM6Ly9sb2Rhc2guY29tL2xpY2Vuc2U+XFxuICogQmFzZWQgb24gVW5kZXJzY29yZS5qcyAxLjguMyA8aHR0cDovL3VuZGVyc2NvcmVqcy5vcmcvTElDRU5TRT5cXG4gKiBDb3B5cmlnaHQgSmVyZW15IEFzaGtlbmFzLCBEb2N1bWVudENsb3VkIGFuZCBJbnZlc3RpZ2F0aXZlIFJlcG9ydGVycyAmIEVkaXRvcnNcXG4gKi9cXG5cXG4vKiogVXNlZCBhcyByZWZlcmVuY2VzIGZvciB2YXJpb3VzIGBOdW1iZXJgIGNvbnN0YW50cy4gKi9cXG52YXIgTUFYX1NBRkVfSU5URUdFUiA9IDkwMDcxOTkyNTQ3NDA5OTE7XFxuXFxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xcbnZhciBhcmdzVGFnID0gJ1tvYmplY3QgQXJndW1lbnRzXScsXFxuICAgIGZ1bmNUYWcgPSAnW29iamVjdCBGdW5jdGlvbl0nLFxcbiAgICBnZW5UYWcgPSAnW29iamVjdCBHZW5lcmF0b3JGdW5jdGlvbl0nO1xcblxcbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xcblxcbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xcbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xcblxcbi8qKlxcbiAqIFVzZWQgdG8gcmVzb2x2ZSB0aGVcXG4gKiBbYHRvU3RyaW5nVGFnYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LnByb3RvdHlwZS50b3N0cmluZylcXG4gKiBvZiB2YWx1ZXMuXFxuICovXFxudmFyIG9iamVjdFRvU3RyaW5nID0gb2JqZWN0UHJvdG8udG9TdHJpbmc7XFxuXFxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXFxudmFyIHByb3BlcnR5SXNFbnVtZXJhYmxlID0gb2JqZWN0UHJvdG8ucHJvcGVydHlJc0VudW1lcmFibGU7XFxuXFxuLyoqXFxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgbGlrZWx5IGFuIGBhcmd1bWVudHNgIG9iamVjdC5cXG4gKlxcbiAqIEBzdGF0aWNcXG4gKiBAbWVtYmVyT2YgX1xcbiAqIEBzaW5jZSAwLjEuMFxcbiAqIEBjYXRlZ29yeSBMYW5nXFxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXFxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYGFyZ3VtZW50c2Agb2JqZWN0LFxcbiAqICBlbHNlIGBmYWxzZWAuXFxuICogQGV4YW1wbGVcXG4gKlxcbiAqIF8uaXNBcmd1bWVudHMoZnVuY3Rpb24oKSB7IHJldHVybiBhcmd1bWVudHM7IH0oKSk7XFxuICogLy8gPT4gdHJ1ZVxcbiAqXFxuICogXy5pc0FyZ3VtZW50cyhbMSwgMiwgM10pO1xcbiAqIC8vID0+IGZhbHNlXFxuICovXFxuZnVuY3Rpb24gaXNBcmd1bWVudHModmFsdWUpIHtcXG4gIC8vIFNhZmFyaSA4LjEgbWFrZXMgYGFyZ3VtZW50cy5jYWxsZWVgIGVudW1lcmFibGUgaW4gc3RyaWN0IG1vZGUuXFxuICByZXR1cm4gaXNBcnJheUxpa2VPYmplY3QodmFsdWUpICYmIGhhc093blByb3BlcnR5LmNhbGwodmFsdWUsICdjYWxsZWUnKSAmJlxcbiAgICAoIXByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwodmFsdWUsICdjYWxsZWUnKSB8fCBvYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKSA9PSBhcmdzVGFnKTtcXG59XFxuXFxuLyoqXFxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYXJyYXktbGlrZS4gQSB2YWx1ZSBpcyBjb25zaWRlcmVkIGFycmF5LWxpa2UgaWYgaXQnc1xcbiAqIG5vdCBhIGZ1bmN0aW9uIGFuZCBoYXMgYSBgdmFsdWUubGVuZ3RoYCB0aGF0J3MgYW4gaW50ZWdlciBncmVhdGVyIHRoYW4gb3JcXG4gKiBlcXVhbCB0byBgMGAgYW5kIGxlc3MgdGhhbiBvciBlcXVhbCB0byBgTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVJgLlxcbiAqXFxuICogQHN0YXRpY1xcbiAqIEBtZW1iZXJPZiBfXFxuICogQHNpbmNlIDQuMC4wXFxuICogQGNhdGVnb3J5IExhbmdcXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhcnJheS1saWtlLCBlbHNlIGBmYWxzZWAuXFxuICogQGV4YW1wbGVcXG4gKlxcbiAqIF8uaXNBcnJheUxpa2UoWzEsIDIsIDNdKTtcXG4gKiAvLyA9PiB0cnVlXFxuICpcXG4gKiBfLmlzQXJyYXlMaWtlKGRvY3VtZW50LmJvZHkuY2hpbGRyZW4pO1xcbiAqIC8vID0+IHRydWVcXG4gKlxcbiAqIF8uaXNBcnJheUxpa2UoJ2FiYycpO1xcbiAqIC8vID0+IHRydWVcXG4gKlxcbiAqIF8uaXNBcnJheUxpa2UoXy5ub29wKTtcXG4gKiAvLyA9PiBmYWxzZVxcbiAqL1xcbmZ1bmN0aW9uIGlzQXJyYXlMaWtlKHZhbHVlKSB7XFxuICByZXR1cm4gdmFsdWUgIT0gbnVsbCAmJiBpc0xlbmd0aCh2YWx1ZS5sZW5ndGgpICYmICFpc0Z1bmN0aW9uKHZhbHVlKTtcXG59XFxuXFxuLyoqXFxuICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5pc0FycmF5TGlrZWAgZXhjZXB0IHRoYXQgaXQgYWxzbyBjaGVja3MgaWYgYHZhbHVlYFxcbiAqIGlzIGFuIG9iamVjdC5cXG4gKlxcbiAqIEBzdGF0aWNcXG4gKiBAbWVtYmVyT2YgX1xcbiAqIEBzaW5jZSA0LjAuMFxcbiAqIEBjYXRlZ29yeSBMYW5nXFxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXFxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYXJyYXktbGlrZSBvYmplY3QsXFxuICogIGVsc2UgYGZhbHNlYC5cXG4gKiBAZXhhbXBsZVxcbiAqXFxuICogXy5pc0FycmF5TGlrZU9iamVjdChbMSwgMiwgM10pO1xcbiAqIC8vID0+IHRydWVcXG4gKlxcbiAqIF8uaXNBcnJheUxpa2VPYmplY3QoZG9jdW1lbnQuYm9keS5jaGlsZHJlbik7XFxuICogLy8gPT4gdHJ1ZVxcbiAqXFxuICogXy5pc0FycmF5TGlrZU9iamVjdCgnYWJjJyk7XFxuICogLy8gPT4gZmFsc2VcXG4gKlxcbiAqIF8uaXNBcnJheUxpa2VPYmplY3QoXy5ub29wKTtcXG4gKiAvLyA9PiBmYWxzZVxcbiAqL1xcbmZ1bmN0aW9uIGlzQXJyYXlMaWtlT2JqZWN0KHZhbHVlKSB7XFxuICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBpc0FycmF5TGlrZSh2YWx1ZSk7XFxufVxcblxcbi8qKlxcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgRnVuY3Rpb25gIG9iamVjdC5cXG4gKlxcbiAqIEBzdGF0aWNcXG4gKiBAbWVtYmVyT2YgX1xcbiAqIEBzaW5jZSAwLjEuMFxcbiAqIEBjYXRlZ29yeSBMYW5nXFxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXFxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBmdW5jdGlvbiwgZWxzZSBgZmFsc2VgLlxcbiAqIEBleGFtcGxlXFxuICpcXG4gKiBfLmlzRnVuY3Rpb24oXyk7XFxuICogLy8gPT4gdHJ1ZVxcbiAqXFxuICogXy5pc0Z1bmN0aW9uKC9hYmMvKTtcXG4gKiAvLyA9PiBmYWxzZVxcbiAqL1xcbmZ1bmN0aW9uIGlzRnVuY3Rpb24odmFsdWUpIHtcXG4gIC8vIFRoZSB1c2Ugb2YgYE9iamVjdCN0b1N0cmluZ2AgYXZvaWRzIGlzc3VlcyB3aXRoIHRoZSBgdHlwZW9mYCBvcGVyYXRvclxcbiAgLy8gaW4gU2FmYXJpIDgtOSB3aGljaCByZXR1cm5zICdvYmplY3QnIGZvciB0eXBlZCBhcnJheSBhbmQgb3RoZXIgY29uc3RydWN0b3JzLlxcbiAgdmFyIHRhZyA9IGlzT2JqZWN0KHZhbHVlKSA/IG9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpIDogJyc7XFxuICByZXR1cm4gdGFnID09IGZ1bmNUYWcgfHwgdGFnID09IGdlblRhZztcXG59XFxuXFxuLyoqXFxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBhcnJheS1saWtlIGxlbmd0aC5cXG4gKlxcbiAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBpcyBsb29zZWx5IGJhc2VkIG9uXFxuICogW2BUb0xlbmd0aGBdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXRvbGVuZ3RoKS5cXG4gKlxcbiAqIEBzdGF0aWNcXG4gKiBAbWVtYmVyT2YgX1xcbiAqIEBzaW5jZSA0LjAuMFxcbiAqIEBjYXRlZ29yeSBMYW5nXFxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXFxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBsZW5ndGgsIGVsc2UgYGZhbHNlYC5cXG4gKiBAZXhhbXBsZVxcbiAqXFxuICogXy5pc0xlbmd0aCgzKTtcXG4gKiAvLyA9PiB0cnVlXFxuICpcXG4gKiBfLmlzTGVuZ3RoKE51bWJlci5NSU5fVkFMVUUpO1xcbiAqIC8vID0+IGZhbHNlXFxuICpcXG4gKiBfLmlzTGVuZ3RoKEluZmluaXR5KTtcXG4gKiAvLyA9PiBmYWxzZVxcbiAqXFxuICogXy5pc0xlbmd0aCgnMycpO1xcbiAqIC8vID0+IGZhbHNlXFxuICovXFxuZnVuY3Rpb24gaXNMZW5ndGgodmFsdWUpIHtcXG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ251bWJlcicgJiZcXG4gICAgdmFsdWUgPiAtMSAmJiB2YWx1ZSAlIDEgPT0gMCAmJiB2YWx1ZSA8PSBNQVhfU0FGRV9JTlRFR0VSO1xcbn1cXG5cXG4vKipcXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyB0aGVcXG4gKiBbbGFuZ3VhZ2UgdHlwZV0oaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLWVjbWFzY3JpcHQtbGFuZ3VhZ2UtdHlwZXMpXFxuICogb2YgYE9iamVjdGAuIChlLmcuIGFycmF5cywgZnVuY3Rpb25zLCBvYmplY3RzLCByZWdleGVzLCBgbmV3IE51bWJlcigwKWAsIGFuZCBgbmV3IFN0cmluZygnJylgKVxcbiAqXFxuICogQHN0YXRpY1xcbiAqIEBtZW1iZXJPZiBfXFxuICogQHNpbmNlIDAuMS4wXFxuICogQGNhdGVnb3J5IExhbmdcXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cXG4gKiBAZXhhbXBsZVxcbiAqXFxuICogXy5pc09iamVjdCh7fSk7XFxuICogLy8gPT4gdHJ1ZVxcbiAqXFxuICogXy5pc09iamVjdChbMSwgMiwgM10pO1xcbiAqIC8vID0+IHRydWVcXG4gKlxcbiAqIF8uaXNPYmplY3QoXy5ub29wKTtcXG4gKiAvLyA9PiB0cnVlXFxuICpcXG4gKiBfLmlzT2JqZWN0KG51bGwpO1xcbiAqIC8vID0+IGZhbHNlXFxuICovXFxuZnVuY3Rpb24gaXNPYmplY3QodmFsdWUpIHtcXG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xcbiAgcmV0dXJuICEhdmFsdWUgJiYgKHR5cGUgPT0gJ29iamVjdCcgfHwgdHlwZSA9PSAnZnVuY3Rpb24nKTtcXG59XFxuXFxuLyoqXFxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UuIEEgdmFsdWUgaXMgb2JqZWN0LWxpa2UgaWYgaXQncyBub3QgYG51bGxgXFxuICogYW5kIGhhcyBhIGB0eXBlb2ZgIHJlc3VsdCBvZiBcXFwib2JqZWN0XFxcIi5cXG4gKlxcbiAqIEBzdGF0aWNcXG4gKiBAbWVtYmVyT2YgX1xcbiAqIEBzaW5jZSA0LjAuMFxcbiAqIEBjYXRlZ29yeSBMYW5nXFxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXFxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UsIGVsc2UgYGZhbHNlYC5cXG4gKiBAZXhhbXBsZVxcbiAqXFxuICogXy5pc09iamVjdExpa2Uoe30pO1xcbiAqIC8vID0+IHRydWVcXG4gKlxcbiAqIF8uaXNPYmplY3RMaWtlKFsxLCAyLCAzXSk7XFxuICogLy8gPT4gdHJ1ZVxcbiAqXFxuICogXy5pc09iamVjdExpa2UoXy5ub29wKTtcXG4gKiAvLyA9PiBmYWxzZVxcbiAqXFxuICogXy5pc09iamVjdExpa2UobnVsbCk7XFxuICogLy8gPT4gZmFsc2VcXG4gKi9cXG5mdW5jdGlvbiBpc09iamVjdExpa2UodmFsdWUpIHtcXG4gIHJldHVybiAhIXZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0JztcXG59XFxuXFxubW9kdWxlLmV4cG9ydHMgPSBpc0FyZ3VtZW50cztcXG5cXG59LHt9XSw3NzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XFxuLyoqXFxuICogbG9kYXNoIDMuMC40IChDdXN0b20gQnVpbGQpIDxodHRwczovL2xvZGFzaC5jb20vPlxcbiAqIEJ1aWxkOiBgbG9kYXNoIG1vZGVybiBtb2R1bGFyaXplIGV4cG9ydHM9XFxcIm5wbVxcXCIgLW8gLi9gXFxuICogQ29weXJpZ2h0IDIwMTItMjAxNSBUaGUgRG9qbyBGb3VuZGF0aW9uIDxodHRwOi8vZG9qb2ZvdW5kYXRpb24ub3JnLz5cXG4gKiBCYXNlZCBvbiBVbmRlcnNjb3JlLmpzIDEuOC4zIDxodHRwOi8vdW5kZXJzY29yZWpzLm9yZy9MSUNFTlNFPlxcbiAqIENvcHlyaWdodCAyMDA5LTIwMTUgSmVyZW15IEFzaGtlbmFzLCBEb2N1bWVudENsb3VkIGFuZCBJbnZlc3RpZ2F0aXZlIFJlcG9ydGVycyAmIEVkaXRvcnNcXG4gKiBBdmFpbGFibGUgdW5kZXIgTUlUIGxpY2Vuc2UgPGh0dHBzOi8vbG9kYXNoLmNvbS9saWNlbnNlPlxcbiAqL1xcblxcbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cXG52YXIgYXJyYXlUYWcgPSAnW29iamVjdCBBcnJheV0nLFxcbiAgICBmdW5jVGFnID0gJ1tvYmplY3QgRnVuY3Rpb25dJztcXG5cXG4vKiogVXNlZCB0byBkZXRlY3QgaG9zdCBjb25zdHJ1Y3RvcnMgKFNhZmFyaSA+IDUpLiAqL1xcbnZhciByZUlzSG9zdEN0b3IgPSAvXlxcXFxbb2JqZWN0IC4rP0NvbnN0cnVjdG9yXFxcXF0kLztcXG5cXG4vKipcXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBvYmplY3QtbGlrZS5cXG4gKlxcbiAqIEBwcml2YXRlXFxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXFxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UsIGVsc2UgYGZhbHNlYC5cXG4gKi9cXG5mdW5jdGlvbiBpc09iamVjdExpa2UodmFsdWUpIHtcXG4gIHJldHVybiAhIXZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0JztcXG59XFxuXFxuLyoqIFVzZWQgZm9yIG5hdGl2ZSBtZXRob2QgcmVmZXJlbmNlcy4gKi9cXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xcblxcbi8qKiBVc2VkIHRvIHJlc29sdmUgdGhlIGRlY29tcGlsZWQgc291cmNlIG9mIGZ1bmN0aW9ucy4gKi9cXG52YXIgZm5Ub1N0cmluZyA9IEZ1bmN0aW9uLnByb3RvdHlwZS50b1N0cmluZztcXG5cXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcXG5cXG4vKipcXG4gKiBVc2VkIHRvIHJlc29sdmUgdGhlIFtgdG9TdHJpbmdUYWdgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi82LjAvI3NlYy1vYmplY3QucHJvdG90eXBlLnRvc3RyaW5nKVxcbiAqIG9mIHZhbHVlcy5cXG4gKi9cXG52YXIgb2JqVG9TdHJpbmcgPSBvYmplY3RQcm90by50b1N0cmluZztcXG5cXG4vKiogVXNlZCB0byBkZXRlY3QgaWYgYSBtZXRob2QgaXMgbmF0aXZlLiAqL1xcbnZhciByZUlzTmF0aXZlID0gUmVnRXhwKCdeJyArXFxuICBmblRvU3RyaW5nLmNhbGwoaGFzT3duUHJvcGVydHkpLnJlcGxhY2UoL1tcXFxcXFxcXF4kLiorPygpW1xcXFxde318XS9nLCAnXFxcXFxcXFwkJicpXFxuICAucmVwbGFjZSgvaGFzT3duUHJvcGVydHl8KGZ1bmN0aW9uKS4qPyg/PVxcXFxcXFxcXFxcXCgpfCBmb3IgLis/KD89XFxcXFxcXFxcXFxcXSkvZywgJyQxLio/JykgKyAnJCdcXG4pO1xcblxcbi8qIE5hdGl2ZSBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXFxudmFyIG5hdGl2ZUlzQXJyYXkgPSBnZXROYXRpdmUoQXJyYXksICdpc0FycmF5Jyk7XFxuXFxuLyoqXFxuICogVXNlZCBhcyB0aGUgW21heGltdW0gbGVuZ3RoXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi82LjAvI3NlYy1udW1iZXIubWF4X3NhZmVfaW50ZWdlcilcXG4gKiBvZiBhbiBhcnJheS1saWtlIHZhbHVlLlxcbiAqL1xcbnZhciBNQVhfU0FGRV9JTlRFR0VSID0gOTAwNzE5OTI1NDc0MDk5MTtcXG5cXG4vKipcXG4gKiBHZXRzIHRoZSBuYXRpdmUgZnVuY3Rpb24gYXQgYGtleWAgb2YgYG9iamVjdGAuXFxuICpcXG4gKiBAcHJpdmF0ZVxcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIG1ldGhvZCB0byBnZXQuXFxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGZ1bmN0aW9uIGlmIGl0J3MgbmF0aXZlLCBlbHNlIGB1bmRlZmluZWRgLlxcbiAqL1xcbmZ1bmN0aW9uIGdldE5hdGl2ZShvYmplY3QsIGtleSkge1xcbiAgdmFyIHZhbHVlID0gb2JqZWN0ID09IG51bGwgPyB1bmRlZmluZWQgOiBvYmplY3Rba2V5XTtcXG4gIHJldHVybiBpc05hdGl2ZSh2YWx1ZSkgPyB2YWx1ZSA6IHVuZGVmaW5lZDtcXG59XFxuXFxuLyoqXFxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBhcnJheS1saWtlIGxlbmd0aC5cXG4gKlxcbiAqICoqTm90ZToqKiBUaGlzIGZ1bmN0aW9uIGlzIGJhc2VkIG9uIFtgVG9MZW5ndGhgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi82LjAvI3NlYy10b2xlbmd0aCkuXFxuICpcXG4gKiBAcHJpdmF0ZVxcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxcbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgbGVuZ3RoLCBlbHNlIGBmYWxzZWAuXFxuICovXFxuZnVuY3Rpb24gaXNMZW5ndGgodmFsdWUpIHtcXG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ251bWJlcicgJiYgdmFsdWUgPiAtMSAmJiB2YWx1ZSAlIDEgPT0gMCAmJiB2YWx1ZSA8PSBNQVhfU0FGRV9JTlRFR0VSO1xcbn1cXG5cXG4vKipcXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGFuIGBBcnJheWAgb2JqZWN0LlxcbiAqXFxuICogQHN0YXRpY1xcbiAqIEBtZW1iZXJPZiBfXFxuICogQGNhdGVnb3J5IExhbmdcXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBjb3JyZWN0bHkgY2xhc3NpZmllZCwgZWxzZSBgZmFsc2VgLlxcbiAqIEBleGFtcGxlXFxuICpcXG4gKiBfLmlzQXJyYXkoWzEsIDIsIDNdKTtcXG4gKiAvLyA9PiB0cnVlXFxuICpcXG4gKiBfLmlzQXJyYXkoZnVuY3Rpb24oKSB7IHJldHVybiBhcmd1bWVudHM7IH0oKSk7XFxuICogLy8gPT4gZmFsc2VcXG4gKi9cXG52YXIgaXNBcnJheSA9IG5hdGl2ZUlzQXJyYXkgfHwgZnVuY3Rpb24odmFsdWUpIHtcXG4gIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIGlzTGVuZ3RoKHZhbHVlLmxlbmd0aCkgJiYgb2JqVG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT0gYXJyYXlUYWc7XFxufTtcXG5cXG4vKipcXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYEZ1bmN0aW9uYCBvYmplY3QuXFxuICpcXG4gKiBAc3RhdGljXFxuICogQG1lbWJlck9mIF9cXG4gKiBAY2F0ZWdvcnkgTGFuZ1xcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxcbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGNvcnJlY3RseSBjbGFzc2lmaWVkLCBlbHNlIGBmYWxzZWAuXFxuICogQGV4YW1wbGVcXG4gKlxcbiAqIF8uaXNGdW5jdGlvbihfKTtcXG4gKiAvLyA9PiB0cnVlXFxuICpcXG4gKiBfLmlzRnVuY3Rpb24oL2FiYy8pO1xcbiAqIC8vID0+IGZhbHNlXFxuICovXFxuZnVuY3Rpb24gaXNGdW5jdGlvbih2YWx1ZSkge1xcbiAgLy8gVGhlIHVzZSBvZiBgT2JqZWN0I3RvU3RyaW5nYCBhdm9pZHMgaXNzdWVzIHdpdGggdGhlIGB0eXBlb2ZgIG9wZXJhdG9yXFxuICAvLyBpbiBvbGRlciB2ZXJzaW9ucyBvZiBDaHJvbWUgYW5kIFNhZmFyaSB3aGljaCByZXR1cm4gJ2Z1bmN0aW9uJyBmb3IgcmVnZXhlc1xcbiAgLy8gYW5kIFNhZmFyaSA4IGVxdWl2YWxlbnRzIHdoaWNoIHJldHVybiAnb2JqZWN0JyBmb3IgdHlwZWQgYXJyYXkgY29uc3RydWN0b3JzLlxcbiAgcmV0dXJuIGlzT2JqZWN0KHZhbHVlKSAmJiBvYmpUb1N0cmluZy5jYWxsKHZhbHVlKSA9PSBmdW5jVGFnO1xcbn1cXG5cXG4vKipcXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyB0aGUgW2xhbmd1YWdlIHR5cGVdKGh0dHBzOi8vZXM1LmdpdGh1Yi5pby8jeDgpIG9mIGBPYmplY3RgLlxcbiAqIChlLmcuIGFycmF5cywgZnVuY3Rpb25zLCBvYmplY3RzLCByZWdleGVzLCBgbmV3IE51bWJlcigwKWAsIGFuZCBgbmV3IFN0cmluZygnJylgKVxcbiAqXFxuICogQHN0YXRpY1xcbiAqIEBtZW1iZXJPZiBfXFxuICogQGNhdGVnb3J5IExhbmdcXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cXG4gKiBAZXhhbXBsZVxcbiAqXFxuICogXy5pc09iamVjdCh7fSk7XFxuICogLy8gPT4gdHJ1ZVxcbiAqXFxuICogXy5pc09iamVjdChbMSwgMiwgM10pO1xcbiAqIC8vID0+IHRydWVcXG4gKlxcbiAqIF8uaXNPYmplY3QoMSk7XFxuICogLy8gPT4gZmFsc2VcXG4gKi9cXG5mdW5jdGlvbiBpc09iamVjdCh2YWx1ZSkge1xcbiAgLy8gQXZvaWQgYSBWOCBKSVQgYnVnIGluIENocm9tZSAxOS0yMC5cXG4gIC8vIFNlZSBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9MjI5MSBmb3IgbW9yZSBkZXRhaWxzLlxcbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XFxuICByZXR1cm4gISF2YWx1ZSAmJiAodHlwZSA9PSAnb2JqZWN0JyB8fCB0eXBlID09ICdmdW5jdGlvbicpO1xcbn1cXG5cXG4vKipcXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIG5hdGl2ZSBmdW5jdGlvbi5cXG4gKlxcbiAqIEBzdGF0aWNcXG4gKiBAbWVtYmVyT2YgX1xcbiAqIEBjYXRlZ29yeSBMYW5nXFxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXFxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBuYXRpdmUgZnVuY3Rpb24sIGVsc2UgYGZhbHNlYC5cXG4gKiBAZXhhbXBsZVxcbiAqXFxuICogXy5pc05hdGl2ZShBcnJheS5wcm90b3R5cGUucHVzaCk7XFxuICogLy8gPT4gdHJ1ZVxcbiAqXFxuICogXy5pc05hdGl2ZShfKTtcXG4gKiAvLyA9PiBmYWxzZVxcbiAqL1xcbmZ1bmN0aW9uIGlzTmF0aXZlKHZhbHVlKSB7XFxuICBpZiAodmFsdWUgPT0gbnVsbCkge1xcbiAgICByZXR1cm4gZmFsc2U7XFxuICB9XFxuICBpZiAoaXNGdW5jdGlvbih2YWx1ZSkpIHtcXG4gICAgcmV0dXJuIHJlSXNOYXRpdmUudGVzdChmblRvU3RyaW5nLmNhbGwodmFsdWUpKTtcXG4gIH1cXG4gIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIHJlSXNIb3N0Q3Rvci50ZXN0KHZhbHVlKTtcXG59XFxuXFxubW9kdWxlLmV4cG9ydHMgPSBpc0FycmF5O1xcblxcbn0se31dLDc4OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcXG4vKipcXG4gKiBsb2Rhc2ggMy4xLjIgKEN1c3RvbSBCdWlsZCkgPGh0dHBzOi8vbG9kYXNoLmNvbS8+XFxuICogQnVpbGQ6IGBsb2Rhc2ggbW9kZXJuIG1vZHVsYXJpemUgZXhwb3J0cz1cXFwibnBtXFxcIiAtbyAuL2BcXG4gKiBDb3B5cmlnaHQgMjAxMi0yMDE1IFRoZSBEb2pvIEZvdW5kYXRpb24gPGh0dHA6Ly9kb2pvZm91bmRhdGlvbi5vcmcvPlxcbiAqIEJhc2VkIG9uIFVuZGVyc2NvcmUuanMgMS44LjMgPGh0dHA6Ly91bmRlcnNjb3JlanMub3JnL0xJQ0VOU0U+XFxuICogQ29weXJpZ2h0IDIwMDktMjAxNSBKZXJlbXkgQXNoa2VuYXMsIERvY3VtZW50Q2xvdWQgYW5kIEludmVzdGlnYXRpdmUgUmVwb3J0ZXJzICYgRWRpdG9yc1xcbiAqIEF2YWlsYWJsZSB1bmRlciBNSVQgbGljZW5zZSA8aHR0cHM6Ly9sb2Rhc2guY29tL2xpY2Vuc2U+XFxuICovXFxudmFyIGdldE5hdGl2ZSA9IHJlcXVpcmUoJ2xvZGFzaC5fZ2V0bmF0aXZlJyksXFxuICAgIGlzQXJndW1lbnRzID0gcmVxdWlyZSgnbG9kYXNoLmlzYXJndW1lbnRzJyksXFxuICAgIGlzQXJyYXkgPSByZXF1aXJlKCdsb2Rhc2guaXNhcnJheScpO1xcblxcbi8qKiBVc2VkIHRvIGRldGVjdCB1bnNpZ25lZCBpbnRlZ2VyIHZhbHVlcy4gKi9cXG52YXIgcmVJc1VpbnQgPSAvXlxcXFxkKyQvO1xcblxcbi8qKiBVc2VkIGZvciBuYXRpdmUgbWV0aG9kIHJlZmVyZW5jZXMuICovXFxudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcXG5cXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcXG5cXG4vKiBOYXRpdmUgbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xcbnZhciBuYXRpdmVLZXlzID0gZ2V0TmF0aXZlKE9iamVjdCwgJ2tleXMnKTtcXG5cXG4vKipcXG4gKiBVc2VkIGFzIHRoZSBbbWF4aW11bSBsZW5ndGhdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzYuMC8jc2VjLW51bWJlci5tYXhfc2FmZV9pbnRlZ2VyKVxcbiAqIG9mIGFuIGFycmF5LWxpa2UgdmFsdWUuXFxuICovXFxudmFyIE1BWF9TQUZFX0lOVEVHRVIgPSA5MDA3MTk5MjU0NzQwOTkxO1xcblxcbi8qKlxcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnByb3BlcnR5YCB3aXRob3V0IHN1cHBvcnQgZm9yIGRlZXAgcGF0aHMuXFxuICpcXG4gKiBAcHJpdmF0ZVxcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxcbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxcbiAqL1xcbmZ1bmN0aW9uIGJhc2VQcm9wZXJ0eShrZXkpIHtcXG4gIHJldHVybiBmdW5jdGlvbihvYmplY3QpIHtcXG4gICAgcmV0dXJuIG9iamVjdCA9PSBudWxsID8gdW5kZWZpbmVkIDogb2JqZWN0W2tleV07XFxuICB9O1xcbn1cXG5cXG4vKipcXG4gKiBHZXRzIHRoZSBcXFwibGVuZ3RoXFxcIiBwcm9wZXJ0eSB2YWx1ZSBvZiBgb2JqZWN0YC5cXG4gKlxcbiAqICoqTm90ZToqKiBUaGlzIGZ1bmN0aW9uIGlzIHVzZWQgdG8gYXZvaWQgYSBbSklUIGJ1Z10oaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTE0Mjc5MilcXG4gKiB0aGF0IGFmZmVjdHMgU2FmYXJpIG9uIGF0IGxlYXN0IGlPUyA4LjEtOC4zIEFSTTY0LlxcbiAqXFxuICogQHByaXZhdGVcXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXFxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIFxcXCJsZW5ndGhcXFwiIHZhbHVlLlxcbiAqL1xcbnZhciBnZXRMZW5ndGggPSBiYXNlUHJvcGVydHkoJ2xlbmd0aCcpO1xcblxcbi8qKlxcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGFycmF5LWxpa2UuXFxuICpcXG4gKiBAcHJpdmF0ZVxcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxcbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFycmF5LWxpa2UsIGVsc2UgYGZhbHNlYC5cXG4gKi9cXG5mdW5jdGlvbiBpc0FycmF5TGlrZSh2YWx1ZSkge1xcbiAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgaXNMZW5ndGgoZ2V0TGVuZ3RoKHZhbHVlKSk7XFxufVxcblxcbi8qKlxcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgYXJyYXktbGlrZSBpbmRleC5cXG4gKlxcbiAqIEBwcml2YXRlXFxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXFxuICogQHBhcmFtIHtudW1iZXJ9IFtsZW5ndGg9TUFYX1NBRkVfSU5URUdFUl0gVGhlIHVwcGVyIGJvdW5kcyBvZiBhIHZhbGlkIGluZGV4LlxcbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgaW5kZXgsIGVsc2UgYGZhbHNlYC5cXG4gKi9cXG5mdW5jdGlvbiBpc0luZGV4KHZhbHVlLCBsZW5ndGgpIHtcXG4gIHZhbHVlID0gKHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJyB8fCByZUlzVWludC50ZXN0KHZhbHVlKSkgPyArdmFsdWUgOiAtMTtcXG4gIGxlbmd0aCA9IGxlbmd0aCA9PSBudWxsID8gTUFYX1NBRkVfSU5URUdFUiA6IGxlbmd0aDtcXG4gIHJldHVybiB2YWx1ZSA+IC0xICYmIHZhbHVlICUgMSA9PSAwICYmIHZhbHVlIDwgbGVuZ3RoO1xcbn1cXG5cXG4vKipcXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGFycmF5LWxpa2UgbGVuZ3RoLlxcbiAqXFxuICogKipOb3RlOioqIFRoaXMgZnVuY3Rpb24gaXMgYmFzZWQgb24gW2BUb0xlbmd0aGBdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzYuMC8jc2VjLXRvbGVuZ3RoKS5cXG4gKlxcbiAqIEBwcml2YXRlXFxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXFxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBsZW5ndGgsIGVsc2UgYGZhbHNlYC5cXG4gKi9cXG5mdW5jdGlvbiBpc0xlbmd0aCh2YWx1ZSkge1xcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJyAmJiB2YWx1ZSA+IC0xICYmIHZhbHVlICUgMSA9PSAwICYmIHZhbHVlIDw9IE1BWF9TQUZFX0lOVEVHRVI7XFxufVxcblxcbi8qKlxcbiAqIEEgZmFsbGJhY2sgaW1wbGVtZW50YXRpb24gb2YgYE9iamVjdC5rZXlzYCB3aGljaCBjcmVhdGVzIGFuIGFycmF5IG9mIHRoZVxcbiAqIG93biBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIG9mIGBvYmplY3RgLlxcbiAqXFxuICogQHByaXZhdGVcXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXFxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cXG4gKi9cXG5mdW5jdGlvbiBzaGltS2V5cyhvYmplY3QpIHtcXG4gIHZhciBwcm9wcyA9IGtleXNJbihvYmplY3QpLFxcbiAgICAgIHByb3BzTGVuZ3RoID0gcHJvcHMubGVuZ3RoLFxcbiAgICAgIGxlbmd0aCA9IHByb3BzTGVuZ3RoICYmIG9iamVjdC5sZW5ndGg7XFxuXFxuICB2YXIgYWxsb3dJbmRleGVzID0gISFsZW5ndGggJiYgaXNMZW5ndGgobGVuZ3RoKSAmJlxcbiAgICAoaXNBcnJheShvYmplY3QpIHx8IGlzQXJndW1lbnRzKG9iamVjdCkpO1xcblxcbiAgdmFyIGluZGV4ID0gLTEsXFxuICAgICAgcmVzdWx0ID0gW107XFxuXFxuICB3aGlsZSAoKytpbmRleCA8IHByb3BzTGVuZ3RoKSB7XFxuICAgIHZhciBrZXkgPSBwcm9wc1tpbmRleF07XFxuICAgIGlmICgoYWxsb3dJbmRleGVzICYmIGlzSW5kZXgoa2V5LCBsZW5ndGgpKSB8fCBoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KSkge1xcbiAgICAgIHJlc3VsdC5wdXNoKGtleSk7XFxuICAgIH1cXG4gIH1cXG4gIHJldHVybiByZXN1bHQ7XFxufVxcblxcbi8qKlxcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIHRoZSBbbGFuZ3VhZ2UgdHlwZV0oaHR0cHM6Ly9lczUuZ2l0aHViLmlvLyN4OCkgb2YgYE9iamVjdGAuXFxuICogKGUuZy4gYXJyYXlzLCBmdW5jdGlvbnMsIG9iamVjdHMsIHJlZ2V4ZXMsIGBuZXcgTnVtYmVyKDApYCwgYW5kIGBuZXcgU3RyaW5nKCcnKWApXFxuICpcXG4gKiBAc3RhdGljXFxuICogQG1lbWJlck9mIF9cXG4gKiBAY2F0ZWdvcnkgTGFuZ1xcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxcbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxcbiAqIEBleGFtcGxlXFxuICpcXG4gKiBfLmlzT2JqZWN0KHt9KTtcXG4gKiAvLyA9PiB0cnVlXFxuICpcXG4gKiBfLmlzT2JqZWN0KFsxLCAyLCAzXSk7XFxuICogLy8gPT4gdHJ1ZVxcbiAqXFxuICogXy5pc09iamVjdCgxKTtcXG4gKiAvLyA9PiBmYWxzZVxcbiAqL1xcbmZ1bmN0aW9uIGlzT2JqZWN0KHZhbHVlKSB7XFxuICAvLyBBdm9pZCBhIFY4IEpJVCBidWcgaW4gQ2hyb21lIDE5LTIwLlxcbiAgLy8gU2VlIGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvdjgvaXNzdWVzL2RldGFpbD9pZD0yMjkxIGZvciBtb3JlIGRldGFpbHMuXFxuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcXG4gIHJldHVybiAhIXZhbHVlICYmICh0eXBlID09ICdvYmplY3QnIHx8IHR5cGUgPT0gJ2Z1bmN0aW9uJyk7XFxufVxcblxcbi8qKlxcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIG93biBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIG9mIGBvYmplY3RgLlxcbiAqXFxuICogKipOb3RlOioqIE5vbi1vYmplY3QgdmFsdWVzIGFyZSBjb2VyY2VkIHRvIG9iamVjdHMuIFNlZSB0aGVcXG4gKiBbRVMgc3BlY10oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNi4wLyNzZWMtb2JqZWN0LmtleXMpXFxuICogZm9yIG1vcmUgZGV0YWlscy5cXG4gKlxcbiAqIEBzdGF0aWNcXG4gKiBAbWVtYmVyT2YgX1xcbiAqIEBjYXRlZ29yeSBPYmplY3RcXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXFxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cXG4gKiBAZXhhbXBsZVxcbiAqXFxuICogZnVuY3Rpb24gRm9vKCkge1xcbiAqICAgdGhpcy5hID0gMTtcXG4gKiAgIHRoaXMuYiA9IDI7XFxuICogfVxcbiAqXFxuICogRm9vLnByb3RvdHlwZS5jID0gMztcXG4gKlxcbiAqIF8ua2V5cyhuZXcgRm9vKTtcXG4gKiAvLyA9PiBbJ2EnLCAnYiddIChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpXFxuICpcXG4gKiBfLmtleXMoJ2hpJyk7XFxuICogLy8gPT4gWycwJywgJzEnXVxcbiAqL1xcbnZhciBrZXlzID0gIW5hdGl2ZUtleXMgPyBzaGltS2V5cyA6IGZ1bmN0aW9uKG9iamVjdCkge1xcbiAgdmFyIEN0b3IgPSBvYmplY3QgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IG9iamVjdC5jb25zdHJ1Y3RvcjtcXG4gIGlmICgodHlwZW9mIEN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiBDdG9yLnByb3RvdHlwZSA9PT0gb2JqZWN0KSB8fFxcbiAgICAgICh0eXBlb2Ygb2JqZWN0ICE9ICdmdW5jdGlvbicgJiYgaXNBcnJheUxpa2Uob2JqZWN0KSkpIHtcXG4gICAgcmV0dXJuIHNoaW1LZXlzKG9iamVjdCk7XFxuICB9XFxuICByZXR1cm4gaXNPYmplY3Qob2JqZWN0KSA/IG5hdGl2ZUtleXMob2JqZWN0KSA6IFtdO1xcbn07XFxuXFxuLyoqXFxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgb3duIGFuZCBpbmhlcml0ZWQgZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBvZiBgb2JqZWN0YC5cXG4gKlxcbiAqICoqTm90ZToqKiBOb24tb2JqZWN0IHZhbHVlcyBhcmUgY29lcmNlZCB0byBvYmplY3RzLlxcbiAqXFxuICogQHN0YXRpY1xcbiAqIEBtZW1iZXJPZiBfXFxuICogQGNhdGVnb3J5IE9iamVjdFxcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxcbiAqIEBleGFtcGxlXFxuICpcXG4gKiBmdW5jdGlvbiBGb28oKSB7XFxuICogICB0aGlzLmEgPSAxO1xcbiAqICAgdGhpcy5iID0gMjtcXG4gKiB9XFxuICpcXG4gKiBGb28ucHJvdG90eXBlLmMgPSAzO1xcbiAqXFxuICogXy5rZXlzSW4obmV3IEZvbyk7XFxuICogLy8gPT4gWydhJywgJ2InLCAnYyddIChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpXFxuICovXFxuZnVuY3Rpb24ga2V5c0luKG9iamVjdCkge1xcbiAgaWYgKG9iamVjdCA9PSBudWxsKSB7XFxuICAgIHJldHVybiBbXTtcXG4gIH1cXG4gIGlmICghaXNPYmplY3Qob2JqZWN0KSkge1xcbiAgICBvYmplY3QgPSBPYmplY3Qob2JqZWN0KTtcXG4gIH1cXG4gIHZhciBsZW5ndGggPSBvYmplY3QubGVuZ3RoO1xcbiAgbGVuZ3RoID0gKGxlbmd0aCAmJiBpc0xlbmd0aChsZW5ndGgpICYmXFxuICAgIChpc0FycmF5KG9iamVjdCkgfHwgaXNBcmd1bWVudHMob2JqZWN0KSkgJiYgbGVuZ3RoKSB8fCAwO1xcblxcbiAgdmFyIEN0b3IgPSBvYmplY3QuY29uc3RydWN0b3IsXFxuICAgICAgaW5kZXggPSAtMSxcXG4gICAgICBpc1Byb3RvID0gdHlwZW9mIEN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiBDdG9yLnByb3RvdHlwZSA9PT0gb2JqZWN0LFxcbiAgICAgIHJlc3VsdCA9IEFycmF5KGxlbmd0aCksXFxuICAgICAgc2tpcEluZGV4ZXMgPSBsZW5ndGggPiAwO1xcblxcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcXG4gICAgcmVzdWx0W2luZGV4XSA9IChpbmRleCArICcnKTtcXG4gIH1cXG4gIGZvciAodmFyIGtleSBpbiBvYmplY3QpIHtcXG4gICAgaWYgKCEoc2tpcEluZGV4ZXMgJiYgaXNJbmRleChrZXksIGxlbmd0aCkpICYmXFxuICAgICAgICAhKGtleSA9PSAnY29uc3RydWN0b3InICYmIChpc1Byb3RvIHx8ICFoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KSkpKSB7XFxuICAgICAgcmVzdWx0LnB1c2goa2V5KTtcXG4gICAgfVxcbiAgfVxcbiAgcmV0dXJuIHJlc3VsdDtcXG59XFxuXFxubW9kdWxlLmV4cG9ydHMgPSBrZXlzO1xcblxcbn0se1xcXCJsb2Rhc2guX2dldG5hdGl2ZVxcXCI6NzMsXFxcImxvZGFzaC5pc2FyZ3VtZW50c1xcXCI6NzYsXFxcImxvZGFzaC5pc2FycmF5XFxcIjo3N31dLDc5OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcXG4oZnVuY3Rpb24gKHByb2Nlc3Mpe1xcbnZhciBwYXRoID0gcmVxdWlyZSgncGF0aCcpO1xcbnZhciBmcyA9IHJlcXVpcmUoJ2ZzJyk7XFxudmFyIF8wNzc3ID0gcGFyc2VJbnQoJzA3NzcnLCA4KTtcXG5cXG5tb2R1bGUuZXhwb3J0cyA9IG1rZGlyUC5ta2RpcnAgPSBta2RpclAubWtkaXJQID0gbWtkaXJQO1xcblxcbmZ1bmN0aW9uIG1rZGlyUCAocCwgb3B0cywgZiwgbWFkZSkge1xcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09ICdmdW5jdGlvbicpIHtcXG4gICAgICAgIGYgPSBvcHRzO1xcbiAgICAgICAgb3B0cyA9IHt9O1xcbiAgICB9XFxuICAgIGVsc2UgaWYgKCFvcHRzIHx8IHR5cGVvZiBvcHRzICE9PSAnb2JqZWN0Jykge1xcbiAgICAgICAgb3B0cyA9IHsgbW9kZTogb3B0cyB9O1xcbiAgICB9XFxuICAgIFxcbiAgICB2YXIgbW9kZSA9IG9wdHMubW9kZTtcXG4gICAgdmFyIHhmcyA9IG9wdHMuZnMgfHwgZnM7XFxuICAgIFxcbiAgICBpZiAobW9kZSA9PT0gdW5kZWZpbmVkKSB7XFxuICAgICAgICBtb2RlID0gXzA3NzcgJiAofnByb2Nlc3MudW1hc2soKSk7XFxuICAgIH1cXG4gICAgaWYgKCFtYWRlKSBtYWRlID0gbnVsbDtcXG4gICAgXFxuICAgIHZhciBjYiA9IGYgfHwgZnVuY3Rpb24gKCkge307XFxuICAgIHAgPSBwYXRoLnJlc29sdmUocCk7XFxuICAgIFxcbiAgICB4ZnMubWtkaXIocCwgbW9kZSwgZnVuY3Rpb24gKGVyKSB7XFxuICAgICAgICBpZiAoIWVyKSB7XFxuICAgICAgICAgICAgbWFkZSA9IG1hZGUgfHwgcDtcXG4gICAgICAgICAgICByZXR1cm4gY2IobnVsbCwgbWFkZSk7XFxuICAgICAgICB9XFxuICAgICAgICBzd2l0Y2ggKGVyLmNvZGUpIHtcXG4gICAgICAgICAgICBjYXNlICdFTk9FTlQnOlxcbiAgICAgICAgICAgICAgICBta2RpclAocGF0aC5kaXJuYW1lKHApLCBvcHRzLCBmdW5jdGlvbiAoZXIsIG1hZGUpIHtcXG4gICAgICAgICAgICAgICAgICAgIGlmIChlcikgY2IoZXIsIG1hZGUpO1xcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBta2RpclAocCwgb3B0cywgY2IsIG1hZGUpO1xcbiAgICAgICAgICAgICAgICB9KTtcXG4gICAgICAgICAgICAgICAgYnJlYWs7XFxuXFxuICAgICAgICAgICAgLy8gSW4gdGhlIGNhc2Ugb2YgYW55IG90aGVyIGVycm9yLCBqdXN0IHNlZSBpZiB0aGVyZSdzIGEgZGlyXFxuICAgICAgICAgICAgLy8gdGhlcmUgYWxyZWFkeS4gIElmIHNvLCB0aGVuIGhvb3JheSEgIElmIG5vdCwgdGhlbiBzb21ldGhpbmdcXG4gICAgICAgICAgICAvLyBpcyBib3JrZWQuXFxuICAgICAgICAgICAgZGVmYXVsdDpcXG4gICAgICAgICAgICAgICAgeGZzLnN0YXQocCwgZnVuY3Rpb24gKGVyMiwgc3RhdCkge1xcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgdGhlIHN0YXQgZmFpbHMsIHRoZW4gdGhhdCdzIHN1cGVyIHdlaXJkLlxcbiAgICAgICAgICAgICAgICAgICAgLy8gbGV0IHRoZSBvcmlnaW5hbCBlcnJvciBiZSB0aGUgZmFpbHVyZSByZWFzb24uXFxuICAgICAgICAgICAgICAgICAgICBpZiAoZXIyIHx8ICFzdGF0LmlzRGlyZWN0b3J5KCkpIGNiKGVyLCBtYWRlKVxcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBjYihudWxsLCBtYWRlKTtcXG4gICAgICAgICAgICAgICAgfSk7XFxuICAgICAgICAgICAgICAgIGJyZWFrO1xcbiAgICAgICAgfVxcbiAgICB9KTtcXG59XFxuXFxubWtkaXJQLnN5bmMgPSBmdW5jdGlvbiBzeW5jIChwLCBvcHRzLCBtYWRlKSB7XFxuICAgIGlmICghb3B0cyB8fCB0eXBlb2Ygb3B0cyAhPT0gJ29iamVjdCcpIHtcXG4gICAgICAgIG9wdHMgPSB7IG1vZGU6IG9wdHMgfTtcXG4gICAgfVxcbiAgICBcXG4gICAgdmFyIG1vZGUgPSBvcHRzLm1vZGU7XFxuICAgIHZhciB4ZnMgPSBvcHRzLmZzIHx8IGZzO1xcbiAgICBcXG4gICAgaWYgKG1vZGUgPT09IHVuZGVmaW5lZCkge1xcbiAgICAgICAgbW9kZSA9IF8wNzc3ICYgKH5wcm9jZXNzLnVtYXNrKCkpO1xcbiAgICB9XFxuICAgIGlmICghbWFkZSkgbWFkZSA9IG51bGw7XFxuXFxuICAgIHAgPSBwYXRoLnJlc29sdmUocCk7XFxuXFxuICAgIHRyeSB7XFxuICAgICAgICB4ZnMubWtkaXJTeW5jKHAsIG1vZGUpO1xcbiAgICAgICAgbWFkZSA9IG1hZGUgfHwgcDtcXG4gICAgfVxcbiAgICBjYXRjaCAoZXJyMCkge1xcbiAgICAgICAgc3dpdGNoIChlcnIwLmNvZGUpIHtcXG4gICAgICAgICAgICBjYXNlICdFTk9FTlQnIDpcXG4gICAgICAgICAgICAgICAgbWFkZSA9IHN5bmMocGF0aC5kaXJuYW1lKHApLCBvcHRzLCBtYWRlKTtcXG4gICAgICAgICAgICAgICAgc3luYyhwLCBvcHRzLCBtYWRlKTtcXG4gICAgICAgICAgICAgICAgYnJlYWs7XFxuXFxuICAgICAgICAgICAgLy8gSW4gdGhlIGNhc2Ugb2YgYW55IG90aGVyIGVycm9yLCBqdXN0IHNlZSBpZiB0aGVyZSdzIGEgZGlyXFxuICAgICAgICAgICAgLy8gdGhlcmUgYWxyZWFkeS4gIElmIHNvLCB0aGVuIGhvb3JheSEgIElmIG5vdCwgdGhlbiBzb21ldGhpbmdcXG4gICAgICAgICAgICAvLyBpcyBib3JrZWQuXFxuICAgICAgICAgICAgZGVmYXVsdDpcXG4gICAgICAgICAgICAgICAgdmFyIHN0YXQ7XFxuICAgICAgICAgICAgICAgIHRyeSB7XFxuICAgICAgICAgICAgICAgICAgICBzdGF0ID0geGZzLnN0YXRTeW5jKHApO1xcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnIxKSB7XFxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnIwO1xcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgIGlmICghc3RhdC5pc0RpcmVjdG9yeSgpKSB0aHJvdyBlcnIwO1xcbiAgICAgICAgICAgICAgICBicmVhaztcXG4gICAgICAgIH1cXG4gICAgfVxcblxcbiAgICByZXR1cm4gbWFkZTtcXG59O1xcblxcbn0pLmNhbGwodGhpcyxyZXF1aXJlKCdfcHJvY2VzcycpKVxcbn0se1xcXCJfcHJvY2Vzc1xcXCI6ODIsXFxcImZzXFxcIjo0MixcXFwicGF0aFxcXCI6NDJ9XSw4MDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XFxuZXhwb3J0cy5lbmRpYW5uZXNzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJ0xFJyB9O1xcblxcbmV4cG9ydHMuaG9zdG5hbWUgPSBmdW5jdGlvbiAoKSB7XFxuICAgIGlmICh0eXBlb2YgbG9jYXRpb24gIT09ICd1bmRlZmluZWQnKSB7XFxuICAgICAgICByZXR1cm4gbG9jYXRpb24uaG9zdG5hbWVcXG4gICAgfVxcbiAgICBlbHNlIHJldHVybiAnJztcXG59O1xcblxcbmV4cG9ydHMubG9hZGF2ZyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtdIH07XFxuXFxuZXhwb3J0cy51cHRpbWUgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAwIH07XFxuXFxuZXhwb3J0cy5mcmVlbWVtID0gZnVuY3Rpb24gKCkge1xcbiAgICByZXR1cm4gTnVtYmVyLk1BWF9WQUxVRTtcXG59O1xcblxcbmV4cG9ydHMudG90YWxtZW0gPSBmdW5jdGlvbiAoKSB7XFxuICAgIHJldHVybiBOdW1iZXIuTUFYX1ZBTFVFO1xcbn07XFxuXFxuZXhwb3J0cy5jcHVzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW10gfTtcXG5cXG5leHBvcnRzLnR5cGUgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnQnJvd3NlcicgfTtcXG5cXG5leHBvcnRzLnJlbGVhc2UgPSBmdW5jdGlvbiAoKSB7XFxuICAgIGlmICh0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJykge1xcbiAgICAgICAgcmV0dXJuIG5hdmlnYXRvci5hcHBWZXJzaW9uO1xcbiAgICB9XFxuICAgIHJldHVybiAnJztcXG59O1xcblxcbmV4cG9ydHMubmV0d29ya0ludGVyZmFjZXNcXG49IGV4cG9ydHMuZ2V0TmV0d29ya0ludGVyZmFjZXNcXG49IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHt9IH07XFxuXFxuZXhwb3J0cy5hcmNoID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJ2phdmFzY3JpcHQnIH07XFxuXFxuZXhwb3J0cy5wbGF0Zm9ybSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICdicm93c2VyJyB9O1xcblxcbmV4cG9ydHMudG1wZGlyID0gZXhwb3J0cy50bXBEaXIgPSBmdW5jdGlvbiAoKSB7XFxuICAgIHJldHVybiAnL3RtcCc7XFxufTtcXG5cXG5leHBvcnRzLkVPTCA9ICdcXFxcbic7XFxuXFxufSx7fV0sODE6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xcbihmdW5jdGlvbiAocHJvY2Vzcyl7XFxuJ3VzZSBzdHJpY3QnO1xcblxcbmlmICghcHJvY2Vzcy52ZXJzaW9uIHx8XFxuICAgIHByb2Nlc3MudmVyc2lvbi5pbmRleE9mKCd2MC4nKSA9PT0gMCB8fFxcbiAgICBwcm9jZXNzLnZlcnNpb24uaW5kZXhPZigndjEuJykgPT09IDAgJiYgcHJvY2Vzcy52ZXJzaW9uLmluZGV4T2YoJ3YxLjguJykgIT09IDApIHtcXG4gIG1vZHVsZS5leHBvcnRzID0gbmV4dFRpY2s7XFxufSBlbHNlIHtcXG4gIG1vZHVsZS5leHBvcnRzID0gcHJvY2Vzcy5uZXh0VGljaztcXG59XFxuXFxuZnVuY3Rpb24gbmV4dFRpY2soZm4sIGFyZzEsIGFyZzIsIGFyZzMpIHtcXG4gIGlmICh0eXBlb2YgZm4gIT09ICdmdW5jdGlvbicpIHtcXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXFxcImNhbGxiYWNrXFxcIiBhcmd1bWVudCBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcXG4gIH1cXG4gIHZhciBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xcbiAgdmFyIGFyZ3MsIGk7XFxuICBzd2l0Y2ggKGxlbikge1xcbiAgY2FzZSAwOlxcbiAgY2FzZSAxOlxcbiAgICByZXR1cm4gcHJvY2Vzcy5uZXh0VGljayhmbik7XFxuICBjYXNlIDI6XFxuICAgIHJldHVybiBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uIGFmdGVyVGlja09uZSgpIHtcXG4gICAgICBmbi5jYWxsKG51bGwsIGFyZzEpO1xcbiAgICB9KTtcXG4gIGNhc2UgMzpcXG4gICAgcmV0dXJuIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24gYWZ0ZXJUaWNrVHdvKCkge1xcbiAgICAgIGZuLmNhbGwobnVsbCwgYXJnMSwgYXJnMik7XFxuICAgIH0pO1xcbiAgY2FzZSA0OlxcbiAgICByZXR1cm4gcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbiBhZnRlclRpY2tUaHJlZSgpIHtcXG4gICAgICBmbi5jYWxsKG51bGwsIGFyZzEsIGFyZzIsIGFyZzMpO1xcbiAgICB9KTtcXG4gIGRlZmF1bHQ6XFxuICAgIGFyZ3MgPSBuZXcgQXJyYXkobGVuIC0gMSk7XFxuICAgIGkgPSAwO1xcbiAgICB3aGlsZSAoaSA8IGFyZ3MubGVuZ3RoKSB7XFxuICAgICAgYXJnc1tpKytdID0gYXJndW1lbnRzW2ldO1xcbiAgICB9XFxuICAgIHJldHVybiBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uIGFmdGVyVGljaygpIHtcXG4gICAgICBmbi5hcHBseShudWxsLCBhcmdzKTtcXG4gICAgfSk7XFxuICB9XFxufVxcblxcbn0pLmNhbGwodGhpcyxyZXF1aXJlKCdfcHJvY2VzcycpKVxcbn0se1xcXCJfcHJvY2Vzc1xcXCI6ODJ9XSw4MjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XFxuLy8gc2hpbSBmb3IgdXNpbmcgcHJvY2VzcyBpbiBicm93c2VyXFxudmFyIHByb2Nlc3MgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xcblxcbi8vIGNhY2hlZCBmcm9tIHdoYXRldmVyIGdsb2JhbCBpcyBwcmVzZW50IHNvIHRoYXQgdGVzdCBydW5uZXJzIHRoYXQgc3R1YiBpdFxcbi8vIGRvbid0IGJyZWFrIHRoaW5ncy4gIEJ1dCB3ZSBuZWVkIHRvIHdyYXAgaXQgaW4gYSB0cnkgY2F0Y2ggaW4gY2FzZSBpdCBpc1xcbi8vIHdyYXBwZWQgaW4gc3RyaWN0IG1vZGUgY29kZSB3aGljaCBkb2Vzbid0IGRlZmluZSBhbnkgZ2xvYmFscy4gIEl0J3MgaW5zaWRlIGFcXG4vLyBmdW5jdGlvbiBiZWNhdXNlIHRyeS9jYXRjaGVzIGRlb3B0aW1pemUgaW4gY2VydGFpbiBlbmdpbmVzLlxcblxcbnZhciBjYWNoZWRTZXRUaW1lb3V0O1xcbnZhciBjYWNoZWRDbGVhclRpbWVvdXQ7XFxuXFxuZnVuY3Rpb24gZGVmYXVsdFNldFRpbW91dCgpIHtcXG4gICAgdGhyb3cgbmV3IEVycm9yKCdzZXRUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XFxufVxcbmZ1bmN0aW9uIGRlZmF1bHRDbGVhclRpbWVvdXQgKCkge1xcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2NsZWFyVGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xcbn1cXG4oZnVuY3Rpb24gKCkge1xcbiAgICB0cnkge1xcbiAgICAgICAgaWYgKHR5cGVvZiBzZXRUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XFxuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XFxuICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xcbiAgICAgICAgfVxcbiAgICB9IGNhdGNoIChlKSB7XFxuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcXG4gICAgfVxcbiAgICB0cnkge1xcbiAgICAgICAgaWYgKHR5cGVvZiBjbGVhclRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcXG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XFxuICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XFxuICAgICAgICB9XFxuICAgIH0gY2F0Y2ggKGUpIHtcXG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XFxuICAgIH1cXG59ICgpKVxcbmZ1bmN0aW9uIHJ1blRpbWVvdXQoZnVuKSB7XFxuICAgIGlmIChjYWNoZWRTZXRUaW1lb3V0ID09PSBzZXRUaW1lb3V0KSB7XFxuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcXG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XFxuICAgIH1cXG4gICAgLy8gaWYgc2V0VGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcXG4gICAgaWYgKChjYWNoZWRTZXRUaW1lb3V0ID09PSBkZWZhdWx0U2V0VGltb3V0IHx8ICFjYWNoZWRTZXRUaW1lb3V0KSAmJiBzZXRUaW1lb3V0KSB7XFxuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcXG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XFxuICAgIH1cXG4gICAgdHJ5IHtcXG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcXG4gICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0KGZ1biwgMCk7XFxuICAgIH0gY2F0Y2goZSl7XFxuICAgICAgICB0cnkge1xcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwobnVsbCwgZnVuLCAwKTtcXG4gICAgICAgIH0gY2F0Y2goZSl7XFxuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3JcXG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKHRoaXMsIGZ1biwgMCk7XFxuICAgICAgICB9XFxuICAgIH1cXG5cXG5cXG59XFxuZnVuY3Rpb24gcnVuQ2xlYXJUaW1lb3V0KG1hcmtlcikge1xcbiAgICBpZiAoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBjbGVhclRpbWVvdXQpIHtcXG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xcbiAgICB9XFxuICAgIC8vIGlmIGNsZWFyVGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcXG4gICAgaWYgKChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGRlZmF1bHRDbGVhclRpbWVvdXQgfHwgIWNhY2hlZENsZWFyVGltZW91dCkgJiYgY2xlYXJUaW1lb3V0KSB7XFxuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XFxuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XFxuICAgIH1cXG4gICAgdHJ5IHtcXG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcXG4gICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQobWFya2VyKTtcXG4gICAgfSBjYXRjaCAoZSl7XFxuICAgICAgICB0cnkge1xcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCAgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcXG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwobnVsbCwgbWFya2VyKTtcXG4gICAgICAgIH0gY2F0Y2ggKGUpe1xcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yLlxcbiAgICAgICAgICAgIC8vIFNvbWUgdmVyc2lvbnMgb2YgSS5FLiBoYXZlIGRpZmZlcmVudCBydWxlcyBmb3IgY2xlYXJUaW1lb3V0IHZzIHNldFRpbWVvdXRcXG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwodGhpcywgbWFya2VyKTtcXG4gICAgICAgIH1cXG4gICAgfVxcblxcblxcblxcbn1cXG52YXIgcXVldWUgPSBbXTtcXG52YXIgZHJhaW5pbmcgPSBmYWxzZTtcXG52YXIgY3VycmVudFF1ZXVlO1xcbnZhciBxdWV1ZUluZGV4ID0gLTE7XFxuXFxuZnVuY3Rpb24gY2xlYW5VcE5leHRUaWNrKCkge1xcbiAgICBpZiAoIWRyYWluaW5nIHx8ICFjdXJyZW50UXVldWUpIHtcXG4gICAgICAgIHJldHVybjtcXG4gICAgfVxcbiAgICBkcmFpbmluZyA9IGZhbHNlO1xcbiAgICBpZiAoY3VycmVudFF1ZXVlLmxlbmd0aCkge1xcbiAgICAgICAgcXVldWUgPSBjdXJyZW50UXVldWUuY29uY2F0KHF1ZXVlKTtcXG4gICAgfSBlbHNlIHtcXG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcXG4gICAgfVxcbiAgICBpZiAocXVldWUubGVuZ3RoKSB7XFxuICAgICAgICBkcmFpblF1ZXVlKCk7XFxuICAgIH1cXG59XFxuXFxuZnVuY3Rpb24gZHJhaW5RdWV1ZSgpIHtcXG4gICAgaWYgKGRyYWluaW5nKSB7XFxuICAgICAgICByZXR1cm47XFxuICAgIH1cXG4gICAgdmFyIHRpbWVvdXQgPSBydW5UaW1lb3V0KGNsZWFuVXBOZXh0VGljayk7XFxuICAgIGRyYWluaW5nID0gdHJ1ZTtcXG5cXG4gICAgdmFyIGxlbiA9IHF1ZXVlLmxlbmd0aDtcXG4gICAgd2hpbGUobGVuKSB7XFxuICAgICAgICBjdXJyZW50UXVldWUgPSBxdWV1ZTtcXG4gICAgICAgIHF1ZXVlID0gW107XFxuICAgICAgICB3aGlsZSAoKytxdWV1ZUluZGV4IDwgbGVuKSB7XFxuICAgICAgICAgICAgaWYgKGN1cnJlbnRRdWV1ZSkge1xcbiAgICAgICAgICAgICAgICBjdXJyZW50UXVldWVbcXVldWVJbmRleF0ucnVuKCk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xcbiAgICAgICAgbGVuID0gcXVldWUubGVuZ3RoO1xcbiAgICB9XFxuICAgIGN1cnJlbnRRdWV1ZSA9IG51bGw7XFxuICAgIGRyYWluaW5nID0gZmFsc2U7XFxuICAgIHJ1bkNsZWFyVGltZW91dCh0aW1lb3V0KTtcXG59XFxuXFxucHJvY2Vzcy5uZXh0VGljayA9IGZ1bmN0aW9uIChmdW4pIHtcXG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpO1xcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcXG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XFxuICAgICAgICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XFxuICAgICAgICB9XFxuICAgIH1cXG4gICAgcXVldWUucHVzaChuZXcgSXRlbShmdW4sIGFyZ3MpKTtcXG4gICAgaWYgKHF1ZXVlLmxlbmd0aCA9PT0gMSAmJiAhZHJhaW5pbmcpIHtcXG4gICAgICAgIHJ1blRpbWVvdXQoZHJhaW5RdWV1ZSk7XFxuICAgIH1cXG59O1xcblxcbi8vIHY4IGxpa2VzIHByZWRpY3RpYmxlIG9iamVjdHNcXG5mdW5jdGlvbiBJdGVtKGZ1biwgYXJyYXkpIHtcXG4gICAgdGhpcy5mdW4gPSBmdW47XFxuICAgIHRoaXMuYXJyYXkgPSBhcnJheTtcXG59XFxuSXRlbS5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKCkge1xcbiAgICB0aGlzLmZ1bi5hcHBseShudWxsLCB0aGlzLmFycmF5KTtcXG59O1xcbnByb2Nlc3MudGl0bGUgPSAnYnJvd3Nlcic7XFxucHJvY2Vzcy5icm93c2VyID0gdHJ1ZTtcXG5wcm9jZXNzLmVudiA9IHt9O1xcbnByb2Nlc3MuYXJndiA9IFtdO1xcbnByb2Nlc3MudmVyc2lvbiA9ICcnOyAvLyBlbXB0eSBzdHJpbmcgdG8gYXZvaWQgcmVnZXhwIGlzc3Vlc1xcbnByb2Nlc3MudmVyc2lvbnMgPSB7fTtcXG5cXG5mdW5jdGlvbiBub29wKCkge31cXG5cXG5wcm9jZXNzLm9uID0gbm9vcDtcXG5wcm9jZXNzLmFkZExpc3RlbmVyID0gbm9vcDtcXG5wcm9jZXNzLm9uY2UgPSBub29wO1xcbnByb2Nlc3Mub2ZmID0gbm9vcDtcXG5wcm9jZXNzLnJlbW92ZUxpc3RlbmVyID0gbm9vcDtcXG5wcm9jZXNzLnJlbW92ZUFsbExpc3RlbmVycyA9IG5vb3A7XFxucHJvY2Vzcy5lbWl0ID0gbm9vcDtcXG5wcm9jZXNzLnByZXBlbmRMaXN0ZW5lciA9IG5vb3A7XFxucHJvY2Vzcy5wcmVwZW5kT25jZUxpc3RlbmVyID0gbm9vcDtcXG5cXG5wcm9jZXNzLmxpc3RlbmVycyA9IGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiBbXSB9XFxuXFxucHJvY2Vzcy5iaW5kaW5nID0gZnVuY3Rpb24gKG5hbWUpIHtcXG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZCcpO1xcbn07XFxuXFxucHJvY2Vzcy5jd2QgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnLycgfTtcXG5wcm9jZXNzLmNoZGlyID0gZnVuY3Rpb24gKGRpcikge1xcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuY2hkaXIgaXMgbm90IHN1cHBvcnRlZCcpO1xcbn07XFxucHJvY2Vzcy51bWFzayA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gMDsgfTtcXG5cXG59LHt9XSw4MzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XFxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2xpYi9fc3RyZWFtX2R1cGxleC5qcycpO1xcblxcbn0se1xcXCIuL2xpYi9fc3RyZWFtX2R1cGxleC5qc1xcXCI6ODR9XSw4NDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XFxuLy8gYSBkdXBsZXggc3RyZWFtIGlzIGp1c3QgYSBzdHJlYW0gdGhhdCBpcyBib3RoIHJlYWRhYmxlIGFuZCB3cml0YWJsZS5cXG4vLyBTaW5jZSBKUyBkb2Vzbid0IGhhdmUgbXVsdGlwbGUgcHJvdG90eXBhbCBpbmhlcml0YW5jZSwgdGhpcyBjbGFzc1xcbi8vIHByb3RvdHlwYWxseSBpbmhlcml0cyBmcm9tIFJlYWRhYmxlLCBhbmQgdGhlbiBwYXJhc2l0aWNhbGx5IGZyb21cXG4vLyBXcml0YWJsZS5cXG5cXG4ndXNlIHN0cmljdCc7XFxuXFxuLyo8cmVwbGFjZW1lbnQ+Ki9cXG5cXG52YXIgb2JqZWN0S2V5cyA9IE9iamVjdC5rZXlzIHx8IGZ1bmN0aW9uIChvYmopIHtcXG4gIHZhciBrZXlzID0gW107XFxuICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XFxuICAgIGtleXMucHVzaChrZXkpO1xcbiAgfXJldHVybiBrZXlzO1xcbn07XFxuLyo8L3JlcGxhY2VtZW50PiovXFxuXFxubW9kdWxlLmV4cG9ydHMgPSBEdXBsZXg7XFxuXFxuLyo8cmVwbGFjZW1lbnQ+Ki9cXG52YXIgcHJvY2Vzc05leHRUaWNrID0gcmVxdWlyZSgncHJvY2Vzcy1uZXh0aWNrLWFyZ3MnKTtcXG4vKjwvcmVwbGFjZW1lbnQ+Ki9cXG5cXG4vKjxyZXBsYWNlbWVudD4qL1xcbnZhciB1dGlsID0gcmVxdWlyZSgnY29yZS11dGlsLWlzJyk7XFxudXRpbC5pbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XFxuLyo8L3JlcGxhY2VtZW50PiovXFxuXFxudmFyIFJlYWRhYmxlID0gcmVxdWlyZSgnLi9fc3RyZWFtX3JlYWRhYmxlJyk7XFxudmFyIFdyaXRhYmxlID0gcmVxdWlyZSgnLi9fc3RyZWFtX3dyaXRhYmxlJyk7XFxuXFxudXRpbC5pbmhlcml0cyhEdXBsZXgsIFJlYWRhYmxlKTtcXG5cXG52YXIga2V5cyA9IG9iamVjdEtleXMoV3JpdGFibGUucHJvdG90eXBlKTtcXG5mb3IgKHZhciB2ID0gMDsgdiA8IGtleXMubGVuZ3RoOyB2KyspIHtcXG4gIHZhciBtZXRob2QgPSBrZXlzW3ZdO1xcbiAgaWYgKCFEdXBsZXgucHJvdG90eXBlW21ldGhvZF0pIER1cGxleC5wcm90b3R5cGVbbWV0aG9kXSA9IFdyaXRhYmxlLnByb3RvdHlwZVttZXRob2RdO1xcbn1cXG5cXG5mdW5jdGlvbiBEdXBsZXgob3B0aW9ucykge1xcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIER1cGxleCkpIHJldHVybiBuZXcgRHVwbGV4KG9wdGlvbnMpO1xcblxcbiAgUmVhZGFibGUuY2FsbCh0aGlzLCBvcHRpb25zKTtcXG4gIFdyaXRhYmxlLmNhbGwodGhpcywgb3B0aW9ucyk7XFxuXFxuICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLnJlYWRhYmxlID09PSBmYWxzZSkgdGhpcy5yZWFkYWJsZSA9IGZhbHNlO1xcblxcbiAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy53cml0YWJsZSA9PT0gZmFsc2UpIHRoaXMud3JpdGFibGUgPSBmYWxzZTtcXG5cXG4gIHRoaXMuYWxsb3dIYWxmT3BlbiA9IHRydWU7XFxuICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLmFsbG93SGFsZk9wZW4gPT09IGZhbHNlKSB0aGlzLmFsbG93SGFsZk9wZW4gPSBmYWxzZTtcXG5cXG4gIHRoaXMub25jZSgnZW5kJywgb25lbmQpO1xcbn1cXG5cXG4vLyB0aGUgbm8taGFsZi1vcGVuIGVuZm9yY2VyXFxuZnVuY3Rpb24gb25lbmQoKSB7XFxuICAvLyBpZiB3ZSBhbGxvdyBoYWxmLW9wZW4gc3RhdGUsIG9yIGlmIHRoZSB3cml0YWJsZSBzaWRlIGVuZGVkLFxcbiAgLy8gdGhlbiB3ZSdyZSBvay5cXG4gIGlmICh0aGlzLmFsbG93SGFsZk9wZW4gfHwgdGhpcy5fd3JpdGFibGVTdGF0ZS5lbmRlZCkgcmV0dXJuO1xcblxcbiAgLy8gbm8gbW9yZSBkYXRhIGNhbiBiZSB3cml0dGVuLlxcbiAgLy8gQnV0IGFsbG93IG1vcmUgd3JpdGVzIHRvIGhhcHBlbiBpbiB0aGlzIHRpY2suXFxuICBwcm9jZXNzTmV4dFRpY2sob25FbmROVCwgdGhpcyk7XFxufVxcblxcbmZ1bmN0aW9uIG9uRW5kTlQoc2VsZikge1xcbiAgc2VsZi5lbmQoKTtcXG59XFxuXFxuZnVuY3Rpb24gZm9yRWFjaCh4cywgZikge1xcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSB4cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcXG4gICAgZih4c1tpXSwgaSk7XFxuICB9XFxufVxcbn0se1xcXCIuL19zdHJlYW1fcmVhZGFibGVcXFwiOjg2LFxcXCIuL19zdHJlYW1fd3JpdGFibGVcXFwiOjg4LFxcXCJjb3JlLXV0aWwtaXNcXFwiOjQ0LFxcXCJpbmhlcml0c1xcXCI6NjYsXFxcInByb2Nlc3MtbmV4dGljay1hcmdzXFxcIjo4MX1dLDg1OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcXG4vLyBhIHBhc3N0aHJvdWdoIHN0cmVhbS5cXG4vLyBiYXNpY2FsbHkganVzdCB0aGUgbW9zdCBtaW5pbWFsIHNvcnQgb2YgVHJhbnNmb3JtIHN0cmVhbS5cXG4vLyBFdmVyeSB3cml0dGVuIGNodW5rIGdldHMgb3V0cHV0IGFzLWlzLlxcblxcbid1c2Ugc3RyaWN0JztcXG5cXG5tb2R1bGUuZXhwb3J0cyA9IFBhc3NUaHJvdWdoO1xcblxcbnZhciBUcmFuc2Zvcm0gPSByZXF1aXJlKCcuL19zdHJlYW1fdHJhbnNmb3JtJyk7XFxuXFxuLyo8cmVwbGFjZW1lbnQ+Ki9cXG52YXIgdXRpbCA9IHJlcXVpcmUoJ2NvcmUtdXRpbC1pcycpO1xcbnV0aWwuaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xcbi8qPC9yZXBsYWNlbWVudD4qL1xcblxcbnV0aWwuaW5oZXJpdHMoUGFzc1Rocm91Z2gsIFRyYW5zZm9ybSk7XFxuXFxuZnVuY3Rpb24gUGFzc1Rocm91Z2gob3B0aW9ucykge1xcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFBhc3NUaHJvdWdoKSkgcmV0dXJuIG5ldyBQYXNzVGhyb3VnaChvcHRpb25zKTtcXG5cXG4gIFRyYW5zZm9ybS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xcbn1cXG5cXG5QYXNzVGhyb3VnaC5wcm90b3R5cGUuX3RyYW5zZm9ybSA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcsIGNiKSB7XFxuICBjYihudWxsLCBjaHVuayk7XFxufTtcXG59LHtcXFwiLi9fc3RyZWFtX3RyYW5zZm9ybVxcXCI6ODcsXFxcImNvcmUtdXRpbC1pc1xcXCI6NDQsXFxcImluaGVyaXRzXFxcIjo2Nn1dLDg2OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcXG4oZnVuY3Rpb24gKHByb2Nlc3Mpe1xcbid1c2Ugc3RyaWN0JztcXG5cXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWRhYmxlO1xcblxcbi8qPHJlcGxhY2VtZW50PiovXFxudmFyIHByb2Nlc3NOZXh0VGljayA9IHJlcXVpcmUoJ3Byb2Nlc3MtbmV4dGljay1hcmdzJyk7XFxuLyo8L3JlcGxhY2VtZW50PiovXFxuXFxuLyo8cmVwbGFjZW1lbnQ+Ki9cXG52YXIgaXNBcnJheSA9IHJlcXVpcmUoJ2lzYXJyYXknKTtcXG4vKjwvcmVwbGFjZW1lbnQ+Ki9cXG5cXG4vKjxyZXBsYWNlbWVudD4qL1xcbnZhciBEdXBsZXg7XFxuLyo8L3JlcGxhY2VtZW50PiovXFxuXFxuUmVhZGFibGUuUmVhZGFibGVTdGF0ZSA9IFJlYWRhYmxlU3RhdGU7XFxuXFxuLyo8cmVwbGFjZW1lbnQ+Ki9cXG52YXIgRUUgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXI7XFxuXFxudmFyIEVFbGlzdGVuZXJDb3VudCA9IGZ1bmN0aW9uIChlbWl0dGVyLCB0eXBlKSB7XFxuICByZXR1cm4gZW1pdHRlci5saXN0ZW5lcnModHlwZSkubGVuZ3RoO1xcbn07XFxuLyo8L3JlcGxhY2VtZW50PiovXFxuXFxuLyo8cmVwbGFjZW1lbnQ+Ki9cXG52YXIgU3RyZWFtID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9zdHJlYW1zL3N0cmVhbScpO1xcbi8qPC9yZXBsYWNlbWVudD4qL1xcblxcbi8qPHJlcGxhY2VtZW50PiovXFxudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ3NhZmUtYnVmZmVyJykuQnVmZmVyO1xcbi8qPC9yZXBsYWNlbWVudD4qL1xcblxcbi8qPHJlcGxhY2VtZW50PiovXFxudmFyIHV0aWwgPSByZXF1aXJlKCdjb3JlLXV0aWwtaXMnKTtcXG51dGlsLmluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcXG4vKjwvcmVwbGFjZW1lbnQ+Ki9cXG5cXG4vKjxyZXBsYWNlbWVudD4qL1xcbnZhciBkZWJ1Z1V0aWwgPSByZXF1aXJlKCd1dGlsJyk7XFxudmFyIGRlYnVnID0gdm9pZCAwO1xcbmlmIChkZWJ1Z1V0aWwgJiYgZGVidWdVdGlsLmRlYnVnbG9nKSB7XFxuICBkZWJ1ZyA9IGRlYnVnVXRpbC5kZWJ1Z2xvZygnc3RyZWFtJyk7XFxufSBlbHNlIHtcXG4gIGRlYnVnID0gZnVuY3Rpb24gKCkge307XFxufVxcbi8qPC9yZXBsYWNlbWVudD4qL1xcblxcbnZhciBCdWZmZXJMaXN0ID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9zdHJlYW1zL0J1ZmZlckxpc3QnKTtcXG52YXIgU3RyaW5nRGVjb2RlcjtcXG5cXG51dGlsLmluaGVyaXRzKFJlYWRhYmxlLCBTdHJlYW0pO1xcblxcbnZhciBrUHJveHlFdmVudHMgPSBbJ2Vycm9yJywgJ2Nsb3NlJywgJ2Rlc3Ryb3knLCAncGF1c2UnLCAncmVzdW1lJ107XFxuXFxuZnVuY3Rpb24gcHJlcGVuZExpc3RlbmVyKGVtaXR0ZXIsIGV2ZW50LCBmbikge1xcbiAgLy8gU2FkbHkgdGhpcyBpcyBub3QgY2FjaGVhYmxlIGFzIHNvbWUgbGlicmFyaWVzIGJ1bmRsZSB0aGVpciBvd25cXG4gIC8vIGV2ZW50IGVtaXR0ZXIgaW1wbGVtZW50YXRpb24gd2l0aCB0aGVtLlxcbiAgaWYgKHR5cGVvZiBlbWl0dGVyLnByZXBlbmRMaXN0ZW5lciA9PT0gJ2Z1bmN0aW9uJykge1xcbiAgICByZXR1cm4gZW1pdHRlci5wcmVwZW5kTGlzdGVuZXIoZXZlbnQsIGZuKTtcXG4gIH0gZWxzZSB7XFxuICAgIC8vIFRoaXMgaXMgYSBoYWNrIHRvIG1ha2Ugc3VyZSB0aGF0IG91ciBlcnJvciBoYW5kbGVyIGlzIGF0dGFjaGVkIGJlZm9yZSBhbnlcXG4gICAgLy8gdXNlcmxhbmQgb25lcy4gIE5FVkVSIERPIFRISVMuIFRoaXMgaXMgaGVyZSBvbmx5IGJlY2F1c2UgdGhpcyBjb2RlIG5lZWRzXFxuICAgIC8vIHRvIGNvbnRpbnVlIHRvIHdvcmsgd2l0aCBvbGRlciB2ZXJzaW9ucyBvZiBOb2RlLmpzIHRoYXQgZG8gbm90IGluY2x1ZGVcXG4gICAgLy8gdGhlIHByZXBlbmRMaXN0ZW5lcigpIG1ldGhvZC4gVGhlIGdvYWwgaXMgdG8gZXZlbnR1YWxseSByZW1vdmUgdGhpcyBoYWNrLlxcbiAgICBpZiAoIWVtaXR0ZXIuX2V2ZW50cyB8fCAhZW1pdHRlci5fZXZlbnRzW2V2ZW50XSkgZW1pdHRlci5vbihldmVudCwgZm4pO2Vsc2UgaWYgKGlzQXJyYXkoZW1pdHRlci5fZXZlbnRzW2V2ZW50XSkpIGVtaXR0ZXIuX2V2ZW50c1tldmVudF0udW5zaGlmdChmbik7ZWxzZSBlbWl0dGVyLl9ldmVudHNbZXZlbnRdID0gW2ZuLCBlbWl0dGVyLl9ldmVudHNbZXZlbnRdXTtcXG4gIH1cXG59XFxuXFxuZnVuY3Rpb24gUmVhZGFibGVTdGF0ZShvcHRpb25zLCBzdHJlYW0pIHtcXG4gIER1cGxleCA9IER1cGxleCB8fCByZXF1aXJlKCcuL19zdHJlYW1fZHVwbGV4Jyk7XFxuXFxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcXG5cXG4gIC8vIG9iamVjdCBzdHJlYW0gZmxhZy4gVXNlZCB0byBtYWtlIHJlYWQobikgaWdub3JlIG4gYW5kIHRvXFxuICAvLyBtYWtlIGFsbCB0aGUgYnVmZmVyIG1lcmdpbmcgYW5kIGxlbmd0aCBjaGVja3MgZ28gYXdheVxcbiAgdGhpcy5vYmplY3RNb2RlID0gISFvcHRpb25zLm9iamVjdE1vZGU7XFxuXFxuICBpZiAoc3RyZWFtIGluc3RhbmNlb2YgRHVwbGV4KSB0aGlzLm9iamVjdE1vZGUgPSB0aGlzLm9iamVjdE1vZGUgfHwgISFvcHRpb25zLnJlYWRhYmxlT2JqZWN0TW9kZTtcXG5cXG4gIC8vIHRoZSBwb2ludCBhdCB3aGljaCBpdCBzdG9wcyBjYWxsaW5nIF9yZWFkKCkgdG8gZmlsbCB0aGUgYnVmZmVyXFxuICAvLyBOb3RlOiAwIGlzIGEgdmFsaWQgdmFsdWUsIG1lYW5zIFxcXCJkb24ndCBjYWxsIF9yZWFkIHByZWVtcHRpdmVseSBldmVyXFxcIlxcbiAgdmFyIGh3bSA9IG9wdGlvbnMuaGlnaFdhdGVyTWFyaztcXG4gIHZhciBkZWZhdWx0SHdtID0gdGhpcy5vYmplY3RNb2RlID8gMTYgOiAxNiAqIDEwMjQ7XFxuICB0aGlzLmhpZ2hXYXRlck1hcmsgPSBod20gfHwgaHdtID09PSAwID8gaHdtIDogZGVmYXVsdEh3bTtcXG5cXG4gIC8vIGNhc3QgdG8gaW50cy5cXG4gIHRoaXMuaGlnaFdhdGVyTWFyayA9IH5+dGhpcy5oaWdoV2F0ZXJNYXJrO1xcblxcbiAgLy8gQSBsaW5rZWQgbGlzdCBpcyB1c2VkIHRvIHN0b3JlIGRhdGEgY2h1bmtzIGluc3RlYWQgb2YgYW4gYXJyYXkgYmVjYXVzZSB0aGVcXG4gIC8vIGxpbmtlZCBsaXN0IGNhbiByZW1vdmUgZWxlbWVudHMgZnJvbSB0aGUgYmVnaW5uaW5nIGZhc3RlciB0aGFuXFxuICAvLyBhcnJheS5zaGlmdCgpXFxuICB0aGlzLmJ1ZmZlciA9IG5ldyBCdWZmZXJMaXN0KCk7XFxuICB0aGlzLmxlbmd0aCA9IDA7XFxuICB0aGlzLnBpcGVzID0gbnVsbDtcXG4gIHRoaXMucGlwZXNDb3VudCA9IDA7XFxuICB0aGlzLmZsb3dpbmcgPSBudWxsO1xcbiAgdGhpcy5lbmRlZCA9IGZhbHNlO1xcbiAgdGhpcy5lbmRFbWl0dGVkID0gZmFsc2U7XFxuICB0aGlzLnJlYWRpbmcgPSBmYWxzZTtcXG5cXG4gIC8vIGEgZmxhZyB0byBiZSBhYmxlIHRvIHRlbGwgaWYgdGhlIG9ud3JpdGUgY2IgaXMgY2FsbGVkIGltbWVkaWF0ZWx5LFxcbiAgLy8gb3Igb24gYSBsYXRlciB0aWNrLiAgV2Ugc2V0IHRoaXMgdG8gdHJ1ZSBhdCBmaXJzdCwgYmVjYXVzZSBhbnlcXG4gIC8vIGFjdGlvbnMgdGhhdCBzaG91bGRuJ3QgaGFwcGVuIHVudGlsIFxcXCJsYXRlclxcXCIgc2hvdWxkIGdlbmVyYWxseSBhbHNvXFxuICAvLyBub3QgaGFwcGVuIGJlZm9yZSB0aGUgZmlyc3Qgd3JpdGUgY2FsbC5cXG4gIHRoaXMuc3luYyA9IHRydWU7XFxuXFxuICAvLyB3aGVuZXZlciB3ZSByZXR1cm4gbnVsbCwgdGhlbiB3ZSBzZXQgYSBmbGFnIHRvIHNheVxcbiAgLy8gdGhhdCB3ZSdyZSBhd2FpdGluZyBhICdyZWFkYWJsZScgZXZlbnQgZW1pc3Npb24uXFxuICB0aGlzLm5lZWRSZWFkYWJsZSA9IGZhbHNlO1xcbiAgdGhpcy5lbWl0dGVkUmVhZGFibGUgPSBmYWxzZTtcXG4gIHRoaXMucmVhZGFibGVMaXN0ZW5pbmcgPSBmYWxzZTtcXG4gIHRoaXMucmVzdW1lU2NoZWR1bGVkID0gZmFsc2U7XFxuXFxuICAvLyBDcnlwdG8gaXMga2luZCBvZiBvbGQgYW5kIGNydXN0eS4gIEhpc3RvcmljYWxseSwgaXRzIGRlZmF1bHQgc3RyaW5nXFxuICAvLyBlbmNvZGluZyBpcyAnYmluYXJ5JyBzbyB3ZSBoYXZlIHRvIG1ha2UgdGhpcyBjb25maWd1cmFibGUuXFxuICAvLyBFdmVyeXRoaW5nIGVsc2UgaW4gdGhlIHVuaXZlcnNlIHVzZXMgJ3V0ZjgnLCB0aG91Z2guXFxuICB0aGlzLmRlZmF1bHRFbmNvZGluZyA9IG9wdGlvbnMuZGVmYXVsdEVuY29kaW5nIHx8ICd1dGY4JztcXG5cXG4gIC8vIHdoZW4gcGlwaW5nLCB3ZSBvbmx5IGNhcmUgYWJvdXQgJ3JlYWRhYmxlJyBldmVudHMgdGhhdCBoYXBwZW5cXG4gIC8vIGFmdGVyIHJlYWQoKWluZyBhbGwgdGhlIGJ5dGVzIGFuZCBub3QgZ2V0dGluZyBhbnkgcHVzaGJhY2suXFxuICB0aGlzLnJhbk91dCA9IGZhbHNlO1xcblxcbiAgLy8gdGhlIG51bWJlciBvZiB3cml0ZXJzIHRoYXQgYXJlIGF3YWl0aW5nIGEgZHJhaW4gZXZlbnQgaW4gLnBpcGUoKXNcXG4gIHRoaXMuYXdhaXREcmFpbiA9IDA7XFxuXFxuICAvLyBpZiB0cnVlLCBhIG1heWJlUmVhZE1vcmUgaGFzIGJlZW4gc2NoZWR1bGVkXFxuICB0aGlzLnJlYWRpbmdNb3JlID0gZmFsc2U7XFxuXFxuICB0aGlzLmRlY29kZXIgPSBudWxsO1xcbiAgdGhpcy5lbmNvZGluZyA9IG51bGw7XFxuICBpZiAob3B0aW9ucy5lbmNvZGluZykge1xcbiAgICBpZiAoIVN0cmluZ0RlY29kZXIpIFN0cmluZ0RlY29kZXIgPSByZXF1aXJlKCdzdHJpbmdfZGVjb2Rlci8nKS5TdHJpbmdEZWNvZGVyO1xcbiAgICB0aGlzLmRlY29kZXIgPSBuZXcgU3RyaW5nRGVjb2RlcihvcHRpb25zLmVuY29kaW5nKTtcXG4gICAgdGhpcy5lbmNvZGluZyA9IG9wdGlvbnMuZW5jb2Rpbmc7XFxuICB9XFxufVxcblxcbmZ1bmN0aW9uIFJlYWRhYmxlKG9wdGlvbnMpIHtcXG4gIER1cGxleCA9IER1cGxleCB8fCByZXF1aXJlKCcuL19zdHJlYW1fZHVwbGV4Jyk7XFxuXFxuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgUmVhZGFibGUpKSByZXR1cm4gbmV3IFJlYWRhYmxlKG9wdGlvbnMpO1xcblxcbiAgdGhpcy5fcmVhZGFibGVTdGF0ZSA9IG5ldyBSZWFkYWJsZVN0YXRlKG9wdGlvbnMsIHRoaXMpO1xcblxcbiAgLy8gbGVnYWN5XFxuICB0aGlzLnJlYWRhYmxlID0gdHJ1ZTtcXG5cXG4gIGlmIChvcHRpb25zICYmIHR5cGVvZiBvcHRpb25zLnJlYWQgPT09ICdmdW5jdGlvbicpIHRoaXMuX3JlYWQgPSBvcHRpb25zLnJlYWQ7XFxuXFxuICBTdHJlYW0uY2FsbCh0aGlzKTtcXG59XFxuXFxuLy8gTWFudWFsbHkgc2hvdmUgc29tZXRoaW5nIGludG8gdGhlIHJlYWQoKSBidWZmZXIuXFxuLy8gVGhpcyByZXR1cm5zIHRydWUgaWYgdGhlIGhpZ2hXYXRlck1hcmsgaGFzIG5vdCBiZWVuIGhpdCB5ZXQsXFxuLy8gc2ltaWxhciB0byBob3cgV3JpdGFibGUud3JpdGUoKSByZXR1cm5zIHRydWUgaWYgeW91IHNob3VsZFxcbi8vIHdyaXRlKCkgc29tZSBtb3JlLlxcblJlYWRhYmxlLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZykge1xcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcXG5cXG4gIGlmICghc3RhdGUub2JqZWN0TW9kZSAmJiB0eXBlb2YgY2h1bmsgPT09ICdzdHJpbmcnKSB7XFxuICAgIGVuY29kaW5nID0gZW5jb2RpbmcgfHwgc3RhdGUuZGVmYXVsdEVuY29kaW5nO1xcbiAgICBpZiAoZW5jb2RpbmcgIT09IHN0YXRlLmVuY29kaW5nKSB7XFxuICAgICAgY2h1bmsgPSBCdWZmZXIuZnJvbShjaHVuaywgZW5jb2RpbmcpO1xcbiAgICAgIGVuY29kaW5nID0gJyc7XFxuICAgIH1cXG4gIH1cXG5cXG4gIHJldHVybiByZWFkYWJsZUFkZENodW5rKHRoaXMsIHN0YXRlLCBjaHVuaywgZW5jb2RpbmcsIGZhbHNlKTtcXG59O1xcblxcbi8vIFVuc2hpZnQgc2hvdWxkICphbHdheXMqIGJlIHNvbWV0aGluZyBkaXJlY3RseSBvdXQgb2YgcmVhZCgpXFxuUmVhZGFibGUucHJvdG90eXBlLnVuc2hpZnQgPSBmdW5jdGlvbiAoY2h1bmspIHtcXG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XFxuICByZXR1cm4gcmVhZGFibGVBZGRDaHVuayh0aGlzLCBzdGF0ZSwgY2h1bmssICcnLCB0cnVlKTtcXG59O1xcblxcblJlYWRhYmxlLnByb3RvdHlwZS5pc1BhdXNlZCA9IGZ1bmN0aW9uICgpIHtcXG4gIHJldHVybiB0aGlzLl9yZWFkYWJsZVN0YXRlLmZsb3dpbmcgPT09IGZhbHNlO1xcbn07XFxuXFxuZnVuY3Rpb24gcmVhZGFibGVBZGRDaHVuayhzdHJlYW0sIHN0YXRlLCBjaHVuaywgZW5jb2RpbmcsIGFkZFRvRnJvbnQpIHtcXG4gIHZhciBlciA9IGNodW5rSW52YWxpZChzdGF0ZSwgY2h1bmspO1xcbiAgaWYgKGVyKSB7XFxuICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVyKTtcXG4gIH0gZWxzZSBpZiAoY2h1bmsgPT09IG51bGwpIHtcXG4gICAgc3RhdGUucmVhZGluZyA9IGZhbHNlO1xcbiAgICBvbkVvZkNodW5rKHN0cmVhbSwgc3RhdGUpO1xcbiAgfSBlbHNlIGlmIChzdGF0ZS5vYmplY3RNb2RlIHx8IGNodW5rICYmIGNodW5rLmxlbmd0aCA+IDApIHtcXG4gICAgaWYgKHN0YXRlLmVuZGVkICYmICFhZGRUb0Zyb250KSB7XFxuICAgICAgdmFyIGUgPSBuZXcgRXJyb3IoJ3N0cmVhbS5wdXNoKCkgYWZ0ZXIgRU9GJyk7XFxuICAgICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgZSk7XFxuICAgIH0gZWxzZSBpZiAoc3RhdGUuZW5kRW1pdHRlZCAmJiBhZGRUb0Zyb250KSB7XFxuICAgICAgdmFyIF9lID0gbmV3IEVycm9yKCdzdHJlYW0udW5zaGlmdCgpIGFmdGVyIGVuZCBldmVudCcpO1xcbiAgICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIF9lKTtcXG4gICAgfSBlbHNlIHtcXG4gICAgICB2YXIgc2tpcEFkZDtcXG4gICAgICBpZiAoc3RhdGUuZGVjb2RlciAmJiAhYWRkVG9Gcm9udCAmJiAhZW5jb2RpbmcpIHtcXG4gICAgICAgIGNodW5rID0gc3RhdGUuZGVjb2Rlci53cml0ZShjaHVuayk7XFxuICAgICAgICBza2lwQWRkID0gIXN0YXRlLm9iamVjdE1vZGUgJiYgY2h1bmsubGVuZ3RoID09PSAwO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAoIWFkZFRvRnJvbnQpIHN0YXRlLnJlYWRpbmcgPSBmYWxzZTtcXG5cXG4gICAgICAvLyBEb24ndCBhZGQgdG8gdGhlIGJ1ZmZlciBpZiB3ZSd2ZSBkZWNvZGVkIHRvIGFuIGVtcHR5IHN0cmluZyBjaHVuayBhbmRcXG4gICAgICAvLyB3ZSdyZSBub3QgaW4gb2JqZWN0IG1vZGVcXG4gICAgICBpZiAoIXNraXBBZGQpIHtcXG4gICAgICAgIC8vIGlmIHdlIHdhbnQgdGhlIGRhdGEgbm93LCBqdXN0IGVtaXQgaXQuXFxuICAgICAgICBpZiAoc3RhdGUuZmxvd2luZyAmJiBzdGF0ZS5sZW5ndGggPT09IDAgJiYgIXN0YXRlLnN5bmMpIHtcXG4gICAgICAgICAgc3RyZWFtLmVtaXQoJ2RhdGEnLCBjaHVuayk7XFxuICAgICAgICAgIHN0cmVhbS5yZWFkKDApO1xcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgLy8gdXBkYXRlIHRoZSBidWZmZXIgaW5mby5cXG4gICAgICAgICAgc3RhdGUubGVuZ3RoICs9IHN0YXRlLm9iamVjdE1vZGUgPyAxIDogY2h1bmsubGVuZ3RoO1xcbiAgICAgICAgICBpZiAoYWRkVG9Gcm9udCkgc3RhdGUuYnVmZmVyLnVuc2hpZnQoY2h1bmspO2Vsc2Ugc3RhdGUuYnVmZmVyLnB1c2goY2h1bmspO1xcblxcbiAgICAgICAgICBpZiAoc3RhdGUubmVlZFJlYWRhYmxlKSBlbWl0UmVhZGFibGUoc3RyZWFtKTtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuXFxuICAgICAgbWF5YmVSZWFkTW9yZShzdHJlYW0sIHN0YXRlKTtcXG4gICAgfVxcbiAgfSBlbHNlIGlmICghYWRkVG9Gcm9udCkge1xcbiAgICBzdGF0ZS5yZWFkaW5nID0gZmFsc2U7XFxuICB9XFxuXFxuICByZXR1cm4gbmVlZE1vcmVEYXRhKHN0YXRlKTtcXG59XFxuXFxuLy8gaWYgaXQncyBwYXN0IHRoZSBoaWdoIHdhdGVyIG1hcmssIHdlIGNhbiBwdXNoIGluIHNvbWUgbW9yZS5cXG4vLyBBbHNvLCBpZiB3ZSBoYXZlIG5vIGRhdGEgeWV0LCB3ZSBjYW4gc3RhbmQgc29tZVxcbi8vIG1vcmUgYnl0ZXMuICBUaGlzIGlzIHRvIHdvcmsgYXJvdW5kIGNhc2VzIHdoZXJlIGh3bT0wLFxcbi8vIHN1Y2ggYXMgdGhlIHJlcGwuICBBbHNvLCBpZiB0aGUgcHVzaCgpIHRyaWdnZXJlZCBhXFxuLy8gcmVhZGFibGUgZXZlbnQsIGFuZCB0aGUgdXNlciBjYWxsZWQgcmVhZChsYXJnZU51bWJlcikgc3VjaCB0aGF0XFxuLy8gbmVlZFJlYWRhYmxlIHdhcyBzZXQsIHRoZW4gd2Ugb3VnaHQgdG8gcHVzaCBtb3JlLCBzbyB0aGF0IGFub3RoZXJcXG4vLyAncmVhZGFibGUnIGV2ZW50IHdpbGwgYmUgdHJpZ2dlcmVkLlxcbmZ1bmN0aW9uIG5lZWRNb3JlRGF0YShzdGF0ZSkge1xcbiAgcmV0dXJuICFzdGF0ZS5lbmRlZCAmJiAoc3RhdGUubmVlZFJlYWRhYmxlIHx8IHN0YXRlLmxlbmd0aCA8IHN0YXRlLmhpZ2hXYXRlck1hcmsgfHwgc3RhdGUubGVuZ3RoID09PSAwKTtcXG59XFxuXFxuLy8gYmFja3dhcmRzIGNvbXBhdGliaWxpdHkuXFxuUmVhZGFibGUucHJvdG90eXBlLnNldEVuY29kaW5nID0gZnVuY3Rpb24gKGVuYykge1xcbiAgaWYgKCFTdHJpbmdEZWNvZGVyKSBTdHJpbmdEZWNvZGVyID0gcmVxdWlyZSgnc3RyaW5nX2RlY29kZXIvJykuU3RyaW5nRGVjb2RlcjtcXG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVjb2RlciA9IG5ldyBTdHJpbmdEZWNvZGVyKGVuYyk7XFxuICB0aGlzLl9yZWFkYWJsZVN0YXRlLmVuY29kaW5nID0gZW5jO1xcbiAgcmV0dXJuIHRoaXM7XFxufTtcXG5cXG4vLyBEb24ndCByYWlzZSB0aGUgaHdtID4gOE1CXFxudmFyIE1BWF9IV00gPSAweDgwMDAwMDtcXG5mdW5jdGlvbiBjb21wdXRlTmV3SGlnaFdhdGVyTWFyayhuKSB7XFxuICBpZiAobiA+PSBNQVhfSFdNKSB7XFxuICAgIG4gPSBNQVhfSFdNO1xcbiAgfSBlbHNlIHtcXG4gICAgLy8gR2V0IHRoZSBuZXh0IGhpZ2hlc3QgcG93ZXIgb2YgMiB0byBwcmV2ZW50IGluY3JlYXNpbmcgaHdtIGV4Y2Vzc2l2ZWx5IGluXFxuICAgIC8vIHRpbnkgYW1vdW50c1xcbiAgICBuLS07XFxuICAgIG4gfD0gbiA+Pj4gMTtcXG4gICAgbiB8PSBuID4+PiAyO1xcbiAgICBuIHw9IG4gPj4+IDQ7XFxuICAgIG4gfD0gbiA+Pj4gODtcXG4gICAgbiB8PSBuID4+PiAxNjtcXG4gICAgbisrO1xcbiAgfVxcbiAgcmV0dXJuIG47XFxufVxcblxcbi8vIFRoaXMgZnVuY3Rpb24gaXMgZGVzaWduZWQgdG8gYmUgaW5saW5hYmxlLCBzbyBwbGVhc2UgdGFrZSBjYXJlIHdoZW4gbWFraW5nXFxuLy8gY2hhbmdlcyB0byB0aGUgZnVuY3Rpb24gYm9keS5cXG5mdW5jdGlvbiBob3dNdWNoVG9SZWFkKG4sIHN0YXRlKSB7XFxuICBpZiAobiA8PSAwIHx8IHN0YXRlLmxlbmd0aCA9PT0gMCAmJiBzdGF0ZS5lbmRlZCkgcmV0dXJuIDA7XFxuICBpZiAoc3RhdGUub2JqZWN0TW9kZSkgcmV0dXJuIDE7XFxuICBpZiAobiAhPT0gbikge1xcbiAgICAvLyBPbmx5IGZsb3cgb25lIGJ1ZmZlciBhdCBhIHRpbWVcXG4gICAgaWYgKHN0YXRlLmZsb3dpbmcgJiYgc3RhdGUubGVuZ3RoKSByZXR1cm4gc3RhdGUuYnVmZmVyLmhlYWQuZGF0YS5sZW5ndGg7ZWxzZSByZXR1cm4gc3RhdGUubGVuZ3RoO1xcbiAgfVxcbiAgLy8gSWYgd2UncmUgYXNraW5nIGZvciBtb3JlIHRoYW4gdGhlIGN1cnJlbnQgaHdtLCB0aGVuIHJhaXNlIHRoZSBod20uXFxuICBpZiAobiA+IHN0YXRlLmhpZ2hXYXRlck1hcmspIHN0YXRlLmhpZ2hXYXRlck1hcmsgPSBjb21wdXRlTmV3SGlnaFdhdGVyTWFyayhuKTtcXG4gIGlmIChuIDw9IHN0YXRlLmxlbmd0aCkgcmV0dXJuIG47XFxuICAvLyBEb24ndCBoYXZlIGVub3VnaFxcbiAgaWYgKCFzdGF0ZS5lbmRlZCkge1xcbiAgICBzdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlO1xcbiAgICByZXR1cm4gMDtcXG4gIH1cXG4gIHJldHVybiBzdGF0ZS5sZW5ndGg7XFxufVxcblxcbi8vIHlvdSBjYW4gb3ZlcnJpZGUgZWl0aGVyIHRoaXMgbWV0aG9kLCBvciB0aGUgYXN5bmMgX3JlYWQobikgYmVsb3cuXFxuUmVhZGFibGUucHJvdG90eXBlLnJlYWQgPSBmdW5jdGlvbiAobikge1xcbiAgZGVidWcoJ3JlYWQnLCBuKTtcXG4gIG4gPSBwYXJzZUludChuLCAxMCk7XFxuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xcbiAgdmFyIG5PcmlnID0gbjtcXG5cXG4gIGlmIChuICE9PSAwKSBzdGF0ZS5lbWl0dGVkUmVhZGFibGUgPSBmYWxzZTtcXG5cXG4gIC8vIGlmIHdlJ3JlIGRvaW5nIHJlYWQoMCkgdG8gdHJpZ2dlciBhIHJlYWRhYmxlIGV2ZW50LCBidXQgd2VcXG4gIC8vIGFscmVhZHkgaGF2ZSBhIGJ1bmNoIG9mIGRhdGEgaW4gdGhlIGJ1ZmZlciwgdGhlbiBqdXN0IHRyaWdnZXJcXG4gIC8vIHRoZSAncmVhZGFibGUnIGV2ZW50IGFuZCBtb3ZlIG9uLlxcbiAgaWYgKG4gPT09IDAgJiYgc3RhdGUubmVlZFJlYWRhYmxlICYmIChzdGF0ZS5sZW5ndGggPj0gc3RhdGUuaGlnaFdhdGVyTWFyayB8fCBzdGF0ZS5lbmRlZCkpIHtcXG4gICAgZGVidWcoJ3JlYWQ6IGVtaXRSZWFkYWJsZScsIHN0YXRlLmxlbmd0aCwgc3RhdGUuZW5kZWQpO1xcbiAgICBpZiAoc3RhdGUubGVuZ3RoID09PSAwICYmIHN0YXRlLmVuZGVkKSBlbmRSZWFkYWJsZSh0aGlzKTtlbHNlIGVtaXRSZWFkYWJsZSh0aGlzKTtcXG4gICAgcmV0dXJuIG51bGw7XFxuICB9XFxuXFxuICBuID0gaG93TXVjaFRvUmVhZChuLCBzdGF0ZSk7XFxuXFxuICAvLyBpZiB3ZSd2ZSBlbmRlZCwgYW5kIHdlJ3JlIG5vdyBjbGVhciwgdGhlbiBmaW5pc2ggaXQgdXAuXFxuICBpZiAobiA9PT0gMCAmJiBzdGF0ZS5lbmRlZCkge1xcbiAgICBpZiAoc3RhdGUubGVuZ3RoID09PSAwKSBlbmRSZWFkYWJsZSh0aGlzKTtcXG4gICAgcmV0dXJuIG51bGw7XFxuICB9XFxuXFxuICAvLyBBbGwgdGhlIGFjdHVhbCBjaHVuayBnZW5lcmF0aW9uIGxvZ2ljIG5lZWRzIHRvIGJlXFxuICAvLyAqYmVsb3cqIHRoZSBjYWxsIHRvIF9yZWFkLiAgVGhlIHJlYXNvbiBpcyB0aGF0IGluIGNlcnRhaW5cXG4gIC8vIHN5bnRoZXRpYyBzdHJlYW0gY2FzZXMsIHN1Y2ggYXMgcGFzc3Rocm91Z2ggc3RyZWFtcywgX3JlYWRcXG4gIC8vIG1heSBiZSBhIGNvbXBsZXRlbHkgc3luY2hyb25vdXMgb3BlcmF0aW9uIHdoaWNoIG1heSBjaGFuZ2VcXG4gIC8vIHRoZSBzdGF0ZSBvZiB0aGUgcmVhZCBidWZmZXIsIHByb3ZpZGluZyBlbm91Z2ggZGF0YSB3aGVuXFxuICAvLyBiZWZvcmUgdGhlcmUgd2FzICpub3QqIGVub3VnaC5cXG4gIC8vXFxuICAvLyBTbywgdGhlIHN0ZXBzIGFyZTpcXG4gIC8vIDEuIEZpZ3VyZSBvdXQgd2hhdCB0aGUgc3RhdGUgb2YgdGhpbmdzIHdpbGwgYmUgYWZ0ZXIgd2UgZG9cXG4gIC8vIGEgcmVhZCBmcm9tIHRoZSBidWZmZXIuXFxuICAvL1xcbiAgLy8gMi4gSWYgdGhhdCByZXN1bHRpbmcgc3RhdGUgd2lsbCB0cmlnZ2VyIGEgX3JlYWQsIHRoZW4gY2FsbCBfcmVhZC5cXG4gIC8vIE5vdGUgdGhhdCB0aGlzIG1heSBiZSBhc3luY2hyb25vdXMsIG9yIHN5bmNocm9ub3VzLiAgWWVzLCBpdCBpc1xcbiAgLy8gZGVlcGx5IHVnbHkgdG8gd3JpdGUgQVBJcyB0aGlzIHdheSwgYnV0IHRoYXQgc3RpbGwgZG9lc24ndCBtZWFuXFxuICAvLyB0aGF0IHRoZSBSZWFkYWJsZSBjbGFzcyBzaG91bGQgYmVoYXZlIGltcHJvcGVybHksIGFzIHN0cmVhbXMgYXJlXFxuICAvLyBkZXNpZ25lZCB0byBiZSBzeW5jL2FzeW5jIGFnbm9zdGljLlxcbiAgLy8gVGFrZSBub3RlIGlmIHRoZSBfcmVhZCBjYWxsIGlzIHN5bmMgb3IgYXN5bmMgKGllLCBpZiB0aGUgcmVhZCBjYWxsXFxuICAvLyBoYXMgcmV0dXJuZWQgeWV0KSwgc28gdGhhdCB3ZSBrbm93IHdoZXRoZXIgb3Igbm90IGl0J3Mgc2FmZSB0byBlbWl0XFxuICAvLyAncmVhZGFibGUnIGV0Yy5cXG4gIC8vXFxuICAvLyAzLiBBY3R1YWxseSBwdWxsIHRoZSByZXF1ZXN0ZWQgY2h1bmtzIG91dCBvZiB0aGUgYnVmZmVyIGFuZCByZXR1cm4uXFxuXFxuICAvLyBpZiB3ZSBuZWVkIGEgcmVhZGFibGUgZXZlbnQsIHRoZW4gd2UgbmVlZCB0byBkbyBzb21lIHJlYWRpbmcuXFxuICB2YXIgZG9SZWFkID0gc3RhdGUubmVlZFJlYWRhYmxlO1xcbiAgZGVidWcoJ25lZWQgcmVhZGFibGUnLCBkb1JlYWQpO1xcblxcbiAgLy8gaWYgd2UgY3VycmVudGx5IGhhdmUgbGVzcyB0aGFuIHRoZSBoaWdoV2F0ZXJNYXJrLCB0aGVuIGFsc28gcmVhZCBzb21lXFxuICBpZiAoc3RhdGUubGVuZ3RoID09PSAwIHx8IHN0YXRlLmxlbmd0aCAtIG4gPCBzdGF0ZS5oaWdoV2F0ZXJNYXJrKSB7XFxuICAgIGRvUmVhZCA9IHRydWU7XFxuICAgIGRlYnVnKCdsZW5ndGggbGVzcyB0aGFuIHdhdGVybWFyaycsIGRvUmVhZCk7XFxuICB9XFxuXFxuICAvLyBob3dldmVyLCBpZiB3ZSd2ZSBlbmRlZCwgdGhlbiB0aGVyZSdzIG5vIHBvaW50LCBhbmQgaWYgd2UncmUgYWxyZWFkeVxcbiAgLy8gcmVhZGluZywgdGhlbiBpdCdzIHVubmVjZXNzYXJ5LlxcbiAgaWYgKHN0YXRlLmVuZGVkIHx8IHN0YXRlLnJlYWRpbmcpIHtcXG4gICAgZG9SZWFkID0gZmFsc2U7XFxuICAgIGRlYnVnKCdyZWFkaW5nIG9yIGVuZGVkJywgZG9SZWFkKTtcXG4gIH0gZWxzZSBpZiAoZG9SZWFkKSB7XFxuICAgIGRlYnVnKCdkbyByZWFkJyk7XFxuICAgIHN0YXRlLnJlYWRpbmcgPSB0cnVlO1xcbiAgICBzdGF0ZS5zeW5jID0gdHJ1ZTtcXG4gICAgLy8gaWYgdGhlIGxlbmd0aCBpcyBjdXJyZW50bHkgemVybywgdGhlbiB3ZSAqbmVlZCogYSByZWFkYWJsZSBldmVudC5cXG4gICAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCkgc3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTtcXG4gICAgLy8gY2FsbCBpbnRlcm5hbCByZWFkIG1ldGhvZFxcbiAgICB0aGlzLl9yZWFkKHN0YXRlLmhpZ2hXYXRlck1hcmspO1xcbiAgICBzdGF0ZS5zeW5jID0gZmFsc2U7XFxuICAgIC8vIElmIF9yZWFkIHB1c2hlZCBkYXRhIHN5bmNocm9ub3VzbHksIHRoZW4gYHJlYWRpbmdgIHdpbGwgYmUgZmFsc2UsXFxuICAgIC8vIGFuZCB3ZSBuZWVkIHRvIHJlLWV2YWx1YXRlIGhvdyBtdWNoIGRhdGEgd2UgY2FuIHJldHVybiB0byB0aGUgdXNlci5cXG4gICAgaWYgKCFzdGF0ZS5yZWFkaW5nKSBuID0gaG93TXVjaFRvUmVhZChuT3JpZywgc3RhdGUpO1xcbiAgfVxcblxcbiAgdmFyIHJldDtcXG4gIGlmIChuID4gMCkgcmV0ID0gZnJvbUxpc3Qobiwgc3RhdGUpO2Vsc2UgcmV0ID0gbnVsbDtcXG5cXG4gIGlmIChyZXQgPT09IG51bGwpIHtcXG4gICAgc3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTtcXG4gICAgbiA9IDA7XFxuICB9IGVsc2Uge1xcbiAgICBzdGF0ZS5sZW5ndGggLT0gbjtcXG4gIH1cXG5cXG4gIGlmIChzdGF0ZS5sZW5ndGggPT09IDApIHtcXG4gICAgLy8gSWYgd2UgaGF2ZSBub3RoaW5nIGluIHRoZSBidWZmZXIsIHRoZW4gd2Ugd2FudCB0byBrbm93XFxuICAgIC8vIGFzIHNvb24gYXMgd2UgKmRvKiBnZXQgc29tZXRoaW5nIGludG8gdGhlIGJ1ZmZlci5cXG4gICAgaWYgKCFzdGF0ZS5lbmRlZCkgc3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTtcXG5cXG4gICAgLy8gSWYgd2UgdHJpZWQgdG8gcmVhZCgpIHBhc3QgdGhlIEVPRiwgdGhlbiBlbWl0IGVuZCBvbiB0aGUgbmV4dCB0aWNrLlxcbiAgICBpZiAobk9yaWcgIT09IG4gJiYgc3RhdGUuZW5kZWQpIGVuZFJlYWRhYmxlKHRoaXMpO1xcbiAgfVxcblxcbiAgaWYgKHJldCAhPT0gbnVsbCkgdGhpcy5lbWl0KCdkYXRhJywgcmV0KTtcXG5cXG4gIHJldHVybiByZXQ7XFxufTtcXG5cXG5mdW5jdGlvbiBjaHVua0ludmFsaWQoc3RhdGUsIGNodW5rKSB7XFxuICB2YXIgZXIgPSBudWxsO1xcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoY2h1bmspICYmIHR5cGVvZiBjaHVuayAhPT0gJ3N0cmluZycgJiYgY2h1bmsgIT09IG51bGwgJiYgY2h1bmsgIT09IHVuZGVmaW5lZCAmJiAhc3RhdGUub2JqZWN0TW9kZSkge1xcbiAgICBlciA9IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgbm9uLXN0cmluZy9idWZmZXIgY2h1bmsnKTtcXG4gIH1cXG4gIHJldHVybiBlcjtcXG59XFxuXFxuZnVuY3Rpb24gb25Fb2ZDaHVuayhzdHJlYW0sIHN0YXRlKSB7XFxuICBpZiAoc3RhdGUuZW5kZWQpIHJldHVybjtcXG4gIGlmIChzdGF0ZS5kZWNvZGVyKSB7XFxuICAgIHZhciBjaHVuayA9IHN0YXRlLmRlY29kZXIuZW5kKCk7XFxuICAgIGlmIChjaHVuayAmJiBjaHVuay5sZW5ndGgpIHtcXG4gICAgICBzdGF0ZS5idWZmZXIucHVzaChjaHVuayk7XFxuICAgICAgc3RhdGUubGVuZ3RoICs9IHN0YXRlLm9iamVjdE1vZGUgPyAxIDogY2h1bmsubGVuZ3RoO1xcbiAgICB9XFxuICB9XFxuICBzdGF0ZS5lbmRlZCA9IHRydWU7XFxuXFxuICAvLyBlbWl0ICdyZWFkYWJsZScgbm93IHRvIG1ha2Ugc3VyZSBpdCBnZXRzIHBpY2tlZCB1cC5cXG4gIGVtaXRSZWFkYWJsZShzdHJlYW0pO1xcbn1cXG5cXG4vLyBEb24ndCBlbWl0IHJlYWRhYmxlIHJpZ2h0IGF3YXkgaW4gc3luYyBtb2RlLCBiZWNhdXNlIHRoaXMgY2FuIHRyaWdnZXJcXG4vLyBhbm90aGVyIHJlYWQoKSBjYWxsID0+IHN0YWNrIG92ZXJmbG93LiAgVGhpcyB3YXksIGl0IG1pZ2h0IHRyaWdnZXJcXG4vLyBhIG5leHRUaWNrIHJlY3Vyc2lvbiB3YXJuaW5nLCBidXQgdGhhdCdzIG5vdCBzbyBiYWQuXFxuZnVuY3Rpb24gZW1pdFJlYWRhYmxlKHN0cmVhbSkge1xcbiAgdmFyIHN0YXRlID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlO1xcbiAgc3RhdGUubmVlZFJlYWRhYmxlID0gZmFsc2U7XFxuICBpZiAoIXN0YXRlLmVtaXR0ZWRSZWFkYWJsZSkge1xcbiAgICBkZWJ1ZygnZW1pdFJlYWRhYmxlJywgc3RhdGUuZmxvd2luZyk7XFxuICAgIHN0YXRlLmVtaXR0ZWRSZWFkYWJsZSA9IHRydWU7XFxuICAgIGlmIChzdGF0ZS5zeW5jKSBwcm9jZXNzTmV4dFRpY2soZW1pdFJlYWRhYmxlXywgc3RyZWFtKTtlbHNlIGVtaXRSZWFkYWJsZV8oc3RyZWFtKTtcXG4gIH1cXG59XFxuXFxuZnVuY3Rpb24gZW1pdFJlYWRhYmxlXyhzdHJlYW0pIHtcXG4gIGRlYnVnKCdlbWl0IHJlYWRhYmxlJyk7XFxuICBzdHJlYW0uZW1pdCgncmVhZGFibGUnKTtcXG4gIGZsb3coc3RyZWFtKTtcXG59XFxuXFxuLy8gYXQgdGhpcyBwb2ludCwgdGhlIHVzZXIgaGFzIHByZXN1bWFibHkgc2VlbiB0aGUgJ3JlYWRhYmxlJyBldmVudCxcXG4vLyBhbmQgY2FsbGVkIHJlYWQoKSB0byBjb25zdW1lIHNvbWUgZGF0YS4gIHRoYXQgbWF5IGhhdmUgdHJpZ2dlcmVkXFxuLy8gaW4gdHVybiBhbm90aGVyIF9yZWFkKG4pIGNhbGwsIGluIHdoaWNoIGNhc2UgcmVhZGluZyA9IHRydWUgaWZcXG4vLyBpdCdzIGluIHByb2dyZXNzLlxcbi8vIEhvd2V2ZXIsIGlmIHdlJ3JlIG5vdCBlbmRlZCwgb3IgcmVhZGluZywgYW5kIHRoZSBsZW5ndGggPCBod20sXFxuLy8gdGhlbiBnbyBhaGVhZCBhbmQgdHJ5IHRvIHJlYWQgc29tZSBtb3JlIHByZWVtcHRpdmVseS5cXG5mdW5jdGlvbiBtYXliZVJlYWRNb3JlKHN0cmVhbSwgc3RhdGUpIHtcXG4gIGlmICghc3RhdGUucmVhZGluZ01vcmUpIHtcXG4gICAgc3RhdGUucmVhZGluZ01vcmUgPSB0cnVlO1xcbiAgICBwcm9jZXNzTmV4dFRpY2sobWF5YmVSZWFkTW9yZV8sIHN0cmVhbSwgc3RhdGUpO1xcbiAgfVxcbn1cXG5cXG5mdW5jdGlvbiBtYXliZVJlYWRNb3JlXyhzdHJlYW0sIHN0YXRlKSB7XFxuICB2YXIgbGVuID0gc3RhdGUubGVuZ3RoO1xcbiAgd2hpbGUgKCFzdGF0ZS5yZWFkaW5nICYmICFzdGF0ZS5mbG93aW5nICYmICFzdGF0ZS5lbmRlZCAmJiBzdGF0ZS5sZW5ndGggPCBzdGF0ZS5oaWdoV2F0ZXJNYXJrKSB7XFxuICAgIGRlYnVnKCdtYXliZVJlYWRNb3JlIHJlYWQgMCcpO1xcbiAgICBzdHJlYW0ucmVhZCgwKTtcXG4gICAgaWYgKGxlbiA9PT0gc3RhdGUubGVuZ3RoKVxcbiAgICAgIC8vIGRpZG4ndCBnZXQgYW55IGRhdGEsIHN0b3Agc3Bpbm5pbmcuXFxuICAgICAgYnJlYWs7ZWxzZSBsZW4gPSBzdGF0ZS5sZW5ndGg7XFxuICB9XFxuICBzdGF0ZS5yZWFkaW5nTW9yZSA9IGZhbHNlO1xcbn1cXG5cXG4vLyBhYnN0cmFjdCBtZXRob2QuICB0byBiZSBvdmVycmlkZGVuIGluIHNwZWNpZmljIGltcGxlbWVudGF0aW9uIGNsYXNzZXMuXFxuLy8gY2FsbCBjYihlciwgZGF0YSkgd2hlcmUgZGF0YSBpcyA8PSBuIGluIGxlbmd0aC5cXG4vLyBmb3IgdmlydHVhbCAobm9uLXN0cmluZywgbm9uLWJ1ZmZlcikgc3RyZWFtcywgXFxcImxlbmd0aFxcXCIgaXMgc29tZXdoYXRcXG4vLyBhcmJpdHJhcnksIGFuZCBwZXJoYXBzIG5vdCB2ZXJ5IG1lYW5pbmdmdWwuXFxuUmVhZGFibGUucHJvdG90eXBlLl9yZWFkID0gZnVuY3Rpb24gKG4pIHtcXG4gIHRoaXMuZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoJ19yZWFkKCkgaXMgbm90IGltcGxlbWVudGVkJykpO1xcbn07XFxuXFxuUmVhZGFibGUucHJvdG90eXBlLnBpcGUgPSBmdW5jdGlvbiAoZGVzdCwgcGlwZU9wdHMpIHtcXG4gIHZhciBzcmMgPSB0aGlzO1xcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcXG5cXG4gIHN3aXRjaCAoc3RhdGUucGlwZXNDb3VudCkge1xcbiAgICBjYXNlIDA6XFxuICAgICAgc3RhdGUucGlwZXMgPSBkZXN0O1xcbiAgICAgIGJyZWFrO1xcbiAgICBjYXNlIDE6XFxuICAgICAgc3RhdGUucGlwZXMgPSBbc3RhdGUucGlwZXMsIGRlc3RdO1xcbiAgICAgIGJyZWFrO1xcbiAgICBkZWZhdWx0OlxcbiAgICAgIHN0YXRlLnBpcGVzLnB1c2goZGVzdCk7XFxuICAgICAgYnJlYWs7XFxuICB9XFxuICBzdGF0ZS5waXBlc0NvdW50ICs9IDE7XFxuICBkZWJ1ZygncGlwZSBjb3VudD0lZCBvcHRzPSVqJywgc3RhdGUucGlwZXNDb3VudCwgcGlwZU9wdHMpO1xcblxcbiAgdmFyIGRvRW5kID0gKCFwaXBlT3B0cyB8fCBwaXBlT3B0cy5lbmQgIT09IGZhbHNlKSAmJiBkZXN0ICE9PSBwcm9jZXNzLnN0ZG91dCAmJiBkZXN0ICE9PSBwcm9jZXNzLnN0ZGVycjtcXG5cXG4gIHZhciBlbmRGbiA9IGRvRW5kID8gb25lbmQgOiB1bnBpcGU7XFxuICBpZiAoc3RhdGUuZW5kRW1pdHRlZCkgcHJvY2Vzc05leHRUaWNrKGVuZEZuKTtlbHNlIHNyYy5vbmNlKCdlbmQnLCBlbmRGbik7XFxuXFxuICBkZXN0Lm9uKCd1bnBpcGUnLCBvbnVucGlwZSk7XFxuICBmdW5jdGlvbiBvbnVucGlwZShyZWFkYWJsZSkge1xcbiAgICBkZWJ1Zygnb251bnBpcGUnKTtcXG4gICAgaWYgKHJlYWRhYmxlID09PSBzcmMpIHtcXG4gICAgICBjbGVhbnVwKCk7XFxuICAgIH1cXG4gIH1cXG5cXG4gIGZ1bmN0aW9uIG9uZW5kKCkge1xcbiAgICBkZWJ1Zygnb25lbmQnKTtcXG4gICAgZGVzdC5lbmQoKTtcXG4gIH1cXG5cXG4gIC8vIHdoZW4gdGhlIGRlc3QgZHJhaW5zLCBpdCByZWR1Y2VzIHRoZSBhd2FpdERyYWluIGNvdW50ZXJcXG4gIC8vIG9uIHRoZSBzb3VyY2UuICBUaGlzIHdvdWxkIGJlIG1vcmUgZWxlZ2FudCB3aXRoIGEgLm9uY2UoKVxcbiAgLy8gaGFuZGxlciBpbiBmbG93KCksIGJ1dCBhZGRpbmcgYW5kIHJlbW92aW5nIHJlcGVhdGVkbHkgaXNcXG4gIC8vIHRvbyBzbG93LlxcbiAgdmFyIG9uZHJhaW4gPSBwaXBlT25EcmFpbihzcmMpO1xcbiAgZGVzdC5vbignZHJhaW4nLCBvbmRyYWluKTtcXG5cXG4gIHZhciBjbGVhbmVkVXAgPSBmYWxzZTtcXG4gIGZ1bmN0aW9uIGNsZWFudXAoKSB7XFxuICAgIGRlYnVnKCdjbGVhbnVwJyk7XFxuICAgIC8vIGNsZWFudXAgZXZlbnQgaGFuZGxlcnMgb25jZSB0aGUgcGlwZSBpcyBicm9rZW5cXG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBvbmNsb3NlKTtcXG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZmluaXNoJywgb25maW5pc2gpO1xcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdkcmFpbicsIG9uZHJhaW4pO1xcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIG9uZXJyb3IpO1xcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCd1bnBpcGUnLCBvbnVucGlwZSk7XFxuICAgIHNyYy5yZW1vdmVMaXN0ZW5lcignZW5kJywgb25lbmQpO1xcbiAgICBzcmMucmVtb3ZlTGlzdGVuZXIoJ2VuZCcsIHVucGlwZSk7XFxuICAgIHNyYy5yZW1vdmVMaXN0ZW5lcignZGF0YScsIG9uZGF0YSk7XFxuXFxuICAgIGNsZWFuZWRVcCA9IHRydWU7XFxuXFxuICAgIC8vIGlmIHRoZSByZWFkZXIgaXMgd2FpdGluZyBmb3IgYSBkcmFpbiBldmVudCBmcm9tIHRoaXNcXG4gICAgLy8gc3BlY2lmaWMgd3JpdGVyLCB0aGVuIGl0IHdvdWxkIGNhdXNlIGl0IHRvIG5ldmVyIHN0YXJ0XFxuICAgIC8vIGZsb3dpbmcgYWdhaW4uXFxuICAgIC8vIFNvLCBpZiB0aGlzIGlzIGF3YWl0aW5nIGEgZHJhaW4sIHRoZW4gd2UganVzdCBjYWxsIGl0IG5vdy5cXG4gICAgLy8gSWYgd2UgZG9uJ3Qga25vdywgdGhlbiBhc3N1bWUgdGhhdCB3ZSBhcmUgd2FpdGluZyBmb3Igb25lLlxcbiAgICBpZiAoc3RhdGUuYXdhaXREcmFpbiAmJiAoIWRlc3QuX3dyaXRhYmxlU3RhdGUgfHwgZGVzdC5fd3JpdGFibGVTdGF0ZS5uZWVkRHJhaW4pKSBvbmRyYWluKCk7XFxuICB9XFxuXFxuICAvLyBJZiB0aGUgdXNlciBwdXNoZXMgbW9yZSBkYXRhIHdoaWxlIHdlJ3JlIHdyaXRpbmcgdG8gZGVzdCB0aGVuIHdlJ2xsIGVuZCB1cFxcbiAgLy8gaW4gb25kYXRhIGFnYWluLiBIb3dldmVyLCB3ZSBvbmx5IHdhbnQgdG8gaW5jcmVhc2UgYXdhaXREcmFpbiBvbmNlIGJlY2F1c2VcXG4gIC8vIGRlc3Qgd2lsbCBvbmx5IGVtaXQgb25lICdkcmFpbicgZXZlbnQgZm9yIHRoZSBtdWx0aXBsZSB3cml0ZXMuXFxuICAvLyA9PiBJbnRyb2R1Y2UgYSBndWFyZCBvbiBpbmNyZWFzaW5nIGF3YWl0RHJhaW4uXFxuICB2YXIgaW5jcmVhc2VkQXdhaXREcmFpbiA9IGZhbHNlO1xcbiAgc3JjLm9uKCdkYXRhJywgb25kYXRhKTtcXG4gIGZ1bmN0aW9uIG9uZGF0YShjaHVuaykge1xcbiAgICBkZWJ1Zygnb25kYXRhJyk7XFxuICAgIGluY3JlYXNlZEF3YWl0RHJhaW4gPSBmYWxzZTtcXG4gICAgdmFyIHJldCA9IGRlc3Qud3JpdGUoY2h1bmspO1xcbiAgICBpZiAoZmFsc2UgPT09IHJldCAmJiAhaW5jcmVhc2VkQXdhaXREcmFpbikge1xcbiAgICAgIC8vIElmIHRoZSB1c2VyIHVucGlwZWQgZHVyaW5nIGBkZXN0LndyaXRlKClgLCBpdCBpcyBwb3NzaWJsZVxcbiAgICAgIC8vIHRvIGdldCBzdHVjayBpbiBhIHBlcm1hbmVudGx5IHBhdXNlZCBzdGF0ZSBpZiB0aGF0IHdyaXRlXFxuICAgICAgLy8gYWxzbyByZXR1cm5lZCBmYWxzZS5cXG4gICAgICAvLyA9PiBDaGVjayB3aGV0aGVyIGBkZXN0YCBpcyBzdGlsbCBhIHBpcGluZyBkZXN0aW5hdGlvbi5cXG4gICAgICBpZiAoKHN0YXRlLnBpcGVzQ291bnQgPT09IDEgJiYgc3RhdGUucGlwZXMgPT09IGRlc3QgfHwgc3RhdGUucGlwZXNDb3VudCA+IDEgJiYgaW5kZXhPZihzdGF0ZS5waXBlcywgZGVzdCkgIT09IC0xKSAmJiAhY2xlYW5lZFVwKSB7XFxuICAgICAgICBkZWJ1ZygnZmFsc2Ugd3JpdGUgcmVzcG9uc2UsIHBhdXNlJywgc3JjLl9yZWFkYWJsZVN0YXRlLmF3YWl0RHJhaW4pO1xcbiAgICAgICAgc3JjLl9yZWFkYWJsZVN0YXRlLmF3YWl0RHJhaW4rKztcXG4gICAgICAgIGluY3JlYXNlZEF3YWl0RHJhaW4gPSB0cnVlO1xcbiAgICAgIH1cXG4gICAgICBzcmMucGF1c2UoKTtcXG4gICAgfVxcbiAgfVxcblxcbiAgLy8gaWYgdGhlIGRlc3QgaGFzIGFuIGVycm9yLCB0aGVuIHN0b3AgcGlwaW5nIGludG8gaXQuXFxuICAvLyBob3dldmVyLCBkb24ndCBzdXBwcmVzcyB0aGUgdGhyb3dpbmcgYmVoYXZpb3IgZm9yIHRoaXMuXFxuICBmdW5jdGlvbiBvbmVycm9yKGVyKSB7XFxuICAgIGRlYnVnKCdvbmVycm9yJywgZXIpO1xcbiAgICB1bnBpcGUoKTtcXG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBvbmVycm9yKTtcXG4gICAgaWYgKEVFbGlzdGVuZXJDb3VudChkZXN0LCAnZXJyb3InKSA9PT0gMCkgZGVzdC5lbWl0KCdlcnJvcicsIGVyKTtcXG4gIH1cXG5cXG4gIC8vIE1ha2Ugc3VyZSBvdXIgZXJyb3IgaGFuZGxlciBpcyBhdHRhY2hlZCBiZWZvcmUgdXNlcmxhbmQgb25lcy5cXG4gIHByZXBlbmRMaXN0ZW5lcihkZXN0LCAnZXJyb3InLCBvbmVycm9yKTtcXG5cXG4gIC8vIEJvdGggY2xvc2UgYW5kIGZpbmlzaCBzaG91bGQgdHJpZ2dlciB1bnBpcGUsIGJ1dCBvbmx5IG9uY2UuXFxuICBmdW5jdGlvbiBvbmNsb3NlKCkge1xcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdmaW5pc2gnLCBvbmZpbmlzaCk7XFxuICAgIHVucGlwZSgpO1xcbiAgfVxcbiAgZGVzdC5vbmNlKCdjbG9zZScsIG9uY2xvc2UpO1xcbiAgZnVuY3Rpb24gb25maW5pc2goKSB7XFxuICAgIGRlYnVnKCdvbmZpbmlzaCcpO1xcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIG9uY2xvc2UpO1xcbiAgICB1bnBpcGUoKTtcXG4gIH1cXG4gIGRlc3Qub25jZSgnZmluaXNoJywgb25maW5pc2gpO1xcblxcbiAgZnVuY3Rpb24gdW5waXBlKCkge1xcbiAgICBkZWJ1ZygndW5waXBlJyk7XFxuICAgIHNyYy51bnBpcGUoZGVzdCk7XFxuICB9XFxuXFxuICAvLyB0ZWxsIHRoZSBkZXN0IHRoYXQgaXQncyBiZWluZyBwaXBlZCB0b1xcbiAgZGVzdC5lbWl0KCdwaXBlJywgc3JjKTtcXG5cXG4gIC8vIHN0YXJ0IHRoZSBmbG93IGlmIGl0IGhhc24ndCBiZWVuIHN0YXJ0ZWQgYWxyZWFkeS5cXG4gIGlmICghc3RhdGUuZmxvd2luZykge1xcbiAgICBkZWJ1ZygncGlwZSByZXN1bWUnKTtcXG4gICAgc3JjLnJlc3VtZSgpO1xcbiAgfVxcblxcbiAgcmV0dXJuIGRlc3Q7XFxufTtcXG5cXG5mdW5jdGlvbiBwaXBlT25EcmFpbihzcmMpIHtcXG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XFxuICAgIHZhciBzdGF0ZSA9IHNyYy5fcmVhZGFibGVTdGF0ZTtcXG4gICAgZGVidWcoJ3BpcGVPbkRyYWluJywgc3RhdGUuYXdhaXREcmFpbik7XFxuICAgIGlmIChzdGF0ZS5hd2FpdERyYWluKSBzdGF0ZS5hd2FpdERyYWluLS07XFxuICAgIGlmIChzdGF0ZS5hd2FpdERyYWluID09PSAwICYmIEVFbGlzdGVuZXJDb3VudChzcmMsICdkYXRhJykpIHtcXG4gICAgICBzdGF0ZS5mbG93aW5nID0gdHJ1ZTtcXG4gICAgICBmbG93KHNyYyk7XFxuICAgIH1cXG4gIH07XFxufVxcblxcblJlYWRhYmxlLnByb3RvdHlwZS51bnBpcGUgPSBmdW5jdGlvbiAoZGVzdCkge1xcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcXG5cXG4gIC8vIGlmIHdlJ3JlIG5vdCBwaXBpbmcgYW55d2hlcmUsIHRoZW4gZG8gbm90aGluZy5cXG4gIGlmIChzdGF0ZS5waXBlc0NvdW50ID09PSAwKSByZXR1cm4gdGhpcztcXG5cXG4gIC8vIGp1c3Qgb25lIGRlc3RpbmF0aW9uLiAgbW9zdCBjb21tb24gY2FzZS5cXG4gIGlmIChzdGF0ZS5waXBlc0NvdW50ID09PSAxKSB7XFxuICAgIC8vIHBhc3NlZCBpbiBvbmUsIGJ1dCBpdCdzIG5vdCB0aGUgcmlnaHQgb25lLlxcbiAgICBpZiAoZGVzdCAmJiBkZXN0ICE9PSBzdGF0ZS5waXBlcykgcmV0dXJuIHRoaXM7XFxuXFxuICAgIGlmICghZGVzdCkgZGVzdCA9IHN0YXRlLnBpcGVzO1xcblxcbiAgICAvLyBnb3QgYSBtYXRjaC5cXG4gICAgc3RhdGUucGlwZXMgPSBudWxsO1xcbiAgICBzdGF0ZS5waXBlc0NvdW50ID0gMDtcXG4gICAgc3RhdGUuZmxvd2luZyA9IGZhbHNlO1xcbiAgICBpZiAoZGVzdCkgZGVzdC5lbWl0KCd1bnBpcGUnLCB0aGlzKTtcXG4gICAgcmV0dXJuIHRoaXM7XFxuICB9XFxuXFxuICAvLyBzbG93IGNhc2UuIG11bHRpcGxlIHBpcGUgZGVzdGluYXRpb25zLlxcblxcbiAgaWYgKCFkZXN0KSB7XFxuICAgIC8vIHJlbW92ZSBhbGwuXFxuICAgIHZhciBkZXN0cyA9IHN0YXRlLnBpcGVzO1xcbiAgICB2YXIgbGVuID0gc3RhdGUucGlwZXNDb3VudDtcXG4gICAgc3RhdGUucGlwZXMgPSBudWxsO1xcbiAgICBzdGF0ZS5waXBlc0NvdW50ID0gMDtcXG4gICAgc3RhdGUuZmxvd2luZyA9IGZhbHNlO1xcblxcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XFxuICAgICAgZGVzdHNbaV0uZW1pdCgndW5waXBlJywgdGhpcyk7XFxuICAgIH1yZXR1cm4gdGhpcztcXG4gIH1cXG5cXG4gIC8vIHRyeSB0byBmaW5kIHRoZSByaWdodCBvbmUuXFxuICB2YXIgaW5kZXggPSBpbmRleE9mKHN0YXRlLnBpcGVzLCBkZXN0KTtcXG4gIGlmIChpbmRleCA9PT0gLTEpIHJldHVybiB0aGlzO1xcblxcbiAgc3RhdGUucGlwZXMuc3BsaWNlKGluZGV4LCAxKTtcXG4gIHN0YXRlLnBpcGVzQ291bnQgLT0gMTtcXG4gIGlmIChzdGF0ZS5waXBlc0NvdW50ID09PSAxKSBzdGF0ZS5waXBlcyA9IHN0YXRlLnBpcGVzWzBdO1xcblxcbiAgZGVzdC5lbWl0KCd1bnBpcGUnLCB0aGlzKTtcXG5cXG4gIHJldHVybiB0aGlzO1xcbn07XFxuXFxuLy8gc2V0IHVwIGRhdGEgZXZlbnRzIGlmIHRoZXkgYXJlIGFza2VkIGZvclxcbi8vIEVuc3VyZSByZWFkYWJsZSBsaXN0ZW5lcnMgZXZlbnR1YWxseSBnZXQgc29tZXRoaW5nXFxuUmVhZGFibGUucHJvdG90eXBlLm9uID0gZnVuY3Rpb24gKGV2LCBmbikge1xcbiAgdmFyIHJlcyA9IFN0cmVhbS5wcm90b3R5cGUub24uY2FsbCh0aGlzLCBldiwgZm4pO1xcblxcbiAgaWYgKGV2ID09PSAnZGF0YScpIHtcXG4gICAgLy8gU3RhcnQgZmxvd2luZyBvbiBuZXh0IHRpY2sgaWYgc3RyZWFtIGlzbid0IGV4cGxpY2l0bHkgcGF1c2VkXFxuICAgIGlmICh0aGlzLl9yZWFkYWJsZVN0YXRlLmZsb3dpbmcgIT09IGZhbHNlKSB0aGlzLnJlc3VtZSgpO1xcbiAgfSBlbHNlIGlmIChldiA9PT0gJ3JlYWRhYmxlJykge1xcbiAgICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xcbiAgICBpZiAoIXN0YXRlLmVuZEVtaXR0ZWQgJiYgIXN0YXRlLnJlYWRhYmxlTGlzdGVuaW5nKSB7XFxuICAgICAgc3RhdGUucmVhZGFibGVMaXN0ZW5pbmcgPSBzdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlO1xcbiAgICAgIHN0YXRlLmVtaXR0ZWRSZWFkYWJsZSA9IGZhbHNlO1xcbiAgICAgIGlmICghc3RhdGUucmVhZGluZykge1xcbiAgICAgICAgcHJvY2Vzc05leHRUaWNrKG5SZWFkaW5nTmV4dFRpY2ssIHRoaXMpO1xcbiAgICAgIH0gZWxzZSBpZiAoc3RhdGUubGVuZ3RoKSB7XFxuICAgICAgICBlbWl0UmVhZGFibGUodGhpcywgc3RhdGUpO1xcbiAgICAgIH1cXG4gICAgfVxcbiAgfVxcblxcbiAgcmV0dXJuIHJlcztcXG59O1xcblJlYWRhYmxlLnByb3RvdHlwZS5hZGRMaXN0ZW5lciA9IFJlYWRhYmxlLnByb3RvdHlwZS5vbjtcXG5cXG5mdW5jdGlvbiBuUmVhZGluZ05leHRUaWNrKHNlbGYpIHtcXG4gIGRlYnVnKCdyZWFkYWJsZSBuZXh0dGljayByZWFkIDAnKTtcXG4gIHNlbGYucmVhZCgwKTtcXG59XFxuXFxuLy8gcGF1c2UoKSBhbmQgcmVzdW1lKCkgYXJlIHJlbW5hbnRzIG9mIHRoZSBsZWdhY3kgcmVhZGFibGUgc3RyZWFtIEFQSVxcbi8vIElmIHRoZSB1c2VyIHVzZXMgdGhlbSwgdGhlbiBzd2l0Y2ggaW50byBvbGQgbW9kZS5cXG5SZWFkYWJsZS5wcm90b3R5cGUucmVzdW1lID0gZnVuY3Rpb24gKCkge1xcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcXG4gIGlmICghc3RhdGUuZmxvd2luZykge1xcbiAgICBkZWJ1ZygncmVzdW1lJyk7XFxuICAgIHN0YXRlLmZsb3dpbmcgPSB0cnVlO1xcbiAgICByZXN1bWUodGhpcywgc3RhdGUpO1xcbiAgfVxcbiAgcmV0dXJuIHRoaXM7XFxufTtcXG5cXG5mdW5jdGlvbiByZXN1bWUoc3RyZWFtLCBzdGF0ZSkge1xcbiAgaWYgKCFzdGF0ZS5yZXN1bWVTY2hlZHVsZWQpIHtcXG4gICAgc3RhdGUucmVzdW1lU2NoZWR1bGVkID0gdHJ1ZTtcXG4gICAgcHJvY2Vzc05leHRUaWNrKHJlc3VtZV8sIHN0cmVhbSwgc3RhdGUpO1xcbiAgfVxcbn1cXG5cXG5mdW5jdGlvbiByZXN1bWVfKHN0cmVhbSwgc3RhdGUpIHtcXG4gIGlmICghc3RhdGUucmVhZGluZykge1xcbiAgICBkZWJ1ZygncmVzdW1lIHJlYWQgMCcpO1xcbiAgICBzdHJlYW0ucmVhZCgwKTtcXG4gIH1cXG5cXG4gIHN0YXRlLnJlc3VtZVNjaGVkdWxlZCA9IGZhbHNlO1xcbiAgc3RhdGUuYXdhaXREcmFpbiA9IDA7XFxuICBzdHJlYW0uZW1pdCgncmVzdW1lJyk7XFxuICBmbG93KHN0cmVhbSk7XFxuICBpZiAoc3RhdGUuZmxvd2luZyAmJiAhc3RhdGUucmVhZGluZykgc3RyZWFtLnJlYWQoMCk7XFxufVxcblxcblJlYWRhYmxlLnByb3RvdHlwZS5wYXVzZSA9IGZ1bmN0aW9uICgpIHtcXG4gIGRlYnVnKCdjYWxsIHBhdXNlIGZsb3dpbmc9JWonLCB0aGlzLl9yZWFkYWJsZVN0YXRlLmZsb3dpbmcpO1xcbiAgaWYgKGZhbHNlICE9PSB0aGlzLl9yZWFkYWJsZVN0YXRlLmZsb3dpbmcpIHtcXG4gICAgZGVidWcoJ3BhdXNlJyk7XFxuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUuZmxvd2luZyA9IGZhbHNlO1xcbiAgICB0aGlzLmVtaXQoJ3BhdXNlJyk7XFxuICB9XFxuICByZXR1cm4gdGhpcztcXG59O1xcblxcbmZ1bmN0aW9uIGZsb3coc3RyZWFtKSB7XFxuICB2YXIgc3RhdGUgPSBzdHJlYW0uX3JlYWRhYmxlU3RhdGU7XFxuICBkZWJ1ZygnZmxvdycsIHN0YXRlLmZsb3dpbmcpO1xcbiAgd2hpbGUgKHN0YXRlLmZsb3dpbmcgJiYgc3RyZWFtLnJlYWQoKSAhPT0gbnVsbCkge31cXG59XFxuXFxuLy8gd3JhcCBhbiBvbGQtc3R5bGUgc3RyZWFtIGFzIHRoZSBhc3luYyBkYXRhIHNvdXJjZS5cXG4vLyBUaGlzIGlzICpub3QqIHBhcnQgb2YgdGhlIHJlYWRhYmxlIHN0cmVhbSBpbnRlcmZhY2UuXFxuLy8gSXQgaXMgYW4gdWdseSB1bmZvcnR1bmF0ZSBtZXNzIG9mIGhpc3RvcnkuXFxuUmVhZGFibGUucHJvdG90eXBlLndyYXAgPSBmdW5jdGlvbiAoc3RyZWFtKSB7XFxuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xcbiAgdmFyIHBhdXNlZCA9IGZhbHNlO1xcblxcbiAgdmFyIHNlbGYgPSB0aGlzO1xcbiAgc3RyZWFtLm9uKCdlbmQnLCBmdW5jdGlvbiAoKSB7XFxuICAgIGRlYnVnKCd3cmFwcGVkIGVuZCcpO1xcbiAgICBpZiAoc3RhdGUuZGVjb2RlciAmJiAhc3RhdGUuZW5kZWQpIHtcXG4gICAgICB2YXIgY2h1bmsgPSBzdGF0ZS5kZWNvZGVyLmVuZCgpO1xcbiAgICAgIGlmIChjaHVuayAmJiBjaHVuay5sZW5ndGgpIHNlbGYucHVzaChjaHVuayk7XFxuICAgIH1cXG5cXG4gICAgc2VsZi5wdXNoKG51bGwpO1xcbiAgfSk7XFxuXFxuICBzdHJlYW0ub24oJ2RhdGEnLCBmdW5jdGlvbiAoY2h1bmspIHtcXG4gICAgZGVidWcoJ3dyYXBwZWQgZGF0YScpO1xcbiAgICBpZiAoc3RhdGUuZGVjb2RlcikgY2h1bmsgPSBzdGF0ZS5kZWNvZGVyLndyaXRlKGNodW5rKTtcXG5cXG4gICAgLy8gZG9uJ3Qgc2tpcCBvdmVyIGZhbHN5IHZhbHVlcyBpbiBvYmplY3RNb2RlXFxuICAgIGlmIChzdGF0ZS5vYmplY3RNb2RlICYmIChjaHVuayA9PT0gbnVsbCB8fCBjaHVuayA9PT0gdW5kZWZpbmVkKSkgcmV0dXJuO2Vsc2UgaWYgKCFzdGF0ZS5vYmplY3RNb2RlICYmICghY2h1bmsgfHwgIWNodW5rLmxlbmd0aCkpIHJldHVybjtcXG5cXG4gICAgdmFyIHJldCA9IHNlbGYucHVzaChjaHVuayk7XFxuICAgIGlmICghcmV0KSB7XFxuICAgICAgcGF1c2VkID0gdHJ1ZTtcXG4gICAgICBzdHJlYW0ucGF1c2UoKTtcXG4gICAgfVxcbiAgfSk7XFxuXFxuICAvLyBwcm94eSBhbGwgdGhlIG90aGVyIG1ldGhvZHMuXFxuICAvLyBpbXBvcnRhbnQgd2hlbiB3cmFwcGluZyBmaWx0ZXJzIGFuZCBkdXBsZXhlcy5cXG4gIGZvciAodmFyIGkgaW4gc3RyZWFtKSB7XFxuICAgIGlmICh0aGlzW2ldID09PSB1bmRlZmluZWQgJiYgdHlwZW9mIHN0cmVhbVtpXSA9PT0gJ2Z1bmN0aW9uJykge1xcbiAgICAgIHRoaXNbaV0gPSBmdW5jdGlvbiAobWV0aG9kKSB7XFxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICByZXR1cm4gc3RyZWFtW21ldGhvZF0uYXBwbHkoc3RyZWFtLCBhcmd1bWVudHMpO1xcbiAgICAgICAgfTtcXG4gICAgICB9KGkpO1xcbiAgICB9XFxuICB9XFxuXFxuICAvLyBwcm94eSBjZXJ0YWluIGltcG9ydGFudCBldmVudHMuXFxuICBmb3IgKHZhciBuID0gMDsgbiA8IGtQcm94eUV2ZW50cy5sZW5ndGg7IG4rKykge1xcbiAgICBzdHJlYW0ub24oa1Byb3h5RXZlbnRzW25dLCBzZWxmLmVtaXQuYmluZChzZWxmLCBrUHJveHlFdmVudHNbbl0pKTtcXG4gIH1cXG5cXG4gIC8vIHdoZW4gd2UgdHJ5IHRvIGNvbnN1bWUgc29tZSBtb3JlIGJ5dGVzLCBzaW1wbHkgdW5wYXVzZSB0aGVcXG4gIC8vIHVuZGVybHlpbmcgc3RyZWFtLlxcbiAgc2VsZi5fcmVhZCA9IGZ1bmN0aW9uIChuKSB7XFxuICAgIGRlYnVnKCd3cmFwcGVkIF9yZWFkJywgbik7XFxuICAgIGlmIChwYXVzZWQpIHtcXG4gICAgICBwYXVzZWQgPSBmYWxzZTtcXG4gICAgICBzdHJlYW0ucmVzdW1lKCk7XFxuICAgIH1cXG4gIH07XFxuXFxuICByZXR1cm4gc2VsZjtcXG59O1xcblxcbi8vIGV4cG9zZWQgZm9yIHRlc3RpbmcgcHVycG9zZXMgb25seS5cXG5SZWFkYWJsZS5fZnJvbUxpc3QgPSBmcm9tTGlzdDtcXG5cXG4vLyBQbHVjayBvZmYgbiBieXRlcyBmcm9tIGFuIGFycmF5IG9mIGJ1ZmZlcnMuXFxuLy8gTGVuZ3RoIGlzIHRoZSBjb21iaW5lZCBsZW5ndGhzIG9mIGFsbCB0aGUgYnVmZmVycyBpbiB0aGUgbGlzdC5cXG4vLyBUaGlzIGZ1bmN0aW9uIGlzIGRlc2lnbmVkIHRvIGJlIGlubGluYWJsZSwgc28gcGxlYXNlIHRha2UgY2FyZSB3aGVuIG1ha2luZ1xcbi8vIGNoYW5nZXMgdG8gdGhlIGZ1bmN0aW9uIGJvZHkuXFxuZnVuY3Rpb24gZnJvbUxpc3Qobiwgc3RhdGUpIHtcXG4gIC8vIG5vdGhpbmcgYnVmZmVyZWRcXG4gIGlmIChzdGF0ZS5sZW5ndGggPT09IDApIHJldHVybiBudWxsO1xcblxcbiAgdmFyIHJldDtcXG4gIGlmIChzdGF0ZS5vYmplY3RNb2RlKSByZXQgPSBzdGF0ZS5idWZmZXIuc2hpZnQoKTtlbHNlIGlmICghbiB8fCBuID49IHN0YXRlLmxlbmd0aCkge1xcbiAgICAvLyByZWFkIGl0IGFsbCwgdHJ1bmNhdGUgdGhlIGxpc3RcXG4gICAgaWYgKHN0YXRlLmRlY29kZXIpIHJldCA9IHN0YXRlLmJ1ZmZlci5qb2luKCcnKTtlbHNlIGlmIChzdGF0ZS5idWZmZXIubGVuZ3RoID09PSAxKSByZXQgPSBzdGF0ZS5idWZmZXIuaGVhZC5kYXRhO2Vsc2UgcmV0ID0gc3RhdGUuYnVmZmVyLmNvbmNhdChzdGF0ZS5sZW5ndGgpO1xcbiAgICBzdGF0ZS5idWZmZXIuY2xlYXIoKTtcXG4gIH0gZWxzZSB7XFxuICAgIC8vIHJlYWQgcGFydCBvZiBsaXN0XFxuICAgIHJldCA9IGZyb21MaXN0UGFydGlhbChuLCBzdGF0ZS5idWZmZXIsIHN0YXRlLmRlY29kZXIpO1xcbiAgfVxcblxcbiAgcmV0dXJuIHJldDtcXG59XFxuXFxuLy8gRXh0cmFjdHMgb25seSBlbm91Z2ggYnVmZmVyZWQgZGF0YSB0byBzYXRpc2Z5IHRoZSBhbW91bnQgcmVxdWVzdGVkLlxcbi8vIFRoaXMgZnVuY3Rpb24gaXMgZGVzaWduZWQgdG8gYmUgaW5saW5hYmxlLCBzbyBwbGVhc2UgdGFrZSBjYXJlIHdoZW4gbWFraW5nXFxuLy8gY2hhbmdlcyB0byB0aGUgZnVuY3Rpb24gYm9keS5cXG5mdW5jdGlvbiBmcm9tTGlzdFBhcnRpYWwobiwgbGlzdCwgaGFzU3RyaW5ncykge1xcbiAgdmFyIHJldDtcXG4gIGlmIChuIDwgbGlzdC5oZWFkLmRhdGEubGVuZ3RoKSB7XFxuICAgIC8vIHNsaWNlIGlzIHRoZSBzYW1lIGZvciBidWZmZXJzIGFuZCBzdHJpbmdzXFxuICAgIHJldCA9IGxpc3QuaGVhZC5kYXRhLnNsaWNlKDAsIG4pO1xcbiAgICBsaXN0LmhlYWQuZGF0YSA9IGxpc3QuaGVhZC5kYXRhLnNsaWNlKG4pO1xcbiAgfSBlbHNlIGlmIChuID09PSBsaXN0LmhlYWQuZGF0YS5sZW5ndGgpIHtcXG4gICAgLy8gZmlyc3QgY2h1bmsgaXMgYSBwZXJmZWN0IG1hdGNoXFxuICAgIHJldCA9IGxpc3Quc2hpZnQoKTtcXG4gIH0gZWxzZSB7XFxuICAgIC8vIHJlc3VsdCBzcGFucyBtb3JlIHRoYW4gb25lIGJ1ZmZlclxcbiAgICByZXQgPSBoYXNTdHJpbmdzID8gY29weUZyb21CdWZmZXJTdHJpbmcobiwgbGlzdCkgOiBjb3B5RnJvbUJ1ZmZlcihuLCBsaXN0KTtcXG4gIH1cXG4gIHJldHVybiByZXQ7XFxufVxcblxcbi8vIENvcGllcyBhIHNwZWNpZmllZCBhbW91bnQgb2YgY2hhcmFjdGVycyBmcm9tIHRoZSBsaXN0IG9mIGJ1ZmZlcmVkIGRhdGFcXG4vLyBjaHVua3MuXFxuLy8gVGhpcyBmdW5jdGlvbiBpcyBkZXNpZ25lZCB0byBiZSBpbmxpbmFibGUsIHNvIHBsZWFzZSB0YWtlIGNhcmUgd2hlbiBtYWtpbmdcXG4vLyBjaGFuZ2VzIHRvIHRoZSBmdW5jdGlvbiBib2R5LlxcbmZ1bmN0aW9uIGNvcHlGcm9tQnVmZmVyU3RyaW5nKG4sIGxpc3QpIHtcXG4gIHZhciBwID0gbGlzdC5oZWFkO1xcbiAgdmFyIGMgPSAxO1xcbiAgdmFyIHJldCA9IHAuZGF0YTtcXG4gIG4gLT0gcmV0Lmxlbmd0aDtcXG4gIHdoaWxlIChwID0gcC5uZXh0KSB7XFxuICAgIHZhciBzdHIgPSBwLmRhdGE7XFxuICAgIHZhciBuYiA9IG4gPiBzdHIubGVuZ3RoID8gc3RyLmxlbmd0aCA6IG47XFxuICAgIGlmIChuYiA9PT0gc3RyLmxlbmd0aCkgcmV0ICs9IHN0cjtlbHNlIHJldCArPSBzdHIuc2xpY2UoMCwgbik7XFxuICAgIG4gLT0gbmI7XFxuICAgIGlmIChuID09PSAwKSB7XFxuICAgICAgaWYgKG5iID09PSBzdHIubGVuZ3RoKSB7XFxuICAgICAgICArK2M7XFxuICAgICAgICBpZiAocC5uZXh0KSBsaXN0LmhlYWQgPSBwLm5leHQ7ZWxzZSBsaXN0LmhlYWQgPSBsaXN0LnRhaWwgPSBudWxsO1xcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICBsaXN0LmhlYWQgPSBwO1xcbiAgICAgICAgcC5kYXRhID0gc3RyLnNsaWNlKG5iKTtcXG4gICAgICB9XFxuICAgICAgYnJlYWs7XFxuICAgIH1cXG4gICAgKytjO1xcbiAgfVxcbiAgbGlzdC5sZW5ndGggLT0gYztcXG4gIHJldHVybiByZXQ7XFxufVxcblxcbi8vIENvcGllcyBhIHNwZWNpZmllZCBhbW91bnQgb2YgYnl0ZXMgZnJvbSB0aGUgbGlzdCBvZiBidWZmZXJlZCBkYXRhIGNodW5rcy5cXG4vLyBUaGlzIGZ1bmN0aW9uIGlzIGRlc2lnbmVkIHRvIGJlIGlubGluYWJsZSwgc28gcGxlYXNlIHRha2UgY2FyZSB3aGVuIG1ha2luZ1xcbi8vIGNoYW5nZXMgdG8gdGhlIGZ1bmN0aW9uIGJvZHkuXFxuZnVuY3Rpb24gY29weUZyb21CdWZmZXIobiwgbGlzdCkge1xcbiAgdmFyIHJldCA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShuKTtcXG4gIHZhciBwID0gbGlzdC5oZWFkO1xcbiAgdmFyIGMgPSAxO1xcbiAgcC5kYXRhLmNvcHkocmV0KTtcXG4gIG4gLT0gcC5kYXRhLmxlbmd0aDtcXG4gIHdoaWxlIChwID0gcC5uZXh0KSB7XFxuICAgIHZhciBidWYgPSBwLmRhdGE7XFxuICAgIHZhciBuYiA9IG4gPiBidWYubGVuZ3RoID8gYnVmLmxlbmd0aCA6IG47XFxuICAgIGJ1Zi5jb3B5KHJldCwgcmV0Lmxlbmd0aCAtIG4sIDAsIG5iKTtcXG4gICAgbiAtPSBuYjtcXG4gICAgaWYgKG4gPT09IDApIHtcXG4gICAgICBpZiAobmIgPT09IGJ1Zi5sZW5ndGgpIHtcXG4gICAgICAgICsrYztcXG4gICAgICAgIGlmIChwLm5leHQpIGxpc3QuaGVhZCA9IHAubmV4dDtlbHNlIGxpc3QuaGVhZCA9IGxpc3QudGFpbCA9IG51bGw7XFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIGxpc3QuaGVhZCA9IHA7XFxuICAgICAgICBwLmRhdGEgPSBidWYuc2xpY2UobmIpO1xcbiAgICAgIH1cXG4gICAgICBicmVhaztcXG4gICAgfVxcbiAgICArK2M7XFxuICB9XFxuICBsaXN0Lmxlbmd0aCAtPSBjO1xcbiAgcmV0dXJuIHJldDtcXG59XFxuXFxuZnVuY3Rpb24gZW5kUmVhZGFibGUoc3RyZWFtKSB7XFxuICB2YXIgc3RhdGUgPSBzdHJlYW0uX3JlYWRhYmxlU3RhdGU7XFxuXFxuICAvLyBJZiB3ZSBnZXQgaGVyZSBiZWZvcmUgY29uc3VtaW5nIGFsbCB0aGUgYnl0ZXMsIHRoZW4gdGhhdCBpcyBhXFxuICAvLyBidWcgaW4gbm9kZS4gIFNob3VsZCBuZXZlciBoYXBwZW4uXFxuICBpZiAoc3RhdGUubGVuZ3RoID4gMCkgdGhyb3cgbmV3IEVycm9yKCdcXFwiZW5kUmVhZGFibGUoKVxcXCIgY2FsbGVkIG9uIG5vbi1lbXB0eSBzdHJlYW0nKTtcXG5cXG4gIGlmICghc3RhdGUuZW5kRW1pdHRlZCkge1xcbiAgICBzdGF0ZS5lbmRlZCA9IHRydWU7XFxuICAgIHByb2Nlc3NOZXh0VGljayhlbmRSZWFkYWJsZU5ULCBzdGF0ZSwgc3RyZWFtKTtcXG4gIH1cXG59XFxuXFxuZnVuY3Rpb24gZW5kUmVhZGFibGVOVChzdGF0ZSwgc3RyZWFtKSB7XFxuICAvLyBDaGVjayB0aGF0IHdlIGRpZG4ndCBnZXQgb25lIGxhc3QgdW5zaGlmdC5cXG4gIGlmICghc3RhdGUuZW5kRW1pdHRlZCAmJiBzdGF0ZS5sZW5ndGggPT09IDApIHtcXG4gICAgc3RhdGUuZW5kRW1pdHRlZCA9IHRydWU7XFxuICAgIHN0cmVhbS5yZWFkYWJsZSA9IGZhbHNlO1xcbiAgICBzdHJlYW0uZW1pdCgnZW5kJyk7XFxuICB9XFxufVxcblxcbmZ1bmN0aW9uIGZvckVhY2goeHMsIGYpIHtcXG4gIGZvciAodmFyIGkgPSAwLCBsID0geHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XFxuICAgIGYoeHNbaV0sIGkpO1xcbiAgfVxcbn1cXG5cXG5mdW5jdGlvbiBpbmRleE9mKHhzLCB4KSB7XFxuICBmb3IgKHZhciBpID0gMCwgbCA9IHhzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xcbiAgICBpZiAoeHNbaV0gPT09IHgpIHJldHVybiBpO1xcbiAgfVxcbiAgcmV0dXJuIC0xO1xcbn1cXG59KS5jYWxsKHRoaXMscmVxdWlyZSgnX3Byb2Nlc3MnKSlcXG59LHtcXFwiLi9fc3RyZWFtX2R1cGxleFxcXCI6ODQsXFxcIi4vaW50ZXJuYWwvc3RyZWFtcy9CdWZmZXJMaXN0XFxcIjo4OSxcXFwiLi9pbnRlcm5hbC9zdHJlYW1zL3N0cmVhbVxcXCI6OTAsXFxcIl9wcm9jZXNzXFxcIjo4MixcXFwiY29yZS11dGlsLWlzXFxcIjo0NCxcXFwiZXZlbnRzXFxcIjo2MixcXFwiaW5oZXJpdHNcXFwiOjY2LFxcXCJpc2FycmF5XFxcIjo2OCxcXFwicHJvY2Vzcy1uZXh0aWNrLWFyZ3NcXFwiOjgxLFxcXCJzYWZlLWJ1ZmZlclxcXCI6OTUsXFxcInN0cmluZ19kZWNvZGVyL1xcXCI6OTcsXFxcInV0aWxcXFwiOjQwfV0sODc6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xcbi8vIGEgdHJhbnNmb3JtIHN0cmVhbSBpcyBhIHJlYWRhYmxlL3dyaXRhYmxlIHN0cmVhbSB3aGVyZSB5b3UgZG9cXG4vLyBzb21ldGhpbmcgd2l0aCB0aGUgZGF0YS4gIFNvbWV0aW1lcyBpdCdzIGNhbGxlZCBhIFxcXCJmaWx0ZXJcXFwiLFxcbi8vIGJ1dCB0aGF0J3Mgbm90IGEgZ3JlYXQgbmFtZSBmb3IgaXQsIHNpbmNlIHRoYXQgaW1wbGllcyBhIHRoaW5nIHdoZXJlXFxuLy8gc29tZSBiaXRzIHBhc3MgdGhyb3VnaCwgYW5kIG90aGVycyBhcmUgc2ltcGx5IGlnbm9yZWQuICAoVGhhdCB3b3VsZFxcbi8vIGJlIGEgdmFsaWQgZXhhbXBsZSBvZiBhIHRyYW5zZm9ybSwgb2YgY291cnNlLilcXG4vL1xcbi8vIFdoaWxlIHRoZSBvdXRwdXQgaXMgY2F1c2FsbHkgcmVsYXRlZCB0byB0aGUgaW5wdXQsIGl0J3Mgbm90IGFcXG4vLyBuZWNlc3NhcmlseSBzeW1tZXRyaWMgb3Igc3luY2hyb25vdXMgdHJhbnNmb3JtYXRpb24uICBGb3IgZXhhbXBsZSxcXG4vLyBhIHpsaWIgc3RyZWFtIG1pZ2h0IHRha2UgbXVsdGlwbGUgcGxhaW4tdGV4dCB3cml0ZXMoKSwgYW5kIHRoZW5cXG4vLyBlbWl0IGEgc2luZ2xlIGNvbXByZXNzZWQgY2h1bmsgc29tZSB0aW1lIGluIHRoZSBmdXR1cmUuXFxuLy9cXG4vLyBIZXJlJ3MgaG93IHRoaXMgd29ya3M6XFxuLy9cXG4vLyBUaGUgVHJhbnNmb3JtIHN0cmVhbSBoYXMgYWxsIHRoZSBhc3BlY3RzIG9mIHRoZSByZWFkYWJsZSBhbmQgd3JpdGFibGVcXG4vLyBzdHJlYW0gY2xhc3Nlcy4gIFdoZW4geW91IHdyaXRlKGNodW5rKSwgdGhhdCBjYWxscyBfd3JpdGUoY2h1bmssY2IpXFxuLy8gaW50ZXJuYWxseSwgYW5kIHJldHVybnMgZmFsc2UgaWYgdGhlcmUncyBhIGxvdCBvZiBwZW5kaW5nIHdyaXRlc1xcbi8vIGJ1ZmZlcmVkIHVwLiAgV2hlbiB5b3UgY2FsbCByZWFkKCksIHRoYXQgY2FsbHMgX3JlYWQobikgdW50aWxcXG4vLyB0aGVyZSdzIGVub3VnaCBwZW5kaW5nIHJlYWRhYmxlIGRhdGEgYnVmZmVyZWQgdXAuXFxuLy9cXG4vLyBJbiBhIHRyYW5zZm9ybSBzdHJlYW0sIHRoZSB3cml0dGVuIGRhdGEgaXMgcGxhY2VkIGluIGEgYnVmZmVyLiAgV2hlblxcbi8vIF9yZWFkKG4pIGlzIGNhbGxlZCwgaXQgdHJhbnNmb3JtcyB0aGUgcXVldWVkIHVwIGRhdGEsIGNhbGxpbmcgdGhlXFxuLy8gYnVmZmVyZWQgX3dyaXRlIGNiJ3MgYXMgaXQgY29uc3VtZXMgY2h1bmtzLiAgSWYgY29uc3VtaW5nIGEgc2luZ2xlXFxuLy8gd3JpdHRlbiBjaHVuayB3b3VsZCByZXN1bHQgaW4gbXVsdGlwbGUgb3V0cHV0IGNodW5rcywgdGhlbiB0aGUgZmlyc3RcXG4vLyBvdXRwdXR0ZWQgYml0IGNhbGxzIHRoZSByZWFkY2IsIGFuZCBzdWJzZXF1ZW50IGNodW5rcyBqdXN0IGdvIGludG9cXG4vLyB0aGUgcmVhZCBidWZmZXIsIGFuZCB3aWxsIGNhdXNlIGl0IHRvIGVtaXQgJ3JlYWRhYmxlJyBpZiBuZWNlc3NhcnkuXFxuLy9cXG4vLyBUaGlzIHdheSwgYmFjay1wcmVzc3VyZSBpcyBhY3R1YWxseSBkZXRlcm1pbmVkIGJ5IHRoZSByZWFkaW5nIHNpZGUsXFxuLy8gc2luY2UgX3JlYWQgaGFzIHRvIGJlIGNhbGxlZCB0byBzdGFydCBwcm9jZXNzaW5nIGEgbmV3IGNodW5rLiAgSG93ZXZlcixcXG4vLyBhIHBhdGhvbG9naWNhbCBpbmZsYXRlIHR5cGUgb2YgdHJhbnNmb3JtIGNhbiBjYXVzZSBleGNlc3NpdmUgYnVmZmVyaW5nXFxuLy8gaGVyZS4gIEZvciBleGFtcGxlLCBpbWFnaW5lIGEgc3RyZWFtIHdoZXJlIGV2ZXJ5IGJ5dGUgb2YgaW5wdXQgaXNcXG4vLyBpbnRlcnByZXRlZCBhcyBhbiBpbnRlZ2VyIGZyb20gMC0yNTUsIGFuZCB0aGVuIHJlc3VsdHMgaW4gdGhhdCBtYW55XFxuLy8gYnl0ZXMgb2Ygb3V0cHV0LiAgV3JpdGluZyB0aGUgNCBieXRlcyB7ZmYsZmYsZmYsZmZ9IHdvdWxkIHJlc3VsdCBpblxcbi8vIDFrYiBvZiBkYXRhIGJlaW5nIG91dHB1dC4gIEluIHRoaXMgY2FzZSwgeW91IGNvdWxkIHdyaXRlIGEgdmVyeSBzbWFsbFxcbi8vIGFtb3VudCBvZiBpbnB1dCwgYW5kIGVuZCB1cCB3aXRoIGEgdmVyeSBsYXJnZSBhbW91bnQgb2Ygb3V0cHV0LiAgSW5cXG4vLyBzdWNoIGEgcGF0aG9sb2dpY2FsIGluZmxhdGluZyBtZWNoYW5pc20sIHRoZXJlJ2QgYmUgbm8gd2F5IHRvIHRlbGxcXG4vLyB0aGUgc3lzdGVtIHRvIHN0b3AgZG9pbmcgdGhlIHRyYW5zZm9ybS4gIEEgc2luZ2xlIDRNQiB3cml0ZSBjb3VsZFxcbi8vIGNhdXNlIHRoZSBzeXN0ZW0gdG8gcnVuIG91dCBvZiBtZW1vcnkuXFxuLy9cXG4vLyBIb3dldmVyLCBldmVuIGluIHN1Y2ggYSBwYXRob2xvZ2ljYWwgY2FzZSwgb25seSBhIHNpbmdsZSB3cml0dGVuIGNodW5rXFxuLy8gd291bGQgYmUgY29uc3VtZWQsIGFuZCB0aGVuIHRoZSByZXN0IHdvdWxkIHdhaXQgKHVuLXRyYW5zZm9ybWVkKSB1bnRpbFxcbi8vIHRoZSByZXN1bHRzIG9mIHRoZSBwcmV2aW91cyB0cmFuc2Zvcm1lZCBjaHVuayB3ZXJlIGNvbnN1bWVkLlxcblxcbid1c2Ugc3RyaWN0JztcXG5cXG5tb2R1bGUuZXhwb3J0cyA9IFRyYW5zZm9ybTtcXG5cXG52YXIgRHVwbGV4ID0gcmVxdWlyZSgnLi9fc3RyZWFtX2R1cGxleCcpO1xcblxcbi8qPHJlcGxhY2VtZW50PiovXFxudmFyIHV0aWwgPSByZXF1aXJlKCdjb3JlLXV0aWwtaXMnKTtcXG51dGlsLmluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcXG4vKjwvcmVwbGFjZW1lbnQ+Ki9cXG5cXG51dGlsLmluaGVyaXRzKFRyYW5zZm9ybSwgRHVwbGV4KTtcXG5cXG5mdW5jdGlvbiBUcmFuc2Zvcm1TdGF0ZShzdHJlYW0pIHtcXG4gIHRoaXMuYWZ0ZXJUcmFuc2Zvcm0gPSBmdW5jdGlvbiAoZXIsIGRhdGEpIHtcXG4gICAgcmV0dXJuIGFmdGVyVHJhbnNmb3JtKHN0cmVhbSwgZXIsIGRhdGEpO1xcbiAgfTtcXG5cXG4gIHRoaXMubmVlZFRyYW5zZm9ybSA9IGZhbHNlO1xcbiAgdGhpcy50cmFuc2Zvcm1pbmcgPSBmYWxzZTtcXG4gIHRoaXMud3JpdGVjYiA9IG51bGw7XFxuICB0aGlzLndyaXRlY2h1bmsgPSBudWxsO1xcbiAgdGhpcy53cml0ZWVuY29kaW5nID0gbnVsbDtcXG59XFxuXFxuZnVuY3Rpb24gYWZ0ZXJUcmFuc2Zvcm0oc3RyZWFtLCBlciwgZGF0YSkge1xcbiAgdmFyIHRzID0gc3RyZWFtLl90cmFuc2Zvcm1TdGF0ZTtcXG4gIHRzLnRyYW5zZm9ybWluZyA9IGZhbHNlO1xcblxcbiAgdmFyIGNiID0gdHMud3JpdGVjYjtcXG5cXG4gIGlmICghY2IpIHJldHVybiBzdHJlYW0uZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoJ25vIHdyaXRlY2IgaW4gVHJhbnNmb3JtIGNsYXNzJykpO1xcblxcbiAgdHMud3JpdGVjaHVuayA9IG51bGw7XFxuICB0cy53cml0ZWNiID0gbnVsbDtcXG5cXG4gIGlmIChkYXRhICE9PSBudWxsICYmIGRhdGEgIT09IHVuZGVmaW5lZCkgc3RyZWFtLnB1c2goZGF0YSk7XFxuXFxuICBjYihlcik7XFxuXFxuICB2YXIgcnMgPSBzdHJlYW0uX3JlYWRhYmxlU3RhdGU7XFxuICBycy5yZWFkaW5nID0gZmFsc2U7XFxuICBpZiAocnMubmVlZFJlYWRhYmxlIHx8IHJzLmxlbmd0aCA8IHJzLmhpZ2hXYXRlck1hcmspIHtcXG4gICAgc3RyZWFtLl9yZWFkKHJzLmhpZ2hXYXRlck1hcmspO1xcbiAgfVxcbn1cXG5cXG5mdW5jdGlvbiBUcmFuc2Zvcm0ob3B0aW9ucykge1xcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFRyYW5zZm9ybSkpIHJldHVybiBuZXcgVHJhbnNmb3JtKG9wdGlvbnMpO1xcblxcbiAgRHVwbGV4LmNhbGwodGhpcywgb3B0aW9ucyk7XFxuXFxuICB0aGlzLl90cmFuc2Zvcm1TdGF0ZSA9IG5ldyBUcmFuc2Zvcm1TdGF0ZSh0aGlzKTtcXG5cXG4gIHZhciBzdHJlYW0gPSB0aGlzO1xcblxcbiAgLy8gc3RhcnQgb3V0IGFza2luZyBmb3IgYSByZWFkYWJsZSBldmVudCBvbmNlIGRhdGEgaXMgdHJhbnNmb3JtZWQuXFxuICB0aGlzLl9yZWFkYWJsZVN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XFxuXFxuICAvLyB3ZSBoYXZlIGltcGxlbWVudGVkIHRoZSBfcmVhZCBtZXRob2QsIGFuZCBkb25lIHRoZSBvdGhlciB0aGluZ3NcXG4gIC8vIHRoYXQgUmVhZGFibGUgd2FudHMgYmVmb3JlIHRoZSBmaXJzdCBfcmVhZCBjYWxsLCBzbyB1bnNldCB0aGVcXG4gIC8vIHN5bmMgZ3VhcmQgZmxhZy5cXG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUuc3luYyA9IGZhbHNlO1xcblxcbiAgaWYgKG9wdGlvbnMpIHtcXG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLnRyYW5zZm9ybSA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fdHJhbnNmb3JtID0gb3B0aW9ucy50cmFuc2Zvcm07XFxuXFxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5mbHVzaCA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fZmx1c2ggPSBvcHRpb25zLmZsdXNoO1xcbiAgfVxcblxcbiAgLy8gV2hlbiB0aGUgd3JpdGFibGUgc2lkZSBmaW5pc2hlcywgdGhlbiBmbHVzaCBvdXQgYW55dGhpbmcgcmVtYWluaW5nLlxcbiAgdGhpcy5vbmNlKCdwcmVmaW5pc2gnLCBmdW5jdGlvbiAoKSB7XFxuICAgIGlmICh0eXBlb2YgdGhpcy5fZmx1c2ggPT09ICdmdW5jdGlvbicpIHRoaXMuX2ZsdXNoKGZ1bmN0aW9uIChlciwgZGF0YSkge1xcbiAgICAgIGRvbmUoc3RyZWFtLCBlciwgZGF0YSk7XFxuICAgIH0pO2Vsc2UgZG9uZShzdHJlYW0pO1xcbiAgfSk7XFxufVxcblxcblRyYW5zZm9ybS5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcpIHtcXG4gIHRoaXMuX3RyYW5zZm9ybVN0YXRlLm5lZWRUcmFuc2Zvcm0gPSBmYWxzZTtcXG4gIHJldHVybiBEdXBsZXgucHJvdG90eXBlLnB1c2guY2FsbCh0aGlzLCBjaHVuaywgZW5jb2RpbmcpO1xcbn07XFxuXFxuLy8gVGhpcyBpcyB0aGUgcGFydCB3aGVyZSB5b3UgZG8gc3R1ZmYhXFxuLy8gb3ZlcnJpZGUgdGhpcyBmdW5jdGlvbiBpbiBpbXBsZW1lbnRhdGlvbiBjbGFzc2VzLlxcbi8vICdjaHVuaycgaXMgYW4gaW5wdXQgY2h1bmsuXFxuLy9cXG4vLyBDYWxsIGBwdXNoKG5ld0NodW5rKWAgdG8gcGFzcyBhbG9uZyB0cmFuc2Zvcm1lZCBvdXRwdXRcXG4vLyB0byB0aGUgcmVhZGFibGUgc2lkZS4gIFlvdSBtYXkgY2FsbCAncHVzaCcgemVybyBvciBtb3JlIHRpbWVzLlxcbi8vXFxuLy8gQ2FsbCBgY2IoZXJyKWAgd2hlbiB5b3UgYXJlIGRvbmUgd2l0aCB0aGlzIGNodW5rLiAgSWYgeW91IHBhc3NcXG4vLyBhbiBlcnJvciwgdGhlbiB0aGF0J2xsIHB1dCB0aGUgaHVydCBvbiB0aGUgd2hvbGUgb3BlcmF0aW9uLiAgSWYgeW91XFxuLy8gbmV2ZXIgY2FsbCBjYigpLCB0aGVuIHlvdSdsbCBuZXZlciBnZXQgYW5vdGhlciBjaHVuay5cXG5UcmFuc2Zvcm0ucHJvdG90eXBlLl90cmFuc2Zvcm0gPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nLCBjYikge1xcbiAgdGhyb3cgbmV3IEVycm9yKCdfdHJhbnNmb3JtKCkgaXMgbm90IGltcGxlbWVudGVkJyk7XFxufTtcXG5cXG5UcmFuc2Zvcm0ucHJvdG90eXBlLl93cml0ZSA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcsIGNiKSB7XFxuICB2YXIgdHMgPSB0aGlzLl90cmFuc2Zvcm1TdGF0ZTtcXG4gIHRzLndyaXRlY2IgPSBjYjtcXG4gIHRzLndyaXRlY2h1bmsgPSBjaHVuaztcXG4gIHRzLndyaXRlZW5jb2RpbmcgPSBlbmNvZGluZztcXG4gIGlmICghdHMudHJhbnNmb3JtaW5nKSB7XFxuICAgIHZhciBycyA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XFxuICAgIGlmICh0cy5uZWVkVHJhbnNmb3JtIHx8IHJzLm5lZWRSZWFkYWJsZSB8fCBycy5sZW5ndGggPCBycy5oaWdoV2F0ZXJNYXJrKSB0aGlzLl9yZWFkKHJzLmhpZ2hXYXRlck1hcmspO1xcbiAgfVxcbn07XFxuXFxuLy8gRG9lc24ndCBtYXR0ZXIgd2hhdCB0aGUgYXJncyBhcmUgaGVyZS5cXG4vLyBfdHJhbnNmb3JtIGRvZXMgYWxsIHRoZSB3b3JrLlxcbi8vIFRoYXQgd2UgZ290IGhlcmUgbWVhbnMgdGhhdCB0aGUgcmVhZGFibGUgc2lkZSB3YW50cyBtb3JlIGRhdGEuXFxuVHJhbnNmb3JtLnByb3RvdHlwZS5fcmVhZCA9IGZ1bmN0aW9uIChuKSB7XFxuICB2YXIgdHMgPSB0aGlzLl90cmFuc2Zvcm1TdGF0ZTtcXG5cXG4gIGlmICh0cy53cml0ZWNodW5rICE9PSBudWxsICYmIHRzLndyaXRlY2IgJiYgIXRzLnRyYW5zZm9ybWluZykge1xcbiAgICB0cy50cmFuc2Zvcm1pbmcgPSB0cnVlO1xcbiAgICB0aGlzLl90cmFuc2Zvcm0odHMud3JpdGVjaHVuaywgdHMud3JpdGVlbmNvZGluZywgdHMuYWZ0ZXJUcmFuc2Zvcm0pO1xcbiAgfSBlbHNlIHtcXG4gICAgLy8gbWFyayB0aGF0IHdlIG5lZWQgYSB0cmFuc2Zvcm0sIHNvIHRoYXQgYW55IGRhdGEgdGhhdCBjb21lcyBpblxcbiAgICAvLyB3aWxsIGdldCBwcm9jZXNzZWQsIG5vdyB0aGF0IHdlJ3ZlIGFza2VkIGZvciBpdC5cXG4gICAgdHMubmVlZFRyYW5zZm9ybSA9IHRydWU7XFxuICB9XFxufTtcXG5cXG5mdW5jdGlvbiBkb25lKHN0cmVhbSwgZXIsIGRhdGEpIHtcXG4gIGlmIChlcikgcmV0dXJuIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVyKTtcXG5cXG4gIGlmIChkYXRhICE9PSBudWxsICYmIGRhdGEgIT09IHVuZGVmaW5lZCkgc3RyZWFtLnB1c2goZGF0YSk7XFxuXFxuICAvLyBpZiB0aGVyZSdzIG5vdGhpbmcgaW4gdGhlIHdyaXRlIGJ1ZmZlciwgdGhlbiB0aGF0IG1lYW5zXFxuICAvLyB0aGF0IG5vdGhpbmcgbW9yZSB3aWxsIGV2ZXIgYmUgcHJvdmlkZWRcXG4gIHZhciB3cyA9IHN0cmVhbS5fd3JpdGFibGVTdGF0ZTtcXG4gIHZhciB0cyA9IHN0cmVhbS5fdHJhbnNmb3JtU3RhdGU7XFxuXFxuICBpZiAod3MubGVuZ3RoKSB0aHJvdyBuZXcgRXJyb3IoJ0NhbGxpbmcgdHJhbnNmb3JtIGRvbmUgd2hlbiB3cy5sZW5ndGggIT0gMCcpO1xcblxcbiAgaWYgKHRzLnRyYW5zZm9ybWluZykgdGhyb3cgbmV3IEVycm9yKCdDYWxsaW5nIHRyYW5zZm9ybSBkb25lIHdoZW4gc3RpbGwgdHJhbnNmb3JtaW5nJyk7XFxuXFxuICByZXR1cm4gc3RyZWFtLnB1c2gobnVsbCk7XFxufVxcbn0se1xcXCIuL19zdHJlYW1fZHVwbGV4XFxcIjo4NCxcXFwiY29yZS11dGlsLWlzXFxcIjo0NCxcXFwiaW5oZXJpdHNcXFwiOjY2fV0sODg6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xcbihmdW5jdGlvbiAocHJvY2Vzcyl7XFxuLy8gQSBiaXQgc2ltcGxlciB0aGFuIHJlYWRhYmxlIHN0cmVhbXMuXFxuLy8gSW1wbGVtZW50IGFuIGFzeW5jIC5fd3JpdGUoY2h1bmssIGVuY29kaW5nLCBjYiksIGFuZCBpdCdsbCBoYW5kbGUgYWxsXFxuLy8gdGhlIGRyYWluIGV2ZW50IGVtaXNzaW9uIGFuZCBidWZmZXJpbmcuXFxuXFxuJ3VzZSBzdHJpY3QnO1xcblxcbm1vZHVsZS5leHBvcnRzID0gV3JpdGFibGU7XFxuXFxuLyo8cmVwbGFjZW1lbnQ+Ki9cXG52YXIgcHJvY2Vzc05leHRUaWNrID0gcmVxdWlyZSgncHJvY2Vzcy1uZXh0aWNrLWFyZ3MnKTtcXG4vKjwvcmVwbGFjZW1lbnQ+Ki9cXG5cXG4vKjxyZXBsYWNlbWVudD4qL1xcbnZhciBhc3luY1dyaXRlID0gIXByb2Nlc3MuYnJvd3NlciAmJiBbJ3YwLjEwJywgJ3YwLjkuJ10uaW5kZXhPZihwcm9jZXNzLnZlcnNpb24uc2xpY2UoMCwgNSkpID4gLTEgPyBzZXRJbW1lZGlhdGUgOiBwcm9jZXNzTmV4dFRpY2s7XFxuLyo8L3JlcGxhY2VtZW50PiovXFxuXFxuLyo8cmVwbGFjZW1lbnQ+Ki9cXG52YXIgRHVwbGV4O1xcbi8qPC9yZXBsYWNlbWVudD4qL1xcblxcbldyaXRhYmxlLldyaXRhYmxlU3RhdGUgPSBXcml0YWJsZVN0YXRlO1xcblxcbi8qPHJlcGxhY2VtZW50PiovXFxudmFyIHV0aWwgPSByZXF1aXJlKCdjb3JlLXV0aWwtaXMnKTtcXG51dGlsLmluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcXG4vKjwvcmVwbGFjZW1lbnQ+Ki9cXG5cXG4vKjxyZXBsYWNlbWVudD4qL1xcbnZhciBpbnRlcm5hbFV0aWwgPSB7XFxuICBkZXByZWNhdGU6IHJlcXVpcmUoJ3V0aWwtZGVwcmVjYXRlJylcXG59O1xcbi8qPC9yZXBsYWNlbWVudD4qL1xcblxcbi8qPHJlcGxhY2VtZW50PiovXFxudmFyIFN0cmVhbSA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvc3RyZWFtcy9zdHJlYW0nKTtcXG4vKjwvcmVwbGFjZW1lbnQ+Ki9cXG5cXG4vKjxyZXBsYWNlbWVudD4qL1xcbnZhciBCdWZmZXIgPSByZXF1aXJlKCdzYWZlLWJ1ZmZlcicpLkJ1ZmZlcjtcXG4vKjwvcmVwbGFjZW1lbnQ+Ki9cXG5cXG51dGlsLmluaGVyaXRzKFdyaXRhYmxlLCBTdHJlYW0pO1xcblxcbmZ1bmN0aW9uIG5vcCgpIHt9XFxuXFxuZnVuY3Rpb24gV3JpdGVSZXEoY2h1bmssIGVuY29kaW5nLCBjYikge1xcbiAgdGhpcy5jaHVuayA9IGNodW5rO1xcbiAgdGhpcy5lbmNvZGluZyA9IGVuY29kaW5nO1xcbiAgdGhpcy5jYWxsYmFjayA9IGNiO1xcbiAgdGhpcy5uZXh0ID0gbnVsbDtcXG59XFxuXFxuZnVuY3Rpb24gV3JpdGFibGVTdGF0ZShvcHRpb25zLCBzdHJlYW0pIHtcXG4gIER1cGxleCA9IER1cGxleCB8fCByZXF1aXJlKCcuL19zdHJlYW1fZHVwbGV4Jyk7XFxuXFxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcXG5cXG4gIC8vIG9iamVjdCBzdHJlYW0gZmxhZyB0byBpbmRpY2F0ZSB3aGV0aGVyIG9yIG5vdCB0aGlzIHN0cmVhbVxcbiAgLy8gY29udGFpbnMgYnVmZmVycyBvciBvYmplY3RzLlxcbiAgdGhpcy5vYmplY3RNb2RlID0gISFvcHRpb25zLm9iamVjdE1vZGU7XFxuXFxuICBpZiAoc3RyZWFtIGluc3RhbmNlb2YgRHVwbGV4KSB0aGlzLm9iamVjdE1vZGUgPSB0aGlzLm9iamVjdE1vZGUgfHwgISFvcHRpb25zLndyaXRhYmxlT2JqZWN0TW9kZTtcXG5cXG4gIC8vIHRoZSBwb2ludCBhdCB3aGljaCB3cml0ZSgpIHN0YXJ0cyByZXR1cm5pbmcgZmFsc2VcXG4gIC8vIE5vdGU6IDAgaXMgYSB2YWxpZCB2YWx1ZSwgbWVhbnMgdGhhdCB3ZSBhbHdheXMgcmV0dXJuIGZhbHNlIGlmXFxuICAvLyB0aGUgZW50aXJlIGJ1ZmZlciBpcyBub3QgZmx1c2hlZCBpbW1lZGlhdGVseSBvbiB3cml0ZSgpXFxuICB2YXIgaHdtID0gb3B0aW9ucy5oaWdoV2F0ZXJNYXJrO1xcbiAgdmFyIGRlZmF1bHRId20gPSB0aGlzLm9iamVjdE1vZGUgPyAxNiA6IDE2ICogMTAyNDtcXG4gIHRoaXMuaGlnaFdhdGVyTWFyayA9IGh3bSB8fCBod20gPT09IDAgPyBod20gOiBkZWZhdWx0SHdtO1xcblxcbiAgLy8gY2FzdCB0byBpbnRzLlxcbiAgdGhpcy5oaWdoV2F0ZXJNYXJrID0gfn50aGlzLmhpZ2hXYXRlck1hcms7XFxuXFxuICAvLyBkcmFpbiBldmVudCBmbGFnLlxcbiAgdGhpcy5uZWVkRHJhaW4gPSBmYWxzZTtcXG4gIC8vIGF0IHRoZSBzdGFydCBvZiBjYWxsaW5nIGVuZCgpXFxuICB0aGlzLmVuZGluZyA9IGZhbHNlO1xcbiAgLy8gd2hlbiBlbmQoKSBoYXMgYmVlbiBjYWxsZWQsIGFuZCByZXR1cm5lZFxcbiAgdGhpcy5lbmRlZCA9IGZhbHNlO1xcbiAgLy8gd2hlbiAnZmluaXNoJyBpcyBlbWl0dGVkXFxuICB0aGlzLmZpbmlzaGVkID0gZmFsc2U7XFxuXFxuICAvLyBzaG91bGQgd2UgZGVjb2RlIHN0cmluZ3MgaW50byBidWZmZXJzIGJlZm9yZSBwYXNzaW5nIHRvIF93cml0ZT9cXG4gIC8vIHRoaXMgaXMgaGVyZSBzbyB0aGF0IHNvbWUgbm9kZS1jb3JlIHN0cmVhbXMgY2FuIG9wdGltaXplIHN0cmluZ1xcbiAgLy8gaGFuZGxpbmcgYXQgYSBsb3dlciBsZXZlbC5cXG4gIHZhciBub0RlY29kZSA9IG9wdGlvbnMuZGVjb2RlU3RyaW5ncyA9PT0gZmFsc2U7XFxuICB0aGlzLmRlY29kZVN0cmluZ3MgPSAhbm9EZWNvZGU7XFxuXFxuICAvLyBDcnlwdG8gaXMga2luZCBvZiBvbGQgYW5kIGNydXN0eS4gIEhpc3RvcmljYWxseSwgaXRzIGRlZmF1bHQgc3RyaW5nXFxuICAvLyBlbmNvZGluZyBpcyAnYmluYXJ5JyBzbyB3ZSBoYXZlIHRvIG1ha2UgdGhpcyBjb25maWd1cmFibGUuXFxuICAvLyBFdmVyeXRoaW5nIGVsc2UgaW4gdGhlIHVuaXZlcnNlIHVzZXMgJ3V0ZjgnLCB0aG91Z2guXFxuICB0aGlzLmRlZmF1bHRFbmNvZGluZyA9IG9wdGlvbnMuZGVmYXVsdEVuY29kaW5nIHx8ICd1dGY4JztcXG5cXG4gIC8vIG5vdCBhbiBhY3R1YWwgYnVmZmVyIHdlIGtlZXAgdHJhY2sgb2YsIGJ1dCBhIG1lYXN1cmVtZW50XFxuICAvLyBvZiBob3cgbXVjaCB3ZSdyZSB3YWl0aW5nIHRvIGdldCBwdXNoZWQgdG8gc29tZSB1bmRlcmx5aW5nXFxuICAvLyBzb2NrZXQgb3IgZmlsZS5cXG4gIHRoaXMubGVuZ3RoID0gMDtcXG5cXG4gIC8vIGEgZmxhZyB0byBzZWUgd2hlbiB3ZSdyZSBpbiB0aGUgbWlkZGxlIG9mIGEgd3JpdGUuXFxuICB0aGlzLndyaXRpbmcgPSBmYWxzZTtcXG5cXG4gIC8vIHdoZW4gdHJ1ZSBhbGwgd3JpdGVzIHdpbGwgYmUgYnVmZmVyZWQgdW50aWwgLnVuY29yaygpIGNhbGxcXG4gIHRoaXMuY29ya2VkID0gMDtcXG5cXG4gIC8vIGEgZmxhZyB0byBiZSBhYmxlIHRvIHRlbGwgaWYgdGhlIG9ud3JpdGUgY2IgaXMgY2FsbGVkIGltbWVkaWF0ZWx5LFxcbiAgLy8gb3Igb24gYSBsYXRlciB0aWNrLiAgV2Ugc2V0IHRoaXMgdG8gdHJ1ZSBhdCBmaXJzdCwgYmVjYXVzZSBhbnlcXG4gIC8vIGFjdGlvbnMgdGhhdCBzaG91bGRuJ3QgaGFwcGVuIHVudGlsIFxcXCJsYXRlclxcXCIgc2hvdWxkIGdlbmVyYWxseSBhbHNvXFxuICAvLyBub3QgaGFwcGVuIGJlZm9yZSB0aGUgZmlyc3Qgd3JpdGUgY2FsbC5cXG4gIHRoaXMuc3luYyA9IHRydWU7XFxuXFxuICAvLyBhIGZsYWcgdG8ga25vdyBpZiB3ZSdyZSBwcm9jZXNzaW5nIHByZXZpb3VzbHkgYnVmZmVyZWQgaXRlbXMsIHdoaWNoXFxuICAvLyBtYXkgY2FsbCB0aGUgX3dyaXRlKCkgY2FsbGJhY2sgaW4gdGhlIHNhbWUgdGljaywgc28gdGhhdCB3ZSBkb24ndFxcbiAgLy8gZW5kIHVwIGluIGFuIG92ZXJsYXBwZWQgb253cml0ZSBzaXR1YXRpb24uXFxuICB0aGlzLmJ1ZmZlclByb2Nlc3NpbmcgPSBmYWxzZTtcXG5cXG4gIC8vIHRoZSBjYWxsYmFjayB0aGF0J3MgcGFzc2VkIHRvIF93cml0ZShjaHVuayxjYilcXG4gIHRoaXMub253cml0ZSA9IGZ1bmN0aW9uIChlcikge1xcbiAgICBvbndyaXRlKHN0cmVhbSwgZXIpO1xcbiAgfTtcXG5cXG4gIC8vIHRoZSBjYWxsYmFjayB0aGF0IHRoZSB1c2VyIHN1cHBsaWVzIHRvIHdyaXRlKGNodW5rLGVuY29kaW5nLGNiKVxcbiAgdGhpcy53cml0ZWNiID0gbnVsbDtcXG5cXG4gIC8vIHRoZSBhbW91bnQgdGhhdCBpcyBiZWluZyB3cml0dGVuIHdoZW4gX3dyaXRlIGlzIGNhbGxlZC5cXG4gIHRoaXMud3JpdGVsZW4gPSAwO1xcblxcbiAgdGhpcy5idWZmZXJlZFJlcXVlc3QgPSBudWxsO1xcbiAgdGhpcy5sYXN0QnVmZmVyZWRSZXF1ZXN0ID0gbnVsbDtcXG5cXG4gIC8vIG51bWJlciBvZiBwZW5kaW5nIHVzZXItc3VwcGxpZWQgd3JpdGUgY2FsbGJhY2tzXFxuICAvLyB0aGlzIG11c3QgYmUgMCBiZWZvcmUgJ2ZpbmlzaCcgY2FuIGJlIGVtaXR0ZWRcXG4gIHRoaXMucGVuZGluZ2NiID0gMDtcXG5cXG4gIC8vIGVtaXQgcHJlZmluaXNoIGlmIHRoZSBvbmx5IHRoaW5nIHdlJ3JlIHdhaXRpbmcgZm9yIGlzIF93cml0ZSBjYnNcXG4gIC8vIFRoaXMgaXMgcmVsZXZhbnQgZm9yIHN5bmNocm9ub3VzIFRyYW5zZm9ybSBzdHJlYW1zXFxuICB0aGlzLnByZWZpbmlzaGVkID0gZmFsc2U7XFxuXFxuICAvLyBUcnVlIGlmIHRoZSBlcnJvciB3YXMgYWxyZWFkeSBlbWl0dGVkIGFuZCBzaG91bGQgbm90IGJlIHRocm93biBhZ2FpblxcbiAgdGhpcy5lcnJvckVtaXR0ZWQgPSBmYWxzZTtcXG5cXG4gIC8vIGNvdW50IGJ1ZmZlcmVkIHJlcXVlc3RzXFxuICB0aGlzLmJ1ZmZlcmVkUmVxdWVzdENvdW50ID0gMDtcXG5cXG4gIC8vIGFsbG9jYXRlIHRoZSBmaXJzdCBDb3JrZWRSZXF1ZXN0LCB0aGVyZSBpcyBhbHdheXNcXG4gIC8vIG9uZSBhbGxvY2F0ZWQgYW5kIGZyZWUgdG8gdXNlLCBhbmQgd2UgbWFpbnRhaW4gYXQgbW9zdCB0d29cXG4gIHRoaXMuY29ya2VkUmVxdWVzdHNGcmVlID0gbmV3IENvcmtlZFJlcXVlc3QodGhpcyk7XFxufVxcblxcbldyaXRhYmxlU3RhdGUucHJvdG90eXBlLmdldEJ1ZmZlciA9IGZ1bmN0aW9uIGdldEJ1ZmZlcigpIHtcXG4gIHZhciBjdXJyZW50ID0gdGhpcy5idWZmZXJlZFJlcXVlc3Q7XFxuICB2YXIgb3V0ID0gW107XFxuICB3aGlsZSAoY3VycmVudCkge1xcbiAgICBvdXQucHVzaChjdXJyZW50KTtcXG4gICAgY3VycmVudCA9IGN1cnJlbnQubmV4dDtcXG4gIH1cXG4gIHJldHVybiBvdXQ7XFxufTtcXG5cXG4oZnVuY3Rpb24gKCkge1xcbiAgdHJ5IHtcXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFdyaXRhYmxlU3RhdGUucHJvdG90eXBlLCAnYnVmZmVyJywge1xcbiAgICAgIGdldDogaW50ZXJuYWxVdGlsLmRlcHJlY2F0ZShmdW5jdGlvbiAoKSB7XFxuICAgICAgICByZXR1cm4gdGhpcy5nZXRCdWZmZXIoKTtcXG4gICAgICB9LCAnX3dyaXRhYmxlU3RhdGUuYnVmZmVyIGlzIGRlcHJlY2F0ZWQuIFVzZSBfd3JpdGFibGVTdGF0ZS5nZXRCdWZmZXIgJyArICdpbnN0ZWFkLicpXFxuICAgIH0pO1xcbiAgfSBjYXRjaCAoXykge31cXG59KSgpO1xcblxcbi8vIFRlc3QgX3dyaXRhYmxlU3RhdGUgZm9yIGluaGVyaXRhbmNlIHRvIGFjY291bnQgZm9yIER1cGxleCBzdHJlYW1zLFxcbi8vIHdob3NlIHByb3RvdHlwZSBjaGFpbiBvbmx5IHBvaW50cyB0byBSZWFkYWJsZS5cXG52YXIgcmVhbEhhc0luc3RhbmNlO1xcbmlmICh0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIFN5bWJvbC5oYXNJbnN0YW5jZSAmJiB0eXBlb2YgRnVuY3Rpb24ucHJvdG90eXBlW1N5bWJvbC5oYXNJbnN0YW5jZV0gPT09ICdmdW5jdGlvbicpIHtcXG4gIHJlYWxIYXNJbnN0YW5jZSA9IEZ1bmN0aW9uLnByb3RvdHlwZVtTeW1ib2wuaGFzSW5zdGFuY2VdO1xcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFdyaXRhYmxlLCBTeW1ib2wuaGFzSW5zdGFuY2UsIHtcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIChvYmplY3QpIHtcXG4gICAgICBpZiAocmVhbEhhc0luc3RhbmNlLmNhbGwodGhpcywgb2JqZWN0KSkgcmV0dXJuIHRydWU7XFxuXFxuICAgICAgcmV0dXJuIG9iamVjdCAmJiBvYmplY3QuX3dyaXRhYmxlU3RhdGUgaW5zdGFuY2VvZiBXcml0YWJsZVN0YXRlO1xcbiAgICB9XFxuICB9KTtcXG59IGVsc2Uge1xcbiAgcmVhbEhhc0luc3RhbmNlID0gZnVuY3Rpb24gKG9iamVjdCkge1xcbiAgICByZXR1cm4gb2JqZWN0IGluc3RhbmNlb2YgdGhpcztcXG4gIH07XFxufVxcblxcbmZ1bmN0aW9uIFdyaXRhYmxlKG9wdGlvbnMpIHtcXG4gIER1cGxleCA9IER1cGxleCB8fCByZXF1aXJlKCcuL19zdHJlYW1fZHVwbGV4Jyk7XFxuXFxuICAvLyBXcml0YWJsZSBjdG9yIGlzIGFwcGxpZWQgdG8gRHVwbGV4ZXMsIHRvby5cXG4gIC8vIGByZWFsSGFzSW5zdGFuY2VgIGlzIG5lY2Vzc2FyeSBiZWNhdXNlIHVzaW5nIHBsYWluIGBpbnN0YW5jZW9mYFxcbiAgLy8gd291bGQgcmV0dXJuIGZhbHNlLCBhcyBubyBgX3dyaXRhYmxlU3RhdGVgIHByb3BlcnR5IGlzIGF0dGFjaGVkLlxcblxcbiAgLy8gVHJ5aW5nIHRvIHVzZSB0aGUgY3VzdG9tIGBpbnN0YW5jZW9mYCBmb3IgV3JpdGFibGUgaGVyZSB3aWxsIGFsc28gYnJlYWsgdGhlXFxuICAvLyBOb2RlLmpzIExhenlUcmFuc2Zvcm0gaW1wbGVtZW50YXRpb24sIHdoaWNoIGhhcyBhIG5vbi10cml2aWFsIGdldHRlciBmb3JcXG4gIC8vIGBfd3JpdGFibGVTdGF0ZWAgdGhhdCB3b3VsZCBsZWFkIHRvIGluZmluaXRlIHJlY3Vyc2lvbi5cXG4gIGlmICghcmVhbEhhc0luc3RhbmNlLmNhbGwoV3JpdGFibGUsIHRoaXMpICYmICEodGhpcyBpbnN0YW5jZW9mIER1cGxleCkpIHtcXG4gICAgcmV0dXJuIG5ldyBXcml0YWJsZShvcHRpb25zKTtcXG4gIH1cXG5cXG4gIHRoaXMuX3dyaXRhYmxlU3RhdGUgPSBuZXcgV3JpdGFibGVTdGF0ZShvcHRpb25zLCB0aGlzKTtcXG5cXG4gIC8vIGxlZ2FjeS5cXG4gIHRoaXMud3JpdGFibGUgPSB0cnVlO1xcblxcbiAgaWYgKG9wdGlvbnMpIHtcXG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLndyaXRlID09PSAnZnVuY3Rpb24nKSB0aGlzLl93cml0ZSA9IG9wdGlvbnMud3JpdGU7XFxuXFxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy53cml0ZXYgPT09ICdmdW5jdGlvbicpIHRoaXMuX3dyaXRldiA9IG9wdGlvbnMud3JpdGV2O1xcbiAgfVxcblxcbiAgU3RyZWFtLmNhbGwodGhpcyk7XFxufVxcblxcbi8vIE90aGVyd2lzZSBwZW9wbGUgY2FuIHBpcGUgV3JpdGFibGUgc3RyZWFtcywgd2hpY2ggaXMganVzdCB3cm9uZy5cXG5Xcml0YWJsZS5wcm90b3R5cGUucGlwZSA9IGZ1bmN0aW9uICgpIHtcXG4gIHRoaXMuZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoJ0Nhbm5vdCBwaXBlLCBub3QgcmVhZGFibGUnKSk7XFxufTtcXG5cXG5mdW5jdGlvbiB3cml0ZUFmdGVyRW5kKHN0cmVhbSwgY2IpIHtcXG4gIHZhciBlciA9IG5ldyBFcnJvcignd3JpdGUgYWZ0ZXIgZW5kJyk7XFxuICAvLyBUT0RPOiBkZWZlciBlcnJvciBldmVudHMgY29uc2lzdGVudGx5IGV2ZXJ5d2hlcmUsIG5vdCBqdXN0IHRoZSBjYlxcbiAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXIpO1xcbiAgcHJvY2Vzc05leHRUaWNrKGNiLCBlcik7XFxufVxcblxcbi8vIENoZWNrcyB0aGF0IGEgdXNlci1zdXBwbGllZCBjaHVuayBpcyB2YWxpZCwgZXNwZWNpYWxseSBmb3IgdGhlIHBhcnRpY3VsYXJcXG4vLyBtb2RlIHRoZSBzdHJlYW0gaXMgaW4uIEN1cnJlbnRseSB0aGlzIG1lYW5zIHRoYXQgYG51bGxgIGlzIG5ldmVyIGFjY2VwdGVkXFxuLy8gYW5kIHVuZGVmaW5lZC9ub24tc3RyaW5nIHZhbHVlcyBhcmUgb25seSBhbGxvd2VkIGluIG9iamVjdCBtb2RlLlxcbmZ1bmN0aW9uIHZhbGlkQ2h1bmsoc3RyZWFtLCBzdGF0ZSwgY2h1bmssIGNiKSB7XFxuICB2YXIgdmFsaWQgPSB0cnVlO1xcbiAgdmFyIGVyID0gZmFsc2U7XFxuXFxuICBpZiAoY2h1bmsgPT09IG51bGwpIHtcXG4gICAgZXIgPSBuZXcgVHlwZUVycm9yKCdNYXkgbm90IHdyaXRlIG51bGwgdmFsdWVzIHRvIHN0cmVhbScpO1xcbiAgfSBlbHNlIGlmICh0eXBlb2YgY2h1bmsgIT09ICdzdHJpbmcnICYmIGNodW5rICE9PSB1bmRlZmluZWQgJiYgIXN0YXRlLm9iamVjdE1vZGUpIHtcXG4gICAgZXIgPSBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIG5vbi1zdHJpbmcvYnVmZmVyIGNodW5rJyk7XFxuICB9XFxuICBpZiAoZXIpIHtcXG4gICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXIpO1xcbiAgICBwcm9jZXNzTmV4dFRpY2soY2IsIGVyKTtcXG4gICAgdmFsaWQgPSBmYWxzZTtcXG4gIH1cXG4gIHJldHVybiB2YWxpZDtcXG59XFxuXFxuV3JpdGFibGUucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2IpIHtcXG4gIHZhciBzdGF0ZSA9IHRoaXMuX3dyaXRhYmxlU3RhdGU7XFxuICB2YXIgcmV0ID0gZmFsc2U7XFxuICB2YXIgaXNCdWYgPSBCdWZmZXIuaXNCdWZmZXIoY2h1bmspO1xcblxcbiAgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ2Z1bmN0aW9uJykge1xcbiAgICBjYiA9IGVuY29kaW5nO1xcbiAgICBlbmNvZGluZyA9IG51bGw7XFxuICB9XFxuXFxuICBpZiAoaXNCdWYpIGVuY29kaW5nID0gJ2J1ZmZlcic7ZWxzZSBpZiAoIWVuY29kaW5nKSBlbmNvZGluZyA9IHN0YXRlLmRlZmF1bHRFbmNvZGluZztcXG5cXG4gIGlmICh0eXBlb2YgY2IgIT09ICdmdW5jdGlvbicpIGNiID0gbm9wO1xcblxcbiAgaWYgKHN0YXRlLmVuZGVkKSB3cml0ZUFmdGVyRW5kKHRoaXMsIGNiKTtlbHNlIGlmIChpc0J1ZiB8fCB2YWxpZENodW5rKHRoaXMsIHN0YXRlLCBjaHVuaywgY2IpKSB7XFxuICAgIHN0YXRlLnBlbmRpbmdjYisrO1xcbiAgICByZXQgPSB3cml0ZU9yQnVmZmVyKHRoaXMsIHN0YXRlLCBpc0J1ZiwgY2h1bmssIGVuY29kaW5nLCBjYik7XFxuICB9XFxuXFxuICByZXR1cm4gcmV0O1xcbn07XFxuXFxuV3JpdGFibGUucHJvdG90eXBlLmNvcmsgPSBmdW5jdGlvbiAoKSB7XFxuICB2YXIgc3RhdGUgPSB0aGlzLl93cml0YWJsZVN0YXRlO1xcblxcbiAgc3RhdGUuY29ya2VkKys7XFxufTtcXG5cXG5Xcml0YWJsZS5wcm90b3R5cGUudW5jb3JrID0gZnVuY3Rpb24gKCkge1xcbiAgdmFyIHN0YXRlID0gdGhpcy5fd3JpdGFibGVTdGF0ZTtcXG5cXG4gIGlmIChzdGF0ZS5jb3JrZWQpIHtcXG4gICAgc3RhdGUuY29ya2VkLS07XFxuXFxuICAgIGlmICghc3RhdGUud3JpdGluZyAmJiAhc3RhdGUuY29ya2VkICYmICFzdGF0ZS5maW5pc2hlZCAmJiAhc3RhdGUuYnVmZmVyUHJvY2Vzc2luZyAmJiBzdGF0ZS5idWZmZXJlZFJlcXVlc3QpIGNsZWFyQnVmZmVyKHRoaXMsIHN0YXRlKTtcXG4gIH1cXG59O1xcblxcbldyaXRhYmxlLnByb3RvdHlwZS5zZXREZWZhdWx0RW5jb2RpbmcgPSBmdW5jdGlvbiBzZXREZWZhdWx0RW5jb2RpbmcoZW5jb2RpbmcpIHtcXG4gIC8vIG5vZGU6OlBhcnNlRW5jb2RpbmcoKSByZXF1aXJlcyBsb3dlciBjYXNlLlxcbiAgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ3N0cmluZycpIGVuY29kaW5nID0gZW5jb2RpbmcudG9Mb3dlckNhc2UoKTtcXG4gIGlmICghKFsnaGV4JywgJ3V0ZjgnLCAndXRmLTgnLCAnYXNjaWknLCAnYmluYXJ5JywgJ2Jhc2U2NCcsICd1Y3MyJywgJ3Vjcy0yJywgJ3V0ZjE2bGUnLCAndXRmLTE2bGUnLCAncmF3J10uaW5kZXhPZigoZW5jb2RpbmcgKyAnJykudG9Mb3dlckNhc2UoKSkgPiAtMSkpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZyk7XFxuICB0aGlzLl93cml0YWJsZVN0YXRlLmRlZmF1bHRFbmNvZGluZyA9IGVuY29kaW5nO1xcbiAgcmV0dXJuIHRoaXM7XFxufTtcXG5cXG5mdW5jdGlvbiBkZWNvZGVDaHVuayhzdGF0ZSwgY2h1bmssIGVuY29kaW5nKSB7XFxuICBpZiAoIXN0YXRlLm9iamVjdE1vZGUgJiYgc3RhdGUuZGVjb2RlU3RyaW5ncyAhPT0gZmFsc2UgJiYgdHlwZW9mIGNodW5rID09PSAnc3RyaW5nJykge1xcbiAgICBjaHVuayA9IEJ1ZmZlci5mcm9tKGNodW5rLCBlbmNvZGluZyk7XFxuICB9XFxuICByZXR1cm4gY2h1bms7XFxufVxcblxcbi8vIGlmIHdlJ3JlIGFscmVhZHkgd3JpdGluZyBzb21ldGhpbmcsIHRoZW4ganVzdCBwdXQgdGhpc1xcbi8vIGluIHRoZSBxdWV1ZSwgYW5kIHdhaXQgb3VyIHR1cm4uICBPdGhlcndpc2UsIGNhbGwgX3dyaXRlXFxuLy8gSWYgd2UgcmV0dXJuIGZhbHNlLCB0aGVuIHdlIG5lZWQgYSBkcmFpbiBldmVudCwgc28gc2V0IHRoYXQgZmxhZy5cXG5mdW5jdGlvbiB3cml0ZU9yQnVmZmVyKHN0cmVhbSwgc3RhdGUsIGlzQnVmLCBjaHVuaywgZW5jb2RpbmcsIGNiKSB7XFxuICBpZiAoIWlzQnVmKSB7XFxuICAgIGNodW5rID0gZGVjb2RlQ2h1bmsoc3RhdGUsIGNodW5rLCBlbmNvZGluZyk7XFxuICAgIGlmIChCdWZmZXIuaXNCdWZmZXIoY2h1bmspKSBlbmNvZGluZyA9ICdidWZmZXInO1xcbiAgfVxcbiAgdmFyIGxlbiA9IHN0YXRlLm9iamVjdE1vZGUgPyAxIDogY2h1bmsubGVuZ3RoO1xcblxcbiAgc3RhdGUubGVuZ3RoICs9IGxlbjtcXG5cXG4gIHZhciByZXQgPSBzdGF0ZS5sZW5ndGggPCBzdGF0ZS5oaWdoV2F0ZXJNYXJrO1xcbiAgLy8gd2UgbXVzdCBlbnN1cmUgdGhhdCBwcmV2aW91cyBuZWVkRHJhaW4gd2lsbCBub3QgYmUgcmVzZXQgdG8gZmFsc2UuXFxuICBpZiAoIXJldCkgc3RhdGUubmVlZERyYWluID0gdHJ1ZTtcXG5cXG4gIGlmIChzdGF0ZS53cml0aW5nIHx8IHN0YXRlLmNvcmtlZCkge1xcbiAgICB2YXIgbGFzdCA9IHN0YXRlLmxhc3RCdWZmZXJlZFJlcXVlc3Q7XFxuICAgIHN0YXRlLmxhc3RCdWZmZXJlZFJlcXVlc3QgPSBuZXcgV3JpdGVSZXEoY2h1bmssIGVuY29kaW5nLCBjYik7XFxuICAgIGlmIChsYXN0KSB7XFxuICAgICAgbGFzdC5uZXh0ID0gc3RhdGUubGFzdEJ1ZmZlcmVkUmVxdWVzdDtcXG4gICAgfSBlbHNlIHtcXG4gICAgICBzdGF0ZS5idWZmZXJlZFJlcXVlc3QgPSBzdGF0ZS5sYXN0QnVmZmVyZWRSZXF1ZXN0O1xcbiAgICB9XFxuICAgIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdENvdW50ICs9IDE7XFxuICB9IGVsc2Uge1xcbiAgICBkb1dyaXRlKHN0cmVhbSwgc3RhdGUsIGZhbHNlLCBsZW4sIGNodW5rLCBlbmNvZGluZywgY2IpO1xcbiAgfVxcblxcbiAgcmV0dXJuIHJldDtcXG59XFxuXFxuZnVuY3Rpb24gZG9Xcml0ZShzdHJlYW0sIHN0YXRlLCB3cml0ZXYsIGxlbiwgY2h1bmssIGVuY29kaW5nLCBjYikge1xcbiAgc3RhdGUud3JpdGVsZW4gPSBsZW47XFxuICBzdGF0ZS53cml0ZWNiID0gY2I7XFxuICBzdGF0ZS53cml0aW5nID0gdHJ1ZTtcXG4gIHN0YXRlLnN5bmMgPSB0cnVlO1xcbiAgaWYgKHdyaXRldikgc3RyZWFtLl93cml0ZXYoY2h1bmssIHN0YXRlLm9ud3JpdGUpO2Vsc2Ugc3RyZWFtLl93cml0ZShjaHVuaywgZW5jb2RpbmcsIHN0YXRlLm9ud3JpdGUpO1xcbiAgc3RhdGUuc3luYyA9IGZhbHNlO1xcbn1cXG5cXG5mdW5jdGlvbiBvbndyaXRlRXJyb3Ioc3RyZWFtLCBzdGF0ZSwgc3luYywgZXIsIGNiKSB7XFxuICAtLXN0YXRlLnBlbmRpbmdjYjtcXG4gIGlmIChzeW5jKSBwcm9jZXNzTmV4dFRpY2soY2IsIGVyKTtlbHNlIGNiKGVyKTtcXG5cXG4gIHN0cmVhbS5fd3JpdGFibGVTdGF0ZS5lcnJvckVtaXR0ZWQgPSB0cnVlO1xcbiAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXIpO1xcbn1cXG5cXG5mdW5jdGlvbiBvbndyaXRlU3RhdGVVcGRhdGUoc3RhdGUpIHtcXG4gIHN0YXRlLndyaXRpbmcgPSBmYWxzZTtcXG4gIHN0YXRlLndyaXRlY2IgPSBudWxsO1xcbiAgc3RhdGUubGVuZ3RoIC09IHN0YXRlLndyaXRlbGVuO1xcbiAgc3RhdGUud3JpdGVsZW4gPSAwO1xcbn1cXG5cXG5mdW5jdGlvbiBvbndyaXRlKHN0cmVhbSwgZXIpIHtcXG4gIHZhciBzdGF0ZSA9IHN0cmVhbS5fd3JpdGFibGVTdGF0ZTtcXG4gIHZhciBzeW5jID0gc3RhdGUuc3luYztcXG4gIHZhciBjYiA9IHN0YXRlLndyaXRlY2I7XFxuXFxuICBvbndyaXRlU3RhdGVVcGRhdGUoc3RhdGUpO1xcblxcbiAgaWYgKGVyKSBvbndyaXRlRXJyb3Ioc3RyZWFtLCBzdGF0ZSwgc3luYywgZXIsIGNiKTtlbHNlIHtcXG4gICAgLy8gQ2hlY2sgaWYgd2UncmUgYWN0dWFsbHkgcmVhZHkgdG8gZmluaXNoLCBidXQgZG9uJ3QgZW1pdCB5ZXRcXG4gICAgdmFyIGZpbmlzaGVkID0gbmVlZEZpbmlzaChzdGF0ZSk7XFxuXFxuICAgIGlmICghZmluaXNoZWQgJiYgIXN0YXRlLmNvcmtlZCAmJiAhc3RhdGUuYnVmZmVyUHJvY2Vzc2luZyAmJiBzdGF0ZS5idWZmZXJlZFJlcXVlc3QpIHtcXG4gICAgICBjbGVhckJ1ZmZlcihzdHJlYW0sIHN0YXRlKTtcXG4gICAgfVxcblxcbiAgICBpZiAoc3luYykge1xcbiAgICAgIC8qPHJlcGxhY2VtZW50PiovXFxuICAgICAgYXN5bmNXcml0ZShhZnRlcldyaXRlLCBzdHJlYW0sIHN0YXRlLCBmaW5pc2hlZCwgY2IpO1xcbiAgICAgIC8qPC9yZXBsYWNlbWVudD4qL1xcbiAgICB9IGVsc2Uge1xcbiAgICAgIGFmdGVyV3JpdGUoc3RyZWFtLCBzdGF0ZSwgZmluaXNoZWQsIGNiKTtcXG4gICAgfVxcbiAgfVxcbn1cXG5cXG5mdW5jdGlvbiBhZnRlcldyaXRlKHN0cmVhbSwgc3RhdGUsIGZpbmlzaGVkLCBjYikge1xcbiAgaWYgKCFmaW5pc2hlZCkgb253cml0ZURyYWluKHN0cmVhbSwgc3RhdGUpO1xcbiAgc3RhdGUucGVuZGluZ2NiLS07XFxuICBjYigpO1xcbiAgZmluaXNoTWF5YmUoc3RyZWFtLCBzdGF0ZSk7XFxufVxcblxcbi8vIE11c3QgZm9yY2UgY2FsbGJhY2sgdG8gYmUgY2FsbGVkIG9uIG5leHRUaWNrLCBzbyB0aGF0IHdlIGRvbid0XFxuLy8gZW1pdCAnZHJhaW4nIGJlZm9yZSB0aGUgd3JpdGUoKSBjb25zdW1lciBnZXRzIHRoZSAnZmFsc2UnIHJldHVyblxcbi8vIHZhbHVlLCBhbmQgaGFzIGEgY2hhbmNlIHRvIGF0dGFjaCBhICdkcmFpbicgbGlzdGVuZXIuXFxuZnVuY3Rpb24gb253cml0ZURyYWluKHN0cmVhbSwgc3RhdGUpIHtcXG4gIGlmIChzdGF0ZS5sZW5ndGggPT09IDAgJiYgc3RhdGUubmVlZERyYWluKSB7XFxuICAgIHN0YXRlLm5lZWREcmFpbiA9IGZhbHNlO1xcbiAgICBzdHJlYW0uZW1pdCgnZHJhaW4nKTtcXG4gIH1cXG59XFxuXFxuLy8gaWYgdGhlcmUncyBzb21ldGhpbmcgaW4gdGhlIGJ1ZmZlciB3YWl0aW5nLCB0aGVuIHByb2Nlc3MgaXRcXG5mdW5jdGlvbiBjbGVhckJ1ZmZlcihzdHJlYW0sIHN0YXRlKSB7XFxuICBzdGF0ZS5idWZmZXJQcm9jZXNzaW5nID0gdHJ1ZTtcXG4gIHZhciBlbnRyeSA9IHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdDtcXG5cXG4gIGlmIChzdHJlYW0uX3dyaXRldiAmJiBlbnRyeSAmJiBlbnRyeS5uZXh0KSB7XFxuICAgIC8vIEZhc3QgY2FzZSwgd3JpdGUgZXZlcnl0aGluZyB1c2luZyBfd3JpdGV2KClcXG4gICAgdmFyIGwgPSBzdGF0ZS5idWZmZXJlZFJlcXVlc3RDb3VudDtcXG4gICAgdmFyIGJ1ZmZlciA9IG5ldyBBcnJheShsKTtcXG4gICAgdmFyIGhvbGRlciA9IHN0YXRlLmNvcmtlZFJlcXVlc3RzRnJlZTtcXG4gICAgaG9sZGVyLmVudHJ5ID0gZW50cnk7XFxuXFxuICAgIHZhciBjb3VudCA9IDA7XFxuICAgIHdoaWxlIChlbnRyeSkge1xcbiAgICAgIGJ1ZmZlcltjb3VudF0gPSBlbnRyeTtcXG4gICAgICBlbnRyeSA9IGVudHJ5Lm5leHQ7XFxuICAgICAgY291bnQgKz0gMTtcXG4gICAgfVxcblxcbiAgICBkb1dyaXRlKHN0cmVhbSwgc3RhdGUsIHRydWUsIHN0YXRlLmxlbmd0aCwgYnVmZmVyLCAnJywgaG9sZGVyLmZpbmlzaCk7XFxuXFxuICAgIC8vIGRvV3JpdGUgaXMgYWxtb3N0IGFsd2F5cyBhc3luYywgZGVmZXIgdGhlc2UgdG8gc2F2ZSBhIGJpdCBvZiB0aW1lXFxuICAgIC8vIGFzIHRoZSBob3QgcGF0aCBlbmRzIHdpdGggZG9Xcml0ZVxcbiAgICBzdGF0ZS5wZW5kaW5nY2IrKztcXG4gICAgc3RhdGUubGFzdEJ1ZmZlcmVkUmVxdWVzdCA9IG51bGw7XFxuICAgIGlmIChob2xkZXIubmV4dCkge1xcbiAgICAgIHN0YXRlLmNvcmtlZFJlcXVlc3RzRnJlZSA9IGhvbGRlci5uZXh0O1xcbiAgICAgIGhvbGRlci5uZXh0ID0gbnVsbDtcXG4gICAgfSBlbHNlIHtcXG4gICAgICBzdGF0ZS5jb3JrZWRSZXF1ZXN0c0ZyZWUgPSBuZXcgQ29ya2VkUmVxdWVzdChzdGF0ZSk7XFxuICAgIH1cXG4gIH0gZWxzZSB7XFxuICAgIC8vIFNsb3cgY2FzZSwgd3JpdGUgY2h1bmtzIG9uZS1ieS1vbmVcXG4gICAgd2hpbGUgKGVudHJ5KSB7XFxuICAgICAgdmFyIGNodW5rID0gZW50cnkuY2h1bms7XFxuICAgICAgdmFyIGVuY29kaW5nID0gZW50cnkuZW5jb2Rpbmc7XFxuICAgICAgdmFyIGNiID0gZW50cnkuY2FsbGJhY2s7XFxuICAgICAgdmFyIGxlbiA9IHN0YXRlLm9iamVjdE1vZGUgPyAxIDogY2h1bmsubGVuZ3RoO1xcblxcbiAgICAgIGRvV3JpdGUoc3RyZWFtLCBzdGF0ZSwgZmFsc2UsIGxlbiwgY2h1bmssIGVuY29kaW5nLCBjYik7XFxuICAgICAgZW50cnkgPSBlbnRyeS5uZXh0O1xcbiAgICAgIC8vIGlmIHdlIGRpZG4ndCBjYWxsIHRoZSBvbndyaXRlIGltbWVkaWF0ZWx5LCB0aGVuXFxuICAgICAgLy8gaXQgbWVhbnMgdGhhdCB3ZSBuZWVkIHRvIHdhaXQgdW50aWwgaXQgZG9lcy5cXG4gICAgICAvLyBhbHNvLCB0aGF0IG1lYW5zIHRoYXQgdGhlIGNodW5rIGFuZCBjYiBhcmUgY3VycmVudGx5XFxuICAgICAgLy8gYmVpbmcgcHJvY2Vzc2VkLCBzbyBtb3ZlIHRoZSBidWZmZXIgY291bnRlciBwYXN0IHRoZW0uXFxuICAgICAgaWYgKHN0YXRlLndyaXRpbmcpIHtcXG4gICAgICAgIGJyZWFrO1xcbiAgICAgIH1cXG4gICAgfVxcblxcbiAgICBpZiAoZW50cnkgPT09IG51bGwpIHN0YXRlLmxhc3RCdWZmZXJlZFJlcXVlc3QgPSBudWxsO1xcbiAgfVxcblxcbiAgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0Q291bnQgPSAwO1xcbiAgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0ID0gZW50cnk7XFxuICBzdGF0ZS5idWZmZXJQcm9jZXNzaW5nID0gZmFsc2U7XFxufVxcblxcbldyaXRhYmxlLnByb3RvdHlwZS5fd3JpdGUgPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nLCBjYikge1xcbiAgY2IobmV3IEVycm9yKCdfd3JpdGUoKSBpcyBub3QgaW1wbGVtZW50ZWQnKSk7XFxufTtcXG5cXG5Xcml0YWJsZS5wcm90b3R5cGUuX3dyaXRldiA9IG51bGw7XFxuXFxuV3JpdGFibGUucHJvdG90eXBlLmVuZCA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcsIGNiKSB7XFxuICB2YXIgc3RhdGUgPSB0aGlzLl93cml0YWJsZVN0YXRlO1xcblxcbiAgaWYgKHR5cGVvZiBjaHVuayA9PT0gJ2Z1bmN0aW9uJykge1xcbiAgICBjYiA9IGNodW5rO1xcbiAgICBjaHVuayA9IG51bGw7XFxuICAgIGVuY29kaW5nID0gbnVsbDtcXG4gIH0gZWxzZSBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnZnVuY3Rpb24nKSB7XFxuICAgIGNiID0gZW5jb2Rpbmc7XFxuICAgIGVuY29kaW5nID0gbnVsbDtcXG4gIH1cXG5cXG4gIGlmIChjaHVuayAhPT0gbnVsbCAmJiBjaHVuayAhPT0gdW5kZWZpbmVkKSB0aGlzLndyaXRlKGNodW5rLCBlbmNvZGluZyk7XFxuXFxuICAvLyAuZW5kKCkgZnVsbHkgdW5jb3Jrc1xcbiAgaWYgKHN0YXRlLmNvcmtlZCkge1xcbiAgICBzdGF0ZS5jb3JrZWQgPSAxO1xcbiAgICB0aGlzLnVuY29yaygpO1xcbiAgfVxcblxcbiAgLy8gaWdub3JlIHVubmVjZXNzYXJ5IGVuZCgpIGNhbGxzLlxcbiAgaWYgKCFzdGF0ZS5lbmRpbmcgJiYgIXN0YXRlLmZpbmlzaGVkKSBlbmRXcml0YWJsZSh0aGlzLCBzdGF0ZSwgY2IpO1xcbn07XFxuXFxuZnVuY3Rpb24gbmVlZEZpbmlzaChzdGF0ZSkge1xcbiAgcmV0dXJuIHN0YXRlLmVuZGluZyAmJiBzdGF0ZS5sZW5ndGggPT09IDAgJiYgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0ID09PSBudWxsICYmICFzdGF0ZS5maW5pc2hlZCAmJiAhc3RhdGUud3JpdGluZztcXG59XFxuXFxuZnVuY3Rpb24gcHJlZmluaXNoKHN0cmVhbSwgc3RhdGUpIHtcXG4gIGlmICghc3RhdGUucHJlZmluaXNoZWQpIHtcXG4gICAgc3RhdGUucHJlZmluaXNoZWQgPSB0cnVlO1xcbiAgICBzdHJlYW0uZW1pdCgncHJlZmluaXNoJyk7XFxuICB9XFxufVxcblxcbmZ1bmN0aW9uIGZpbmlzaE1heWJlKHN0cmVhbSwgc3RhdGUpIHtcXG4gIHZhciBuZWVkID0gbmVlZEZpbmlzaChzdGF0ZSk7XFxuICBpZiAobmVlZCkge1xcbiAgICBpZiAoc3RhdGUucGVuZGluZ2NiID09PSAwKSB7XFxuICAgICAgcHJlZmluaXNoKHN0cmVhbSwgc3RhdGUpO1xcbiAgICAgIHN0YXRlLmZpbmlzaGVkID0gdHJ1ZTtcXG4gICAgICBzdHJlYW0uZW1pdCgnZmluaXNoJyk7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgcHJlZmluaXNoKHN0cmVhbSwgc3RhdGUpO1xcbiAgICB9XFxuICB9XFxuICByZXR1cm4gbmVlZDtcXG59XFxuXFxuZnVuY3Rpb24gZW5kV3JpdGFibGUoc3RyZWFtLCBzdGF0ZSwgY2IpIHtcXG4gIHN0YXRlLmVuZGluZyA9IHRydWU7XFxuICBmaW5pc2hNYXliZShzdHJlYW0sIHN0YXRlKTtcXG4gIGlmIChjYikge1xcbiAgICBpZiAoc3RhdGUuZmluaXNoZWQpIHByb2Nlc3NOZXh0VGljayhjYik7ZWxzZSBzdHJlYW0ub25jZSgnZmluaXNoJywgY2IpO1xcbiAgfVxcbiAgc3RhdGUuZW5kZWQgPSB0cnVlO1xcbiAgc3RyZWFtLndyaXRhYmxlID0gZmFsc2U7XFxufVxcblxcbi8vIEl0IHNlZW1zIGEgbGlua2VkIGxpc3QgYnV0IGl0IGlzIG5vdFxcbi8vIHRoZXJlIHdpbGwgYmUgb25seSAyIG9mIHRoZXNlIGZvciBlYWNoIHN0cmVhbVxcbmZ1bmN0aW9uIENvcmtlZFJlcXVlc3Qoc3RhdGUpIHtcXG4gIHZhciBfdGhpcyA9IHRoaXM7XFxuXFxuICB0aGlzLm5leHQgPSBudWxsO1xcbiAgdGhpcy5lbnRyeSA9IG51bGw7XFxuICB0aGlzLmZpbmlzaCA9IGZ1bmN0aW9uIChlcnIpIHtcXG4gICAgdmFyIGVudHJ5ID0gX3RoaXMuZW50cnk7XFxuICAgIF90aGlzLmVudHJ5ID0gbnVsbDtcXG4gICAgd2hpbGUgKGVudHJ5KSB7XFxuICAgICAgdmFyIGNiID0gZW50cnkuY2FsbGJhY2s7XFxuICAgICAgc3RhdGUucGVuZGluZ2NiLS07XFxuICAgICAgY2IoZXJyKTtcXG4gICAgICBlbnRyeSA9IGVudHJ5Lm5leHQ7XFxuICAgIH1cXG4gICAgaWYgKHN0YXRlLmNvcmtlZFJlcXVlc3RzRnJlZSkge1xcbiAgICAgIHN0YXRlLmNvcmtlZFJlcXVlc3RzRnJlZS5uZXh0ID0gX3RoaXM7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgc3RhdGUuY29ya2VkUmVxdWVzdHNGcmVlID0gX3RoaXM7XFxuICAgIH1cXG4gIH07XFxufVxcbn0pLmNhbGwodGhpcyxyZXF1aXJlKCdfcHJvY2VzcycpKVxcbn0se1xcXCIuL19zdHJlYW1fZHVwbGV4XFxcIjo4NCxcXFwiLi9pbnRlcm5hbC9zdHJlYW1zL3N0cmVhbVxcXCI6OTAsXFxcIl9wcm9jZXNzXFxcIjo4MixcXFwiY29yZS11dGlsLWlzXFxcIjo0NCxcXFwiaW5oZXJpdHNcXFwiOjY2LFxcXCJwcm9jZXNzLW5leHRpY2stYXJnc1xcXCI6ODEsXFxcInNhZmUtYnVmZmVyXFxcIjo5NSxcXFwidXRpbC1kZXByZWNhdGVcXFwiOjk5fV0sODk6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xcbid1c2Ugc3RyaWN0JztcXG5cXG4vKjxyZXBsYWNlbWVudD4qL1xcblxcbnZhciBCdWZmZXIgPSByZXF1aXJlKCdzYWZlLWJ1ZmZlcicpLkJ1ZmZlcjtcXG4vKjwvcmVwbGFjZW1lbnQ+Ki9cXG5cXG5tb2R1bGUuZXhwb3J0cyA9IEJ1ZmZlckxpc3Q7XFxuXFxuZnVuY3Rpb24gQnVmZmVyTGlzdCgpIHtcXG4gIHRoaXMuaGVhZCA9IG51bGw7XFxuICB0aGlzLnRhaWwgPSBudWxsO1xcbiAgdGhpcy5sZW5ndGggPSAwO1xcbn1cXG5cXG5CdWZmZXJMaXN0LnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKHYpIHtcXG4gIHZhciBlbnRyeSA9IHsgZGF0YTogdiwgbmV4dDogbnVsbCB9O1xcbiAgaWYgKHRoaXMubGVuZ3RoID4gMCkgdGhpcy50YWlsLm5leHQgPSBlbnRyeTtlbHNlIHRoaXMuaGVhZCA9IGVudHJ5O1xcbiAgdGhpcy50YWlsID0gZW50cnk7XFxuICArK3RoaXMubGVuZ3RoO1xcbn07XFxuXFxuQnVmZmVyTGlzdC5wcm90b3R5cGUudW5zaGlmdCA9IGZ1bmN0aW9uICh2KSB7XFxuICB2YXIgZW50cnkgPSB7IGRhdGE6IHYsIG5leHQ6IHRoaXMuaGVhZCB9O1xcbiAgaWYgKHRoaXMubGVuZ3RoID09PSAwKSB0aGlzLnRhaWwgPSBlbnRyeTtcXG4gIHRoaXMuaGVhZCA9IGVudHJ5O1xcbiAgKyt0aGlzLmxlbmd0aDtcXG59O1xcblxcbkJ1ZmZlckxpc3QucHJvdG90eXBlLnNoaWZ0ID0gZnVuY3Rpb24gKCkge1xcbiAgaWYgKHRoaXMubGVuZ3RoID09PSAwKSByZXR1cm47XFxuICB2YXIgcmV0ID0gdGhpcy5oZWFkLmRhdGE7XFxuICBpZiAodGhpcy5sZW5ndGggPT09IDEpIHRoaXMuaGVhZCA9IHRoaXMudGFpbCA9IG51bGw7ZWxzZSB0aGlzLmhlYWQgPSB0aGlzLmhlYWQubmV4dDtcXG4gIC0tdGhpcy5sZW5ndGg7XFxuICByZXR1cm4gcmV0O1xcbn07XFxuXFxuQnVmZmVyTGlzdC5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiAoKSB7XFxuICB0aGlzLmhlYWQgPSB0aGlzLnRhaWwgPSBudWxsO1xcbiAgdGhpcy5sZW5ndGggPSAwO1xcbn07XFxuXFxuQnVmZmVyTGlzdC5wcm90b3R5cGUuam9pbiA9IGZ1bmN0aW9uIChzKSB7XFxuICBpZiAodGhpcy5sZW5ndGggPT09IDApIHJldHVybiAnJztcXG4gIHZhciBwID0gdGhpcy5oZWFkO1xcbiAgdmFyIHJldCA9ICcnICsgcC5kYXRhO1xcbiAgd2hpbGUgKHAgPSBwLm5leHQpIHtcXG4gICAgcmV0ICs9IHMgKyBwLmRhdGE7XFxuICB9cmV0dXJuIHJldDtcXG59O1xcblxcbkJ1ZmZlckxpc3QucHJvdG90eXBlLmNvbmNhdCA9IGZ1bmN0aW9uIChuKSB7XFxuICBpZiAodGhpcy5sZW5ndGggPT09IDApIHJldHVybiBCdWZmZXIuYWxsb2MoMCk7XFxuICBpZiAodGhpcy5sZW5ndGggPT09IDEpIHJldHVybiB0aGlzLmhlYWQuZGF0YTtcXG4gIHZhciByZXQgPSBCdWZmZXIuYWxsb2NVbnNhZmUobiA+Pj4gMCk7XFxuICB2YXIgcCA9IHRoaXMuaGVhZDtcXG4gIHZhciBpID0gMDtcXG4gIHdoaWxlIChwKSB7XFxuICAgIHAuZGF0YS5jb3B5KHJldCwgaSk7XFxuICAgIGkgKz0gcC5kYXRhLmxlbmd0aDtcXG4gICAgcCA9IHAubmV4dDtcXG4gIH1cXG4gIHJldHVybiByZXQ7XFxufTtcXG59LHtcXFwic2FmZS1idWZmZXJcXFwiOjk1fV0sOTA6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyO1xcblxcbn0se1xcXCJldmVudHNcXFwiOjYyfV0sOTE6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9yZWFkYWJsZScpLlBhc3NUaHJvdWdoXFxuXFxufSx7XFxcIi4vcmVhZGFibGVcXFwiOjkyfV0sOTI6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xcbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vbGliL19zdHJlYW1fcmVhZGFibGUuanMnKTtcXG5leHBvcnRzLlN0cmVhbSA9IGV4cG9ydHM7XFxuZXhwb3J0cy5SZWFkYWJsZSA9IGV4cG9ydHM7XFxuZXhwb3J0cy5Xcml0YWJsZSA9IHJlcXVpcmUoJy4vbGliL19zdHJlYW1fd3JpdGFibGUuanMnKTtcXG5leHBvcnRzLkR1cGxleCA9IHJlcXVpcmUoJy4vbGliL19zdHJlYW1fZHVwbGV4LmpzJyk7XFxuZXhwb3J0cy5UcmFuc2Zvcm0gPSByZXF1aXJlKCcuL2xpYi9fc3RyZWFtX3RyYW5zZm9ybS5qcycpO1xcbmV4cG9ydHMuUGFzc1Rocm91Z2ggPSByZXF1aXJlKCcuL2xpYi9fc3RyZWFtX3Bhc3N0aHJvdWdoLmpzJyk7XFxuXFxufSx7XFxcIi4vbGliL19zdHJlYW1fZHVwbGV4LmpzXFxcIjo4NCxcXFwiLi9saWIvX3N0cmVhbV9wYXNzdGhyb3VnaC5qc1xcXCI6ODUsXFxcIi4vbGliL19zdHJlYW1fcmVhZGFibGUuanNcXFwiOjg2LFxcXCIuL2xpYi9fc3RyZWFtX3RyYW5zZm9ybS5qc1xcXCI6ODcsXFxcIi4vbGliL19zdHJlYW1fd3JpdGFibGUuanNcXFwiOjg4fV0sOTM6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9yZWFkYWJsZScpLlRyYW5zZm9ybVxcblxcbn0se1xcXCIuL3JlYWRhYmxlXFxcIjo5Mn1dLDk0OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vbGliL19zdHJlYW1fd3JpdGFibGUuanMnKTtcXG5cXG59LHtcXFwiLi9saWIvX3N0cmVhbV93cml0YWJsZS5qc1xcXCI6ODh9XSw5NTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XFxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCdidWZmZXInKVxcblxcbn0se1xcXCJidWZmZXJcXFwiOjQzfV0sOTY6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xcbi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxcbi8vXFxuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXFxuLy8gXFxcIlNvZnR3YXJlXFxcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXFxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XFxuLy9cXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxcbi8vXFxuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFxcXCJBUyBJU1xcXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1NcXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXFxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxcbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxcblxcbm1vZHVsZS5leHBvcnRzID0gU3RyZWFtO1xcblxcbnZhciBFRSA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlcjtcXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xcblxcbmluaGVyaXRzKFN0cmVhbSwgRUUpO1xcblN0cmVhbS5SZWFkYWJsZSA9IHJlcXVpcmUoJ3JlYWRhYmxlLXN0cmVhbS9yZWFkYWJsZS5qcycpO1xcblN0cmVhbS5Xcml0YWJsZSA9IHJlcXVpcmUoJ3JlYWRhYmxlLXN0cmVhbS93cml0YWJsZS5qcycpO1xcblN0cmVhbS5EdXBsZXggPSByZXF1aXJlKCdyZWFkYWJsZS1zdHJlYW0vZHVwbGV4LmpzJyk7XFxuU3RyZWFtLlRyYW5zZm9ybSA9IHJlcXVpcmUoJ3JlYWRhYmxlLXN0cmVhbS90cmFuc2Zvcm0uanMnKTtcXG5TdHJlYW0uUGFzc1Rocm91Z2ggPSByZXF1aXJlKCdyZWFkYWJsZS1zdHJlYW0vcGFzc3Rocm91Z2guanMnKTtcXG5cXG4vLyBCYWNrd2FyZHMtY29tcGF0IHdpdGggbm9kZSAwLjQueFxcblN0cmVhbS5TdHJlYW0gPSBTdHJlYW07XFxuXFxuXFxuXFxuLy8gb2xkLXN0eWxlIHN0cmVhbXMuICBOb3RlIHRoYXQgdGhlIHBpcGUgbWV0aG9kICh0aGUgb25seSByZWxldmFudFxcbi8vIHBhcnQgb2YgdGhpcyBjbGFzcykgaXMgb3ZlcnJpZGRlbiBpbiB0aGUgUmVhZGFibGUgY2xhc3MuXFxuXFxuZnVuY3Rpb24gU3RyZWFtKCkge1xcbiAgRUUuY2FsbCh0aGlzKTtcXG59XFxuXFxuU3RyZWFtLnByb3RvdHlwZS5waXBlID0gZnVuY3Rpb24oZGVzdCwgb3B0aW9ucykge1xcbiAgdmFyIHNvdXJjZSA9IHRoaXM7XFxuXFxuICBmdW5jdGlvbiBvbmRhdGEoY2h1bmspIHtcXG4gICAgaWYgKGRlc3Qud3JpdGFibGUpIHtcXG4gICAgICBpZiAoZmFsc2UgPT09IGRlc3Qud3JpdGUoY2h1bmspICYmIHNvdXJjZS5wYXVzZSkge1xcbiAgICAgICAgc291cmNlLnBhdXNlKCk7XFxuICAgICAgfVxcbiAgICB9XFxuICB9XFxuXFxuICBzb3VyY2Uub24oJ2RhdGEnLCBvbmRhdGEpO1xcblxcbiAgZnVuY3Rpb24gb25kcmFpbigpIHtcXG4gICAgaWYgKHNvdXJjZS5yZWFkYWJsZSAmJiBzb3VyY2UucmVzdW1lKSB7XFxuICAgICAgc291cmNlLnJlc3VtZSgpO1xcbiAgICB9XFxuICB9XFxuXFxuICBkZXN0Lm9uKCdkcmFpbicsIG9uZHJhaW4pO1xcblxcbiAgLy8gSWYgdGhlICdlbmQnIG9wdGlvbiBpcyBub3Qgc3VwcGxpZWQsIGRlc3QuZW5kKCkgd2lsbCBiZSBjYWxsZWQgd2hlblxcbiAgLy8gc291cmNlIGdldHMgdGhlICdlbmQnIG9yICdjbG9zZScgZXZlbnRzLiAgT25seSBkZXN0LmVuZCgpIG9uY2UuXFxuICBpZiAoIWRlc3QuX2lzU3RkaW8gJiYgKCFvcHRpb25zIHx8IG9wdGlvbnMuZW5kICE9PSBmYWxzZSkpIHtcXG4gICAgc291cmNlLm9uKCdlbmQnLCBvbmVuZCk7XFxuICAgIHNvdXJjZS5vbignY2xvc2UnLCBvbmNsb3NlKTtcXG4gIH1cXG5cXG4gIHZhciBkaWRPbkVuZCA9IGZhbHNlO1xcbiAgZnVuY3Rpb24gb25lbmQoKSB7XFxuICAgIGlmIChkaWRPbkVuZCkgcmV0dXJuO1xcbiAgICBkaWRPbkVuZCA9IHRydWU7XFxuXFxuICAgIGRlc3QuZW5kKCk7XFxuICB9XFxuXFxuXFxuICBmdW5jdGlvbiBvbmNsb3NlKCkge1xcbiAgICBpZiAoZGlkT25FbmQpIHJldHVybjtcXG4gICAgZGlkT25FbmQgPSB0cnVlO1xcblxcbiAgICBpZiAodHlwZW9mIGRlc3QuZGVzdHJveSA9PT0gJ2Z1bmN0aW9uJykgZGVzdC5kZXN0cm95KCk7XFxuICB9XFxuXFxuICAvLyBkb24ndCBsZWF2ZSBkYW5nbGluZyBwaXBlcyB3aGVuIHRoZXJlIGFyZSBlcnJvcnMuXFxuICBmdW5jdGlvbiBvbmVycm9yKGVyKSB7XFxuICAgIGNsZWFudXAoKTtcXG4gICAgaWYgKEVFLmxpc3RlbmVyQ291bnQodGhpcywgJ2Vycm9yJykgPT09IDApIHtcXG4gICAgICB0aHJvdyBlcjsgLy8gVW5oYW5kbGVkIHN0cmVhbSBlcnJvciBpbiBwaXBlLlxcbiAgICB9XFxuICB9XFxuXFxuICBzb3VyY2Uub24oJ2Vycm9yJywgb25lcnJvcik7XFxuICBkZXN0Lm9uKCdlcnJvcicsIG9uZXJyb3IpO1xcblxcbiAgLy8gcmVtb3ZlIGFsbCB0aGUgZXZlbnQgbGlzdGVuZXJzIHRoYXQgd2VyZSBhZGRlZC5cXG4gIGZ1bmN0aW9uIGNsZWFudXAoKSB7XFxuICAgIHNvdXJjZS5yZW1vdmVMaXN0ZW5lcignZGF0YScsIG9uZGF0YSk7XFxuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2RyYWluJywgb25kcmFpbik7XFxuXFxuICAgIHNvdXJjZS5yZW1vdmVMaXN0ZW5lcignZW5kJywgb25lbmQpO1xcbiAgICBzb3VyY2UucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgb25jbG9zZSk7XFxuXFxuICAgIHNvdXJjZS5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBvbmVycm9yKTtcXG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBvbmVycm9yKTtcXG5cXG4gICAgc291cmNlLnJlbW92ZUxpc3RlbmVyKCdlbmQnLCBjbGVhbnVwKTtcXG4gICAgc291cmNlLnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIGNsZWFudXApO1xcblxcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIGNsZWFudXApO1xcbiAgfVxcblxcbiAgc291cmNlLm9uKCdlbmQnLCBjbGVhbnVwKTtcXG4gIHNvdXJjZS5vbignY2xvc2UnLCBjbGVhbnVwKTtcXG5cXG4gIGRlc3Qub24oJ2Nsb3NlJywgY2xlYW51cCk7XFxuXFxuICBkZXN0LmVtaXQoJ3BpcGUnLCBzb3VyY2UpO1xcblxcbiAgLy8gQWxsb3cgZm9yIHVuaXgtbGlrZSB1c2FnZTogQS5waXBlKEIpLnBpcGUoQylcXG4gIHJldHVybiBkZXN0O1xcbn07XFxuXFxufSx7XFxcImV2ZW50c1xcXCI6NjIsXFxcImluaGVyaXRzXFxcIjo2NixcXFwicmVhZGFibGUtc3RyZWFtL2R1cGxleC5qc1xcXCI6ODMsXFxcInJlYWRhYmxlLXN0cmVhbS9wYXNzdGhyb3VnaC5qc1xcXCI6OTEsXFxcInJlYWRhYmxlLXN0cmVhbS9yZWFkYWJsZS5qc1xcXCI6OTIsXFxcInJlYWRhYmxlLXN0cmVhbS90cmFuc2Zvcm0uanNcXFwiOjkzLFxcXCJyZWFkYWJsZS1zdHJlYW0vd3JpdGFibGUuanNcXFwiOjk0fV0sOTc6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xcbid1c2Ugc3RyaWN0JztcXG5cXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnc2FmZS1idWZmZXInKS5CdWZmZXI7XFxuXFxudmFyIGlzRW5jb2RpbmcgPSBCdWZmZXIuaXNFbmNvZGluZyB8fCBmdW5jdGlvbiAoZW5jb2RpbmcpIHtcXG4gIGVuY29kaW5nID0gJycgKyBlbmNvZGluZztcXG4gIHN3aXRjaCAoZW5jb2RpbmcgJiYgZW5jb2RpbmcudG9Mb3dlckNhc2UoKSkge1xcbiAgICBjYXNlICdoZXgnOmNhc2UgJ3V0ZjgnOmNhc2UgJ3V0Zi04JzpjYXNlICdhc2NpaSc6Y2FzZSAnYmluYXJ5JzpjYXNlICdiYXNlNjQnOmNhc2UgJ3VjczInOmNhc2UgJ3Vjcy0yJzpjYXNlICd1dGYxNmxlJzpjYXNlICd1dGYtMTZsZSc6Y2FzZSAncmF3JzpcXG4gICAgICByZXR1cm4gdHJ1ZTtcXG4gICAgZGVmYXVsdDpcXG4gICAgICByZXR1cm4gZmFsc2U7XFxuICB9XFxufTtcXG5cXG5mdW5jdGlvbiBfbm9ybWFsaXplRW5jb2RpbmcoZW5jKSB7XFxuICBpZiAoIWVuYykgcmV0dXJuICd1dGY4JztcXG4gIHZhciByZXRyaWVkO1xcbiAgd2hpbGUgKHRydWUpIHtcXG4gICAgc3dpdGNoIChlbmMpIHtcXG4gICAgICBjYXNlICd1dGY4JzpcXG4gICAgICBjYXNlICd1dGYtOCc6XFxuICAgICAgICByZXR1cm4gJ3V0ZjgnO1xcbiAgICAgIGNhc2UgJ3VjczInOlxcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcXG4gICAgICBjYXNlICd1dGYxNmxlJzpcXG4gICAgICBjYXNlICd1dGYtMTZsZSc6XFxuICAgICAgICByZXR1cm4gJ3V0ZjE2bGUnO1xcbiAgICAgIGNhc2UgJ2xhdGluMSc6XFxuICAgICAgY2FzZSAnYmluYXJ5JzpcXG4gICAgICAgIHJldHVybiAnbGF0aW4xJztcXG4gICAgICBjYXNlICdiYXNlNjQnOlxcbiAgICAgIGNhc2UgJ2FzY2lpJzpcXG4gICAgICBjYXNlICdoZXgnOlxcbiAgICAgICAgcmV0dXJuIGVuYztcXG4gICAgICBkZWZhdWx0OlxcbiAgICAgICAgaWYgKHJldHJpZWQpIHJldHVybjsgLy8gdW5kZWZpbmVkXFxuICAgICAgICBlbmMgPSAoJycgKyBlbmMpLnRvTG93ZXJDYXNlKCk7XFxuICAgICAgICByZXRyaWVkID0gdHJ1ZTtcXG4gICAgfVxcbiAgfVxcbn07XFxuXFxuLy8gRG8gbm90IGNhY2hlIGBCdWZmZXIuaXNFbmNvZGluZ2Agd2hlbiBjaGVja2luZyBlbmNvZGluZyBuYW1lcyBhcyBzb21lXFxuLy8gbW9kdWxlcyBtb25rZXktcGF0Y2ggaXQgdG8gc3VwcG9ydCBhZGRpdGlvbmFsIGVuY29kaW5nc1xcbmZ1bmN0aW9uIG5vcm1hbGl6ZUVuY29kaW5nKGVuYykge1xcbiAgdmFyIG5lbmMgPSBfbm9ybWFsaXplRW5jb2RpbmcoZW5jKTtcXG4gIGlmICh0eXBlb2YgbmVuYyAhPT0gJ3N0cmluZycgJiYgKEJ1ZmZlci5pc0VuY29kaW5nID09PSBpc0VuY29kaW5nIHx8ICFpc0VuY29kaW5nKGVuYykpKSB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmMpO1xcbiAgcmV0dXJuIG5lbmMgfHwgZW5jO1xcbn1cXG5cXG4vLyBTdHJpbmdEZWNvZGVyIHByb3ZpZGVzIGFuIGludGVyZmFjZSBmb3IgZWZmaWNpZW50bHkgc3BsaXR0aW5nIGEgc2VyaWVzIG9mXFxuLy8gYnVmZmVycyBpbnRvIGEgc2VyaWVzIG9mIEpTIHN0cmluZ3Mgd2l0aG91dCBicmVha2luZyBhcGFydCBtdWx0aS1ieXRlXFxuLy8gY2hhcmFjdGVycy5cXG5leHBvcnRzLlN0cmluZ0RlY29kZXIgPSBTdHJpbmdEZWNvZGVyO1xcbmZ1bmN0aW9uIFN0cmluZ0RlY29kZXIoZW5jb2RpbmcpIHtcXG4gIHRoaXMuZW5jb2RpbmcgPSBub3JtYWxpemVFbmNvZGluZyhlbmNvZGluZyk7XFxuICB2YXIgbmI7XFxuICBzd2l0Y2ggKHRoaXMuZW5jb2RpbmcpIHtcXG4gICAgY2FzZSAndXRmMTZsZSc6XFxuICAgICAgdGhpcy50ZXh0ID0gdXRmMTZUZXh0O1xcbiAgICAgIHRoaXMuZW5kID0gdXRmMTZFbmQ7XFxuICAgICAgbmIgPSA0O1xcbiAgICAgIGJyZWFrO1xcbiAgICBjYXNlICd1dGY4JzpcXG4gICAgICB0aGlzLmZpbGxMYXN0ID0gdXRmOEZpbGxMYXN0O1xcbiAgICAgIG5iID0gNDtcXG4gICAgICBicmVhaztcXG4gICAgY2FzZSAnYmFzZTY0JzpcXG4gICAgICB0aGlzLnRleHQgPSBiYXNlNjRUZXh0O1xcbiAgICAgIHRoaXMuZW5kID0gYmFzZTY0RW5kO1xcbiAgICAgIG5iID0gMztcXG4gICAgICBicmVhaztcXG4gICAgZGVmYXVsdDpcXG4gICAgICB0aGlzLndyaXRlID0gc2ltcGxlV3JpdGU7XFxuICAgICAgdGhpcy5lbmQgPSBzaW1wbGVFbmQ7XFxuICAgICAgcmV0dXJuO1xcbiAgfVxcbiAgdGhpcy5sYXN0TmVlZCA9IDA7XFxuICB0aGlzLmxhc3RUb3RhbCA9IDA7XFxuICB0aGlzLmxhc3RDaGFyID0gQnVmZmVyLmFsbG9jVW5zYWZlKG5iKTtcXG59XFxuXFxuU3RyaW5nRGVjb2Rlci5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiAoYnVmKSB7XFxuICBpZiAoYnVmLmxlbmd0aCA9PT0gMCkgcmV0dXJuICcnO1xcbiAgdmFyIHI7XFxuICB2YXIgaTtcXG4gIGlmICh0aGlzLmxhc3ROZWVkKSB7XFxuICAgIHIgPSB0aGlzLmZpbGxMYXN0KGJ1Zik7XFxuICAgIGlmIChyID09PSB1bmRlZmluZWQpIHJldHVybiAnJztcXG4gICAgaSA9IHRoaXMubGFzdE5lZWQ7XFxuICAgIHRoaXMubGFzdE5lZWQgPSAwO1xcbiAgfSBlbHNlIHtcXG4gICAgaSA9IDA7XFxuICB9XFxuICBpZiAoaSA8IGJ1Zi5sZW5ndGgpIHJldHVybiByID8gciArIHRoaXMudGV4dChidWYsIGkpIDogdGhpcy50ZXh0KGJ1ZiwgaSk7XFxuICByZXR1cm4gciB8fCAnJztcXG59O1xcblxcblN0cmluZ0RlY29kZXIucHJvdG90eXBlLmVuZCA9IHV0ZjhFbmQ7XFxuXFxuLy8gUmV0dXJucyBvbmx5IGNvbXBsZXRlIGNoYXJhY3RlcnMgaW4gYSBCdWZmZXJcXG5TdHJpbmdEZWNvZGVyLnByb3RvdHlwZS50ZXh0ID0gdXRmOFRleHQ7XFxuXFxuLy8gQXR0ZW1wdHMgdG8gY29tcGxldGUgYSBwYXJ0aWFsIG5vbi1VVEYtOCBjaGFyYWN0ZXIgdXNpbmcgYnl0ZXMgZnJvbSBhIEJ1ZmZlclxcblN0cmluZ0RlY29kZXIucHJvdG90eXBlLmZpbGxMYXN0ID0gZnVuY3Rpb24gKGJ1Zikge1xcbiAgaWYgKHRoaXMubGFzdE5lZWQgPD0gYnVmLmxlbmd0aCkge1xcbiAgICBidWYuY29weSh0aGlzLmxhc3RDaGFyLCB0aGlzLmxhc3RUb3RhbCAtIHRoaXMubGFzdE5lZWQsIDAsIHRoaXMubGFzdE5lZWQpO1xcbiAgICByZXR1cm4gdGhpcy5sYXN0Q2hhci50b1N0cmluZyh0aGlzLmVuY29kaW5nLCAwLCB0aGlzLmxhc3RUb3RhbCk7XFxuICB9XFxuICBidWYuY29weSh0aGlzLmxhc3RDaGFyLCB0aGlzLmxhc3RUb3RhbCAtIHRoaXMubGFzdE5lZWQsIDAsIGJ1Zi5sZW5ndGgpO1xcbiAgdGhpcy5sYXN0TmVlZCAtPSBidWYubGVuZ3RoO1xcbn07XFxuXFxuLy8gQ2hlY2tzIHRoZSB0eXBlIG9mIGEgVVRGLTggYnl0ZSwgd2hldGhlciBpdCdzIEFTQ0lJLCBhIGxlYWRpbmcgYnl0ZSwgb3IgYVxcbi8vIGNvbnRpbnVhdGlvbiBieXRlLlxcbmZ1bmN0aW9uIHV0ZjhDaGVja0J5dGUoYnl0ZSkge1xcbiAgaWYgKGJ5dGUgPD0gMHg3RikgcmV0dXJuIDA7ZWxzZSBpZiAoYnl0ZSA+PiA1ID09PSAweDA2KSByZXR1cm4gMjtlbHNlIGlmIChieXRlID4+IDQgPT09IDB4MEUpIHJldHVybiAzO2Vsc2UgaWYgKGJ5dGUgPj4gMyA9PT0gMHgxRSkgcmV0dXJuIDQ7XFxuICByZXR1cm4gLTE7XFxufVxcblxcbi8vIENoZWNrcyBhdCBtb3N0IDMgYnl0ZXMgYXQgdGhlIGVuZCBvZiBhIEJ1ZmZlciBpbiBvcmRlciB0byBkZXRlY3QgYW5cXG4vLyBpbmNvbXBsZXRlIG11bHRpLWJ5dGUgVVRGLTggY2hhcmFjdGVyLiBUaGUgdG90YWwgbnVtYmVyIG9mIGJ5dGVzICgyLCAzLCBvciA0KVxcbi8vIG5lZWRlZCB0byBjb21wbGV0ZSB0aGUgVVRGLTggY2hhcmFjdGVyIChpZiBhcHBsaWNhYmxlKSBhcmUgcmV0dXJuZWQuXFxuZnVuY3Rpb24gdXRmOENoZWNrSW5jb21wbGV0ZShzZWxmLCBidWYsIGkpIHtcXG4gIHZhciBqID0gYnVmLmxlbmd0aCAtIDE7XFxuICBpZiAoaiA8IGkpIHJldHVybiAwO1xcbiAgdmFyIG5iID0gdXRmOENoZWNrQnl0ZShidWZbal0pO1xcbiAgaWYgKG5iID49IDApIHtcXG4gICAgaWYgKG5iID4gMCkgc2VsZi5sYXN0TmVlZCA9IG5iIC0gMTtcXG4gICAgcmV0dXJuIG5iO1xcbiAgfVxcbiAgaWYgKC0taiA8IGkpIHJldHVybiAwO1xcbiAgbmIgPSB1dGY4Q2hlY2tCeXRlKGJ1ZltqXSk7XFxuICBpZiAobmIgPj0gMCkge1xcbiAgICBpZiAobmIgPiAwKSBzZWxmLmxhc3ROZWVkID0gbmIgLSAyO1xcbiAgICByZXR1cm4gbmI7XFxuICB9XFxuICBpZiAoLS1qIDwgaSkgcmV0dXJuIDA7XFxuICBuYiA9IHV0ZjhDaGVja0J5dGUoYnVmW2pdKTtcXG4gIGlmIChuYiA+PSAwKSB7XFxuICAgIGlmIChuYiA+IDApIHtcXG4gICAgICBpZiAobmIgPT09IDIpIG5iID0gMDtlbHNlIHNlbGYubGFzdE5lZWQgPSBuYiAtIDM7XFxuICAgIH1cXG4gICAgcmV0dXJuIG5iO1xcbiAgfVxcbiAgcmV0dXJuIDA7XFxufVxcblxcbi8vIFZhbGlkYXRlcyBhcyBtYW55IGNvbnRpbnVhdGlvbiBieXRlcyBmb3IgYSBtdWx0aS1ieXRlIFVURi04IGNoYXJhY3RlciBhc1xcbi8vIG5lZWRlZCBvciBhcmUgYXZhaWxhYmxlLiBJZiB3ZSBzZWUgYSBub24tY29udGludWF0aW9uIGJ5dGUgd2hlcmUgd2UgZXhwZWN0XFxuLy8gb25lLCB3ZSBcXFwicmVwbGFjZVxcXCIgdGhlIHZhbGlkYXRlZCBjb250aW51YXRpb24gYnl0ZXMgd2UndmUgc2VlbiBzbyBmYXIgd2l0aFxcbi8vIFVURi04IHJlcGxhY2VtZW50IGNoYXJhY3RlcnMgKCdcXFxcdWZmZmQnKSwgdG8gbWF0Y2ggdjgncyBVVEYtOCBkZWNvZGluZ1xcbi8vIGJlaGF2aW9yLiBUaGUgY29udGludWF0aW9uIGJ5dGUgY2hlY2sgaXMgaW5jbHVkZWQgdGhyZWUgdGltZXMgaW4gdGhlIGNhc2VcXG4vLyB3aGVyZSBhbGwgb2YgdGhlIGNvbnRpbnVhdGlvbiBieXRlcyBmb3IgYSBjaGFyYWN0ZXIgZXhpc3QgaW4gdGhlIHNhbWUgYnVmZmVyLlxcbi8vIEl0IGlzIGFsc28gZG9uZSB0aGlzIHdheSBhcyBhIHNsaWdodCBwZXJmb3JtYW5jZSBpbmNyZWFzZSBpbnN0ZWFkIG9mIHVzaW5nIGFcXG4vLyBsb29wLlxcbmZ1bmN0aW9uIHV0ZjhDaGVja0V4dHJhQnl0ZXMoc2VsZiwgYnVmLCBwKSB7XFxuICBpZiAoKGJ1ZlswXSAmIDB4QzApICE9PSAweDgwKSB7XFxuICAgIHNlbGYubGFzdE5lZWQgPSAwO1xcbiAgICByZXR1cm4gJ1xcXFx1ZmZmZCcucmVwZWF0KHApO1xcbiAgfVxcbiAgaWYgKHNlbGYubGFzdE5lZWQgPiAxICYmIGJ1Zi5sZW5ndGggPiAxKSB7XFxuICAgIGlmICgoYnVmWzFdICYgMHhDMCkgIT09IDB4ODApIHtcXG4gICAgICBzZWxmLmxhc3ROZWVkID0gMTtcXG4gICAgICByZXR1cm4gJ1xcXFx1ZmZmZCcucmVwZWF0KHAgKyAxKTtcXG4gICAgfVxcbiAgICBpZiAoc2VsZi5sYXN0TmVlZCA+IDIgJiYgYnVmLmxlbmd0aCA+IDIpIHtcXG4gICAgICBpZiAoKGJ1ZlsyXSAmIDB4QzApICE9PSAweDgwKSB7XFxuICAgICAgICBzZWxmLmxhc3ROZWVkID0gMjtcXG4gICAgICAgIHJldHVybiAnXFxcXHVmZmZkJy5yZXBlYXQocCArIDIpO1xcbiAgICAgIH1cXG4gICAgfVxcbiAgfVxcbn1cXG5cXG4vLyBBdHRlbXB0cyB0byBjb21wbGV0ZSBhIG11bHRpLWJ5dGUgVVRGLTggY2hhcmFjdGVyIHVzaW5nIGJ5dGVzIGZyb20gYSBCdWZmZXIuXFxuZnVuY3Rpb24gdXRmOEZpbGxMYXN0KGJ1Zikge1xcbiAgdmFyIHAgPSB0aGlzLmxhc3RUb3RhbCAtIHRoaXMubGFzdE5lZWQ7XFxuICB2YXIgciA9IHV0ZjhDaGVja0V4dHJhQnl0ZXModGhpcywgYnVmLCBwKTtcXG4gIGlmIChyICE9PSB1bmRlZmluZWQpIHJldHVybiByO1xcbiAgaWYgKHRoaXMubGFzdE5lZWQgPD0gYnVmLmxlbmd0aCkge1xcbiAgICBidWYuY29weSh0aGlzLmxhc3RDaGFyLCBwLCAwLCB0aGlzLmxhc3ROZWVkKTtcXG4gICAgcmV0dXJuIHRoaXMubGFzdENoYXIudG9TdHJpbmcodGhpcy5lbmNvZGluZywgMCwgdGhpcy5sYXN0VG90YWwpO1xcbiAgfVxcbiAgYnVmLmNvcHkodGhpcy5sYXN0Q2hhciwgcCwgMCwgYnVmLmxlbmd0aCk7XFxuICB0aGlzLmxhc3ROZWVkIC09IGJ1Zi5sZW5ndGg7XFxufVxcblxcbi8vIFJldHVybnMgYWxsIGNvbXBsZXRlIFVURi04IGNoYXJhY3RlcnMgaW4gYSBCdWZmZXIuIElmIHRoZSBCdWZmZXIgZW5kZWQgb24gYVxcbi8vIHBhcnRpYWwgY2hhcmFjdGVyLCB0aGUgY2hhcmFjdGVyJ3MgYnl0ZXMgYXJlIGJ1ZmZlcmVkIHVudGlsIHRoZSByZXF1aXJlZFxcbi8vIG51bWJlciBvZiBieXRlcyBhcmUgYXZhaWxhYmxlLlxcbmZ1bmN0aW9uIHV0ZjhUZXh0KGJ1ZiwgaSkge1xcbiAgdmFyIHRvdGFsID0gdXRmOENoZWNrSW5jb21wbGV0ZSh0aGlzLCBidWYsIGkpO1xcbiAgaWYgKCF0aGlzLmxhc3ROZWVkKSByZXR1cm4gYnVmLnRvU3RyaW5nKCd1dGY4JywgaSk7XFxuICB0aGlzLmxhc3RUb3RhbCA9IHRvdGFsO1xcbiAgdmFyIGVuZCA9IGJ1Zi5sZW5ndGggLSAodG90YWwgLSB0aGlzLmxhc3ROZWVkKTtcXG4gIGJ1Zi5jb3B5KHRoaXMubGFzdENoYXIsIDAsIGVuZCk7XFxuICByZXR1cm4gYnVmLnRvU3RyaW5nKCd1dGY4JywgaSwgZW5kKTtcXG59XFxuXFxuLy8gRm9yIFVURi04LCBhIHJlcGxhY2VtZW50IGNoYXJhY3RlciBmb3IgZWFjaCBidWZmZXJlZCBieXRlIG9mIGEgKHBhcnRpYWwpXFxuLy8gY2hhcmFjdGVyIG5lZWRzIHRvIGJlIGFkZGVkIHRvIHRoZSBvdXRwdXQuXFxuZnVuY3Rpb24gdXRmOEVuZChidWYpIHtcXG4gIHZhciByID0gYnVmICYmIGJ1Zi5sZW5ndGggPyB0aGlzLndyaXRlKGJ1ZikgOiAnJztcXG4gIGlmICh0aGlzLmxhc3ROZWVkKSByZXR1cm4gciArICdcXFxcdWZmZmQnLnJlcGVhdCh0aGlzLmxhc3RUb3RhbCAtIHRoaXMubGFzdE5lZWQpO1xcbiAgcmV0dXJuIHI7XFxufVxcblxcbi8vIFVURi0xNkxFIHR5cGljYWxseSBuZWVkcyB0d28gYnl0ZXMgcGVyIGNoYXJhY3RlciwgYnV0IGV2ZW4gaWYgd2UgaGF2ZSBhbiBldmVuXFxuLy8gbnVtYmVyIG9mIGJ5dGVzIGF2YWlsYWJsZSwgd2UgbmVlZCB0byBjaGVjayBpZiB3ZSBlbmQgb24gYSBsZWFkaW5nL2hpZ2hcXG4vLyBzdXJyb2dhdGUuIEluIHRoYXQgY2FzZSwgd2UgbmVlZCB0byB3YWl0IGZvciB0aGUgbmV4dCB0d28gYnl0ZXMgaW4gb3JkZXIgdG9cXG4vLyBkZWNvZGUgdGhlIGxhc3QgY2hhcmFjdGVyIHByb3Blcmx5LlxcbmZ1bmN0aW9uIHV0ZjE2VGV4dChidWYsIGkpIHtcXG4gIGlmICgoYnVmLmxlbmd0aCAtIGkpICUgMiA9PT0gMCkge1xcbiAgICB2YXIgciA9IGJ1Zi50b1N0cmluZygndXRmMTZsZScsIGkpO1xcbiAgICBpZiAocikge1xcbiAgICAgIHZhciBjID0gci5jaGFyQ29kZUF0KHIubGVuZ3RoIC0gMSk7XFxuICAgICAgaWYgKGMgPj0gMHhEODAwICYmIGMgPD0gMHhEQkZGKSB7XFxuICAgICAgICB0aGlzLmxhc3ROZWVkID0gMjtcXG4gICAgICAgIHRoaXMubGFzdFRvdGFsID0gNDtcXG4gICAgICAgIHRoaXMubGFzdENoYXJbMF0gPSBidWZbYnVmLmxlbmd0aCAtIDJdO1xcbiAgICAgICAgdGhpcy5sYXN0Q2hhclsxXSA9IGJ1ZltidWYubGVuZ3RoIC0gMV07XFxuICAgICAgICByZXR1cm4gci5zbGljZSgwLCAtMSk7XFxuICAgICAgfVxcbiAgICB9XFxuICAgIHJldHVybiByO1xcbiAgfVxcbiAgdGhpcy5sYXN0TmVlZCA9IDE7XFxuICB0aGlzLmxhc3RUb3RhbCA9IDI7XFxuICB0aGlzLmxhc3RDaGFyWzBdID0gYnVmW2J1Zi5sZW5ndGggLSAxXTtcXG4gIHJldHVybiBidWYudG9TdHJpbmcoJ3V0ZjE2bGUnLCBpLCBidWYubGVuZ3RoIC0gMSk7XFxufVxcblxcbi8vIEZvciBVVEYtMTZMRSB3ZSBkbyBub3QgZXhwbGljaXRseSBhcHBlbmQgc3BlY2lhbCByZXBsYWNlbWVudCBjaGFyYWN0ZXJzIGlmIHdlXFxuLy8gZW5kIG9uIGEgcGFydGlhbCBjaGFyYWN0ZXIsIHdlIHNpbXBseSBsZXQgdjggaGFuZGxlIHRoYXQuXFxuZnVuY3Rpb24gdXRmMTZFbmQoYnVmKSB7XFxuICB2YXIgciA9IGJ1ZiAmJiBidWYubGVuZ3RoID8gdGhpcy53cml0ZShidWYpIDogJyc7XFxuICBpZiAodGhpcy5sYXN0TmVlZCkge1xcbiAgICB2YXIgZW5kID0gdGhpcy5sYXN0VG90YWwgLSB0aGlzLmxhc3ROZWVkO1xcbiAgICByZXR1cm4gciArIHRoaXMubGFzdENoYXIudG9TdHJpbmcoJ3V0ZjE2bGUnLCAwLCBlbmQpO1xcbiAgfVxcbiAgcmV0dXJuIHI7XFxufVxcblxcbmZ1bmN0aW9uIGJhc2U2NFRleHQoYnVmLCBpKSB7XFxuICB2YXIgbiA9IChidWYubGVuZ3RoIC0gaSkgJSAzO1xcbiAgaWYgKG4gPT09IDApIHJldHVybiBidWYudG9TdHJpbmcoJ2Jhc2U2NCcsIGkpO1xcbiAgdGhpcy5sYXN0TmVlZCA9IDMgLSBuO1xcbiAgdGhpcy5sYXN0VG90YWwgPSAzO1xcbiAgaWYgKG4gPT09IDEpIHtcXG4gICAgdGhpcy5sYXN0Q2hhclswXSA9IGJ1ZltidWYubGVuZ3RoIC0gMV07XFxuICB9IGVsc2Uge1xcbiAgICB0aGlzLmxhc3RDaGFyWzBdID0gYnVmW2J1Zi5sZW5ndGggLSAyXTtcXG4gICAgdGhpcy5sYXN0Q2hhclsxXSA9IGJ1ZltidWYubGVuZ3RoIC0gMV07XFxuICB9XFxuICByZXR1cm4gYnVmLnRvU3RyaW5nKCdiYXNlNjQnLCBpLCBidWYubGVuZ3RoIC0gbik7XFxufVxcblxcbmZ1bmN0aW9uIGJhc2U2NEVuZChidWYpIHtcXG4gIHZhciByID0gYnVmICYmIGJ1Zi5sZW5ndGggPyB0aGlzLndyaXRlKGJ1ZikgOiAnJztcXG4gIGlmICh0aGlzLmxhc3ROZWVkKSByZXR1cm4gciArIHRoaXMubGFzdENoYXIudG9TdHJpbmcoJ2Jhc2U2NCcsIDAsIDMgLSB0aGlzLmxhc3ROZWVkKTtcXG4gIHJldHVybiByO1xcbn1cXG5cXG4vLyBQYXNzIGJ5dGVzIG9uIHRocm91Z2ggZm9yIHNpbmdsZS1ieXRlIGVuY29kaW5ncyAoZS5nLiBhc2NpaSwgbGF0aW4xLCBoZXgpXFxuZnVuY3Rpb24gc2ltcGxlV3JpdGUoYnVmKSB7XFxuICByZXR1cm4gYnVmLnRvU3RyaW5nKHRoaXMuZW5jb2RpbmcpO1xcbn1cXG5cXG5mdW5jdGlvbiBzaW1wbGVFbmQoYnVmKSB7XFxuICByZXR1cm4gYnVmICYmIGJ1Zi5sZW5ndGggPyB0aGlzLndyaXRlKGJ1ZikgOiAnJztcXG59XFxufSx7XFxcInNhZmUtYnVmZmVyXFxcIjo5OH1dLDk4OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcXG4vKiBlc2xpbnQtZGlzYWJsZSBub2RlL25vLWRlcHJlY2F0ZWQtYXBpICovXFxudmFyIGJ1ZmZlciA9IHJlcXVpcmUoJ2J1ZmZlcicpXFxudmFyIEJ1ZmZlciA9IGJ1ZmZlci5CdWZmZXJcXG5cXG4vLyBhbHRlcm5hdGl2ZSB0byB1c2luZyBPYmplY3Qua2V5cyBmb3Igb2xkIGJyb3dzZXJzXFxuZnVuY3Rpb24gY29weVByb3BzIChzcmMsIGRzdCkge1xcbiAgZm9yICh2YXIga2V5IGluIHNyYykge1xcbiAgICBkc3Rba2V5XSA9IHNyY1trZXldXFxuICB9XFxufVxcbmlmIChCdWZmZXIuZnJvbSAmJiBCdWZmZXIuYWxsb2MgJiYgQnVmZmVyLmFsbG9jVW5zYWZlICYmIEJ1ZmZlci5hbGxvY1Vuc2FmZVNsb3cpIHtcXG4gIG1vZHVsZS5leHBvcnRzID0gYnVmZmVyXFxufSBlbHNlIHtcXG4gIC8vIENvcHkgcHJvcGVydGllcyBmcm9tIHJlcXVpcmUoJ2J1ZmZlcicpXFxuICBjb3B5UHJvcHMoYnVmZmVyLCBleHBvcnRzKVxcbiAgZXhwb3J0cy5CdWZmZXIgPSBTYWZlQnVmZmVyXFxufVxcblxcbmZ1bmN0aW9uIFNhZmVCdWZmZXIgKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XFxuICByZXR1cm4gQnVmZmVyKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxcbn1cXG5cXG4vLyBDb3B5IHN0YXRpYyBtZXRob2RzIGZyb20gQnVmZmVyXFxuY29weVByb3BzKEJ1ZmZlciwgU2FmZUJ1ZmZlcilcXG5cXG5TYWZlQnVmZmVyLmZyb20gPSBmdW5jdGlvbiAoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcXG4gIGlmICh0eXBlb2YgYXJnID09PSAnbnVtYmVyJykge1xcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IG5vdCBiZSBhIG51bWJlcicpXFxuICB9XFxuICByZXR1cm4gQnVmZmVyKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxcbn1cXG5cXG5TYWZlQnVmZmVyLmFsbG9jID0gZnVuY3Rpb24gKHNpemUsIGZpbGwsIGVuY29kaW5nKSB7XFxuICBpZiAodHlwZW9mIHNpemUgIT09ICdudW1iZXInKSB7XFxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBudW1iZXInKVxcbiAgfVxcbiAgdmFyIGJ1ZiA9IEJ1ZmZlcihzaXplKVxcbiAgaWYgKGZpbGwgIT09IHVuZGVmaW5lZCkge1xcbiAgICBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnc3RyaW5nJykge1xcbiAgICAgIGJ1Zi5maWxsKGZpbGwsIGVuY29kaW5nKVxcbiAgICB9IGVsc2Uge1xcbiAgICAgIGJ1Zi5maWxsKGZpbGwpXFxuICAgIH1cXG4gIH0gZWxzZSB7XFxuICAgIGJ1Zi5maWxsKDApXFxuICB9XFxuICByZXR1cm4gYnVmXFxufVxcblxcblNhZmVCdWZmZXIuYWxsb2NVbnNhZmUgPSBmdW5jdGlvbiAoc2l6ZSkge1xcbiAgaWYgKHR5cGVvZiBzaXplICE9PSAnbnVtYmVyJykge1xcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgbnVtYmVyJylcXG4gIH1cXG4gIHJldHVybiBCdWZmZXIoc2l6ZSlcXG59XFxuXFxuU2FmZUJ1ZmZlci5hbGxvY1Vuc2FmZVNsb3cgPSBmdW5jdGlvbiAoc2l6ZSkge1xcbiAgaWYgKHR5cGVvZiBzaXplICE9PSAnbnVtYmVyJykge1xcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgbnVtYmVyJylcXG4gIH1cXG4gIHJldHVybiBidWZmZXIuU2xvd0J1ZmZlcihzaXplKVxcbn1cXG5cXG59LHtcXFwiYnVmZmVyXFxcIjo0M31dLDk5OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcXG4oZnVuY3Rpb24gKGdsb2JhbCl7XFxuXFxuLyoqXFxuICogTW9kdWxlIGV4cG9ydHMuXFxuICovXFxuXFxubW9kdWxlLmV4cG9ydHMgPSBkZXByZWNhdGU7XFxuXFxuLyoqXFxuICogTWFyayB0aGF0IGEgbWV0aG9kIHNob3VsZCBub3QgYmUgdXNlZC5cXG4gKiBSZXR1cm5zIGEgbW9kaWZpZWQgZnVuY3Rpb24gd2hpY2ggd2FybnMgb25jZSBieSBkZWZhdWx0LlxcbiAqXFxuICogSWYgYGxvY2FsU3RvcmFnZS5ub0RlcHJlY2F0aW9uID0gdHJ1ZWAgaXMgc2V0LCB0aGVuIGl0IGlzIGEgbm8tb3AuXFxuICpcXG4gKiBJZiBgbG9jYWxTdG9yYWdlLnRocm93RGVwcmVjYXRpb24gPSB0cnVlYCBpcyBzZXQsIHRoZW4gZGVwcmVjYXRlZCBmdW5jdGlvbnNcXG4gKiB3aWxsIHRocm93IGFuIEVycm9yIHdoZW4gaW52b2tlZC5cXG4gKlxcbiAqIElmIGBsb2NhbFN0b3JhZ2UudHJhY2VEZXByZWNhdGlvbiA9IHRydWVgIGlzIHNldCwgdGhlbiBkZXByZWNhdGVkIGZ1bmN0aW9uc1xcbiAqIHdpbGwgaW52b2tlIGBjb25zb2xlLnRyYWNlKClgIGluc3RlYWQgb2YgYGNvbnNvbGUuZXJyb3IoKWAuXFxuICpcXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiAtIHRoZSBmdW5jdGlvbiB0byBkZXByZWNhdGVcXG4gKiBAcGFyYW0ge1N0cmluZ30gbXNnIC0gdGhlIHN0cmluZyB0byBwcmludCB0byB0aGUgY29uc29sZSB3aGVuIGBmbmAgaXMgaW52b2tlZFxcbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gYSBuZXcgXFxcImRlcHJlY2F0ZWRcXFwiIHZlcnNpb24gb2YgYGZuYFxcbiAqIEBhcGkgcHVibGljXFxuICovXFxuXFxuZnVuY3Rpb24gZGVwcmVjYXRlIChmbiwgbXNnKSB7XFxuICBpZiAoY29uZmlnKCdub0RlcHJlY2F0aW9uJykpIHtcXG4gICAgcmV0dXJuIGZuO1xcbiAgfVxcblxcbiAgdmFyIHdhcm5lZCA9IGZhbHNlO1xcbiAgZnVuY3Rpb24gZGVwcmVjYXRlZCgpIHtcXG4gICAgaWYgKCF3YXJuZWQpIHtcXG4gICAgICBpZiAoY29uZmlnKCd0aHJvd0RlcHJlY2F0aW9uJykpIHtcXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihtc2cpO1xcbiAgICAgIH0gZWxzZSBpZiAoY29uZmlnKCd0cmFjZURlcHJlY2F0aW9uJykpIHtcXG4gICAgICAgIGNvbnNvbGUudHJhY2UobXNnKTtcXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgY29uc29sZS53YXJuKG1zZyk7XFxuICAgICAgfVxcbiAgICAgIHdhcm5lZCA9IHRydWU7XFxuICAgIH1cXG4gICAgcmV0dXJuIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XFxuICB9XFxuXFxuICByZXR1cm4gZGVwcmVjYXRlZDtcXG59XFxuXFxuLyoqXFxuICogQ2hlY2tzIGBsb2NhbFN0b3JhZ2VgIGZvciBib29sZWFuIHZhbHVlcyBmb3IgdGhlIGdpdmVuIGBuYW1lYC5cXG4gKlxcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXFxuICogQHJldHVybnMge0Jvb2xlYW59XFxuICogQGFwaSBwcml2YXRlXFxuICovXFxuXFxuZnVuY3Rpb24gY29uZmlnIChuYW1lKSB7XFxuICAvLyBhY2Nlc3NpbmcgZ2xvYmFsLmxvY2FsU3RvcmFnZSBjYW4gdHJpZ2dlciBhIERPTUV4Y2VwdGlvbiBpbiBzYW5kYm94ZWQgaWZyYW1lc1xcbiAgdHJ5IHtcXG4gICAgaWYgKCFnbG9iYWwubG9jYWxTdG9yYWdlKSByZXR1cm4gZmFsc2U7XFxuICB9IGNhdGNoIChfKSB7XFxuICAgIHJldHVybiBmYWxzZTtcXG4gIH1cXG4gIHZhciB2YWwgPSBnbG9iYWwubG9jYWxTdG9yYWdlW25hbWVdO1xcbiAgaWYgKG51bGwgPT0gdmFsKSByZXR1cm4gZmFsc2U7XFxuICByZXR1cm4gU3RyaW5nKHZhbCkudG9Mb3dlckNhc2UoKSA9PT0gJ3RydWUnO1xcbn1cXG5cXG59KS5jYWxsKHRoaXMsdHlwZW9mIGdsb2JhbCAhPT0gXFxcInVuZGVmaW5lZFxcXCIgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gXFxcInVuZGVmaW5lZFxcXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXFxcInVuZGVmaW5lZFxcXCIgPyB3aW5kb3cgOiB7fSlcXG59LHt9XSwxMDA6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xcbmFyZ3VtZW50c1s0XVs2Nl1bMF0uYXBwbHkoZXhwb3J0cyxhcmd1bWVudHMpXFxufSx7XFxcImR1cFxcXCI6NjZ9XSwxMDE6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaXNCdWZmZXIoYXJnKSB7XFxuICByZXR1cm4gYXJnICYmIHR5cGVvZiBhcmcgPT09ICdvYmplY3QnXFxuICAgICYmIHR5cGVvZiBhcmcuY29weSA9PT0gJ2Z1bmN0aW9uJ1xcbiAgICAmJiB0eXBlb2YgYXJnLmZpbGwgPT09ICdmdW5jdGlvbidcXG4gICAgJiYgdHlwZW9mIGFyZy5yZWFkVUludDggPT09ICdmdW5jdGlvbic7XFxufVxcbn0se31dLDEwMjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XFxuKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCl7XFxuLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXFxuLy9cXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcXG4vLyBcXFwiU29mdHdhcmVcXFwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXFxuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcXG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcXG4vL1xcbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXFxuLy9cXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXFxcIkFTIElTXFxcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xcbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0ZcXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXFxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXFxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXFxuXFxudmFyIGZvcm1hdFJlZ0V4cCA9IC8lW3NkaiVdL2c7XFxuZXhwb3J0cy5mb3JtYXQgPSBmdW5jdGlvbihmKSB7XFxuICBpZiAoIWlzU3RyaW5nKGYpKSB7XFxuICAgIHZhciBvYmplY3RzID0gW107XFxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XFxuICAgICAgb2JqZWN0cy5wdXNoKGluc3BlY3QoYXJndW1lbnRzW2ldKSk7XFxuICAgIH1cXG4gICAgcmV0dXJuIG9iamVjdHMuam9pbignICcpO1xcbiAgfVxcblxcbiAgdmFyIGkgPSAxO1xcbiAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XFxuICB2YXIgbGVuID0gYXJncy5sZW5ndGg7XFxuICB2YXIgc3RyID0gU3RyaW5nKGYpLnJlcGxhY2UoZm9ybWF0UmVnRXhwLCBmdW5jdGlvbih4KSB7XFxuICAgIGlmICh4ID09PSAnJSUnKSByZXR1cm4gJyUnO1xcbiAgICBpZiAoaSA+PSBsZW4pIHJldHVybiB4O1xcbiAgICBzd2l0Y2ggKHgpIHtcXG4gICAgICBjYXNlICclcyc6IHJldHVybiBTdHJpbmcoYXJnc1tpKytdKTtcXG4gICAgICBjYXNlICclZCc6IHJldHVybiBOdW1iZXIoYXJnc1tpKytdKTtcXG4gICAgICBjYXNlICclaic6XFxuICAgICAgICB0cnkge1xcbiAgICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoYXJnc1tpKytdKTtcXG4gICAgICAgIH0gY2F0Y2ggKF8pIHtcXG4gICAgICAgICAgcmV0dXJuICdbQ2lyY3VsYXJdJztcXG4gICAgICAgIH1cXG4gICAgICBkZWZhdWx0OlxcbiAgICAgICAgcmV0dXJuIHg7XFxuICAgIH1cXG4gIH0pO1xcbiAgZm9yICh2YXIgeCA9IGFyZ3NbaV07IGkgPCBsZW47IHggPSBhcmdzWysraV0pIHtcXG4gICAgaWYgKGlzTnVsbCh4KSB8fCAhaXNPYmplY3QoeCkpIHtcXG4gICAgICBzdHIgKz0gJyAnICsgeDtcXG4gICAgfSBlbHNlIHtcXG4gICAgICBzdHIgKz0gJyAnICsgaW5zcGVjdCh4KTtcXG4gICAgfVxcbiAgfVxcbiAgcmV0dXJuIHN0cjtcXG59O1xcblxcblxcbi8vIE1hcmsgdGhhdCBhIG1ldGhvZCBzaG91bGQgbm90IGJlIHVzZWQuXFxuLy8gUmV0dXJucyBhIG1vZGlmaWVkIGZ1bmN0aW9uIHdoaWNoIHdhcm5zIG9uY2UgYnkgZGVmYXVsdC5cXG4vLyBJZiAtLW5vLWRlcHJlY2F0aW9uIGlzIHNldCwgdGhlbiBpdCBpcyBhIG5vLW9wLlxcbmV4cG9ydHMuZGVwcmVjYXRlID0gZnVuY3Rpb24oZm4sIG1zZykge1xcbiAgLy8gQWxsb3cgZm9yIGRlcHJlY2F0aW5nIHRoaW5ncyBpbiB0aGUgcHJvY2VzcyBvZiBzdGFydGluZyB1cC5cXG4gIGlmIChpc1VuZGVmaW5lZChnbG9iYWwucHJvY2VzcykpIHtcXG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xcbiAgICAgIHJldHVybiBleHBvcnRzLmRlcHJlY2F0ZShmbiwgbXNnKS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xcbiAgICB9O1xcbiAgfVxcblxcbiAgaWYgKHByb2Nlc3Mubm9EZXByZWNhdGlvbiA9PT0gdHJ1ZSkge1xcbiAgICByZXR1cm4gZm47XFxuICB9XFxuXFxuICB2YXIgd2FybmVkID0gZmFsc2U7XFxuICBmdW5jdGlvbiBkZXByZWNhdGVkKCkge1xcbiAgICBpZiAoIXdhcm5lZCkge1xcbiAgICAgIGlmIChwcm9jZXNzLnRocm93RGVwcmVjYXRpb24pIHtcXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihtc2cpO1xcbiAgICAgIH0gZWxzZSBpZiAocHJvY2Vzcy50cmFjZURlcHJlY2F0aW9uKSB7XFxuICAgICAgICBjb25zb2xlLnRyYWNlKG1zZyk7XFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIGNvbnNvbGUuZXJyb3IobXNnKTtcXG4gICAgICB9XFxuICAgICAgd2FybmVkID0gdHJ1ZTtcXG4gICAgfVxcbiAgICByZXR1cm4gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcXG4gIH1cXG5cXG4gIHJldHVybiBkZXByZWNhdGVkO1xcbn07XFxuXFxuXFxudmFyIGRlYnVncyA9IHt9O1xcbnZhciBkZWJ1Z0Vudmlyb247XFxuZXhwb3J0cy5kZWJ1Z2xvZyA9IGZ1bmN0aW9uKHNldCkge1xcbiAgaWYgKGlzVW5kZWZpbmVkKGRlYnVnRW52aXJvbikpXFxuICAgIGRlYnVnRW52aXJvbiA9IHByb2Nlc3MuZW52Lk5PREVfREVCVUcgfHwgJyc7XFxuICBzZXQgPSBzZXQudG9VcHBlckNhc2UoKTtcXG4gIGlmICghZGVidWdzW3NldF0pIHtcXG4gICAgaWYgKG5ldyBSZWdFeHAoJ1xcXFxcXFxcYicgKyBzZXQgKyAnXFxcXFxcXFxiJywgJ2knKS50ZXN0KGRlYnVnRW52aXJvbikpIHtcXG4gICAgICB2YXIgcGlkID0gcHJvY2Vzcy5waWQ7XFxuICAgICAgZGVidWdzW3NldF0gPSBmdW5jdGlvbigpIHtcXG4gICAgICAgIHZhciBtc2cgPSBleHBvcnRzLmZvcm1hdC5hcHBseShleHBvcnRzLCBhcmd1bWVudHMpO1xcbiAgICAgICAgY29uc29sZS5lcnJvcignJXMgJWQ6ICVzJywgc2V0LCBwaWQsIG1zZyk7XFxuICAgICAgfTtcXG4gICAgfSBlbHNlIHtcXG4gICAgICBkZWJ1Z3Nbc2V0XSA9IGZ1bmN0aW9uKCkge307XFxuICAgIH1cXG4gIH1cXG4gIHJldHVybiBkZWJ1Z3Nbc2V0XTtcXG59O1xcblxcblxcbi8qKlxcbiAqIEVjaG9zIHRoZSB2YWx1ZSBvZiBhIHZhbHVlLiBUcnlzIHRvIHByaW50IHRoZSB2YWx1ZSBvdXRcXG4gKiBpbiB0aGUgYmVzdCB3YXkgcG9zc2libGUgZ2l2ZW4gdGhlIGRpZmZlcmVudCB0eXBlcy5cXG4gKlxcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmogVGhlIG9iamVjdCB0byBwcmludCBvdXQuXFxuICogQHBhcmFtIHtPYmplY3R9IG9wdHMgT3B0aW9uYWwgb3B0aW9ucyBvYmplY3QgdGhhdCBhbHRlcnMgdGhlIG91dHB1dC5cXG4gKi9cXG4vKiBsZWdhY3k6IG9iaiwgc2hvd0hpZGRlbiwgZGVwdGgsIGNvbG9ycyovXFxuZnVuY3Rpb24gaW5zcGVjdChvYmosIG9wdHMpIHtcXG4gIC8vIGRlZmF1bHQgb3B0aW9uc1xcbiAgdmFyIGN0eCA9IHtcXG4gICAgc2VlbjogW10sXFxuICAgIHN0eWxpemU6IHN0eWxpemVOb0NvbG9yXFxuICB9O1xcbiAgLy8gbGVnYWN5Li4uXFxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+PSAzKSBjdHguZGVwdGggPSBhcmd1bWVudHNbMl07XFxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+PSA0KSBjdHguY29sb3JzID0gYXJndW1lbnRzWzNdO1xcbiAgaWYgKGlzQm9vbGVhbihvcHRzKSkge1xcbiAgICAvLyBsZWdhY3kuLi5cXG4gICAgY3R4LnNob3dIaWRkZW4gPSBvcHRzO1xcbiAgfSBlbHNlIGlmIChvcHRzKSB7XFxuICAgIC8vIGdvdCBhbiBcXFwib3B0aW9uc1xcXCIgb2JqZWN0XFxuICAgIGV4cG9ydHMuX2V4dGVuZChjdHgsIG9wdHMpO1xcbiAgfVxcbiAgLy8gc2V0IGRlZmF1bHQgb3B0aW9uc1xcbiAgaWYgKGlzVW5kZWZpbmVkKGN0eC5zaG93SGlkZGVuKSkgY3R4LnNob3dIaWRkZW4gPSBmYWxzZTtcXG4gIGlmIChpc1VuZGVmaW5lZChjdHguZGVwdGgpKSBjdHguZGVwdGggPSAyO1xcbiAgaWYgKGlzVW5kZWZpbmVkKGN0eC5jb2xvcnMpKSBjdHguY29sb3JzID0gZmFsc2U7XFxuICBpZiAoaXNVbmRlZmluZWQoY3R4LmN1c3RvbUluc3BlY3QpKSBjdHguY3VzdG9tSW5zcGVjdCA9IHRydWU7XFxuICBpZiAoY3R4LmNvbG9ycykgY3R4LnN0eWxpemUgPSBzdHlsaXplV2l0aENvbG9yO1xcbiAgcmV0dXJuIGZvcm1hdFZhbHVlKGN0eCwgb2JqLCBjdHguZGVwdGgpO1xcbn1cXG5leHBvcnRzLmluc3BlY3QgPSBpbnNwZWN0O1xcblxcblxcbi8vIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQU5TSV9lc2NhcGVfY29kZSNncmFwaGljc1xcbmluc3BlY3QuY29sb3JzID0ge1xcbiAgJ2JvbGQnIDogWzEsIDIyXSxcXG4gICdpdGFsaWMnIDogWzMsIDIzXSxcXG4gICd1bmRlcmxpbmUnIDogWzQsIDI0XSxcXG4gICdpbnZlcnNlJyA6IFs3LCAyN10sXFxuICAnd2hpdGUnIDogWzM3LCAzOV0sXFxuICAnZ3JleScgOiBbOTAsIDM5XSxcXG4gICdibGFjaycgOiBbMzAsIDM5XSxcXG4gICdibHVlJyA6IFszNCwgMzldLFxcbiAgJ2N5YW4nIDogWzM2LCAzOV0sXFxuICAnZ3JlZW4nIDogWzMyLCAzOV0sXFxuICAnbWFnZW50YScgOiBbMzUsIDM5XSxcXG4gICdyZWQnIDogWzMxLCAzOV0sXFxuICAneWVsbG93JyA6IFszMywgMzldXFxufTtcXG5cXG4vLyBEb24ndCB1c2UgJ2JsdWUnIG5vdCB2aXNpYmxlIG9uIGNtZC5leGVcXG5pbnNwZWN0LnN0eWxlcyA9IHtcXG4gICdzcGVjaWFsJzogJ2N5YW4nLFxcbiAgJ251bWJlcic6ICd5ZWxsb3cnLFxcbiAgJ2Jvb2xlYW4nOiAneWVsbG93JyxcXG4gICd1bmRlZmluZWQnOiAnZ3JleScsXFxuICAnbnVsbCc6ICdib2xkJyxcXG4gICdzdHJpbmcnOiAnZ3JlZW4nLFxcbiAgJ2RhdGUnOiAnbWFnZW50YScsXFxuICAvLyBcXFwibmFtZVxcXCI6IGludGVudGlvbmFsbHkgbm90IHN0eWxpbmdcXG4gICdyZWdleHAnOiAncmVkJ1xcbn07XFxuXFxuXFxuZnVuY3Rpb24gc3R5bGl6ZVdpdGhDb2xvcihzdHIsIHN0eWxlVHlwZSkge1xcbiAgdmFyIHN0eWxlID0gaW5zcGVjdC5zdHlsZXNbc3R5bGVUeXBlXTtcXG5cXG4gIGlmIChzdHlsZSkge1xcbiAgICByZXR1cm4gJ1xcXFx1MDAxYlsnICsgaW5zcGVjdC5jb2xvcnNbc3R5bGVdWzBdICsgJ20nICsgc3RyICtcXG4gICAgICAgICAgICdcXFxcdTAwMWJbJyArIGluc3BlY3QuY29sb3JzW3N0eWxlXVsxXSArICdtJztcXG4gIH0gZWxzZSB7XFxuICAgIHJldHVybiBzdHI7XFxuICB9XFxufVxcblxcblxcbmZ1bmN0aW9uIHN0eWxpemVOb0NvbG9yKHN0ciwgc3R5bGVUeXBlKSB7XFxuICByZXR1cm4gc3RyO1xcbn1cXG5cXG5cXG5mdW5jdGlvbiBhcnJheVRvSGFzaChhcnJheSkge1xcbiAgdmFyIGhhc2ggPSB7fTtcXG5cXG4gIGFycmF5LmZvckVhY2goZnVuY3Rpb24odmFsLCBpZHgpIHtcXG4gICAgaGFzaFt2YWxdID0gdHJ1ZTtcXG4gIH0pO1xcblxcbiAgcmV0dXJuIGhhc2g7XFxufVxcblxcblxcbmZ1bmN0aW9uIGZvcm1hdFZhbHVlKGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcykge1xcbiAgLy8gUHJvdmlkZSBhIGhvb2sgZm9yIHVzZXItc3BlY2lmaWVkIGluc3BlY3QgZnVuY3Rpb25zLlxcbiAgLy8gQ2hlY2sgdGhhdCB2YWx1ZSBpcyBhbiBvYmplY3Qgd2l0aCBhbiBpbnNwZWN0IGZ1bmN0aW9uIG9uIGl0XFxuICBpZiAoY3R4LmN1c3RvbUluc3BlY3QgJiZcXG4gICAgICB2YWx1ZSAmJlxcbiAgICAgIGlzRnVuY3Rpb24odmFsdWUuaW5zcGVjdCkgJiZcXG4gICAgICAvLyBGaWx0ZXIgb3V0IHRoZSB1dGlsIG1vZHVsZSwgaXQncyBpbnNwZWN0IGZ1bmN0aW9uIGlzIHNwZWNpYWxcXG4gICAgICB2YWx1ZS5pbnNwZWN0ICE9PSBleHBvcnRzLmluc3BlY3QgJiZcXG4gICAgICAvLyBBbHNvIGZpbHRlciBvdXQgYW55IHByb3RvdHlwZSBvYmplY3RzIHVzaW5nIHRoZSBjaXJjdWxhciBjaGVjay5cXG4gICAgICAhKHZhbHVlLmNvbnN0cnVjdG9yICYmIHZhbHVlLmNvbnN0cnVjdG9yLnByb3RvdHlwZSA9PT0gdmFsdWUpKSB7XFxuICAgIHZhciByZXQgPSB2YWx1ZS5pbnNwZWN0KHJlY3Vyc2VUaW1lcywgY3R4KTtcXG4gICAgaWYgKCFpc1N0cmluZyhyZXQpKSB7XFxuICAgICAgcmV0ID0gZm9ybWF0VmFsdWUoY3R4LCByZXQsIHJlY3Vyc2VUaW1lcyk7XFxuICAgIH1cXG4gICAgcmV0dXJuIHJldDtcXG4gIH1cXG5cXG4gIC8vIFByaW1pdGl2ZSB0eXBlcyBjYW5ub3QgaGF2ZSBwcm9wZXJ0aWVzXFxuICB2YXIgcHJpbWl0aXZlID0gZm9ybWF0UHJpbWl0aXZlKGN0eCwgdmFsdWUpO1xcbiAgaWYgKHByaW1pdGl2ZSkge1xcbiAgICByZXR1cm4gcHJpbWl0aXZlO1xcbiAgfVxcblxcbiAgLy8gTG9vayB1cCB0aGUga2V5cyBvZiB0aGUgb2JqZWN0LlxcbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyh2YWx1ZSk7XFxuICB2YXIgdmlzaWJsZUtleXMgPSBhcnJheVRvSGFzaChrZXlzKTtcXG5cXG4gIGlmIChjdHguc2hvd0hpZGRlbikge1xcbiAgICBrZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModmFsdWUpO1xcbiAgfVxcblxcbiAgLy8gSUUgZG9lc24ndCBtYWtlIGVycm9yIGZpZWxkcyBub24tZW51bWVyYWJsZVxcbiAgLy8gaHR0cDovL21zZG4ubWljcm9zb2Z0LmNvbS9lbi11cy9saWJyYXJ5L2llL2R3dzUyc2J0KHY9dnMuOTQpLmFzcHhcXG4gIGlmIChpc0Vycm9yKHZhbHVlKVxcbiAgICAgICYmIChrZXlzLmluZGV4T2YoJ21lc3NhZ2UnKSA+PSAwIHx8IGtleXMuaW5kZXhPZignZGVzY3JpcHRpb24nKSA+PSAwKSkge1xcbiAgICByZXR1cm4gZm9ybWF0RXJyb3IodmFsdWUpO1xcbiAgfVxcblxcbiAgLy8gU29tZSB0eXBlIG9mIG9iamVjdCB3aXRob3V0IHByb3BlcnRpZXMgY2FuIGJlIHNob3J0Y3V0dGVkLlxcbiAgaWYgKGtleXMubGVuZ3RoID09PSAwKSB7XFxuICAgIGlmIChpc0Z1bmN0aW9uKHZhbHVlKSkge1xcbiAgICAgIHZhciBuYW1lID0gdmFsdWUubmFtZSA/ICc6ICcgKyB2YWx1ZS5uYW1lIDogJyc7XFxuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKCdbRnVuY3Rpb24nICsgbmFtZSArICddJywgJ3NwZWNpYWwnKTtcXG4gICAgfVxcbiAgICBpZiAoaXNSZWdFeHAodmFsdWUpKSB7XFxuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKFJlZ0V4cC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSksICdyZWdleHAnKTtcXG4gICAgfVxcbiAgICBpZiAoaXNEYXRlKHZhbHVlKSkge1xcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZShEYXRlLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSwgJ2RhdGUnKTtcXG4gICAgfVxcbiAgICBpZiAoaXNFcnJvcih2YWx1ZSkpIHtcXG4gICAgICByZXR1cm4gZm9ybWF0RXJyb3IodmFsdWUpO1xcbiAgICB9XFxuICB9XFxuXFxuICB2YXIgYmFzZSA9ICcnLCBhcnJheSA9IGZhbHNlLCBicmFjZXMgPSBbJ3snLCAnfSddO1xcblxcbiAgLy8gTWFrZSBBcnJheSBzYXkgdGhhdCB0aGV5IGFyZSBBcnJheVxcbiAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XFxuICAgIGFycmF5ID0gdHJ1ZTtcXG4gICAgYnJhY2VzID0gWydbJywgJ10nXTtcXG4gIH1cXG5cXG4gIC8vIE1ha2UgZnVuY3Rpb25zIHNheSB0aGF0IHRoZXkgYXJlIGZ1bmN0aW9uc1xcbiAgaWYgKGlzRnVuY3Rpb24odmFsdWUpKSB7XFxuICAgIHZhciBuID0gdmFsdWUubmFtZSA/ICc6ICcgKyB2YWx1ZS5uYW1lIDogJyc7XFxuICAgIGJhc2UgPSAnIFtGdW5jdGlvbicgKyBuICsgJ10nO1xcbiAgfVxcblxcbiAgLy8gTWFrZSBSZWdFeHBzIHNheSB0aGF0IHRoZXkgYXJlIFJlZ0V4cHNcXG4gIGlmIChpc1JlZ0V4cCh2YWx1ZSkpIHtcXG4gICAgYmFzZSA9ICcgJyArIFJlZ0V4cC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSk7XFxuICB9XFxuXFxuICAvLyBNYWtlIGRhdGVzIHdpdGggcHJvcGVydGllcyBmaXJzdCBzYXkgdGhlIGRhdGVcXG4gIGlmIChpc0RhdGUodmFsdWUpKSB7XFxuICAgIGJhc2UgPSAnICcgKyBEYXRlLnByb3RvdHlwZS50b1VUQ1N0cmluZy5jYWxsKHZhbHVlKTtcXG4gIH1cXG5cXG4gIC8vIE1ha2UgZXJyb3Igd2l0aCBtZXNzYWdlIGZpcnN0IHNheSB0aGUgZXJyb3JcXG4gIGlmIChpc0Vycm9yKHZhbHVlKSkge1xcbiAgICBiYXNlID0gJyAnICsgZm9ybWF0RXJyb3IodmFsdWUpO1xcbiAgfVxcblxcbiAgaWYgKGtleXMubGVuZ3RoID09PSAwICYmICghYXJyYXkgfHwgdmFsdWUubGVuZ3RoID09IDApKSB7XFxuICAgIHJldHVybiBicmFjZXNbMF0gKyBiYXNlICsgYnJhY2VzWzFdO1xcbiAgfVxcblxcbiAgaWYgKHJlY3Vyc2VUaW1lcyA8IDApIHtcXG4gICAgaWYgKGlzUmVnRXhwKHZhbHVlKSkge1xcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZShSZWdFeHAucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpLCAncmVnZXhwJyk7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKCdbT2JqZWN0XScsICdzcGVjaWFsJyk7XFxuICAgIH1cXG4gIH1cXG5cXG4gIGN0eC5zZWVuLnB1c2godmFsdWUpO1xcblxcbiAgdmFyIG91dHB1dDtcXG4gIGlmIChhcnJheSkge1xcbiAgICBvdXRwdXQgPSBmb3JtYXRBcnJheShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLCBrZXlzKTtcXG4gIH0gZWxzZSB7XFxuICAgIG91dHB1dCA9IGtleXMubWFwKGZ1bmN0aW9uKGtleSkge1xcbiAgICAgIHJldHVybiBmb3JtYXRQcm9wZXJ0eShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLCBrZXksIGFycmF5KTtcXG4gICAgfSk7XFxuICB9XFxuXFxuICBjdHguc2Vlbi5wb3AoKTtcXG5cXG4gIHJldHVybiByZWR1Y2VUb1NpbmdsZVN0cmluZyhvdXRwdXQsIGJhc2UsIGJyYWNlcyk7XFxufVxcblxcblxcbmZ1bmN0aW9uIGZvcm1hdFByaW1pdGl2ZShjdHgsIHZhbHVlKSB7XFxuICBpZiAoaXNVbmRlZmluZWQodmFsdWUpKVxcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoJ3VuZGVmaW5lZCcsICd1bmRlZmluZWQnKTtcXG4gIGlmIChpc1N0cmluZyh2YWx1ZSkpIHtcXG4gICAgdmFyIHNpbXBsZSA9ICdcXFxcJycgKyBKU09OLnN0cmluZ2lmeSh2YWx1ZSkucmVwbGFjZSgvXlxcXCJ8XFxcIiQvZywgJycpXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoLycvZywgXFxcIlxcXFxcXFxcJ1xcXCIpXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL1xcXFxcXFxcXFxcIi9nLCAnXFxcIicpICsgJ1xcXFwnJztcXG4gICAgcmV0dXJuIGN0eC5zdHlsaXplKHNpbXBsZSwgJ3N0cmluZycpO1xcbiAgfVxcbiAgaWYgKGlzTnVtYmVyKHZhbHVlKSlcXG4gICAgcmV0dXJuIGN0eC5zdHlsaXplKCcnICsgdmFsdWUsICdudW1iZXInKTtcXG4gIGlmIChpc0Jvb2xlYW4odmFsdWUpKVxcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoJycgKyB2YWx1ZSwgJ2Jvb2xlYW4nKTtcXG4gIC8vIEZvciBzb21lIHJlYXNvbiB0eXBlb2YgbnVsbCBpcyBcXFwib2JqZWN0XFxcIiwgc28gc3BlY2lhbCBjYXNlIGhlcmUuXFxuICBpZiAoaXNOdWxsKHZhbHVlKSlcXG4gICAgcmV0dXJuIGN0eC5zdHlsaXplKCdudWxsJywgJ251bGwnKTtcXG59XFxuXFxuXFxuZnVuY3Rpb24gZm9ybWF0RXJyb3IodmFsdWUpIHtcXG4gIHJldHVybiAnWycgKyBFcnJvci5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSkgKyAnXSc7XFxufVxcblxcblxcbmZ1bmN0aW9uIGZvcm1hdEFycmF5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsIGtleXMpIHtcXG4gIHZhciBvdXRwdXQgPSBbXTtcXG4gIGZvciAodmFyIGkgPSAwLCBsID0gdmFsdWUubGVuZ3RoOyBpIDwgbDsgKytpKSB7XFxuICAgIGlmIChoYXNPd25Qcm9wZXJ0eSh2YWx1ZSwgU3RyaW5nKGkpKSkge1xcbiAgICAgIG91dHB1dC5wdXNoKGZvcm1hdFByb3BlcnR5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsXFxuICAgICAgICAgIFN0cmluZyhpKSwgdHJ1ZSkpO1xcbiAgICB9IGVsc2Uge1xcbiAgICAgIG91dHB1dC5wdXNoKCcnKTtcXG4gICAgfVxcbiAgfVxcbiAga2V5cy5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xcbiAgICBpZiAoIWtleS5tYXRjaCgvXlxcXFxkKyQvKSkge1xcbiAgICAgIG91dHB1dC5wdXNoKGZvcm1hdFByb3BlcnR5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsXFxuICAgICAgICAgIGtleSwgdHJ1ZSkpO1xcbiAgICB9XFxuICB9KTtcXG4gIHJldHVybiBvdXRwdXQ7XFxufVxcblxcblxcbmZ1bmN0aW9uIGZvcm1hdFByb3BlcnR5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsIGtleSwgYXJyYXkpIHtcXG4gIHZhciBuYW1lLCBzdHIsIGRlc2M7XFxuICBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih2YWx1ZSwga2V5KSB8fCB7IHZhbHVlOiB2YWx1ZVtrZXldIH07XFxuICBpZiAoZGVzYy5nZXQpIHtcXG4gICAgaWYgKGRlc2Muc2V0KSB7XFxuICAgICAgc3RyID0gY3R4LnN0eWxpemUoJ1tHZXR0ZXIvU2V0dGVyXScsICdzcGVjaWFsJyk7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgc3RyID0gY3R4LnN0eWxpemUoJ1tHZXR0ZXJdJywgJ3NwZWNpYWwnKTtcXG4gICAgfVxcbiAgfSBlbHNlIHtcXG4gICAgaWYgKGRlc2Muc2V0KSB7XFxuICAgICAgc3RyID0gY3R4LnN0eWxpemUoJ1tTZXR0ZXJdJywgJ3NwZWNpYWwnKTtcXG4gICAgfVxcbiAgfVxcbiAgaWYgKCFoYXNPd25Qcm9wZXJ0eSh2aXNpYmxlS2V5cywga2V5KSkge1xcbiAgICBuYW1lID0gJ1snICsga2V5ICsgJ10nO1xcbiAgfVxcbiAgaWYgKCFzdHIpIHtcXG4gICAgaWYgKGN0eC5zZWVuLmluZGV4T2YoZGVzYy52YWx1ZSkgPCAwKSB7XFxuICAgICAgaWYgKGlzTnVsbChyZWN1cnNlVGltZXMpKSB7XFxuICAgICAgICBzdHIgPSBmb3JtYXRWYWx1ZShjdHgsIGRlc2MudmFsdWUsIG51bGwpO1xcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICBzdHIgPSBmb3JtYXRWYWx1ZShjdHgsIGRlc2MudmFsdWUsIHJlY3Vyc2VUaW1lcyAtIDEpO1xcbiAgICAgIH1cXG4gICAgICBpZiAoc3RyLmluZGV4T2YoJ1xcXFxuJykgPiAtMSkge1xcbiAgICAgICAgaWYgKGFycmF5KSB7XFxuICAgICAgICAgIHN0ciA9IHN0ci5zcGxpdCgnXFxcXG4nKS5tYXAoZnVuY3Rpb24obGluZSkge1xcbiAgICAgICAgICAgIHJldHVybiAnICAnICsgbGluZTtcXG4gICAgICAgICAgfSkuam9pbignXFxcXG4nKS5zdWJzdHIoMik7XFxuICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICBzdHIgPSAnXFxcXG4nICsgc3RyLnNwbGl0KCdcXFxcbicpLm1hcChmdW5jdGlvbihsaW5lKSB7XFxuICAgICAgICAgICAgcmV0dXJuICcgICAnICsgbGluZTtcXG4gICAgICAgICAgfSkuam9pbignXFxcXG4nKTtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuICAgIH0gZWxzZSB7XFxuICAgICAgc3RyID0gY3R4LnN0eWxpemUoJ1tDaXJjdWxhcl0nLCAnc3BlY2lhbCcpO1xcbiAgICB9XFxuICB9XFxuICBpZiAoaXNVbmRlZmluZWQobmFtZSkpIHtcXG4gICAgaWYgKGFycmF5ICYmIGtleS5tYXRjaCgvXlxcXFxkKyQvKSkge1xcbiAgICAgIHJldHVybiBzdHI7XFxuICAgIH1cXG4gICAgbmFtZSA9IEpTT04uc3RyaW5naWZ5KCcnICsga2V5KTtcXG4gICAgaWYgKG5hbWUubWF0Y2goL15cXFwiKFthLXpBLVpfXVthLXpBLVpfMC05XSopXFxcIiQvKSkge1xcbiAgICAgIG5hbWUgPSBuYW1lLnN1YnN0cigxLCBuYW1lLmxlbmd0aCAtIDIpO1xcbiAgICAgIG5hbWUgPSBjdHguc3R5bGl6ZShuYW1lLCAnbmFtZScpO1xcbiAgICB9IGVsc2Uge1xcbiAgICAgIG5hbWUgPSBuYW1lLnJlcGxhY2UoLycvZywgXFxcIlxcXFxcXFxcJ1xcXCIpXFxuICAgICAgICAgICAgICAgICAucmVwbGFjZSgvXFxcXFxcXFxcXFwiL2csICdcXFwiJylcXG4gICAgICAgICAgICAgICAgIC5yZXBsYWNlKC8oXlxcXCJ8XFxcIiQpL2csIFxcXCInXFxcIik7XFxuICAgICAgbmFtZSA9IGN0eC5zdHlsaXplKG5hbWUsICdzdHJpbmcnKTtcXG4gICAgfVxcbiAgfVxcblxcbiAgcmV0dXJuIG5hbWUgKyAnOiAnICsgc3RyO1xcbn1cXG5cXG5cXG5mdW5jdGlvbiByZWR1Y2VUb1NpbmdsZVN0cmluZyhvdXRwdXQsIGJhc2UsIGJyYWNlcykge1xcbiAgdmFyIG51bUxpbmVzRXN0ID0gMDtcXG4gIHZhciBsZW5ndGggPSBvdXRwdXQucmVkdWNlKGZ1bmN0aW9uKHByZXYsIGN1cikge1xcbiAgICBudW1MaW5lc0VzdCsrO1xcbiAgICBpZiAoY3VyLmluZGV4T2YoJ1xcXFxuJykgPj0gMCkgbnVtTGluZXNFc3QrKztcXG4gICAgcmV0dXJuIHByZXYgKyBjdXIucmVwbGFjZSgvXFxcXHUwMDFiXFxcXFtcXFxcZFxcXFxkP20vZywgJycpLmxlbmd0aCArIDE7XFxuICB9LCAwKTtcXG5cXG4gIGlmIChsZW5ndGggPiA2MCkge1xcbiAgICByZXR1cm4gYnJhY2VzWzBdICtcXG4gICAgICAgICAgIChiYXNlID09PSAnJyA/ICcnIDogYmFzZSArICdcXFxcbiAnKSArXFxuICAgICAgICAgICAnICcgK1xcbiAgICAgICAgICAgb3V0cHV0LmpvaW4oJyxcXFxcbiAgJykgK1xcbiAgICAgICAgICAgJyAnICtcXG4gICAgICAgICAgIGJyYWNlc1sxXTtcXG4gIH1cXG5cXG4gIHJldHVybiBicmFjZXNbMF0gKyBiYXNlICsgJyAnICsgb3V0cHV0LmpvaW4oJywgJykgKyAnICcgKyBicmFjZXNbMV07XFxufVxcblxcblxcbi8vIE5PVEU6IFRoZXNlIHR5cGUgY2hlY2tpbmcgZnVuY3Rpb25zIGludGVudGlvbmFsbHkgZG9uJ3QgdXNlIGBpbnN0YW5jZW9mYFxcbi8vIGJlY2F1c2UgaXQgaXMgZnJhZ2lsZSBhbmQgY2FuIGJlIGVhc2lseSBmYWtlZCB3aXRoIGBPYmplY3QuY3JlYXRlKClgLlxcbmZ1bmN0aW9uIGlzQXJyYXkoYXIpIHtcXG4gIHJldHVybiBBcnJheS5pc0FycmF5KGFyKTtcXG59XFxuZXhwb3J0cy5pc0FycmF5ID0gaXNBcnJheTtcXG5cXG5mdW5jdGlvbiBpc0Jvb2xlYW4oYXJnKSB7XFxuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ2Jvb2xlYW4nO1xcbn1cXG5leHBvcnRzLmlzQm9vbGVhbiA9IGlzQm9vbGVhbjtcXG5cXG5mdW5jdGlvbiBpc051bGwoYXJnKSB7XFxuICByZXR1cm4gYXJnID09PSBudWxsO1xcbn1cXG5leHBvcnRzLmlzTnVsbCA9IGlzTnVsbDtcXG5cXG5mdW5jdGlvbiBpc051bGxPclVuZGVmaW5lZChhcmcpIHtcXG4gIHJldHVybiBhcmcgPT0gbnVsbDtcXG59XFxuZXhwb3J0cy5pc051bGxPclVuZGVmaW5lZCA9IGlzTnVsbE9yVW5kZWZpbmVkO1xcblxcbmZ1bmN0aW9uIGlzTnVtYmVyKGFyZykge1xcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdudW1iZXInO1xcbn1cXG5leHBvcnRzLmlzTnVtYmVyID0gaXNOdW1iZXI7XFxuXFxuZnVuY3Rpb24gaXNTdHJpbmcoYXJnKSB7XFxuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ3N0cmluZyc7XFxufVxcbmV4cG9ydHMuaXNTdHJpbmcgPSBpc1N0cmluZztcXG5cXG5mdW5jdGlvbiBpc1N5bWJvbChhcmcpIHtcXG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnc3ltYm9sJztcXG59XFxuZXhwb3J0cy5pc1N5bWJvbCA9IGlzU3ltYm9sO1xcblxcbmZ1bmN0aW9uIGlzVW5kZWZpbmVkKGFyZykge1xcbiAgcmV0dXJuIGFyZyA9PT0gdm9pZCAwO1xcbn1cXG5leHBvcnRzLmlzVW5kZWZpbmVkID0gaXNVbmRlZmluZWQ7XFxuXFxuZnVuY3Rpb24gaXNSZWdFeHAocmUpIHtcXG4gIHJldHVybiBpc09iamVjdChyZSkgJiYgb2JqZWN0VG9TdHJpbmcocmUpID09PSAnW29iamVjdCBSZWdFeHBdJztcXG59XFxuZXhwb3J0cy5pc1JlZ0V4cCA9IGlzUmVnRXhwO1xcblxcbmZ1bmN0aW9uIGlzT2JqZWN0KGFyZykge1xcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdvYmplY3QnICYmIGFyZyAhPT0gbnVsbDtcXG59XFxuZXhwb3J0cy5pc09iamVjdCA9IGlzT2JqZWN0O1xcblxcbmZ1bmN0aW9uIGlzRGF0ZShkKSB7XFxuICByZXR1cm4gaXNPYmplY3QoZCkgJiYgb2JqZWN0VG9TdHJpbmcoZCkgPT09ICdbb2JqZWN0IERhdGVdJztcXG59XFxuZXhwb3J0cy5pc0RhdGUgPSBpc0RhdGU7XFxuXFxuZnVuY3Rpb24gaXNFcnJvcihlKSB7XFxuICByZXR1cm4gaXNPYmplY3QoZSkgJiZcXG4gICAgICAob2JqZWN0VG9TdHJpbmcoZSkgPT09ICdbb2JqZWN0IEVycm9yXScgfHwgZSBpbnN0YW5jZW9mIEVycm9yKTtcXG59XFxuZXhwb3J0cy5pc0Vycm9yID0gaXNFcnJvcjtcXG5cXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKGFyZykge1xcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdmdW5jdGlvbic7XFxufVxcbmV4cG9ydHMuaXNGdW5jdGlvbiA9IGlzRnVuY3Rpb247XFxuXFxuZnVuY3Rpb24gaXNQcmltaXRpdmUoYXJnKSB7XFxuICByZXR1cm4gYXJnID09PSBudWxsIHx8XFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ2Jvb2xlYW4nIHx8XFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ251bWJlcicgfHxcXG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnc3RyaW5nJyB8fFxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdzeW1ib2wnIHx8ICAvLyBFUzYgc3ltYm9sXFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ3VuZGVmaW5lZCc7XFxufVxcbmV4cG9ydHMuaXNQcmltaXRpdmUgPSBpc1ByaW1pdGl2ZTtcXG5cXG5leHBvcnRzLmlzQnVmZmVyID0gcmVxdWlyZSgnLi9zdXBwb3J0L2lzQnVmZmVyJyk7XFxuXFxuZnVuY3Rpb24gb2JqZWN0VG9TdHJpbmcobykge1xcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKTtcXG59XFxuXFxuXFxuZnVuY3Rpb24gcGFkKG4pIHtcXG4gIHJldHVybiBuIDwgMTAgPyAnMCcgKyBuLnRvU3RyaW5nKDEwKSA6IG4udG9TdHJpbmcoMTApO1xcbn1cXG5cXG5cXG52YXIgbW9udGhzID0gWydKYW4nLCAnRmViJywgJ01hcicsICdBcHInLCAnTWF5JywgJ0p1bicsICdKdWwnLCAnQXVnJywgJ1NlcCcsXFxuICAgICAgICAgICAgICAnT2N0JywgJ05vdicsICdEZWMnXTtcXG5cXG4vLyAyNiBGZWIgMTY6MTk6MzRcXG5mdW5jdGlvbiB0aW1lc3RhbXAoKSB7XFxuICB2YXIgZCA9IG5ldyBEYXRlKCk7XFxuICB2YXIgdGltZSA9IFtwYWQoZC5nZXRIb3VycygpKSxcXG4gICAgICAgICAgICAgIHBhZChkLmdldE1pbnV0ZXMoKSksXFxuICAgICAgICAgICAgICBwYWQoZC5nZXRTZWNvbmRzKCkpXS5qb2luKCc6Jyk7XFxuICByZXR1cm4gW2QuZ2V0RGF0ZSgpLCBtb250aHNbZC5nZXRNb250aCgpXSwgdGltZV0uam9pbignICcpO1xcbn1cXG5cXG5cXG4vLyBsb2cgaXMganVzdCBhIHRoaW4gd3JhcHBlciB0byBjb25zb2xlLmxvZyB0aGF0IHByZXBlbmRzIGEgdGltZXN0YW1wXFxuZXhwb3J0cy5sb2cgPSBmdW5jdGlvbigpIHtcXG4gIGNvbnNvbGUubG9nKCclcyAtICVzJywgdGltZXN0YW1wKCksIGV4cG9ydHMuZm9ybWF0LmFwcGx5KGV4cG9ydHMsIGFyZ3VtZW50cykpO1xcbn07XFxuXFxuXFxuLyoqXFxuICogSW5oZXJpdCB0aGUgcHJvdG90eXBlIG1ldGhvZHMgZnJvbSBvbmUgY29uc3RydWN0b3IgaW50byBhbm90aGVyLlxcbiAqXFxuICogVGhlIEZ1bmN0aW9uLnByb3RvdHlwZS5pbmhlcml0cyBmcm9tIGxhbmcuanMgcmV3cml0dGVuIGFzIGEgc3RhbmRhbG9uZVxcbiAqIGZ1bmN0aW9uIChub3Qgb24gRnVuY3Rpb24ucHJvdG90eXBlKS4gTk9URTogSWYgdGhpcyBmaWxlIGlzIHRvIGJlIGxvYWRlZFxcbiAqIGR1cmluZyBib290c3RyYXBwaW5nIHRoaXMgZnVuY3Rpb24gbmVlZHMgdG8gYmUgcmV3cml0dGVuIHVzaW5nIHNvbWUgbmF0aXZlXFxuICogZnVuY3Rpb25zIGFzIHByb3RvdHlwZSBzZXR1cCB1c2luZyBub3JtYWwgSmF2YVNjcmlwdCBkb2VzIG5vdCB3b3JrIGFzXFxuICogZXhwZWN0ZWQgZHVyaW5nIGJvb3RzdHJhcHBpbmcgKHNlZSBtaXJyb3IuanMgaW4gcjExNDkwMykuXFxuICpcXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBjdG9yIENvbnN0cnVjdG9yIGZ1bmN0aW9uIHdoaWNoIG5lZWRzIHRvIGluaGVyaXQgdGhlXFxuICogICAgIHByb3RvdHlwZS5cXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBzdXBlckN0b3IgQ29uc3RydWN0b3IgZnVuY3Rpb24gdG8gaW5oZXJpdCBwcm90b3R5cGUgZnJvbS5cXG4gKi9cXG5leHBvcnRzLmluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcXG5cXG5leHBvcnRzLl9leHRlbmQgPSBmdW5jdGlvbihvcmlnaW4sIGFkZCkge1xcbiAgLy8gRG9uJ3QgZG8gYW55dGhpbmcgaWYgYWRkIGlzbid0IGFuIG9iamVjdFxcbiAgaWYgKCFhZGQgfHwgIWlzT2JqZWN0KGFkZCkpIHJldHVybiBvcmlnaW47XFxuXFxuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGFkZCk7XFxuICB2YXIgaSA9IGtleXMubGVuZ3RoO1xcbiAgd2hpbGUgKGktLSkge1xcbiAgICBvcmlnaW5ba2V5c1tpXV0gPSBhZGRba2V5c1tpXV07XFxuICB9XFxuICByZXR1cm4gb3JpZ2luO1xcbn07XFxuXFxuZnVuY3Rpb24gaGFzT3duUHJvcGVydHkob2JqLCBwcm9wKSB7XFxuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgcHJvcCk7XFxufVxcblxcbn0pLmNhbGwodGhpcyxyZXF1aXJlKCdfcHJvY2VzcycpLHR5cGVvZiBnbG9iYWwgIT09IFxcXCJ1bmRlZmluZWRcXFwiID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09IFxcXCJ1bmRlZmluZWRcXFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFxcXCJ1bmRlZmluZWRcXFwiID8gd2luZG93IDoge30pXFxufSx7XFxcIi4vc3VwcG9ydC9pc0J1ZmZlclxcXCI6MTAxLFxcXCJfcHJvY2Vzc1xcXCI6ODIsXFxcImluaGVyaXRzXFxcIjoxMDB9XX0se30sWzFdKTtcXG5cIlxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9yYXctbG9hZGVyIS4vfi9tb2NoYS9tb2NoYS5qc1xuLy8gbW9kdWxlIGlkID0gMTRcbi8vIG1vZHVsZSBjaHVua3MgPSAxIiwicHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbigpIHtcblx0ZGVsZXRlIHJlcXVpcmUuY2FjaGVbbW9kdWxlLmlkXTtcblx0aWYodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB3aW5kb3cubW9jaGFQaGFudG9tSlMpXG5cdFx0bW9jaGFQaGFudG9tSlMucnVuKCk7XG5cdGVsc2Vcblx0XHRtb2NoYS5ydW4oKTtcbn0pO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L21vY2hhLWxvYWRlci9zdGFydC5qc1xuLy8gbW9kdWxlIGlkID0gMTZcbi8vIG1vZHVsZSBjaHVua3MgPSAxIiwiLy8gc2hpbSBmb3IgdXNpbmcgcHJvY2VzcyBpbiBicm93c2VyXG52YXIgcHJvY2VzcyA9IG1vZHVsZS5leHBvcnRzID0ge307XG5cbi8vIGNhY2hlZCBmcm9tIHdoYXRldmVyIGdsb2JhbCBpcyBwcmVzZW50IHNvIHRoYXQgdGVzdCBydW5uZXJzIHRoYXQgc3R1YiBpdFxuLy8gZG9uJ3QgYnJlYWsgdGhpbmdzLiAgQnV0IHdlIG5lZWQgdG8gd3JhcCBpdCBpbiBhIHRyeSBjYXRjaCBpbiBjYXNlIGl0IGlzXG4vLyB3cmFwcGVkIGluIHN0cmljdCBtb2RlIGNvZGUgd2hpY2ggZG9lc24ndCBkZWZpbmUgYW55IGdsb2JhbHMuICBJdCdzIGluc2lkZSBhXG4vLyBmdW5jdGlvbiBiZWNhdXNlIHRyeS9jYXRjaGVzIGRlb3B0aW1pemUgaW4gY2VydGFpbiBlbmdpbmVzLlxuXG52YXIgY2FjaGVkU2V0VGltZW91dDtcbnZhciBjYWNoZWRDbGVhclRpbWVvdXQ7XG5cbmZ1bmN0aW9uIGRlZmF1bHRTZXRUaW1vdXQoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdzZXRUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG5mdW5jdGlvbiBkZWZhdWx0Q2xlYXJUaW1lb3V0ICgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2NsZWFyVGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuKGZ1bmN0aW9uICgpIHtcbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIHNldFRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIGNsZWFyVGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICB9XG59ICgpKVxuZnVuY3Rpb24gcnVuVGltZW91dChmdW4pIHtcbiAgICBpZiAoY2FjaGVkU2V0VGltZW91dCA9PT0gc2V0VGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgLy8gaWYgc2V0VGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZFNldFRpbWVvdXQgPT09IGRlZmF1bHRTZXRUaW1vdXQgfHwgIWNhY2hlZFNldFRpbWVvdXQpICYmIHNldFRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9IGNhdGNoKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0IHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKG51bGwsIGZ1biwgMCk7XG4gICAgICAgIH0gY2F0Y2goZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvclxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbCh0aGlzLCBmdW4sIDApO1xuICAgICAgICB9XG4gICAgfVxuXG5cbn1cbmZ1bmN0aW9uIHJ1bkNsZWFyVGltZW91dChtYXJrZXIpIHtcbiAgICBpZiAoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgLy8gaWYgY2xlYXJUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBkZWZhdWx0Q2xlYXJUaW1lb3V0IHx8ICFjYWNoZWRDbGVhclRpbWVvdXQpICYmIGNsZWFyVGltZW91dCkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfSBjYXRjaCAoZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgIHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwobnVsbCwgbWFya2VyKTtcbiAgICAgICAgfSBjYXRjaCAoZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvci5cbiAgICAgICAgICAgIC8vIFNvbWUgdmVyc2lvbnMgb2YgSS5FLiBoYXZlIGRpZmZlcmVudCBydWxlcyBmb3IgY2xlYXJUaW1lb3V0IHZzIHNldFRpbWVvdXRcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbCh0aGlzLCBtYXJrZXIpO1xuICAgICAgICB9XG4gICAgfVxuXG5cblxufVxudmFyIHF1ZXVlID0gW107XG52YXIgZHJhaW5pbmcgPSBmYWxzZTtcbnZhciBjdXJyZW50UXVldWU7XG52YXIgcXVldWVJbmRleCA9IC0xO1xuXG5mdW5jdGlvbiBjbGVhblVwTmV4dFRpY2soKSB7XG4gICAgaWYgKCFkcmFpbmluZyB8fCAhY3VycmVudFF1ZXVlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBpZiAoY3VycmVudFF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBxdWV1ZSA9IGN1cnJlbnRRdWV1ZS5jb25jYXQocXVldWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICB9XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBkcmFpblF1ZXVlKCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBkcmFpblF1ZXVlKCkge1xuICAgIGlmIChkcmFpbmluZykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciB0aW1lb3V0ID0gcnVuVGltZW91dChjbGVhblVwTmV4dFRpY2spO1xuICAgIGRyYWluaW5nID0gdHJ1ZTtcblxuICAgIHZhciBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgd2hpbGUobGVuKSB7XG4gICAgICAgIGN1cnJlbnRRdWV1ZSA9IHF1ZXVlO1xuICAgICAgICBxdWV1ZSA9IFtdO1xuICAgICAgICB3aGlsZSAoKytxdWV1ZUluZGV4IDwgbGVuKSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudFF1ZXVlKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFF1ZXVlW3F1ZXVlSW5kZXhdLnJ1bigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICAgICAgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIH1cbiAgICBjdXJyZW50UXVldWUgPSBudWxsO1xuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgcnVuQ2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xufVxuXG5wcm9jZXNzLm5leHRUaWNrID0gZnVuY3Rpb24gKGZ1bikge1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHF1ZXVlLnB1c2gobmV3IEl0ZW0oZnVuLCBhcmdzKSk7XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCA9PT0gMSAmJiAhZHJhaW5pbmcpIHtcbiAgICAgICAgcnVuVGltZW91dChkcmFpblF1ZXVlKTtcbiAgICB9XG59O1xuXG4vLyB2OCBsaWtlcyBwcmVkaWN0aWJsZSBvYmplY3RzXG5mdW5jdGlvbiBJdGVtKGZ1biwgYXJyYXkpIHtcbiAgICB0aGlzLmZ1biA9IGZ1bjtcbiAgICB0aGlzLmFycmF5ID0gYXJyYXk7XG59XG5JdGVtLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5mdW4uYXBwbHkobnVsbCwgdGhpcy5hcnJheSk7XG59O1xucHJvY2Vzcy50aXRsZSA9ICdicm93c2VyJztcbnByb2Nlc3MuYnJvd3NlciA9IHRydWU7XG5wcm9jZXNzLmVudiA9IHt9O1xucHJvY2Vzcy5hcmd2ID0gW107XG5wcm9jZXNzLnZlcnNpb24gPSAnJzsgLy8gZW1wdHkgc3RyaW5nIHRvIGF2b2lkIHJlZ2V4cCBpc3N1ZXNcbnByb2Nlc3MudmVyc2lvbnMgPSB7fTtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbnByb2Nlc3Mub24gPSBub29wO1xucHJvY2Vzcy5hZGRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLm9uY2UgPSBub29wO1xucHJvY2Vzcy5vZmYgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUFsbExpc3RlbmVycyA9IG5vb3A7XG5wcm9jZXNzLmVtaXQgPSBub29wO1xucHJvY2Vzcy5wcmVwZW5kTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5wcmVwZW5kT25jZUxpc3RlbmVyID0gbm9vcDtcblxucHJvY2Vzcy5saXN0ZW5lcnMgPSBmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gW10gfVxuXG5wcm9jZXNzLmJpbmRpbmcgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5cbnByb2Nlc3MuY3dkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJy8nIH07XG5wcm9jZXNzLmNoZGlyID0gZnVuY3Rpb24gKGRpcikge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xucHJvY2Vzcy51bWFzayA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gMDsgfTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9wcm9jZXNzL2Jyb3dzZXIuanNcbi8vIG1vZHVsZSBpZCA9IDE3XG4vLyBtb2R1bGUgY2h1bmtzID0gMSJdLCJzb3VyY2VSb290IjoiIn0=